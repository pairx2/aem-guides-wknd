require({cache:{
'dijit/ToolbarSeparator':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"./_Widget",
	"./_TemplatedMixin"
], function(declare, dom, _Widget, _TemplatedMixin){

	// module:
	//		dijit/ToolbarSeparator


	return declare("dijit.ToolbarSeparator", [_Widget, _TemplatedMixin], {
		// summary:
		//		A spacer between two `dijit.Toolbar` items

		templateString: '<div class="dijitToolbarSeparator dijitInline" role="presentation"></div>',

		buildRendering: function(){
			this.inherited(arguments);
			dom.setSelectable(this.domNode, false);
		},

		isFocusable: function(){
			// summary:
			//		This widget isn't focusable, so pass along that fact.
			// tags:
			//		protected
			return false;
		}
	});
});

},
'vodori/ui/Toolbar':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/on', 'dojo/aspect',
    'dijit/Toolbar', './_KeyNavContainer',
    'dijit/form/DropDownButton',
    'vodori/util/getDijitDescendantsByClass'
], function(module, provide,
            _,
            lang,
            on, aspect,
            Toolbar, _KeyNavContainer,
            DijitDropDownButton,
            getDijitDescendantsByClass) {
    /*
     * The purpose of this module is to allow us to override some of the _KeyNavContainer functionality that
     * dijit.Toolbar pulls in by default.
     */
    return provide(module.id, [Toolbar, _KeyNavContainer], {
        /**
         * Indicates whether the open and close handles have been connected to each popup.
         * This is needed because what we do in startup should be done in postCreate (as it
         * should only happen once), but we cannot do it in postCreate due to the fact that
         * the button widgets inside the toolbar have not been parsed at postCreate.
         * @type boolean
         */
        _popupsConnected: false,

        /**
         * Map of each opened popup, so that its open state can be tracked.
         * @type Object
         */
        _popupStates: null,

        constructor: function() {
            this._popupStates = {};
        },

        startup: function() {
            this.inherited(arguments);

            if (!this._popupsConnected) {
                // Stripe's button widgets are not parsed when postCreate is called, so this currently
                // does not work there.
                var buttons = getDijitDescendantsByClass(this.domNode, DijitDropDownButton);

                // Attach open and close handlers to each button in the toolbar
                _.forEach(buttons, function(button) {
                    this.own(on(button.dropDown, 'open', lang.hitch(this, function() {
                        // Call the popup opened function that others can connect to
                        this.onPopupOpen(button.dropDown);
                        // Add the popup's button to the map with 'true' for open
                        this._popupStates[button.id] = true;
                    })));
                    this.own(aspect.after(button.dropDown, 'onClose', lang.hitch(this, function() {
                        // Call the popup closed function that others can connect to
                        this.onPopupClose(button.dropDown);

                        var states = this._popupStates;
                        // Change popup's button state to false for closed
                        states[button.id] = false;

                        // Determine, with the map, if any popups are still open
                        var anyShown = false;
                        for (var id in states) {
                            if (states.hasOwnProperty(id) && states[id]) {
                                anyShown = true;
                            }
                        }

                        // If not, call the all popups closed function that others can connect to
                        if (!anyShown) {
                            this.onAllPopupsClosed();
                        }
                    })));
                }, this);

                // Using this to not break the paradigm of calling startup many times
                this._popupsConnected = true;
            }
        },

        onAllPopupsClosed: function() {

        },

        onPopupOpen: function(popup) {

        },

        onPopupClose: function(popup) {

        }

    });
});

},
'dijit/Toolbar':function(){
define([
	"require",
	"dojo/_base/declare", // declare
	"dojo/has",
	"dojo/keys", // keys.LEFT_ARROW keys.RIGHT_ARROW
	"dojo/ready",
	"./_Widget",
	"./_KeyNavContainer",
	"./_TemplatedMixin"
], function(require, declare, has, keys, ready, _Widget, _KeyNavContainer, _TemplatedMixin){

	// module:
	//		dijit/Toolbar


	// Back compat w/1.6, remove for 2.0
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/ToolbarSeparator"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.Toolbar", [_Widget, _TemplatedMixin, _KeyNavContainer], {
		// summary:
		//		A Toolbar widget, used to hold things like `dijit/Editor` buttons

		templateString:
			'<div class="dijit" role="toolbar" tabIndex="${tabIndex}" data-dojo-attach-point="containerNode">' +
			'</div>',

		baseClass: "dijitToolbar",

		_onLeftArrow: function(){
			this.focusPrev();
		},

		_onRightArrow: function(){
			this.focusNext();
		}
	});
});

},
'vodori/ui/_KeyNavContainer':function(){
define([
    'module', 'vodori/provide',
    'dojo/dom-attr',
    'dijit/registry',
    'dijit/_KeyNavContainer',
    'dijit/form/TextBox'
], function (module, provide, domAttr, dijitRegistry, _KeyNavContainer, Textbox) {
    return provide(module.id, [_KeyNavContainer], {

        /**
         * Override _onContainerKeypress.
         * Default action in _KeyNavContainer is to use to arrow keys to move focus in the toolbar to another toolbar
         * button.
         * If the current button is actually a TextBox, then we don't do this
         */
        _onContainerKeypress: function (event) {
            var targetNodeId = domAttr.get(event.target, 'id');
            var targetDijit = dijitRegistry.byId(targetNodeId);
            if (targetDijit && !targetDijit.isInstanceOf(Textbox)) {
                this.inherited(arguments);
            }
        }
    });
});

},
'vodori/util/getDijitDescendantsByClass':function(){
define(
    [
        'lodash',
        'dojo/query',
        'dijit/registry'
    ],
    function (_, query, registry) {

        'use strict';
        /**
         * Returns an array of widgets contained within the given DOM node that are of the given class or a subclass of
         * the given class.
         *
         * @param {HTMLElement} node the root node beneath which to search
         * @param {Constructor} the constructor indicating the type of widget to search for
         * @return {Array.<Object>} array of matching widget in the order they appear in the DOM
         */
        return function (node, targetClass) {

            var widgets = query('[widgetid]', node).map(function (widgetNode) {
                return registry.byNode(widgetNode);
            });

            /*
             * If there's no target class, then return all of the found widgets,
             * otherwise, filter based on the target class
             */
            return !targetClass ? widgets : _.filter(widgets, function (widget) {
                return widget.isInstanceOf(targetClass);
            });
        };
    });

},
'pepper/ui/EditorToolbar':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/registry',
    'dojo/_base/lang', 'dojo/on', 'dojo/when',
    'dojo/dom-construct', 'dojo/dom-class', 'dojo/dom-style',
    'dojo/aspect',
    'pepper/propertyManager', 'pepper/ui/_QuarantineMixin',
    'dojo/text!./templates/EditorToolbar.html'
], function (provide, module,
             _,
             _WidgetBase, _TemplatedMixin, registry,
             lang, on, when,
             domConstruct, domClass, domStyle,
             aspect,
             propertyManager, _QuarantineMixin,
             template) {
    return provide(module, [_WidgetBase, _TemplatedMixin, _QuarantineMixin], {
        tabs: [],
        tabLabels: {},

        templateString: template,
        baseClass: 'pepperEditorToolbar',

        editors: [],

        activeToolbars: 0,

        noEditorMessage: '',
        _setNoEditorMessageAttr: { node: 'noEditorMessageNode', type: 'innerHTML' },

        noBackground: false, // _QuarantineMixin setting


        constructor: function () {
            this.editors = [];
            this.tabs = [];
            this.tabLabels = {};
        },

        buildRendering: function () {
            this.inherited(arguments);
            this.renderTabs();
            on(this.noEditorMessageNode, 'mouseover', function () {
                propertyManager.highlightWrappers();
            });
            on(this.noEditorMessageNode, 'mouseout', function () {
                propertyManager.unhighlightWrappers();
            });
        },

        renderTabs: function () {
            // Add a button for each tab.
            _.forEach(this.tabs, function (tabLabel) {
                this.addTab(tabLabel);
            }, this);

            this.activateTab(0);
        },

        addTab: function (tabLabel, tabIndex) {
            if (typeof this.tabLabels[tabLabel] !== 'undefined') {
                return this.tabLabels[tabLabel];
            }

            if (typeof tabIndex === 'undefined') {
                tabIndex = this.tabs.length;
            }
            this.tabs[tabIndex] = domConstruct.create('button', {
                'class': 'tab',
                innerHTML: tabLabel,
                onmousedown: lang.hitch(this, 'tabClicked', tabIndex)
            }, this.tabContainer);
            this.tabLabels[tabLabel] = tabIndex;
            return tabIndex;
        },

        hideAllTabs: function () {
            _.forEach(this.tabs, function (tab, i) {
                this.hideTab(i);
            }, this);
            return this;
        },

        showAllTabs: function () {
            _.forEach(this.tabs, function (tab, i) {
                this.showTab(i);
            }, this);
            return this;
        },

        hideTab: function (tabID) {
            var tab = this._getTabReference(tabID);
            domStyle.set(tab, 'display', 'none');
            return this;
        },

        hideAllToolbars: function () {
            _.forEach(this.editors, function (theEd) {
                theEd.getToolbarHolder().then(function (holder) {
                    domStyle.set(holder, 'display', 'none');
                });
            });
        },

        showTab: function (tabID) {
            var tab = this._getTabReference(tabID);
            domStyle.set(tab, 'display', '');
            return this;
        },

        _getTabReference: function (tab) {
            if (lang.isObject(tab)) {
                tab = tab.innerHTML;
            }
            if (lang.isString(tab)) {
                tab = this.tabLabels[tab];
                if (typeof tab === 'undefined') {
                    return this;
                }
            }
            return this.tabs[tab];
        },

        tabClicked: function (index, e) {
            // Keep a tab click from taking focus out of an editor.
            e.stopPropagation();
            e.preventDefault();

            this.activateTab(index);
        },

        activateTab: function (activateTabIdx) {
            // Activate the tab button.
            var tabToToolbarMap = {};
            var visibleTabCount = 0;
            _.forEach(this.tabs, function (tab, tabIdx) {
                domClass.toggle(tab, 'active', tabIdx === activateTabIdx);
                if (domStyle.get(tab, 'display') !== 'none') {
                    tabToToolbarMap[tabIdx] = visibleTabCount;
                    visibleTabCount++;
                }
            }, this);

            var activateToolbarIdx = tabToToolbarMap[activateTabIdx] || 0;

            // Activate a specific row of each toolbar.
            _.forEach(this.editors, function (editor) {
                when(editor.getToolbars(), function (toolbars) {
                    _.forEach(toolbars, function (toolbar, toolbarIdx) {
                        if (toolbarIdx !== activateToolbarIdx) {
                            domClass.add(toolbar, 'hidden');
                        }
                        else {
                            domClass.remove(toolbar, 'hidden');
                        }

                    }, this);
                });
            }, this);
        },

        postCreate: function () {
            this.inherited(arguments);

            // Connect to each editor instance as it's created.
            // Adopt its toolbar if it meets the requirements.
            this.own(aspect.after(registry, 'add', lang.hitch(this, function (editorWidget) {
                if (editorWidget.hasToolbars) {
                    editorWidget.own(aspect.after(editorWidget, 'postCreate', lang.hitch(this, function () {
                        var toolbarTabs = editorWidget.generateToolbars(
                            {
                                onActivate: lang.hitch(this, 'editorActivated'),
                                onDeactivate: lang.hitch(this, 'editorDeactivated'),
                                container: this.toolbarContainer
                            });

                        when(toolbarTabs, lang.hitch(this, function (tabs) {
                            this.editors.push(editorWidget);
                            _.forEach(tabs, function (tabLabel) {
                                this.addTab(tabLabel);
                                this.hideTab(tabLabel);
                            }, this);
                        }));
                    })));
                }
            }), true));
        },


        editorActivated: function (theEd, tabs) {
            this.editorFocused();
            this.hideAllTabs();
            _.forEach(tabs, this.showTab, this);

            _.forEach(this.editors, function (anEd) {
                var displayValue = (anEd === theEd) ? '' : 'none';
                when(anEd.getToolbarHolder(), function (holder) {
                    domStyle.set(holder, 'display', displayValue);
                });
            });
            this.activateTab(0);
            this.activeToolbars++;
        },

        editorDeactivated: function (theEd, tabs) {
            _.forEach(tabs, this.hideTab, this);

            when(theEd.getToolbarHolder(), function (holder) {
                domStyle.set(holder, 'display', 'none');
            });
            this.activeToolbars--;
            if (this.activeToolbars <= 0) {
                this.noEditorFocused();
            }
        },

        editorFocused: function () {
            domStyle.set(this.noEditorMessageNode, 'display', 'none');
        },

        noEditorFocused: function () {
            domStyle.set(this.noEditorMessageNode, 'display', '');
            this.activeToolbars = 0;
        },

        // We're going to swallow mousedowns on the root node
        // to avoid deactivating the current editor.
        _probablyAccidentalMouseDown: function (e) {
            e.stopPropagation();
            e.preventDefault();
        }
    });
});

},
'pepper/propertyManager':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'dojo/on',
    'dojo/dom-class',
    'dijit/registry',
    'pepper/PropertyWrapper',
    'vodori/util/node/getParents'
], function (provide, module, _, lang, on, domClass, dijitRegistry, PropertyWrapper, getParents) {

    var PM = provide(module.id, {
        getContent: function () {
            var payload = {};

            _.forEach(this.getWrappers(), function (wrapper) {
                var name = wrapper.get('name');

                if (name in payload) {
                    console.warn('You have two content blocks with the name:', name);
                }

                payload[name] = wrapper.get('value');
            });

            return payload;
        },

        invalids: [], // Names of invalid wrappers. Look at this after calling "validate".

        // Are any of the wrappers dirty?
        isDirty: function () {
            return _.some(this.getWrappers(), function (wrapper) {
                return wrapper.isDirty();
            });
        },

        // Are all the wrappers valid?
        validate: function () {
            var sparseInvalids = _.map(this.getWrappers(), function (wrapper) {
                if (!wrapper.isValid()) {
                    return wrapper.get('name');
                }
            });

            this.invalids = _.filter(sparseInvalids, Boolean);

            if (this.invalids.length === 0) {
                return true;
            } else {
                console.warn('The following properties are invalid:\n', this.invalids);
                return false;
            }
        },

        // Declare that the current state is clean,
        // and all future dirtiness should be judged from it.
        setCleanState: function () {
            _.forEach(this.getWrappers(), function (wrapper) {
                wrapper.setCleanState();
            });
        },

        // Get all the wrappers on a page.
        getWrappers: function () {
            var regArray = dijitRegistry.toArray();
            return _.filter(regArray, function (widget) {
                return widget.isInstanceOf(PropertyWrapper);
            });
        },

        highlightWrappers: function () {
            var wrappers = this.getWrappers();
            _.forEach(wrappers, function (wrapper) {
                domClass.add(wrapper.id, 'flash');
            });
        },

        unhighlightWrappers: function () {
            var wrappers = this.getWrappers();
            _.forEach(wrappers, function (wrapper) {
                domClass.remove(wrapper.id, 'flash');
            });
        },

        flashWrappers: function (duration) {
            if (typeof duration === 'undefined') {
                duration = 1000;
            }
            /*
             * Ideally, this would be an animation.
             * Unfortunately, there's no way to animate the removal of a *-color property, due to a deficiency
             * in the Dojo code.
             * Also, support for CSS3 animations is limited
             */
            this.highlightWrappers();
            setTimeout(lang.hitch(this, function () {
                this.unhighlightWrappers();
            }), duration);
        }
    });

    /*
     * We're adding a Event delegation method here.
     * Any 'click' event in the document will be inspected.
     *
     * We take the event target and create a NodeList of it and all its parents up to the HTML element
     *
     * Then, we inspect each one and return the highest PropertyWrapper we find.
     *
     * If user clicked on a PropertyWrapper, we ignore it if it's already active.
     * Otherwise, we deactivate all of the PropertyWrappers and activate this one.
     *
     * If user didn't click on a PropertyWrapper, but one is currentlyActive, we figure out if we can deactivate it
     * by feeding it the clickedNodes list and responding accordingly.
     */
    on(document, 'click', function (evt) {
        var clickedNodes = getParents(evt.target);
        clickedNodes.unshift(evt.target);

        var foundWrapper = clickedNodes.filter(function (node) {
            var dijitNode = dijitRegistry.byNode(node);
            return (typeof dijitNode !== 'undefined' && dijitNode.isInstanceOf(PropertyWrapper));
        }).pop();

        if (foundWrapper) {
            foundWrapper = dijitRegistry.byNode(foundWrapper);
            if (!foundWrapper.isActive()) {
                _.forEach(PM.getWrappers(), function (wrapper) {
                    if (wrapper.isActive()) {
                        wrapper.deactivate();
                    }
                });
                foundWrapper.activate();
            }
        }
        else {
            _.forEach(PM.getWrappers(), function (wrapper) {
                if (wrapper.isActive()) {
                    if (wrapper.canDeactivateTo(clickedNodes)) {
                        wrapper.deactivate();
                    }
                }
            });
        }
    });

    return PM;
});

},
'pepper/ui/Popup':function(){
define([
    'module',
    'vodori/provide',
    'vodori/ui/Popup',
    './_QuarantineMixin'
], function (module, provide, Popup, _QuarantineMixin) {
    return provide(module.id, [Popup, _QuarantineMixin], {

        /**
         * Appending a specific className to the container, so we know which
         * quarantine nodes contain popups.
         */
        constructor: function () {
            this.quarantineAreaClassNames += ' popupContainer';
        }
    });
});

},
'vodori/ui/Popup':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/on', 'dojo/_base/lang',
    'dojo/dom-attr', 'dojo/dom-class', 'dojo/dom-construct', 'dojo/dom-geometry', 'dojo/dom-style',
    'dijit/registry', 'dijit/TooltipDialog'
], function (module, provide,
             _,
             on, lang,
             domAttr, domClass, domConstruct, domGeometry, domStyle,
             dijitRegistry,
             DijitTooltipDialog
    ) {
    // A dijit.TooltipDialog with a reference back to its opener

    return provide(module.id, [DijitTooltipDialog], {
        baseClass: 'vodoriPopup',

        titleNode: null,

        opener: null,

        buildRendering: function () {
            this.inherited(arguments);

            if (this.title) {
                this.renderTitle();
            }
        },

        renderTitle: function () {
            this.titleNode = domConstruct.create('div', {
                'class': 'titleBar',
                innerHTML: this.title
            }, this.contentsNode, 'before');
        },

        startup: function () {
            this.inherited(arguments);

            domClass.add(this.domNode, 'vodoriPopup');

            if (this.dojoAttachPoint !== null) {
                domClass.add(this.domNode, this.dojoAttachPoint);
            }

            domAttr.remove(this.containerNode, 'title');

            this.opener = _.filter(dijitRegistry.toArray(), function (widget) {
                // dijit.form.DropDownButton has a "dropDown"
                // dijit.PopupMenu(Bar)Item has a "popup"

                return widget.dropDown === this || widget.popup === this;
            }, this)[0];

            // Close when a menu item is selected.
            var firstChild = this.getChildren()[0];
            if (firstChild && 'onItemClick' in firstChild) {
                this.own(on(firstChild, 'itemClick', lang.hitch(this.opener, 'closeDropDown')));
            }
        },

        // If you ever want to change the height of a upward-opening popup's content,
        // pin it to the bottom. Pin it back to the top when you're done.
        pinTo: function (side) {
            var pos = domGeometry.position(this._popupWrapper);

            domStyle.set(this._popupWrapper, {
                bottom: side === 'bottom' ? (window.innerHeight - (pos.y + pos.h)) + 'px' : '',
                top: side === 'top' ? (window.innerHeight - pos.y) + 'px' : ''
            });
        }
    });
});

},
'pepper/stripe/Toolbar':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/aspect',
    'dojo/_base/fx', 'dojo/_base/lang', 'dojo/_base/window',
    'dojo/when',
    'dojo/dom-attr', 'dojo/dom-class', 'dojo/dom-construct', 'dojo/dom-geometry', 'dojo/dom-style',
    'dojo/query', 'dojo/cookie',
    'dojo/fx/easing',
    'dijit/_Widget', 'vodori/util/_InPageTemplatedMixin',
    'dijit/registry',
    'vodori/util/pageState',
    'pepper/ui/Dialog', 'pepper/ui/_QuarantineMixin',
    'pepper/data/PostDescriptorStore', 'pepper/services', 'pepper/utilities/parseStringEnum',

    'pepper/utilities/pageState',
    /* Unreferenced MIDs */
    'vodori/ui/Toolbar',
    'vodori/input/LogoutForm',
    'dijit/ToolbarSeparator',
    'vodori/ui/Button',
    'pepper/ui/DropDownButton',
    'pepper/ui/Popup',
    'pepper/ui/Menu',
    'pepper/commands',

    'pepper/dialogs/Create',

    'pepper/stripe/StripeActionMenu',
    'pepper/stripe/LifecycleButton',
    'pepper/stripe/LifecyclePopup',
    'pepper/stripe/MessagesPopup',
    'pepper/stripe/MessagesButton',
    'pepper/stripe/PepperPopup',
    'pepper/stripe/SearchBox',
    'pepper/stripe/SearchPopup',
    'pepper/stripe/ToolbarPin'
], function (provide, module,
             _,
             aspect,
             fx, lang, win,
             when,
             domAttr, domClass, domConstruct, domGeometry, domStyle,
             query, cookie,
             easing,
             _Widget, _InPageTemplatedMixin,
             dijitRegistry,
             vodoriPageState,
             Dialog, _QuarantineMixin,
             postDescriptorStore, services, parseStringEnum,
             pepperPageState) {
    return provide(module.id, [_Widget, _InPageTemplatedMixin, _QuarantineMixin], {
        /* attach points*/
        createBtn: null,
        importBtn: null,
        navBtn: null,
        actBtn: null,
        infoBtn: null,
        lcBtn: null,
        libBtn: null,

        baseClass: 'pepperToolbar',

        /**
         * Whether the action menu, info menu and wayfinder should be enabled. They will only be enabled when a
         * current page is available from the PostDescriptorStore as well.
         */
        authorToolsEnabled: true,

        /**
         * Whether the current page is in the current subscription. Used to determine whether certain
         * activities should be enabled.
         */
        currentPageIsInSubscription: true,

        pinned: true,

        stopParser: true,
        _toolbar: null,
        _isAnyMenuOpen: false,
        _currentAnimation: null,
        _isVisible: true,

        /**
         * Used to track if mouse is in Stripe or not. Not the greatest thing to need to track, but was
         * necessary without refactoring the entire Stripe.
         */
        _isMouseIn: true,

        supportNestedInPageTemplates: true,

        PINNED_CLASS: 'pinned',
        UNPINNED_CLASS: 'unpinned',

        noBackground: false, // _QuarantineMixin setting

        postCreate: function() {
            this.inherited(arguments);

            this.set('pinned', this.pinned);

            this.on('mouseEnter', function() {
                this._isMouseIn = true;
                if (!this.pinned && !vodoriPageState.atLeastOneDialogOpen()) {
                    this.show();
                }
            });

            this.on('mouseLeave', function() {
                this._isMouseIn = false;
                this.maybeHideStripe();
            });

            this.own(vodoriPageState.watch('atLeastOneDialogIsOpen', lang.hitch(this, function(name, prev, value) {
                if (value) {
                    this.hide();
                } else {
                    // Calling show() and then maybeHideStripe() will show the Stripe, unless the
                    // Stripe is unpinned, in which case it will stay hidden. A plain call of
                    // if (this.pinned) this.show(); wouldn't get rid of a display:none; CSS rule
                    // on the Stripe's container if it was unpinned, so the Stripe would never come
                    // back on dialog close. There may be a simpler solution, but this worked first for me.
                    this.show();
                    this.maybeHideStripe();
                }
            })));

            // Connect to vodori.ui.Toolbar's popup opened and all popups closed function call events
            // to set if any menus are open.
            this.own(aspect.after(this._toolbar, 'popupOpen', function() {
                this._isAnyMenuOpen = true;
            }, true));
            this.own(aspect.after(this._toolbar, 'onAllPopupsClosed', lang.hitch(this, function() {
                this._isAnyMenuOpen = false;
                // Want to determine if Stripe should be hidden at this point (in case user clicks away
                // from both Stripe and popup, which closes the popup and needs to hide an unpinned Stripe).
                this.maybeHideStripe();
            }, true)));


        },

        startup: function() {
            this.inherited(arguments);

            // Set the logged-in user on the Pepper Popup menu
            this.pepPop.set('user', this.currentUser);

            // Set the user roles on the Pepper Popup menu
            this.pepPop.set('userRoles', parseStringEnum(this.currentUserRoles));

            // Disable authoring tools by default
            this.set('authorTools', false);

            var inAuthorMode = pepperPageState.inAuthorMode();
            this.createBtn.set('disabled', !inAuthorMode);
            this.importBtn.set('disabled', !inAuthorMode);
            this.libBtn.set('disabled', !inAuthorMode);
            this.navBtn.set('disabled', !inAuthorMode);
            this.searchBox.set('disabled', !inAuthorMode);

            if (cookie('pepper3_statusbar_unpin')) {
                this.pinned = false;
                this.hide();
            }

            // Fetch the object being described (`null` is returned if the current page is an app page)
            var result = postDescriptorStore.getCurrentPageObject();

            if (result) {
                // Initialize the widget and refresh on every object update
                when(result, lang.hitch(this, '_currentPageChangeHandler'));
                this.own(result.observe(lang.hitch(this, '_currentPageChangeHandler')));
            } else {
                this.set('authorTools', false);
            }

        },

        /**
         * Enables or disables certain authoring tools on the Stripe.
         * @param enabled Whether to enable or disable the buttons/tools
         */
        _setAuthorToolsAttr: function(enabled) {
            this.actBtn.set('disabled', !enabled);
            this.infoBtn.set('disabled', !enabled);
            this.lcBtn.set('disabled', !enabled);
            this.navBtn.set('disabled', !enabled);
        },

        _setInSubscriptionToolsAttr: function(enabled) {
            // If authoring tools are not enabled, we don't want to override and re-enable anything.
            // See the table in `_currentPageChangeHandler` for details.
            if (this.authorToolsEnabled) {
                this.createBtn.set('disabled', !enabled);
                this.importBtn.set('disabled', !enabled);
                this.navBtn.set('disabled', !enabled);
            }
        },

        /**
         * Toggles whether or not the dialog is pinned open
         */
        togglePinning: function() {
            if (this.pinned) {
                cookie('pepper3_statusbar_unpin', 'true', { expires: 1 });
            }  
            else {
                cookie('pepper3_statusbar_unpin', null, { expires: -1 });

            }
            this.set('pinned', !this.pinned);
        },

        /**
         * Hide the stripe if it is not pinned, has no open menus, and does not have the mouse in it.
         * Used in the event connections in postCreate to help determine when the Stripe should close
         * when popup menus and dialogs are closed. The name of this function could be improved...
         */
        maybeHideStripe: function() {
            if (!this.pinned && !this._isAnyMenuOpen && !this._isMouseIn) {
                this.hide();
            }
        },

        /**
         * Shows the toolbar using fancy animation
         */
        show: function() {
            if (this._isVisible) {
                return;
            }

            if (this._currentAnimation) {
                this._currentAnimation.stop();
            }

            this._currentAnimation = fx.animateProperty({
                node: this.wrapperNode,
                duration: 333,
                easing: easing.quadOut,
                beforeBegin: lang.hitch(this, function() {
                    // Re-show from a dialog-induced hide
                    domStyle.set(this.domNode, 'display', '');
                }),
                onEnd: lang.hitch(this, function() {
                    this._currentAnimation = null;
                }),
                properties: {
                    top: 0,
                    opacity: 1
                }
            });
            this._currentAnimation.play();
            this._isVisible = true;
        },

        /**
         * Hides the toolbar with a fancy animation
         */
        hide: function() {
            // Prevents Stripe from continuously hiding itself
            if (!this._isAnyMenuOpen && !this._isVisible) {
                return;
            }

            if (this._currentAnimation) {
                this._currentAnimation.stop();
            }

            var height = domGeometry.getMarginBox(this.wrapperNode).h;

            this._currentAnimation = fx.animateProperty({
                node: this.wrapperNode,
                duration: 333,
                delay: 250,
                easing: easing.quadOut,
                onBegin: lang.hitch(this, 'closePopups'),
                onEnd: lang.hitch(this, function() {
                    // Opening a dialog should hide the node completely so it doesn't eat clicks
                    if (vodoriPageState.atLeastOneDialogOpen()) {
                        domStyle.set(this.domNode, 'display', 'none');
                    }
                    this._currentAnimation = null;
                }),
                properties: {
                    top: height,
                    opacity: 0
                }
            });
            this._currentAnimation.play();
            this._isVisible = false;
        },

        closePopups: function() {
            var popups = query('[widgetId]', this.domNode);
            popups.forEach(function(widget) {
                widget = dijitRegistry.byNode(widget);
                if ('closeDropDown' in widget) {
                    widget.closeDropDown();
                }
            });
        },

        _currentPageChangeHandler: function(object) {
            // For application-driven pages, the objectId shouldn't exist and can be used
            // to enable/disable certain authoring items on the Stripe.
            // See pepper.stripe.Toolbar._setAuthorToolsAttr()
            if (!object || !object.objectId) {
                this.set('authorTools', false);
            } else {
                // Cover the following combinations:
                // ---------------------------------------------------------------------------------------------------
                // | authorToolsEnabled      | currentpageIsInSubscription    | Expectation                          |
                // ---------------------------------------------------------------------------------------------------
                // | true                    | true                           | Enable the union of buttons specified|
                // |                         |                                | by both setters                      |
                // ---------------------------------------------------------------------------------------------------
                // | true                    | false                          | Selectively disable a few items that |
                // |                         |                                | the author tools setter has enabled  |
                // ---------------------------------------------------------------------------------------------------
                // | false                   | true                           | Keep the page in the author tools    |
                // |                         |                                | disabled state without any change    |
                // ---------------------------------------------------------------------------------------------------
                // | false                   | false                          | Disable the union of buttons         |
                // |                         |                                | specified by both setters            |
                // ---------------------------------------------------------------------------------------------------
                this.set('authorTools', this.authorToolsEnabled);
                this.set('inSubscriptionTools', this.currentPageIsInSubscription);
            }

            var mine = object.lockedByCurrentUser;
            var infoIcon = query('img', this.infoBtn.domNode)[0];
            if (object.lockOwner === null || object.lockOwner === '') {
                domAttr.set(infoIcon, 'src', '/static/js/pepper/images/info.png');
            } else {
                if (mine) {
                    domAttr.set(infoIcon, 'src', '/static/js/pepper/images/info-key.png');
                } else {
                    domAttr.set(infoIcon, 'src', '/static/js/pepper/images/info-lock.png');
                }
            }
        },

        _setPinnedAttr: function(pinned) {
            pinned = !!pinned;

            domClass.toggle(this.domNode, this.PINNED_CLASS, pinned);
            domClass.toggle(this.domNode, this.UNPINNED_CLASS, !pinned);

            this.pinned = pinned;

            /**
             * If you unpin with a dialog open, need to hide the stripe
             */
            if (!this.pinned && vodoriPageState.atLeastOneDialogOpen()) {
                this.hide();
            }
        }
    });
});

},
'vodori/util/_InPageTemplatedMixin':function(){
/**
 * Causes a widget to convert its markup into a template.
 * Mainly useful for micro templates that rely heavily on server generated variables.
 *
 * @module vodori/util/_InPageTemplatedMixin
 */
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'dojo/query',
    'dojo/dom-construct', 'dojo/dom-attr',
    'vodori/util/node/getOuterHTML',
    'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin'
], function (module, provide,
             lang, query,
             domConstruct, domAttr,
             getOuterHTML,
             _TemplatedMixin, _WidgetsInTemplateMixin) {
    /**
     * @lends module:vodori/util/_InPageTemplatedMixin#
     */
    var _InPageTemplatedMixin = {
        /**
         * Set to false if you need to extend an in page templated widget and don't want
         * to use a different template format.
         * Logically, must be set to false for programmatic instantiation.
         *
         * @type {boolean}
         * @protected
         */
        useInPageTemplate: true,

        /**
         * Set this to false if you don't need the inPageTemplate for this.
         *
         * @see: module:dojo/parser#parse
         * @type {boolean}
         */
        stopParser: true,

        /**
         * Supporting nested templates is expensive, so only set to true when necessary.
         *
         * @type {boolean}
         */
        supportNestedInPageTemplates: false,

        /**
         * @type {string}
         * @const
         */
        TEMPLATE_MARKER: 'data-vodori-template-stash-index',

        /**
         * A lookup table for our templates.
         *
         * @type {Object}
         * @static
         * @private
         */
        _protectedTemplates: {},

        /**
         * @type {number}
         * @private
         */
        _instanceCount: 0,

        /*
         * Grab the outerHTML of our widget and use it as the template.
         * Optionally, protect descendants.
         */
        postMixInProperties: function () {
            this.inherited(arguments);

            // Make sure the any keys are unique by creating an index.
            this.constructor.prototype._instanceCount++;

            // Prevent wasting memory for widgets that know
            // they won't have descendants w/ in page templates
            if (this.supportNestedInPageTemplates) {
                this._protectDescendantTemplates(this.srcNodeRef);
            }

            // If your in page template was cached, then we'll force you to use it.
            var cachedTemplateKey = domAttr.get(this.srcNodeRef, this.TEMPLATE_MARKER);
            if (!!cachedTemplateKey) {
                this.useInPageTemplate = false;
                this.templateString = this._protectedTemplates[cachedTemplateKey];
                domAttr.remove(this.srcNodeRef, this.TEMPLATE_MARKER);
                delete this._protectedTemplates[cachedTemplateKey];
            }

            if (this.useInPageTemplate) {
                // Clean off the dojo decorators to prevent reparsing.
                domAttr.remove(this.srcNodeRef, 'data-dojo-type');
                domAttr.remove(this.srcNodeRef, 'dojoType');
                this.templateString = getOuterHTML(this.srcNodeRef);
                this.srcNodeRef.innerHTML = '';
            }
        },

        /*
         * Something magical about setting the containerNode to this.domNode.
         */
        postCreate: function () {
            this.inherited(arguments);

            if (this.useInPageTemplate) {
                domConstruct.destroy(this.srcNodeRef);
                this.containerNode = this.domNode;
            }
        },

        _nodeHasInlineTemplates: function (node) {
            var hasTemplates;
            try {
                hasTemplates = !!require(domAttr.get(node, 'data-dojo-type')).prototype.useInPageTemplate;
            }
            catch(ex) {
                if(ex.message === 'undefinedModule') {
                    console.error('Your InPageTemplate refers to a module that has not been declared as a dependency');
                }
            }
            return hasTemplates;
        },

        /**
         * This is a bit gnarly, but the basic idea is to stash the descendant templates
         * in a lookup table to prevent them from being accidentally parsed by their parent.
         *
         * @param {Element} rootNode
         * @private
         */
        _protectDescendantTemplates: function (rootNode) {
            var nodesWithInPageTemplates = query('[data-dojo-type]', rootNode)
                .filter(this._nodeHasInlineTemplates);

            // Work inside out, so we don't break nesting.
            nodesWithInPageTemplates.reverse();

            nodesWithInPageTemplates.forEach(function (node, i) {
                var key = this._makeKey(node, i);
                this._protectedTemplates[key] = getOuterHTML(node);
                node.innerHTML = '';
                domAttr.set(node, this.TEMPLATE_MARKER, key);
            }, this);
        },

        /**
         * Make a unique key in the in memory templates
         *
         * @param {number} index
         * @return {string}
         * @private
         */
        _makeKey: function (node, index) {
            return domAttr.get(node, 'data-dojo-type') + ':' + this._instanceCount + ':' + index;
        }
    };

    /**
     * @constructor
     * @alias module:vodori/util/_InPageTemplatedMixin
     */
    return provide(module.id, [_TemplatedMixin, _WidgetsInTemplateMixin], _InPageTemplatedMixin);
});

},
'vodori/util/node/getOuterHTML':function(){
define([
    'dojo/has', 'dojo/_base/lang',
    './createFragmentedElement'
], function (has, lang, createFragmentedElement) {
    // Simple test for whether or not
    has.add('outer-html', function (global, document, node) {
        return !!node.outerHTML;
    });

    // We can just use the same node over and over.
    var shell = createFragmentedElement();

    /**
     * Safely get outerHTML.
     *
     * @param {Element} node
     * @return {string} The outerHTML of the node.
     */
    return has('outer-html') ? function (node) {
        return node.outerHTML;
    } : function (node) {
        shell.appendChild(lang.clone(node));

        var outerHTML = shell.innerHTML;

        shell.innerHTML = '';

        return outerHTML;
    };
});

},
'pepper/ui/Dialog':function(){
define([
    'dojo/_base/declare',
    'vodori/ui/Dialog',
    './_QuarantineMixin'
], function (declare, Dialog, _QuarantineMixin) {

    return declare([Dialog, _QuarantineMixin], {
        /**
         * Appending a specific className to the container, so we know which
         * quarantine nodes contain popups.
         */
        constructor: function () {
            this.quarantineAreaClassNames += ' dialogContainer';
        }
    });
});

},
'pepper/data/PostDescriptorStore':function(){
define([
    'lodash',
    'dojo/_base/declare', 'dojo/_base/lang', 'dojo/_base/config',
    'dojo/query', 'dojo/json',
    'dojo/when', 'dojo/Deferred',
    'dojo/store/Memory', './ObservableWithGet', 'dojo/store/util/QueryResults',
    'pepper/services', 'pepper/utilities/createPayload'
], function (_,
             declare, lang, config,
             query, json,
             when, Deferred,
             Memory, ObservableWithGet, QueryResults,
             services, createPayload
    ) {

    /**
     * Provides a unified way to access PostDescriptors.  This is a singleton class, which implements caching
     * and observing of results.  It also adds a 'currentPage' property to all posts, as this is a purely
     * front-end concept.
     **/

    /**
     * Given an ID and optionally a version number build the ID for that version. If no version is specified, any
     * version already on the ID will be removed.
     *
     * @param {string} id versioned or unversioned ID
     * @param {string} [version] version label. If null or omitted, return the ID with no version
     * @returns {string}
     */
    function buildIdForVersion(id, version) {
        if (!id) {
            // Sometimes id is null or undefined. In that case, bypass this function.
            return id;
        }

        var pos = id.indexOf(';');
        if (pos !== -1) {
            id = id.substring(0, pos);
        }

        if (version) {
            id = id + ';' + version;
        }

        return id;
    }

    /**
     * Get the version of the ID to match the version specified in the page URL with "&version=x.x". If the URL does
     * not specify a version, get the unversioned ID.
     * @param {string} id versioned or unversioned ID
     * @returns {string}
     */
    function adjustCurrentPageIdWithVersionFromUrl(id) {
        var version = null;
        // Attempt to find "&version=x.x" in URL
        var versionMatch = /[&?]version=(\d+\.\d+)/.exec(document.URL);
        if (id && versionMatch && versionMatch.length > 1) {
            version = versionMatch[1];
        }
        return buildIdForVersion(id, version);
    }

    /**
     * The CSS selector used to retrieve the initial JSON store provided by the JSP
     * @type {string}
     * @const
     */
    var POST_DESCRIPTOR_SELECTOR = 'script[data-templated-data-for-modules*="pepper/data/PostDescriptorStore"]';

    // Fetch the current page ID
    var currentPageId = adjustCurrentPageIdWithVersionFromUrl(config['page-id']);

    // Determine if we're on an app page (like the admin page) or not
    var onAppPage = _.isEmpty(currentPageId);

    // Fetch our JSON node and extract its contents
    var postStorePreloadNode = query(POST_DESCRIPTOR_SELECTOR);

    var postDescriptors = [];
    if ((postStorePreloadNode.length > 0) && postStorePreloadNode[0].innerHTML) {
        postDescriptors = json.parse(postStorePreloadNode[0].innerHTML);
    } else {
        console.warn('Unable to find data for the PostDescriptorStore.  ' +
            'There must be a node that matches the following selector: ' + POST_DESCRIPTOR_SELECTOR);
    }


    var prototype = {

        /**
         * The ID property to reference on objects put in the store
         */
        idProperty: 'objectId',

        /**
         * The id (including version) for the current page (if any)
         */
        currentPageObjectId: currentPageId,
        /**
         * The id (excluding version) for the current page (if any)
         * @private
         */
        _currentPageObjectIdUnversioned: buildIdForVersion(currentPageId, null),

        // Indicate whether we are on an app-driven page
        onAppPage: onAppPage,

        /**
         * @inheritDoc
         * @param {string} id The objectID property to fetch
         * @param {object} [options] Configuration to specify.
         * @param {boolean} [options.forceRefresh] skips the local cache, retrieves the object from the back end, and
         *                  updates the cache. (optional - defaults to false)
         * @return {dojo/Deferred|Object} the result may be a Deferred or may be the object itself. It will also have
         * an observe() function from pepper/data/ObservableWithGet.
         */
        get: function (id, options) {

            if(id) {
                var skipCache = options && options.forceRefresh;
                if (!skipCache) {
                    var cachedResults = this.inherited(arguments);

                    if (cachedResults) {
                        return cachedResults;
                    }
                }
                return this._getInfo(id);
            } else {
                return null;
            }

        },

        /**
         * This put adds the 'currentPage' flag to any descriptors
         * @inheritDoc
         */
        put: function (object, options) {

            // On every put, update the currentPage property
            object.currentPage = this.isCurrentPage(object);

            this.inherited(arguments);
        },

        /**
         * A helper function to return the objectID of the current page
         * @return {String}
         */
        getCurrentPageObjectId: function () {
            return this.currentPageObjectId;
        },

        /**
         * Check whether an object or id represents the current page. Note that this will return true for any version
         * of the current page.
         *
         * @param {Object|string} objectOrId either an object with 'objectId' or 'id' property or an ID string.
         * @returns {boolean}
         */
        isCurrentPage: function(objectOrId) {
            var id = objectOrId;
            if (_.isObject(objectOrId)) {
                id = objectOrId.objectId || objectOrId.id;
            }
            if (!_.isString(id)) {
                return false;
            }

            id = buildIdForVersion(id, null);
            return id === this._currentPageObjectIdUnversioned;
        },

        /**
         * A helper function to return a promise that resolves to the current page object.
         * @return {dojo/Deferred}
         */
        getCurrentPageObject: function () {
            if (this.onAppPage) {
                console.info('PostDescriptorStore.getCurrentPageObject: returning null since onAppPage = true');

                return null;
            }

            var id = this.getCurrentPageObjectId();
            return this.get(id);
        },

        /**
         * get PostDescriptor data by objectId
         * @param {string} objectId The objectId of the PostDescriptor to fetch
         * @param {boolean} useQueryResults whether or not the results should be wrapped in QueryResults
         * @param {boolean} force whether or not the cache should be used
         * @returns {@module dojo/Deferred|@module dojo/store/util/QueryResults}
         */
        getInfo: function(objectId, useQueryResults, force) {
            if(!_.isBoolean(force)) {
                force = false;
            }

            if(!_.isBoolean(useQueryResults)) {
                useQueryResults = true;
            }

            var cachedResults = this.get(objectId);

            if (!force && _.size(cachedResults) > 0) {
                return new QueryResults(cachedResults);
            } else {
                return this._getInfo(objectId, useQueryResults);
            }
        },

        /**
         * actually makes the service call, formatting the request as the backend expects
         */
        _getInfo: function(objectId) {
            var resultsPromise = new Deferred();

            var serviceCallResponse = services.getInfo({ params: { objects: [ { objectId: objectId } ]}});

            when(serviceCallResponse, lang.hitch(this, function (getInfoResults) {
                this._updateInternallyFromResponse(getInfoResults);

                resultsPromise.resolve(getInfoResults.results[0]);
            }));
            return resultsPromise;
        },

        /**
         * makes a getInfo call to the back end for multiple items
         */
        _getInfoForMultiple: function(objectIds) {
            var resultsPromise = new Deferred();

            var serviceCallResponse = services.getInfo({
                params: { objects: createPayload(objectIds) }
            });

            when(serviceCallResponse, lang.hitch(this, function (getInfoResults) {
                this._updateInternallyFromResponse(getInfoResults);

                resultsPromise.resolve(getInfoResults.results);
            }));
            return resultsPromise;
        },

        /**
         * @param query
         * @param {object} [options] In addition to the Memory store options, forceRefresh and cacheOnly are available
         * @param {boolean} [options.forceRefresh] skips the local cache, retrieves the object from the back end, and
         *                  updates the cache. (optional - defaults to false)
         * @param {boolean} [options.cacheOnly] only retrieves matching objects from local cache. The back end is never
         *                  queried, even if matches are not found in the cache. (optional - defaults to false)
         * @returns {Array|Promise} may return an array of the results immediately or may return a promise with that
         *          array as the result
         */
        query: function(query, options) {
            if (this._isQueryById(query)) {
                return this.queryByIds(query.objectId, options);
            } else if (options && options.cacheOnly) {
                return this.inherited(arguments);
            } else {
                throw new Error('This store only supports query by objectId unless cacheOnly option is used.');
            }
        },

        /**
         * Return true if the query is an object that has an objectId property and ONLY an objectId property
         * @private
         */
        _isQueryById: function(query) {
            return query && query.objectId && _.size(query) === 1;
        },

        /**
         * Fetch results with the given objectIds. If no sort is specified in the options, order the results in the same
         * order as the list of IDs.
         *
         * @param ids array of ids of objects to return
         * @param [options] just like query() options
         * @returns {Array|Promise} may return an array of the results immediately or may return a promise with that
         *          array as the result
         */
        queryByIds: function(ids, options) {
            options = options || {};
            if (!_.isArray(ids)) {
                ids = [ids];
            }
            var query = function(object) {
                return _.contains(ids, object.objectId);
            };
            var cacheOnlyOptions = lang.mixin({ cacheOnly: true }, options);
            delete cacheOnlyOptions.forceRefresh;

            // If no sort is specified, sort according to the ids order by default.
            if (!cacheOnlyOptions.sort) {
                cacheOnlyOptions.sort = this._getSortByObjectIdListFunction(ids);
            }

            if (options.forceRefresh) {
                return this._fetchFromServicesThenQuery(ids, query, cacheOnlyOptions);
            } else {
                var cachedResults = this.query(query, cacheOnlyOptions);
                var allQueriedObjectsWereFoundInCache = cachedResults.length === ids.length;
                if (allQueriedObjectsWereFoundInCache || options.cacheOnly) {
                    return cachedResults;
                } else {
                    return this._fetchFromServicesThenQuery(ids, query, cacheOnlyOptions);
                }
            }
        },

        /**
         * Returns a compare function suitable for SimpleQueryEngine.sort or Array.prototype.sort() that sorts a list
         * of objects to match a given ordered list of IDs.
         *
         * @param {Array.<String>} ids list of IDs defining the order in which the objects should be sorted
         * @returns {Function}
         * @private
         */
        _getSortByObjectIdListFunction: function(ids) {
            return function(a, b) {
                if (!ids || !ids.length || !a || !b) {
                    return 0;
                }
                a = a.objectId;
                b = b.objectId;
                if (!a || !b) {
                    return 0;
                }
                for (var i = 0; i < ids.length; i++) {
                    var id = ids[i];
                    if (id === a) {
                        return -1;
                    } else if (id === b) {
                        return 1;
                    }
                }
                return 0;
            };
        },

        _fetchFromServicesThenQuery: function(objectIds, query, options) {
            return this._getInfoForMultiple(objectIds).then(lang.hitch(this, function() {
                return this.query(query, options);
            }));
        },

        /**
         * executes a library query
         *
         * Note: the query object will not be formatted here
         * @param {object} query the library query to execute
         * @returns {@module dojo/Deferred}
         */
        queryLibrary: function(query) {
            var resultsPromise = new Deferred();

            var serviceCallResponse = services.queryLibrary({ params: { query: query } });

            when(serviceCallResponse, lang.hitch(this, function (getInfoResults) {
                this._updateInternallyFromResponse(getInfoResults);

                resultsPromise.resolve(getInfoResults);
            }));

            return resultsPromise;
        },

        // TODO: CAYENNE-3170
        saveAndCheckIn: function (objectOrObjects, comment, content) {
            var payload = createPayload(objectOrObjects);

            var servicePromise = services.saveAndCheckIn({
                params: {
                    objects: payload,
                    comment: '',
                    content: content
                }
            });

            this._registerStandardResponseHandler(servicePromise);

            return servicePromise;
        },

        /**
         * Save an object.
         * @param {Object|Array.<Object>} objectOrObjects the object to save or an array of objects
         *        to save
         * @param {Object} [content] content to save on these objects (optional - if undefined, the
         *        'content' property of each object will be used.
         * @returns Promise that is resolved to the result of the service call when it returns.
         */
        save: function (objectOrObjects, content) {
            var payload = createPayload(objectOrObjects,
                function (mapped, object) {
                    if (content !== undefined) {
                        mapped.content = content;
                    } else {
                        mapped.content = object.content;
                    }
                    return mapped;
                }
            );

            var servicePromise = services.save({
                params: {
                    objects: payload
                }
            });

            this._registerStandardResponseHandler(servicePromise);

            return servicePromise;
        },

        deleteObjects: function (objectOrObjects) {
            var servicePromise = this._callService('deleteObjects', objectOrObjects);

            servicePromise.then(lang.hitch(this, function (response) {

                _.forEach(response.results, function (result) {
                    this.remove(result);
                }, this);

            }));

            return servicePromise;
        },

        copyTo: function(objectOrObjects, destinationFolderId, parentFolderId) {
            return this._callServiceAndRefreshCachedObjects('copyTo', objectOrObjects, {
                destinationFolderId: destinationFolderId,
                parentFolderId: parentFolderId
            });
        },

        moveTo: function(objectOrObjects, destinationFolderId, sourceFolderId) {
            return this._callServiceAndRefreshCachedObjects('moveTo', objectOrObjects, {
                destinationFolderId: destinationFolderId,
                parentFolderId: sourceFolderId
            });
        },

        unfile: function(objectOrObjects, folderId) {
            return this._callServiceAndRefreshCachedObjects('unfile', objectOrObjects, {
                parentFolderId: folderId
            });
        },

        distribute: function(objectOrObjects, targetChannelIds, distributionName) {
            return this._callServiceAndRefreshCachedObjects('distribute', objectOrObjects, {
                targetChannelIds: targetChannelIds,
                distributionName: distributionName
            });
        },

        /**
         * Call the given service then refresh any of the objects that are in the cache
         *
         * @param {string} serviceMethod name of the service method
         * @param {Object|string|Array} objectOrObjects object(s) or object id(s)
         * @param {Object} [additionalParams] hash of parameters and values to include in the service params in addition
         *                 to the objects
         * @returns {Promise} the promise from the service
         * @private
         */
        _callServiceAndRefreshCachedObjects: function(serviceMethod, objectOrObjects, additionalParams) {
            var promise = this._callService.apply(this, arguments);
            promise.then(lang.hitch(this, function() {
                this.refreshCachedObjects(createPayload(objectOrObjects));
            }));
            return promise;
        },

        /**
         * Call the given service.
         *
         * @param {string} serviceMethod name of the service method
         * @param {Object|string|Array} objectOrObjects object(s) or object id(s)
         * @param {Object} [additionalParams] hash of parameters and values to include in the service params in addition
         *                 to the objects
         * @returns {Promise} the promise from the service
         * @private
         */
        _callService: function(serviceMethod, objectOrObjects, additionalParams) {
            var objects = createPayload(objectOrObjects);
            var promise = services[serviceMethod]({
                params: lang.mixin({ objects: objects }, additionalParams)
            });
            return promise;
        },

        /**
         * Most of the services have the same form. These can all be executed using this method.
         * @param serviceName ex: 'checkIn', 'promote', 'save'
         * @param {Object|Array.<Object>} objectOrObjects the object on which to perform the service
         *        or an array such objects
         * @returns Promise that is resolved to the result of the service call when it returns.
         * @private
         */
        _executeStandardService: function (serviceName, objectOrObjects, additionalParams) {
            var servicePromise = this._callService(serviceName, objectOrObjects, additionalParams);

            this._registerStandardResponseHandler(servicePromise);

            return servicePromise;
        },

        _registerStandardResponseHandler: function (servicePromise) {
            servicePromise
                .then(lang.hitch(this, '_clearVersionCachesForResponse'))
                .then(lang.hitch(this, '_updateInternallyFromResponse'));
        },

        _updateInternallyFromResponse: function (response) {

            _.forEach(response.results, function (result) {
                this.put(result);
            }, this);

        },

        _clearVersionCachesForResponse: function(response) {
            _.forEach(response.results, function (result) {
                this.clearCacheForVersionSeries(result.versionSeriesId, result.objectId);
            }, this);
            return response;
        },

        clearCacheForVersionSeries: function(versionSeriesId, currentObjectId) {
            var objects = this.query({versionSeriesId: versionSeriesId}, {cacheOnly: true});
            _.forEach(objects, function(object) {
                // Don't clear out the current object
                if (object.objectId !== currentObjectId) {
                    this.remove(object.objectId);
                }
            }, this);
        },

        clearCache: function() {
            this.setData([]);
        },

        /**
         * Refresh any of the given objects that are in the cache.
         * @param {String|{objectId: String}|Array} objects objects to refresh. Could be a single object ID or an object
         *        with an objectId property or an array of either of those.
         */
        refreshCachedObjects: function(objects) {
            objects = createPayload(objects); // normalize input
            var ids = _.pluck(objects, 'objectId');
            var objectsToRefresh = this.query({objectId: ids}, {cacheOnly: true});
            ids = _.pluck(objectsToRefresh, 'objectId');
            this.query({objectId: ids}, {forceRefresh: true});
        }

    };


    // Add a bunch of boilerplate methods to 'prototype' that make a basic service call and update the store
    _.forEach(['checkIn', 'checkOut', 'cancelCheckOut', 'copy', 'expressPromote',
               'promote', 'demoteAndCheckout', 'demote', 'expire',
               'revive', 'reinstate'], function (serviceName) {
        prototype[serviceName] = function (objectOrObjects, additionalParams) {
            return this._executeStandardService(serviceName, objectOrObjects, additionalParams);
        };
    });

    // Instantiate a memory store, and override the ID property
    var PostStoreClass = declare([Memory], prototype);

    // Instantiate the store with our post descriptors
    var postStore = new PostStoreClass();
    _.forEach(postDescriptors, lang.hitch(postStore, 'put'));

    var finishedStore = new ObservableWithGet(postStore);

    console.log('Finished initializing PostDescriptorStore.  ' +
                'Current page is: ' + finishedStore.getCurrentPageObjectId());

    return finishedStore;
});

},
'pepper/data/ObservableWithGet':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'lodash',
    'dojo/_base/lang', 'dojo/_base/array',
    'dojo/store/Observable',  'dojo/when'
], function(_,
            lang, array,
            Observable, when
    ){
    /**
     * The purpose of this module is to extend dojo/store/Observable to be able to observe the results
     * of a call to store.get() similarly to store.query()
     *
     * observers are called with the object that was changed, and the objects id OR in the case of remove
     * the observers are called with null, and the id of the object that was removed
     *
     * @param store the store to wrap
     * @returns {*}
     * @constructor
     */
    var ObservableWithGet = function(store) {
        store = new Observable(store);
        store = lang.delegate(store);

        var observedIds = {};

        var originalGet = store.get;

        // wrap the call to get so that the results have an observe method
        store.get = function(id, options) {
            var result = originalGet.apply(this, arguments);

            if(result) {
                result.observe = function (listener) {
                    if (!observedIds[id]) {
                        observedIds[id] = [];
                    }

                    var listeners = observedIds[id];

                    listeners.push(listener);

                    var handle = {};

                    handle.remove = handle.cancel = function () {
                        // remove this listener
                        var index = array.indexOf(listeners, listener);

                        // check to make sure we haven't already called cancel
                        if (index > -1) {
                            listeners.splice(index, 1);
                        }
                    };

                    return handle;
                };
            }

            return result;
        };

        // the notifier method that calls any attached listeners
        store.notifyGet = function(object, id) {
            _.forEach(observedIds[id], function(listener) {
                listener(object);
            });
        };

        var inMethod;

        // copied directly from dojo/store/Observable
        function whenFinished(method, action){
            var original = store[method];

            if(original) {
                store[method] = function(value) {
                    if(inMethod) {
                        // if one method calls another (like add() calling put()) we don't want two events
                        return original.apply(this, arguments);
                    }

                    inMethod = true;

                    try {
                        var results = original.apply(this, arguments);

                        when(results, function() {
                            action(value);
                        });

                        return results;
                    } finally {
                        inMethod = false;
                    }
                };
            }
        }

        // monitor for updates by listening to these methods
        whenFinished('put', function(object) {
            store.notifyGet(object, store.getIdentity(object));
        });

        whenFinished('remove', function(id) {
            store.notifyGet(null, id);
        });

        return store;
    };

    return ObservableWithGet;
});

},
'pepper/services':function(){
define([
    'module',
    'vodori/provide',
    'pepper/services/servicesWrapper'
], function (module, provide, servicesWrapper) {
    return provide(module.id, servicesWrapper);
});

},
'pepper/services/servicesWrapper':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/json', 'dojo/_base/lang',
    'dojo/dom-construct', 'dojo/_base/kernel',
    'vodori/rpc/Service',
    'pepper/services/_serverServices', 'pepper/services/pepperServices', 'pepper/services/ServiceCallCache',
    'pepper/ui/handleNotification',
    'pepper/services/serviceStates', 'pepper/services/serviceManager',
    'vodori/ui/Button', 'vodori/util/PageUnloadPauser'
], function (module, provide,
             _,
             json, lang,
             domConstruct,
             kernel,
             Service,
             _serverServices, pepperServices, ServiceCallCache,
             handleNotification,
             serviceStates, serviceManager,
             Button, PageUnloadPauser) {
    /**
     * This services wrapper takes service methods defined in _serverServices
     * and combines them into a unified list of service calls. The service calls are wrapped with extra
     * functionality to allow automatic handling of service requests with notifications and dialog boxes.
     */

    // This is just a combination of the services in pepper.smd and in _serverServices.
    var wrappedServices = [_serverServices, pepperServices];

    var services = {};

    // Add the wrapped services to the services object. This got sorta weird, so we could make them distinct, but muddle
    // their membership.
    lang.mixin.apply(lang, [services].concat(wrappedServices));

    // Every time a service is called, it'll be stored here for a very short time.
    // If another request is made to the same service with the same params,
    // it'll use the stored request instead of firing a new one.
    // This is to ensure that two requests for the same data only use one request.
    var serviceCallCache = new ServiceCallCache();

    // Go through each service in the SMD and automatically handle notifications and server errors.
    // The returned Deferred will be passed only the "results" array from the response.
    // We can pass a function to run *on each result*.
    // To override all this, pass true as the last argument.
    var handledServices = {};

    /**
     * Take an SMD call and wrap it with extra functionality such as error-handling
     * and displaying notifications and dialog boxes. The wrapped function is then
     * placed in the handledServices object
     *
     * @param {string} service
     * @param {boolean} flattenParams
     */
    var wrapService = function (service, p31) {

        /**
         * @typedef Query
         * @type object
         * @property {Object} params      the parameters to send to the server
         * @property {function} callback    the callback to run after the results have been returned
         * @property {object} context     the context with which to run the callback
         */
        /**
         * Create a new service call in the handledServices object using this SMD.
         *
         * @param {Query} [query] parameters for the service call
         * @return {dojo/promise/Promise} a promise to the results returned
         */
        handledServices[service] = function (/* Object */ query) {
            query = query || {};

            // Default request workflow state is TRY
            var defaultParams = {
                state: serviceStates.begin
            };

            if (p31) {
                // The query is the `params`. This is related to a shift in pattern. We were using the params property
                // for everything, but it made the execute a service onerous.
                query = {
                    params: query
                };
            }

            // Automatically add some default params to the query if they are missing
            query.params = lang.mixin(defaultParams, query.params);

            return executeService.call(this, query);
        };

        /**
         * Run the service and handle any dialog boxes or notifications necessary
         *
         * @param {Query} [query] parameters for the service call
         * @return {dojo/promise/Promise} the results
         */
        var executeService = function (/* Object */ query) {
            // A unique token used for caching service requests
            var cacheKey = _generateCacheKey(query);

            if (serviceCallCache.contains(cacheKey)) {
                _handleCachedServiceCall(query, cacheKey);
            } else {
                _executeAndCacheNewServiceCall(query, cacheKey);
            }

            var responseDeferred = serviceCallCache.getDeferred(cacheKey);

            _applyCallbackFromQueryToDeferred(query, responseDeferred);

            return responseDeferred;
        };

        var _generateCacheKey = function (query) {
            return service + json.stringify(query.params);
        };

        var _handleCachedServiceCall = function (query, cacheKey) {
            var cachedQuery = serviceCallCache.get(cacheKey);
            query.params = cachedQuery.params;

            _logQuery('USING CACHED SERVICE CALL', query);
        };

        var _logQuery = function (message, query) {
            if (query.params && typeof query.params.command === 'string') {
                console.info(message + ' (%s). QUERY:', query.params.command, query);
            } else {
                console.info(message + '. QUERY:', query);
            }
        };

        var _executeAndCacheNewServiceCall = function (query, cacheKey) {
            _prepareQueryForExecution(query);
            var responseDeferred = _registerManagedServiceCall(query);
            _cacheQueryWithDeferred(cacheKey, query, responseDeferred);
            try {
                _callTheService(query);
            } finally {
                // Log after the service call because the call adds the command name to the query
                _logQuery('EXECUTING SERVICE', query);
            }
        };

        var _prepareQueryForExecution = function (query) {
            // Set new conversation id
            query.params.conversationId = getConversationId(query.params);
        };

        var _cacheQueryWithDeferred = function (cacheKey, query, deferred) {
            serviceCallCache.put(cacheKey, query);
            serviceCallCache.setDeferred(cacheKey, deferred);
        };

        /**
         * Add or retrieve the managed service call from the service manager.
         *
         * @param {Query} [query] parameters for the service call
         * @return {dojo/Deferred} a 'super' deferred that encapsulates all service
         * requests sharing a conversationId
         */
        var _registerManagedServiceCall = function (query) {
            // This is the actual Deferred we will be returning. It represents
            // a series of service requests and callbacks that are chained to this Deferred.
            var superDeferred = serviceManager.addRequest(query);
            return superDeferred;
        };

        /**
         * This will execute the actual service request.
         *
         * @param {Query} [query] parameters for the service call
         */
        var _callTheService = function (/* Object */ query) {
            var serviceCall = services[service];
            var request = serviceCall(query.params);

            // Add internal callbacks to handle the response of every service request
            request.then(lang.partial(requestHandler, query.params), function(err) {
                // this will catch 500 errors that happen during requests - very different from other exceptions
                // that still return a JSON object with exception information (handled separately)
                handleNotification({
                    message: 'We\'re sorry, but something went wrong. We\'ve notified the engineers about the issue.',
                    type: 'toast'
                });

            });

            if (serviceCall.progressDialog.type !== 'none') {
                // If the server is taking a while, let's show a modal dialog.
                setTimeout(lang.partial(indicateSlowServiceCall, request, query.params.conversationId),
                           serviceCall.progressDialog.timeout);
            }
        };

        /**
         * Support for legacy 'callback' in query. If the query has a callback function, attach it
         * to the deferred. Also log a warning to refactor.
         * @param {Query} [query] parameters for the service call
         * @param deferred
         * @private
         */
        var _applyCallbackFromQueryToDeferred = function (query, deferred) {
            // been eliminated.
            if ('callback' in query) {
                kernel.deprecated('query.callback is a stale pattern.', 'Refactor to use Deferred.');
                deferred.then(lang.hitch(query.context, query.callback));
            }
        };


        /*
         * The PageUnloadPauser is used to pause the display of errors when a page is unloading
         * Only one is needed to handle all handled requests.
         */
        var pauser = new PageUnloadPauser();

        /**
         * Called when a response from the server comes back. Handles stateful
         * requests as well as errors.
         *
         * @param params    the original params sent with the request
         * @param response  the response object
         */
        var requestHandler = function (/* Object */ params, /* Object */ response) {
            // If there was an error with the request, handle everything here
            // Error happens when we don't get back status 200
            if (!response || response instanceof Error) {
                // If there is no response, it means the server is down
                response = response || {
                    message: 'Unable to connect to the server'
                };

                // Create an object for the serviceManager to clear out the super deferred
                var errorContainer = {
                    command: {
                        conversationId: params.conversationId
                    },
                    message: response.message,
                    params: params
                };

                // If the page is unloading, hold off on reporting this stuff for a better user experience
                return pauser.pauseIfUnloading(function () {
                    serviceManager.failRequest(errorContainer);

                    // Create the error message to display in the piece of toast popup
                    response.message = buildErrorStatusMessage(params, response);
                    return handleError(response);
                });
            }

            // If the request went through and we got a 200 response from the server, move onwards!

            if (response.deliveryMethod === 'UI_ALERT') { // Handle responses directed towards the UI
                handleSuccess(response);
            } else if (response.deliveryMethod === 'INBOX') { // Handle inbox-related responses
                handleNotification({
                    title: 'Inbox Notification',
                    message: 'Implement this.'
                });
            }

            // New style no longer sends command back w/ the response.
            if (p31) {
                lang.mixin(response, {
                    command: params
                });
            }

            // If we're not using a stateful request or the request chain has completed,
            // tell the service manager that it is complete
            if (!response.state || response.state === serviceStates.success) {
                serviceManager.completeRequest(response);
            } else if (response.state === serviceStates.error || !response.successful) {
                serviceManager.failRequest(response);
            }
        };

        /**
         * Retrieve the request chain identification token
         *
         * @param params    the PepperAJAXCommand
         * @return String   the conversation id
         */
        var getConversationId = function (/* Object */ params) {
            // Retrieve the token or generate one if it doesn't exist
            if (params && 'conversationId' in params) {
                return params.conversationId;
            } else {
                return serviceManager.generateToken();
            }
        };

        /**
         * Successful service calls are handled here
         *
         * @param response the response object
         */
        var handleSuccess = function (response) {
            if (response.notificationStyle !== 'NONE') {
                handleNotification(response);
            } else {
                // We want to catch any cases where the response returns, but isn't
                // successful and there is no notification dialog to notify the user
                if (response.state === 'ERROR' || !response.successful) {
                    handleError(response);
                }
            }
        };

        /**
         * Handle when service calls fail
         *
         * @param response  the response object
         */
        var handleError = function (response) {
            if (!response) {
                return;
            }

            // We're going to attempt a few different ways to provide a good error message to the user
            var errorMessage = '';

            if (!response.message) {
                // If there is no attached message, try building a message from results
                _.forEach(response.results, function (result, index) {
                    if (result.message) {
                        errorMessage += '<p><strong>Result ' + (index + 1) + ':</strong> ' + result.message + '</p>';
                    }
                });
            } else {
                // Otherwise use the attached message
                errorMessage = response.message;
            }

            // If there's still no error message, try to determine the best message
            // to give to the user
            if (!errorMessage) {
                if (!response.successful) {
                    errorMessage = 'The request went through, but the server was unable to complete your request';
                } else {
                    errorMessage = 'There was an error with the request';
                }
            }

            handleNotification({
                title: 'Error at <code>' + service + '</code>',
                message: errorMessage
            });
        };

        /**
         * Builds an error message for responses that return error statuses other than 200
         *
         * @param params    the original params sent with the request
         * @param response  the response object
         *
         * @return DOMNode      A DOM node containing the error message
         */
        var buildErrorStatusMessage = function (/* Object */ params, /* Object */ response) {
            // Build a pretty message containing the response message and original params
            var messageContainer = domConstruct.create('div');

            // If there is an HTML response page, create a button to display it
            if (response.responseText) {
                // Build a button that will popup a new window with the full error details
                var popupHTML = response.responseText();
                var popupButton = new Button({
                    label: 'View Error',
                    onClick: function () {
                        var popupWindow = window.open('', '', 'location=no, menubar=no, status=no, toolbar=no');
                        popupWindow.document.write(popupHTML);
                        popupWindow.focus();
                    }
                });
                domConstruct.place(popupButton.domNode, messageContainer);
            }

            domConstruct.place('<p>' + response.message + '</p>', messageContainer);
            domConstruct.place('<pre>' + json.stringify(params, true) + '</pre>', messageContainer);

            return messageContainer;
        };

        /**
         * This is called after a set amount of time if the service call is
         * taking a while. It will popup a modal that blocks users input letting
         * them know that the request is taking a while.
         *
         * @param request   the request we're waiting for
         * @param requestId the ID of the super deferred
         */
        var indicateSlowServiceCall = function (/* dojo/Deferred */ request, requestId) {
            // Do nothing if the service call is already resolved.
            if (request.isFulfilled() || serviceManager.isFulfilled(requestId)) {
                return;
            }

            // Apply custom progress dialog properties defined in _serverServices, if any
            var progressDialog = services[service].progressDialog;

            var message;
            if (progressDialog.message && progressDialog.message !== '') {
                message = progressDialog.message;
            } else if (progressDialog.name && progressDialog.name !== '') {
                message = 'Your request for ' + progressDialog.name + ' is taking a while.';
            } else {
                message = 'Your request is currently being processed.';
            }

            var waitDialog = handleNotification({
                type: services[service].progressDialog.type,
                title: 'Please wait',
                message: message,
                buttons: []
            });

            // Hide the dialog whether or not it was completed successfully.
            var hideDialog = lang.hitch(waitDialog, 'hide');
            request.then(hideDialog, hideDialog);
        };
    };

    _.forEach(wrappedServices, function (service) {
        // Apply service handler to all services and provide resulting services
        for (var method in service) {
            // Ignore dojox.rpc.Service inherited attributes
            if (typeof service[method] === 'function' && !(method in Service.prototype)) {
                wrapService(method, !!service.p31);
            }
        }
    });


    return provide(module.id, handledServices);
});

},
'vodori/rpc/Service':function(){
define([
    'lodash',
    'dojo/_base/declare', 'dojo/_base/config', 'dojo/_base/lang', 'dojo/json',
    'dojo/has',
    'dojo/query',
    'dojo/request/registry',
    'dojo/io-query',
    'dojo/request/script',
    'dojo/AdapterRegistry',
    'vodori/util/csrf'
], function (_, declare, config, lang, JSON, has, query, requestRegistry, ioQuery, script, AdapterRegistry, csrf) {
    /**
     * Version of dojox/rpc/Service that is able to be run within Rhino\EnvJs for unit tests.
     * Doesn't read\write from the global dojo and dojox objects, uses non-deprecated versions of modules, etc...
     */
    var module = declare(null, {
            constructor: function (smd, options) {
                var mid;
                var self = this;

                function processSmd(smd) {
                    smd._baseUrl =  1  ? '' : config.baseUrl;
                    self._smd = smd;

                    //generate the methods
                    _.forOwn(self._smd.services, function(service, serviceName) {
                        var pieces = serviceName.split('.'); // handle "namespaced" services by breaking apart by .
                        var current = self;
                        for (var i = 0; i < pieces.length - 1; i++) {
                            // create or reuse each object as we go down the chain
                            current = current[pieces[i]] || (current[pieces[i]] = {});
                        }
                        current[pieces[pieces.length - 1]] = self._generateService(serviceName, service);
                    });

                    self._postConstruct(options);
                }

                if (smd) {
                    //ifthe arg is a string, we assume it is a url to retrieve an smd definition from
                    if (_.isString(smd)) {
                        mid = 'dojo/text!' + smd;

                        require([mid], function (text) {
                            processSmd(JSON.parse(text));
                        });
                    } else {
                        processSmd(smd);
                    }
                }
                else {
                    this._postConstruct(options);
                }
            },

            _postConstruct: function (options) {
                this._options = (options ? options : {});
                this._requestId = 0;
            },

            _generateService: function (serviceName, method) {
                if (this[method]) {
                    throw new Error('WARNING: ' + serviceName + ' already exists for service. ' +
                                    'Unable to generate function');
                }
                method.name = serviceName;
                var func = lang.hitch(this, '_executeMethod', method);
                var transport = module.transportRegistry.match(method.transport || this._smd.transport);
                if (transport.getExecutor) {
                    func = transport.getExecutor(func, method, this);
                }
                var schema = method.returns || (method._schema = {}); // define the schema
                var servicePath = '/' + serviceName + '/';
                // schemas are minimally used to track the id prefixes for the different services
                schema._service = func;
                func.servicePath = servicePath;
                func._schema = schema;
                func.id = module._nextId++;
                return func;
            },

            _createFromNamedParams: function (args, parameters, strict) {
                var i;
                if ((args.length === 1) && _.isObject(args[0])) {
                    // looks like we have what we want
                    args = args[0];
                } else {
                    // they provided ordered, must convert
                    var data = {};
                    for (i = 0; i < parameters.length; i++) {
                        if (typeof args[i] !== 'undefined' || !parameters[i].optional) {
                            data[parameters[i].name] = args[i];
                        }
                    }
                    args = data;
                }

                if (strict) {
                    args = _.pick(args, function (value, key) {
                        return _.some(parameters, function (parameter) {
                            return parameter.name === key;
                        });

                    });
                }
                // setting default values
                _.forEach(parameters, function (param) {
                    if (!param.optional && param.name && !args[param.name]) {
                        if (param['default']) {
                            args[param.name] = param['default'];
                        } else if (!(param.name in args)) {
                            throw new Error('Required parameter ' + param.name + ' was omitted');
                        }
                    }
                });
                return args;
            },

            _getRequest: function (method, args) {
                var smd = this._smd,
                    envelope = module.envelopeRegistry.match(method.envelope || smd.envelope || 'NONE'),
                    parameters = (method.parameters || []).concat(smd.parameters || []);

                if (envelope.namedParams) {
                    args = this._createFromNamedParams(args,
                                                       parameters,
                                                       method.strictParameters || smd.strictParameters);
                }
                else if (parameters[0] && parameters[0].name && (args.length === 1) && _.isObject(args[0])) {
                    // looks like named params, we will convert
                    if (envelope.namedParams === false) {
                        // the serializer is expecting ordered params, must be ordered
                        args = module.toOrdered(parameters, args);
                    } else {
                        // named is ok
                        args = args[0];
                    }
                }

                if (_.isObject(this._options)) {
                    args = lang.mixin(args, this._options);
                }

                var schema = method._schema || method.returns; // serialize with the right schema for the context;
                var request = envelope.serialize.apply(this, [smd, method, args]);
                request._envDef = envelope;// save this for executeMethod
                var contentType = (method.contentType || smd.contentType || request.contentType);

                // this allows to mandate synchronous behavior from elsewhere when necessary,
                // this may need to be changed to be one-shot in FF3 new sync handling model
                return lang.mixin(request, {
                    sync: false,
                    contentType: contentType,
                    headers: method.headers || smd.headers || request.headers || {},
                    target: request.target || module.getTarget(smd, method),
                    transport: method.transport || smd.transport || request.transport,
                    envelope: method.envelope || smd.envelope || request.envelope,
                    timeout: method.timeout || smd.timeout,
                    callbackParamName: method.callbackParamName || smd.callbackParamName,
                    rpcObjectParamName: method.rpcObjectParamName || smd.rpcObjectParamName,
                    schema: schema,
                    handleAs: request.handleAs || 'auto',
                    preventCache: method.preventCache || smd.preventCache,
                    frameDoc: this._options.frameDoc || undefined
                });
            },

            _executeMethod: function (method) {
                var args = [];
                var i;
                for (i = 1; i < arguments.length; i++) {
                    args.push(arguments[i]);
                }
                var request = this._getRequest(method, args);
                var deferred = module.transportRegistry.match(request.transport).fire(request);

                deferred.then(function (results) {
                    return request._envDef.deserialize.call(this, results);
                });
                return deferred;
            }
        });

    module.getTarget = function (smd, method) {
        var dest = smd._baseUrl;
        if (method.target) {
            dest = dest + method.target + '';
        }
        else if (smd.target) {
            dest = dest + smd.target + '';
        }
        return dest;
    };

    module.toOrdered = function (parameters, args) {
        if (_.isArray(args)) {
            return args;
        }
        var data = [];
        for (var i = 0; i < parameters.length; i++) {
            data.push(args[parameters[i].name]);
        }
        return data;
    };

    module.transportRegistry = new AdapterRegistry(true);

    var csrfHeaders = csrf.getHeaderKeyValuePair();

    var transportRegistry = module.transportRegistry;

    //post is registered first because it is the default;
    transportRegistry.register(
        'POST',
        function (str) {
            return str === 'POST';
        },
        {
            fire: function (r) {
                r.url = r.target;
                r.postData = r.data;

                var headers = {
                    'Content-Type': r.contentType
                };

                lang.mixin(headers, r.headers, csrfHeaders);

                return requestRegistry.post(r.url, {
                    data: r.postData,
                    handleAs: r.handleAs,
                    headers: headers
                });
            }
        }
    );

    transportRegistry.register(
        'GET',
        function (str) {
            return str === 'GET';
        },
        {
            fire: function (r) {
                var target = r.target,
                    query = (r.data ? '?' + ((r.rpcObjectParamName) ? r.rpcObjectParamName + '=' : '') + r.data : '');

                r.url = target + query;

                var headers = {
                    'Content-Type': r.contentType
                };

                lang.mixin(headers, r.headers, csrfHeaders);

                return requestRegistry.get(target, {
                    query: query,
                    handleAs: r.handleAs,
                    headers: headers
                });
            }
        }
    );

    transportRegistry.register(
        'JSONP',
        function (str) {
            return str === 'JSONP';
        },
        {
            fire: function (r) {
                r.url = r.target +
                        ((r.target.indexOf('?') === -1) ? '?' : '&') +
                        ((r.rpcObjectParamName) ? r.rpcObjectParamName + '=' : '') +
                        r.data;
                r.callbackParamName = r.callbackParamName || 'callback';
                return script.get(r);
            }
        }
    );

    module.envelopeRegistry = new AdapterRegistry(true);

    var envelopeRegistry = module.envelopeRegistry;

    //Built In Envelopes
    envelopeRegistry.register(
        'URL',
        function (str) {
            return str === 'URL';
        },
        {
            serialize: function (smd, method, data) {
                var d = ioQuery.objectToQuery(data);
                return {
                    data: d,
                    transport: 'POST'
                };
            },
            deserialize: function (results) {
                return results;
            },
            namedParams: true
        }
    );

    envelopeRegistry.register(
        'JSON',
        function (str) {
            return str === 'JSON';
        },
        {
            serialize: function (smd, method, data) {
                var d = JSON.stringify(data);

                return {
                    data: d,
                    handleAs: 'json',
                    contentType: 'application/json'
                };
            },
            deserialize: function (results) {
                return results;
            }
        }
    );

    envelopeRegistry.register(
        'PATH',
        function (str) {
            return str === 'PATH';
        },
        {
            serialize: function (smd, method, data) {
                var i;
                var target = module.getTarget(smd, method);
                if (_.isArray(data)) {
                    for (i = 0; i < data.length; i++) {
                        target += '/' + data[i];
                    }
                } else {
                    for (i in data) {
                        target += '/' + i + '/' + data[i];
                    }
                }

                return {
                    data: '',
                    target: target
                };
            },
            deserialize: function (results) {
                return results;
            }
        }
    );

    module._nextId = 1;

    // Fairly certain this is not used.
    /*dojo._contentHandlers.auto = function(xhr){
     // automatically choose the right handler based on the returned content type
     var handlers = dojo._contentHandlers;
     var retContentType = xhr.getResponseHeader("Content-Type");
     var results = !retContentType ? handlers.text(xhr) :
     retContentType.match(/\/.*json/) ? handlers.json(xhr) :
     retContentType.match(/\/javascript/) ? handlers.javascript(xhr) :
     retContentType.match(/\/xml/) ? handlers.xml(xhr) : handlers.text(xhr);
     return results;
     };*/

    return module;
});

},
'dojo/request/script':function(){
define([
	'module',
	'./watch',
	'./util',
	'../_base/kernel',
	'../_base/array',
	'../_base/lang',
	'../on',
	'../dom',
	'../dom-construct',
	'../has',
	'../_base/window'/*=====,
	'../request',
	'../_base/declare' =====*/
], function(module, watch, util, kernel, array, lang, on, dom, domConstruct, has, win/*=====, request, declare =====*/){
	has.add('script-readystatechange', function(global, document){
		var script = document.createElement('script');
		return typeof script['onreadystatechange'] !== 'undefined' &&
			(typeof global['opera'] === 'undefined' || global['opera'].toString() !== '[object Opera]');
	});

	var mid = module.id.replace(/[\/\.\-]/g, '_'),
		counter = 0,
		loadEvent = has('script-readystatechange') ? 'readystatechange' : 'load',
		readyRegExp = /complete|loaded/,
		callbacks = kernel.global[mid + '_callbacks'] = {},
		deadScripts = [];

	function attach(id, url, frameDoc){
		var doc = (frameDoc || win.doc),
			element = doc.createElement('script');

		element.type = 'text/javascript';
		element.src = url;
		element.id = id;
		element.async = true;
		element.charset = 'utf-8';

		return doc.getElementsByTagName('head')[0].appendChild(element);
	}

	function remove(id, frameDoc, cleanup){
		domConstruct.destroy(dom.byId(id, frameDoc));

		if(callbacks[id]){
			if(cleanup){
				// set callback to a function that deletes itself so requests that
				// are in-flight don't error out when returning and also
				// clean up after themselves
				callbacks[id] = function(){
					delete callbacks[id];
				};
			}else{
				delete callbacks[id];
			}
		}
	}

	function _addDeadScript(dfd){
		// Be sure to check ioArgs because it can dynamically change in the dojox/io plugins.
		// See http://bugs.dojotoolkit.org/ticket/15890.
		var options = dfd.response.options,
			frameDoc = options.ioArgs ? options.ioArgs.frameDoc : options.frameDoc;

		deadScripts.push({ id: dfd.id, frameDoc: frameDoc });

		if(options.ioArgs){
			options.ioArgs.frameDoc = null;
		}
		options.frameDoc = null;
	}

	function canceler(dfd, response){
		if(dfd.canDelete){
			//For timeouts and cancels, remove the script element immediately to
			//avoid a response from it coming back later and causing trouble.
			script._remove(dfd.id, response.options.frameDoc, true);
		}
	}
	function isValid(response){
		//Do script cleanup here. We wait for one inflight pass
		//to make sure we don't get any weird things by trying to remove a script
		//tag that is part of the call chain (IE 6 has been known to
		//crash in that case).
		if(deadScripts && deadScripts.length){
			array.forEach(deadScripts, function(_script){
				script._remove(_script.id, _script.frameDoc);
				_script.frameDoc = null;
			});
			deadScripts = [];
		}

		return response.options.jsonp ? !response.data : true;
	}
	function isReadyScript(response){
		return !!this.scriptLoaded;
	}
	function isReadyCheckString(response){
		var checkString = response.options.checkString;

		return checkString && eval('typeof(' + checkString + ') !== "undefined"');
	}
	function handleResponse(response, error){
		if(this.canDelete){
			_addDeadScript(this);
		}
		if(error){
			this.reject(error);
		}else{
			this.resolve(response);
		}
	}

	function script(url, options, returnDeferred){
		var response = util.parseArgs(url, util.deepCopy({}, options));
		url = response.url;
		options = response.options;

		var dfd = util.deferred(
			response,
			canceler,
			isValid,
			options.jsonp ? null : (options.checkString ? isReadyCheckString : isReadyScript),
			handleResponse
		);

		lang.mixin(dfd, {
			id: mid + (counter++),
			canDelete: false
		});

		if(options.jsonp){
			var queryParameter = new RegExp('[?&]' + options.jsonp + '=');
			if(!queryParameter.test(url)){
				url += (~url.indexOf('?') ? '&' : '?') +
					options.jsonp + '=' +
					(options.frameDoc ? 'parent.' : '') +
					mid + '_callbacks.' + dfd.id;
			}

			dfd.canDelete = true;
			callbacks[dfd.id] = function(json){
				response.data = json;
				dfd.handleResponse(response);
			};
		}

		if(util.notify){
			util.notify.emit('send', response, dfd.promise.cancel);
		}

		if(!options.canAttach || options.canAttach(dfd)){
			var node = script._attach(dfd.id, url, options.frameDoc);

			if(!options.jsonp && !options.checkString){
				var handle = on(node, loadEvent, function(evt){
					if(evt.type === 'load' || readyRegExp.test(node.readyState)){
						handle.remove();
						dfd.scriptLoaded = evt;
					}
				});
			}
		}

		watch(dfd);

		return returnDeferred ? dfd : dfd.promise;
	}
	script.get = script;
	/*=====
	script = function(url, options){
		// summary:
		//		Sends a request using a script element with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/script.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	script.__BaseOptions = declare(request.__BaseOptions, {
		// jsonp: String?
		//		The URL parameter name that indicates the JSONP callback string.
		//		For instance, when using Yahoo JSONP calls it is normally,
		//		jsonp: "callback". For AOL JSONP calls it is normally
		//		jsonp: "c".
		// checkString: String?
		//		A string of JavaScript that when evaluated like so:
		//		"typeof(" + checkString + ") != 'undefined'"
		//		being true means that the script fetched has been loaded.
		//		Do not use this if doing a JSONP type of call (use `jsonp` instead).
		// frameDoc: Document?
		//		The Document object of a child iframe. If this is passed in, the script
		//		will be attached to that document. This can be helpful in some comet long-polling
		//		scenarios with Firefox and Opera.
	});
	script.__MethodOptions = declare(null, {
		// method: String?
		//		This option is ignored. All requests using this transport are
		//		GET requests.
	});
	script.__Options = declare([script.__BaseOptions, script.__MethodOptions]);

	script.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using a script element with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/script.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/

	// TODO: Remove in 2.0
	script._attach = attach;
	script._remove = remove;
	script._callbacksProperty = mid + '_callbacks';

	return script;
});

},
'dojo/AdapterRegistry':function(){
define(["./_base/kernel", "./_base/lang"], function(dojo, lang){
// module:
//		dojo/AdapterRegistry

var AdapterRegistry = dojo.AdapterRegistry = function(/*Boolean?*/ returnWrappers){
	// summary:
	//		A registry to make contextual calling/searching easier.
	// description:
	//		Objects of this class keep list of arrays in the form [name, check,
	//		wrap, directReturn] that are used to determine what the contextual
	//		result of a set of checked arguments is. All check/wrap functions
	//		in this registry should be of the same arity.
	// example:
	//	|	// create a new registry
	//	|	require(["dojo/AdapterRegistry"],
	//	|	function(AdapterRegistry){
	//	|		var reg = new AdapterRegistry();
	//	|		reg.register("handleString",
	//	|			function(str){
	//	|				return typeof val == "string"
	//	|			},
	//	|			function(str){
	//	|				// do something with the string here
	//	|			}
	//	|		);
	//	|		reg.register("handleArr",
	//	|			dojo.isArray,
	//	|			function(arr){
	//	|				// do something with the array here
	//	|			}
	//	|		);
	//	|
	//	|		// now we can pass reg.match() *either* an array or a string and
	//	|		// the value we pass will get handled by the right function
	//	|		reg.match("someValue"); // will call the first function
	//	|		reg.match(["someValue"]); // will call the second
	//	|	});

	this.pairs = [];
	this.returnWrappers = returnWrappers || false; // Boolean
};

lang.extend(AdapterRegistry, {
	register: function(/*String*/ name, /*Function*/ check, /*Function*/ wrap, /*Boolean?*/ directReturn, /*Boolean?*/ override){
		// summary:
		//		register a check function to determine if the wrap function or
		//		object gets selected
		// name:
		//		a way to identify this matcher.
		// check:
		//		a function that arguments are passed to from the adapter's
		//		match() function.  The check function should return true if the
		//		given arguments are appropriate for the wrap function.
		// directReturn:
		//		If directReturn is true, the value passed in for wrap will be
		//		returned instead of being called. Alternately, the
		//		AdapterRegistry can be set globally to "return not call" using
		//		the returnWrappers property. Either way, this behavior allows
		//		the registry to act as a "search" function instead of a
		//		function interception library.
		// override:
		//		If override is given and true, the check function will be given
		//		highest priority. Otherwise, it will be the lowest priority
		//		adapter.
		this.pairs[((override) ? "unshift" : "push")]([name, check, wrap, directReturn]);
	},

	match: function(/* ... */){
		// summary:
		//		Find an adapter for the given arguments. If no suitable adapter
		//		is found, throws an exception. match() accepts any number of
		//		arguments, all of which are passed to all matching functions
		//		from the registered pairs.
		for(var i = 0; i < this.pairs.length; i++){
			var pair = this.pairs[i];
			if(pair[1].apply(this, arguments)){
				if((pair[3])||(this.returnWrappers)){
					return pair[2];
				}else{
					return pair[2].apply(this, arguments);
				}
			}
		}
		throw new Error("No match found");
	},

	unregister: function(name){
		// summary:
		//		Remove a named adapter from the registry
		// name: String
		//		The name of the adapter.
		// returns: Boolean
		//		Returns true if operation is successful.
		//		Returns false if operation fails.
	
		// FIXME: this is kind of a dumb way to handle this. On a large
		// registry this will be slow-ish and we can use the name as a lookup
		// should we choose to trade memory for speed.
		for(var i = 0; i < this.pairs.length; i++){
			var pair = this.pairs[i];
			if(pair[0] == name){
				this.pairs.splice(i, 1);
				return true;
			}
		}
		return false;
	}
});

return AdapterRegistry;
});

},
'vodori/util/csrf':function(){
/*
 * Copyright (c) 2015. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define(['dojo/query'], function (query) {

    function getMetaContent(name) {
        var metaNode = query("meta[name='" + name + "']")[0]; // jshint ignore:line
        return metaNode ? metaNode.content : null;
    }

    /**
     * This module contains the CSRF protection parmeter and header names and the token value configured for this site.
     * These values are pulled from &lt;meta&gt; tags on the page.
     */
    return {
        /**
         * name for form parameter to use when submitting CSRF protection token
         */
        parameterName: getMetaContent('_csrf_param'),

        /**
         * name of the header to use when submitting CSRF protection token with an AJAX request
         */
        headerName: getMetaContent('_csrf_header'),

        /**
         * value of the CSRF protection token
         */
        token: getMetaContent('_csrf'),

        /**
         * Get the parameter -> token pair as an object with the parameterName as the only key and the token as the
         * value.
         * @returns {{}}
         */
        getParameterKeyValuePair: function() {
            var pair = {};
            pair[this.parameterName] = this.token;
            return pair;
        },

        /**
         * Get the header -> token pair as an object with the headerName as the only key and the token as the value.
         * @returns {{}}
         */
        getHeaderKeyValuePair: function() {
            var pair = {};
            pair[this.headerName] = this.token;
            return pair;
        }
    };
});
},
'pepper/services/_serverServices':function(){
define([
    'dojo/_base/declare',
    'vodori/rpc/Service',
    'dojo/has'
], function (declare, Service, has) {
    /*
     * Unfortunately, we have to use this older style code for accessing the envelopeRegistry, since the
     * dojox.rpc.Service code demands it.
     */
    var envelopeRegistry = Service.envelopeRegistry;
    // These services return data from the server.

    // Extend the JSON envelope to allow named parameters
    var jsonEnvelope = envelopeRegistry.match('JSON');
    envelopeRegistry.register('JSON-named', function (str) {
        return str === 'JSON-named';
    }, {
        serialize: jsonEnvelope.serialize,
        deserialize: jsonEnvelope.deserialize,
        namedParams: true
    });

    /**
     * Custom service wrapper to do some additional processing of the JSON service descriptor
     */
    var ServiceCtor = declare(Service, {
        _generateService: function (serviceName, method) {
            var f = this.inherited(arguments);
            f.updatesRegistry = method.updatesRegistry || this._smd.updatesRegistry;
            f.progressDialog = method.progressDialog || this._smd.progressDialog;
            return f;
        }
    });

    var services = new ServiceCtor({
        SMDVersion: '2.0',

        target: '/pepper-ajax-call/execute',
        transport: 'POST',
        envelope: 'JSON-named',

        // These are included in every request
        // Each service will hit the same URL, but pass along its command name
        parameters: [
            // If content: objectId, versionSeriesId
            { name: 'command', type: 'string', 'default': 'COMMAND_MISSING', 'optional': false }
        ],

        // If you want your service's response to automatically update the object registry, updatesRegistry must be true
        updatesRegistry: false,
        additionalParameters: true,

        // Default long running service call progress dialog behavior
        // This property will decide how the user should be notified of a service call that is
        // taking a long time to complete
        progressDialog: {
            name: null,    // an optional human friendly name for the service call
            message: null, // override the long progress dialog waiting message here
                           // (the 'name' property above will be ignored)
            type: 'modal', // the notification type to display: 'modal', 'toaster', or 'none'
            timeout: 1000  // the amount of time in milliseconds to wait before displaying the notification
        },

        services: {
            // Get a list of objects matching the query
            queryLibrary: {
                updatesRegistry: true,
                progressDialog: {
                    name: 'library results',
                    type: 'toaster',
                    timeout: 3000
                },
                parameters: [
                    {name: 'command', 'default': 'QUERY_LIBRARY'},
                    {name: 'query', type: 'object', optional: false}
                ],

                returns: {}
            },

            queryInbox: {
                parameters: [
                    {name: 'command', 'default': 'QUERY_INBOX'},
                    {name: 'query', type: 'object', optional: false}
                ]
            },

            getNotificationDetails: {
                parameters: [
                    {name: 'command', 'default': 'GET_NOTIFICATION_DETAILS'},
                    {name: 'id', type: 'string', optional: false},
                    {name: 'type', type: 'string', optional: false}
                ]
            },

            stripeQuery: {
                parameters: [
                    { name: 'command', type: 'string', 'default': 'STRIPE_QUERY' },
                    { name: 'search', type: 'string' }
                ]
            },

            getAuditHistory: {
                parameters: [
                    { name: 'command', 'default': 'GET_AUDIT_HISTORY' },
                    { name: 'objects', 'type': 'array' }
                ]
            },

            getRelationships: {
                parameters: [
                    { name: 'command', 'default': 'GET_RELATIONSHIPS' },
                    { name: 'objects', 'type': 'array' }
                ]
            },

            getVersionHistory: {
                parameters: [
                    { name: 'command', 'default': 'GET_VERSION_HISTORY' },
                    { name: 'objects', 'type': 'array' }
                ]
            },

            getWorkflowHistory: {
                parameters: [
                    { name: 'command', 'default': 'GET_WORKFLOW_HISTORY'},
                    { name: 'objects', 'type': 'array'}
                ]
            },

            getImportReviewFileInfo: {
                updatesRegistry: true,
                parameters: [
                    { name: 'command', 'default': 'GET_BASIC_FILE_INFO_FOR_IMPORT_REVIEW' },
                    { name: 'objects', 'type': 'array' }
                ]
            },

            edit: {
                parameters: [
                    { name: 'command', type: 'string', 'default': 'EDIT' },
                    { name: 'objects', 'type': 'array' }
                ]
            },


            getAvailableCommands: {
                mockTarget: '/static/js/pepper/mockData/availableCommands.json',
                progressDialog: {
                    type: 'none'
                },
                parameters: [
                    {name: 'command', 'default': 'GET_AVAILABLE_COMMANDS'},
                    {name: 'objects', 'type': 'array'}
                ]
            },

            getDetailsSummary: {
                updatesRegistry: true,
                parameters: [
                    {name: 'command', 'default': 'GET_LIBRARY_DETAIL_SUMMARY'},
                    {name: 'objects', 'type': 'array'}
                ]
            },

            // Get a list of directories
            getDirectories: {
                parameters: [
                    {name: 'command', 'default': 'GET_DIRECTORIES'},
                    {name: 'directoryType', 'default': 'DIRECTORIES'} // or "FOLKSONOMIES" or "TAXONOMIES"
                ]
            },

            // A map of an object's properties to their values
            getInfo: {
                mockTarget: '/static/js/pepper/mockData/pageStatus.json',
                updatesRegistry: true,
                parameters: [
                    {name: 'command', type: 'string', 'default': 'GET_INFO'},
                    {name: 'objects', type: 'array'}
                ],

                returns: {
                    // Everything you could ever want to know about an object.
                    // See pepper/ObjectStatus and pepper/mockData/pageStatus.json
                }
            },

            // Returns a tree containing the site's navigation elements
            getNavigation: {
                mockTarget: '/static/js/pepper/mockData/navigation.json',
                updatesRegistry: true,
                progressDialog: {
                    name: 'navigation elements',
                    type: 'toaster',
                    timeout: 15000
                },
                parameters: [
                    { name: 'command', type: 'string', 'default': 'GET_NAVIGATION' },
                    { name: 'objects', type: 'array', optional: true }
                ]
            },

            switchNavigation: {
                parameters: [
                    { name: 'command', type: 'string', 'default': 'SWITCH_NAVIGATION' },
                    { name: 'objects', type: 'array', optional: true }
                ]

            },

            deleteNavigation: {
                parameters: [
                    { name: 'command', type: 'string', 'default': 'DELETE_NAVIGATION' }
                ]
            },

            pasteNavigation: {
                parameters: [
                    { name: 'command', type: 'string', 'default': 'PASTE_NAVIGATION' },
                    { name: 'profile', type: 'string' },
                    { name: 'copiedElementId', type: 'string' },
                    { name: 'parentElementId', type: 'string' },
                    { name: 'position', type: 'string'},
                    { name: 'before', type: 'boolean'}
                ]
            },

	        // Validates workflow items as they are being added to the flow in wizard
	        validateWorkflowItems: {
		        parameters: [
			        { name: 'command', type: 'string', 'default': 'VALIDATE_WORKFLOW_ITEMS'},
			        { name: 'currentlySelected', type: 'array', optional: false },
			        { name: 'currentlyValidated', type: 'array', optional: false },
			        { name: 'currentlyInvalidated', type: 'array', optional: false },
			        { name: 'workflowDefinitionKey', type: 'string', optional: false }
		        ],

		        returns: [
			        // {objectId:string, success:boolean, rejectionReason?:string}[]
		        ]
	        },

            // A list of templates in the template directory structure
            getTemplates: {
                parameters: [
                    {name: 'command', type: 'string', 'default': 'GET_TEMPLATES'},
                    {name: 'pathId', type: 'string', optional: true},
                    {name: 'networkId', type: 'string', optional: true},
                    {name: 'channelId', type: 'string', optional: true},
                    {name: 'objects', type: 'array', optional: true}
                ],

                returns: [
                    // The template tree structure
                ]
            },

            acceptWorkflowTask: {
                parameters: [
                    {name: 'command', 'default': 'ACCEPT_WORKFLOW_TASK'},
                    {name: 'taskId', type: 'string', optional: false}
                ]
            },

            releaseWorkflowTask: {
                parameters: [
                    {name: 'command', 'default': 'RELEASE_WORKFLOW_TASK'},
                    {name: 'taskId', type: 'string', optional: false}
                ]
            },

            dismissDistribution: {
                parameters: [
                    {name: 'command', 'default': 'DISMISS_DISTRIBUTION'},
                    {name: 'id', type: 'string', optional: false}
                ]
            },

            // Create a new object with the given properties
            create: {
                parameters: [
                    {name: 'command', type: 'string', 'default': 'CREATE'}
                ],

                returns: {} // Same as getInfo
            },

            // Delete a collection of objects from the repository
            deleteObjects: {
                updatesRegistry: true,
                parameters: [
                    {name: 'command', type: 'string', 'default': 'DELETE'},
                    {name: 'objects', type: 'array'}
                ],

                returns: {} // array of payload items
            },

            // Checkout an object for editing
            checkOut: {
                updatesRegistry: true,
                parameters: [
                    {name: 'command', type: 'string', 'default': 'CHECK_OUT'},
                    {name: 'objects', type: 'array'}
                ],

                returns: {} // Same as getInfo
            },

            // Perform a demote, then checkout
            demoteAndCheckout: {
                updatesRegistry: true,
                parameters: [
                    {name: 'command', type: 'string', 'default': 'DEMOTE_AND_CHECKOUT'},
                    {name: 'objects', type: 'array'}
                ],

                returns: {} // Same as getInfo
            },

            // Checkout an object for editing
            cancelCheckOut: {
                updatesRegistry: true,
                mockTarget: '/pepper-ajax-call/mock',
                parameters: [
                    {name: 'command', type: 'string', 'default': 'CANCEL'},
                    {name: 'objects', type: 'array'}
                ],

                returns: {} // Same as getInfo
            },

            // Save an object's local changes to the server
            save: {
                updatesRegistry: true,
                progressDialog: {
                    message: 'Saving...',
                    type: 'toaster',
                    timeout: 0
                },
                mockTarget: '/pepper-ajax-call/mock',
                parameters: [
                    {name: 'command', type: 'string', 'default': 'SAVE', optional: false},
                    {name: 'objects', type: 'array'}
                ],

                returns: {} // Same as getInfo
            },

            distribute: {
                updatesRegistry: true,
                progressDialog: {
                    message: 'Distributing...',
                    type: 'toaster',
                    timeout: 0
                },
                mockTarget: '/pepper-ajax-call/mock',
                parameters: [
                    {name: 'command', type: 'string', 'default': 'DISTRIBUTE', optional: false},
                    {name: 'distributionName', type: 'string'},
                    {name: 'targetChannelIds', type: 'array'},
                    {name: 'objects', type: 'array'}
                ],

                returns: {} // Same as getInfo
            },

            copy: {
                updatesRegistry: true,
                mockTarget: '/pepper-ajax-call/mock',
                parameters: [
                    {name: 'command', type: 'string', 'default': 'COPY', optional: false},
                    {name: 'objects', type: 'array'}
                ],

                returns: {} // Same as getInfo
            },

            checkIn: {
                updatesRegistry: true,
                mockTarget: '/pepper-ajax-call/mock',
                parameters: [
                    {name: 'command', type: 'string', 'default': 'CHECK_IN'},
                    {name: 'objects', type: 'array'}
                ],

                returns: {} // Same as getInfo
            },

            saveAndCheckIn: {
                updatesRegistry: true,
                parameters: [
                    {name: 'command', type: 'string', 'default': 'SAVE_AND_CHECK_IN'},
                    {name: 'comment', type: 'string', optional: true},
                    {name: 'content', type: 'object'},
                    {name: 'objects', type: 'array'}
                ],
                returns: {}
            },

            promote: {
                updatesRegistry: true,
                mockTarget: '/pepper-ajax-call/mock',
                parameters: [
                    {name: 'command', type: 'string', 'default': 'PROMOTE'},
                    {name: 'objects', type: 'array'}
                ],

                returns: {} // Same as getInfo
            },

            demote: {
                updatesRegistry: true,
                mockTarget: '/pepper-ajax-call/mock',
                parameters: [
                    {name: 'command', type: 'string', 'default': 'DEMOTE'},
                    {name: 'objects', type: 'array'}
                ],

                returns: {} // Same as getInfo
            },

            expressPromote: {
                updatesRegistry: true,
                parameters: [
                    {name: 'command', type: 'string', 'default': 'EXPRESS_PROMOTE'},
                    {name: 'objects', type: 'array'}
                ],

                returns: {}
            },

            expire: {
                updatesRegistry: true,
                parameters: [
                    {name: 'command', type: 'string', 'default': 'EXPIRE' },
                    {name: 'objects', type: 'array'}
                ],
                returns: {}
            },

            reinstate: {
                updatesRegistry: true,
                parameters: [
                    {name: 'command', type: 'string', 'default': 'REINSTATE' },
                    {name: 'objects', type: 'array'}
                ],
                returns: {}
            },

            revive: {
                updatesRegistry: true,
                parameters: [
                    {name: 'command', type: 'string', 'default': 'REVIVE' },
                    {name: 'objects', type: 'array'}
                ],
                returns: {}
            },

            createFolder: {
                parameters: [
                    { name: 'command', type: 'string', 'default': 'CREATE_FOLDER' },
                    { name: 'name', type: 'string' },
                    { name: 'description', type: 'string', optional: true },
                    { name: 'parentFolderId', type: 'string' },
                    { name: 'folderType', type: 'string' }
                ],

                returns: {}
            },

            moveTo: {
                mockTarget: '/pepper-ajax-call/mock',
                parameters: [
                    { name: 'command', type: 'string', 'default': 'MOVE_TO' },
                    { name: 'objects', type: 'array', optional: false },
                    { name: 'destinationFolderId', type: 'string', optional: false },
                    { name: 'parentFolderId', type: 'string', optional: false }
                ]
            },

            copyTo: {
                mockTarget: '/pepper-ajax-call/mock',
                parameters: [
                    { name: 'command', type: 'string', 'default': 'COPY_TO' },
                    { name: 'objects', type: 'array', optional: false },
                    { name: 'destinationFolderId', type: 'string', optional: false },
                    { name: 'parentFolderId', type: 'string', optional: false }
                ]
            },

            unfile: {
                parameters: [
                    { name: 'command', type: 'string', 'default': 'UNFILE' },
                    { name: 'objects', type: 'array', optional: false },
                    { name: 'parentFolderId', type: 'string', optional: false }
                ]
            },

            moveNavigationElement: {
                mockTarget: '/static/js/pepper/mockData/moveNavigationElement.json',
                parameters: [
                    { name: 'command', type: 'string', 'default': 'MOVE_NAVIGATION_ELEMENT' },
                    { name: 'objects', type: 'array', optional: false },
                    { name: 'parentElementId', type: 'string', optional: false }
                ]
            },

            repositionNavigationElement: {
                parameters: [
                    { name: 'command', type: 'string', 'default': 'REPOSITION_NAVIGATION_ELEMENT' },
                    { name: 'objects', type: 'array', optional: false },
                    { name: 'parentElementId', type: 'string', optional: false },
                    { name: 'newPosition', type: 'string', optional: false }
                ]
            },

            getRenditions: {
                parameters: [
                    {name: 'command', type: 'string', 'default': 'GET_RENDITIONS'},
                    {name: 'objects', type: 'array', optional: false}
                ]
            },

            deleteRendition: {
                parameters: [
                    { name: 'command', type: 'string', 'default': 'DELETE_RENDITION' },
                    { name: 'renditionVersionSeriesId', type: 'string', optional: false },
                    { name: 'objects', type: 'array', optional: false }
                ]
            },

            executeStep: {
                updatesRegistry: true,
                mockTarget: '/pepper-ajax-call/mock'
            },

            getChannels: {
                parameters: [
                    { name: 'command', type: 'string', 'default': 'GET_CHANNELS' },
                    { name: 'objects', type: 'array', optional: true}
                ]
            },

            getCustomFilters: {
                parameters: [
                    { name: 'command', type: 'string', 'default': 'GET_CUSTOM_FILTERS' },
                    { name: 'channelId', type: 'string', optional: false}
                ]
            },

            getLinksForDistribution: {
                parameters: [
                    { name: 'command', type: 'string', 'default': 'GET_LINKS_FOR_DISTRIBUTION' },
                    { name: 'objects', type: 'array', optional: false}
                ]
            },

            getSyncInfo: {
                parameters: [
                    { name: 'command', type: 'string', 'default': 'GET_SYNC_INFO' },
                    { name: 'objects', type: 'array', optional: false}
                ]
            },

            sync: {
                parameters: [
                    { name: 'command', type: 'string', 'default': 'SYNC' },
                    { name: 'objects', type: 'array', optional: false}
                ]
            }
        }
    });

    // Use mock data sources if the Dojo configuration says to
    if (has('config-mock-data')) {
        for (var service in services._smd.services) {
            if ('mockTarget' in services._smd.services[service]) {
                services._smd.services[service].target = services._smd.services[service].mockTarget;
            }
        }
    }

    return services;
});

},
'pepper/services/pepperServices':function(){
define([
    'require',
    'pepper/services/Service',
    'vodori/rpc/JsonRPC' // This file registers json-rpc-2.0.
], function (require, Service) {
    // See: https://github.com/dojo/docs/blob/master/dojox/rpc/smd.rst
    return new Service(require.toUrl('pepper/services/smds/pepper.smd'));
});

},
'pepper/services/Service':function(){
define([
    'module', 'vodori/provide',
    'vodori/rpc/Service',
    // We'll be digging around in the dojox namespace to add our envelope.
    'dojox'
], function (module, provide, Service) {

    /**
     * Simple extension of Service, which has light customizations for handling a modal and updating our registry.
     *
     * @class pepper/services/Service
     * @extends dojox/rpc/Service
     */
    return provide(module.id, [Service],
        /**
         * @lends pepper/services/Service#
         */
        {

            /**
             * Indicate this is the new style Service. Mainly, we're not using params for all our methods and
             * we're sending the request `command` back w/ the reponse.
             *
             * @type {boolean}
             */
            p31: true,

            /**
             * Hook into our custom decorations.
             *
             * @param {string} name
             * @param {Object} method
             * @return {pepper.services.Service} The generated service.
             * @private
             */
            _generateService: function (name, method) {
                var service = this.inherited(arguments);
                service.updatesRegistry = method.updatesRegistry || this._smd.updatesRegistry;
                service.progressDialog = method.progressDialog || this._smd.progressDialog;
                return service;
            }
        });
});

},
'vodori/rpc/JsonRPC':function(){
define([
    'dojo/_base/lang', 'dojo/json',
    './Service'
], function (lang, JSON, Service) {
    function jsonRpcEnvelope(version) {
        return {
            serialize: function (smd, method, data, options) {
                //not converted to json it self. This  will be done, if
                //appropriate, at the transport level

                var d = {
                    id: this._requestId++,
                    method: method.name,
                    params: data
                };
                if (version) {
                    d.jsonrpc = version;
                }
                return {
                    data: JSON.stringify(d),
                    handleAs: 'json',
                    contentType: 'application/json',
                    transport: 'POST'
                };
            },

            deserialize: function (obj) {
                if ('Error' === obj.name) {
                    obj = JSON.parse(obj.responseText);
                }
                if (obj.error) {
                    var e = new Error(obj.error.message || obj.error);
                    e._rpcErrorObject = obj.error;
                    return e;
                }
                return obj.result;
            }
        };
    }

    Service.envelopeRegistry.register(
        'JSON-RPC-1.0',
        function (str) {
            return str === 'JSON-RPC-1.0';
        },
        lang.mixin({namedParams: false}, jsonRpcEnvelope()) // 1.0 will only work with ordered params
    );

    Service.envelopeRegistry.register(
        'JSON-RPC-2.0',
        function (str) {
            return str === 'JSON-RPC-2.0';
        },
        jsonRpcEnvelope('2.0')
    );

});

},
'pepper/services/ServiceCallCache':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang'
], function (module, provide, lang) {

    /**
     * Cache for service calls and their associated Deferreds. An arbitrary value can be cached
     * under a unique cache key. A deferred can also be associated with the value. The entry is
     * removed from the cache after a time (specified by timeoutInMilliseconds) or if the deferred
     * is canceled or rejected.
     *
     * @class pepper/services/ServiceCallCache
     */
    return provide(module.id, [],
        /**
         * @lends pepper/services/ServiceCallCache.prototype
         */
        {
            timeoutInMilliseconds: 250,

            _cache: null,

            constructor: function () {
                this._cache = {};
            },

            /**
             * Does the cache currently contain an value with the given cache key
             * @param {String} key
             * @return {Boolean}
             */
            contains: function (key) {
                return this._cache.hasOwnProperty(key);
            },

            /**
             * Get the value contained in the cache with the given cache key.
             * @param {String} key
             * @return {*} the value or null if none found
             */
            get: function (key) {
                return this._get(key, 'value');
            },

            _get: function (key, objectType) {
                var cacheEntry = this._cache[key];
                if (cacheEntry) {
                    return cacheEntry[objectType];
                }
                else {
                    return null;
                }
            },

            /**
             * Put the given value into the cache, referenced by the given cache key. If an value
             * with that key already currently exists in the cache, it will be removed and replaced
             * with this new value.
             * @param {String} key
             * @param value
             */
            put: function (key, value) {
                if (this.contains(key)) {
                    // Call remove first so we can clear the timeout from a previous entry
                    this.remove(key);
                }

                this._setValue(key, value);
            },

            _setValue: function (key, value) {
                this._cache[key] =
                {
                    value: value,
                    deferred: null,
                    timeout: setTimeout(lang.hitch(this, 'remove', key), this.timeoutInMilliseconds)
                };
            },

            /**
             * Get the Deferred stored in the cache with the given cache key
             * @param {String} key
             * @return {dojo/Deferred} the deferred or null if none found
             */
            getDeferred: function (key) {
                return this._get(key, 'deferred');
            },

            /**
             * Set the Deferred associated with the given cache key. The cache must already contain
             * a value for the given key before a Deferred can be set.
             * @param {String} key
             * @param {dojo/Deferred} deferred
             * @throws {Error} if the cache does not already contain a value for the key
             */
            setDeferred: function (key, deferred) {
                var cacheEntry = this._cache[key];
                if (!cacheEntry) {
                    throw new Error('Cannot set Deferred because no cache entry exists for key: ' + key);
                }
                else {
                    this._doSetDeferred(key, cacheEntry, deferred);
                }
            },

            _doSetDeferred: function (key, cacheEntry, deferred) {
                cacheEntry.deferred = deferred;
                deferred.then(null, lang.hitch(this, '_handleDeferredReject', key, deferred));
            },

            _handleDeferredReject: function (key, deferred) {
                var currentlyCachedDeferred = this.getDeferred(key);
                if (currentlyCachedDeferred !== deferred) {
                    return;
                }

                this.remove(key);
            },

            /**
             * If there is a value in the cache with the given cache key, remove it and its
             * associated Deferred. Otherwise do nothing.
             * @param {String} key
             */
            remove: function (key) {
                var cacheEntry = this._cache[key];
                if (cacheEntry) {
                    clearTimeout(cacheEntry.timeout);
                    delete this._cache[key];
                }
            }
        }
    );
});

},
'pepper/ui/handleNotification':function(){
/**
 * @module pepper/ui/handleNotification
 */
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'dojo/topic',
    'dojo/dom-construct',
    './Dialog',
    './PieceOfToast',
    'vodori/ui/Button',
    'vodori/util/string/getFunction',
    'pepper/events',
    'pepper/services/serviceStates'
], function (provide, module,
             _,
             lang,
             topic,
             domConstruct,
             Dialog,
             PieceOfToast,
             Button,
             getFunction,
             events,
             serviceStates) {
    // NOTIFICATION:
    // A notification is an object with:
    //
    // A type string,
    // "modal", "action", or "toaster". Default is toaster.
    //
    // An expireAfter integer
    // Optional time in milliseconds after which a toaster will hide itself
    //
    // A title string
    // Default is "Notification".
    //
    // A message string
    //
    // A buttons array (of objects).
    //
    // BUTTONS:
    // Along with a label, each button object can contain:
    //
    // An action string (or function)
    // Either a function or a string that can resolve to a function (e.g. "window.alert").
    // If no function can be inferred, the string itself will simply be published.
    // See vodori/util/string/getFunction for further details.
    //
    // command: An args array
    // Nothing special happens to this, so make sure it means exactly what you want it to.
    //
    // Another notification
    // The new notification will replace the current one.

    /*

     EXAMPLE:
     handleNotification({
     type: 'modal',
     title: 'Error!',
     message: 'I've made a terrible mistake.'
     buttons: [
     {
     label: 'Cancel'
     },
     {
     label: 'Try again',
     action: 'pepper.commands.doSomething',
     command: [ arguments ]
     }
     ]
     });

     */

    /**
     * Create a dialog button with the given label and click action
     *
     * @param {Object} btnObj        an object containing (optional) metadata about the button:
     *                      {label: '', action: function(), notification: '', class: ['','']}.
     *                      If no action is provided, the button just hides the dialog
     * @param {Object} dialog        the button's parent dialog
     * @param {Object} pepperResult  (optional) a Pepper AJAX result
     *
     * @return Button the dialog button
     */
    var getButton = function (btnObj, dialog, pepperResult) {
        var clickAction = null; // The onClick callback

        if (btnObj.action) { // If a button has a click action, use it
            var func = getFunction(btnObj.action);
            if (btnObj.command) {
                clickAction = lang.partial(func, btnObj.command, pepperResult);
            } else {
                clickAction = func;
            }
        } else if (btnObj.command) { // no action, the command is an actual function. Created in JS, not server-side
            clickAction = btnObj.command;
        } else if (btnObj.notification) { // If a button displays a notification, use this instead
            // Show another notification.
            clickAction = lang.partial(handleNotification, btnObj.notification);
        } else { // If a button is a 'cancel' button
            if (pepperResult &&
                pepperResult.state &&
                pepperResult.state !== serviceStates.success &&
                pepperResult.state !== serviceStates.error) {
                clickAction = lang.partial(topic.publish, events.services.canceledRequest, pepperResult);
            }
        }

        var buttonLabel = (btnObj.label).toLowerCase().replace(/ /g, '_');
        return new Button({
            'class': ['standard'].concat(btnObj['class']).concat(buttonLabel).join(' '),
            label: btnObj.label,
            onClick: function () {
                dialog.hide();
                if (clickAction) {
                    clickAction.call();
                }
            }
        });
    };

    /**
     * Creates a modal dialog box using the notification parameters
     *
     * @param notification  notification parameters
     *
     * @returns vodori.ui.Dialog    a reference to the dialog
     */
    var handleModal = function (notification) {
        var dialog = new Dialog({
            title: notification.title || 'Notification',
            closable: false,
            destroyOnHide: true,
            'class': 'notificationDialog'
        });

        // A place to hold the message
        var message = domConstruct.create('div', {
            'class': 'message'
        }, dialog.containerNode);

        // Convert any markup to DOM nodes
        var messageBody = domConstruct.toDom(notification.message || '');

        domConstruct.place(messageBody, message);

        // A place to hold the buttons
        var footer = domConstruct.create('div', {
            'class': 'footer'
        }, dialog.containerNode);

        var button = null;
        if ('buttons' in notification) {
            for (var i = 0; i < notification.buttons.length; i++) {
                button = getButton(notification.buttons[i], dialog, notification.pepperResult);
                button.placeAt(footer);
                button.startup();

                // Insert spaces between buttons.
                domConstruct.place(document.createTextNode(' '), footer);
            }
        } else {
            button = new Button({
                'class': 'standard',
                label: 'OK',
                onClick: lang.hitch(dialog, 'hide')
            });

            button.placeAt(footer);
            button.startup();
        }

        dialog.startup();
        dialog.show();

        return dialog;
    };

    /**
     * When an ACTION dialog is passed back, execute the command(s) for the notification's buttons
     * @param notification
     */
    var handleAction = function (notification) {
        _.forEach(notification.buttons, function (button) {
            var func = getFunction(button.action);
            if (button.command) {
                lang.partial(func, button.command).call();
            } else {
                func.call();
            }
        });
    };

    /**
     * Take in a Pepper AJAX response object and create a notification from its contents
     *
     * @param response the Pepper AJAX response object
     */
    var adaptPepperResponse = function (/* Object */ response) {
        var notification;

        // Build notification using provided notification parameters
        if (response.notificationStyle === 'DIALOG_BOX') {
            notification = response.notification;
            notification.type = 'modal';

            // Keep a reference to the response object
            notification.pepperResult = response;
        } else if (response.notificationStyle === 'INFORMATIONAL') {
            // Build notification with an optional provided message
            notification = {
                title: '', // For now use no title, just the message
                message: response.message || '',
                expireAfter: response.expireAfter
            };
        } else if (response.notificationStyle === 'ACTION') {
            notification = response.notification;
            notification.type = 'action';
            notification.expireAfter = response.expireAfter;
        } else {
            /* jshint noempty:false */
            // WAITING_ON_RETURN (which is not implemented) is the other possible condition
        }

        return notification;
    };

    /**
     * @typedef NotificationButton
     * @type object
     * @property {string} label the text to display in the button
     * @property {string} [action] a pepper.command to run when clicked
     * @property {object} [command] if action is supplied, then command is the parameter object for the
     *                              pepper.command.
     *                              if no action is supplied, command is a callback function
     *
     */

    /**
     * @typedef Notification
     * @type object
     * @property {string} [type=toaster] modal, action, or (default) toaster
     * - modal shows a modal dialog that blocks actions behind the dialog
     * - action automatically runs the actions in the notification buttons and then optionally displays a
     *   notification afterwards
     * - toaster shows a growl-style popup notification
     * @property {number} [expireAfter] if using a toaster popup, you can specify a time (in milliseconds)
     *                                  after which the popup will hide itself
     * @property {string} [title] the title of the notification
     * @property {string} message     the message to show in the notification
     * @property {Array.<NotificationButton>} [buttons] an array of buttons to display in the notification if
     *                                                  no buttons supplied, a default "OK" button will be created
     */

    /**
     * This is the function that gets returned. It takes in a notification object OR
     * a Pepper AJAX response
     *
     * @function
     * @param {Notification} notification  object with params describing how the notification should look/function
     * @alias module:pepper/ui/handleNotification
     */
    var handleNotification = function (notification) {
        if (typeof notification === 'string') {
            notification = {
                message: notification
            };
        } else if ('notification' in notification) {
            notification = adaptPepperResponse(notification);

            // Fix for the WAITING_ON_RETURN case
            if (!notification) {
                return;
            }
        }

        if (notification.type === 'modal') {
            return handleModal(notification);
        }

        if (notification.type === 'action') {
            handleAction(notification);
            notification.buttons = [];
            if (!notification.message) {
                return;
            }
        }

        // If it's not modal, it's a toaster popup.
        // Pieces of toast pretty much take care of themselves.

        var toast = PieceOfToast.displayNotification({
            title: notification.title || '',
            content: notification.message || '',
            expireAfter: notification.expireAfter,
            actions: _.map(notification.buttons || [], function (button) {
                return new Button(button);
            })
        });

        return toast;
    };

    return provide(module.id, handleNotification);
});

},
'pepper/ui/PieceOfToast':function(){
define([
    'vodori/provide',
    'module',
    'vodori/ui/PieceOfToast',
    'dojo/ready', 'dojo/dom-construct', 'dojo/_base/window'
], function (provide, module, PieceOfToast, ready, domConstruct, window) {
    // This is the node all our pieces of toast will appear in.
    var toasterNode = domConstruct.create('div', {
        'class': ' pepper quarantine vodoriToasterNode noBackground'
    });

    ready(function () {
        domConstruct.place(toasterNode, window.body());
    });

    var ToastPiece = provide(module.id, [PieceOfToast], {
        toasterNode: toasterNode
    });

    /**
     * Shortcut method for creating and displaying a piece of toast notification.
     * @param params {Object} constructor parameter for PieceOfToast
     * @return {pepper/ui/ToastPiece}
     */
    ToastPiece.displayNotification = function (params) {
        var toast = new ToastPiece(params);
        toast.startup();
        toast.show();
        return toast;
    };

    return ToastPiece;
});

},
'vodori/ui/PieceOfToast':function(){
define([
    'vodori/provide', 'module',
    'dojo/_base/lang', 'dojo/_base/window',
    'dojo/Deferred',
    'dojo/dom-construct', 'dojo/dom-style',
    'dojo/ready', 'dojo/_base/fx', 'dojo/fx',
    'dijit/_base/manager', 'dijit/_Widget', 'dijit/_TemplatedMixin',
    'dojo/text!./templates/PieceOfToast.html'
], function (provide, module,
             lang, win,
             Deferred,
             domConstruct, domStyle,
             ready, fx, coreFx,
             dijitManager, _Widget, _TemplatedMixin,
             template) {
    // This is the node all our pieces of toast will appear in.
    var toasterNode = domConstruct.create('div', {
        'class': 'vodoriToasterNode'
    });

    ready(function () {
        domConstruct.place(toasterNode, win.body());
    });

    var toastRegistry = {};

    var PieceOfToast = provide(module.id, [_Widget, _TemplatedMixin], {
        title: '',
        content: '',
        expireAfter: 0,
        actions: [],
        actionsNode: null,
        duration: dijitManager.defaultDuration,

        toasterNode: toasterNode,

        templateString: template,
        baseClass: 'vodoriPieceOfToast',

        _showing: false,

        constructor: function () {
            this.actions = [];
        },

        buildRendering: function () {
            this.inherited(arguments);

            this._injectActions();
        },

        _injectActions: function () {
            // The "actions" property can be a mixed array of widgets and DOM nodes.
            var action;
            for (var i = 0; i < this.actions.length; i++) {
                action = this.actions[i];
                if ('placeAt' in action) {
                    action.placeAt(this.actionsNode);
                } else {
                    domConstruct.place(action, this.actionsNode);
                }

                domConstruct.create('br', {}, this.actionsNode);
            }
        },

        postCreate: function () {
            this.inherited(arguments);
            if (this.title === '') {
                domConstruct.destroy(this.titleNode);
            }
            if (!this.content) {
                domConstruct.destroy(this.containerNode);
            }

            toastRegistry[this.id] = this;
        },

        show: function () {
            var showDef = new Deferred();

            if (this._showing) {
                // Move it to the top
                this.hide().then(lang.hitch(this, 'show'));
                return;
            }

            this._showing = true;

            this.placeAt(this.toasterNode, 'first');
            domStyle.set(this.domNode, {
                opacity: 0
            });

            fx.fadeIn({
                node: this.domNode,
                duration: this.duration,
                onEnd: function () {
                    showDef.resolve();
                }
            }).play();

            // If an expire time is provided, set a timer to hide this piece of toast
            if (this.expireAfter && this.expireAfter > 0) {
                setTimeout(lang.hitch(this, 'hide'), this.expireAfter);
            }

            return showDef;
        },

        hide: function () {
            var hideDef = new Deferred();

            // Prevent errors if multiple things are trying to close the piece of toast
            if (this._destroyed) {
                hideDef.resolve();
                return hideDef;
            }

            coreFx.chain([
                fx.fadeOut({
                    node: this.domNode,
                    duration: this.duration - 10
                }),
                coreFx.wipeOut({
                    node: this.domNode,
                    duration: this.duration,
                    onEnd: function () {
                        hideDef.resolve();
                    }
                })
            ]).play();

            this._showing = false;

            hideDef.then(lang.hitch(this, 'destroy'));

            return hideDef;
        },

        uninitialize: function () {
            delete toastRegistry[this.id];

            this.inherited(arguments);
        },

        _setTitleAttr: {node: 'titleNode', type: 'innerHTML'},

        _setContentAttr: function (content) {
            if (!content) {
                content = '';
            }
            this.content = content;
            if (content.nodeType) {
                domConstruct.empty(this.containerNode);
                domConstruct.place(content, this.containerNode);
            } else {
                this.containerNode.innerHTML = content;
            }
        }
    });

    PieceOfToast.registry = toastRegistry;

    /**
     * Shortcut method for creating and displaying a piece of toast notification.
     * @param params {Object} constructor parameter for PieceOfToast
     * @return {vodori/ui/PieceOfToast}
     */
    PieceOfToast.displayNotification = function (params) {
        var toast = new PieceOfToast(params);
        toast.startup();
        toast.show();
        return toast;
    };

    return PieceOfToast;
});

},
'vodori/util/string/getFunction':function(){
define([
    'dojo/_base/lang',
    'dojo/topic'
], function (lang, topic) {

    // Returns the function at the given object path
    // If there isn't one, returns a function that publishes that string

    // Example:
    // doIt = getFunction('foo.bar.doIt');
    // doIt(); // Inside, 'this' is foo.bar

    // Example:
    // pubIt = getFunction('foo/bar/boo');
    // pubIt(); // Publishes 'foo/bar/boo'


    return function (str, context) {
        if (typeof str !== 'string') {
            return str;
        }
        var gottenObject = lang.getObject(str, context);
        var isFunction = typeof gottenObject === 'function';

        // If there's no context, the value of 'this' in the
        // function should be the object of which it is a method.
        var theThis = context || lang.getObject(str.split('.').slice(0, -1).join('.'));

        if (gottenObject && isFunction) {
            return function () {
                gottenObject.apply(theThis, Array.prototype.slice.call(arguments));
            };
        } else {

            if (str.indexOf('.') > 0) {
                console.warn('Called getFunction with an argument with periods -- you probably ' +
                    'meant to return a function instead of publish this topic. ' +
                    'The reason this happened was because your namespace and object couldn\'t be ' +
                    'found.  ' +
                    'Double check your code to make sure you\'re Requiring the correct classes');
            }

            return function () {
                topic.publish(str, Array.prototype.slice.call(arguments));
            };
        }
    };
});

},
'pepper/services/serviceStates':function(){
define(
    /**
     * "Enum" for the different possible states service calls can be in
     * @name serviceStates
     * @memberOf pepper/services
     * @enum {string}
     */
    {
        begin: 'TRY',
        confirmed: 'CONFIRMED',
        success: 'SUCCESS',
        error: 'ERROR',
        download: 'DOWNLOAD'
    });
},
'pepper/services/serviceManager':function(){
define([
    'vodori/provide',
    'module',
    'dojo/_base/lang',
    'dojo/topic',
    'dojo/Deferred',
    'pepper/events'
], function (provide, module, lang, topic, Deferred, events) {
    // Service Manager Deferreds are cached here with a unique token to keep
    // track of them. This is useful for cases where confirmation dialogs
    // cause chained service calls to happen and we don't want the callback
    // to fire until the final service call completes
    var serviceRegistry = {};

    var serviceRegistrySize = 0; // Keep track of number of objects in the registry

    var uniqueCounter = 0;

    /**
     * Wrapper for the deferred that is being managed along with the index of the current page's object, if it
     * was used in the service request.
     */
    var ManagedServiceCall = provide(null, {

        constructor: function (params) {
            this.params = params;
            this.deferred = new Deferred();
        }

    });

    /**
     * This singleton object will manage all pepper/service calls and can
     * defer callbacks until a workflow has completed. It communicates with
     * the services wrapper using pub/sub and provides a wrapped Deferred that
     * only resolves until we are sure the final service call in a chain of
     * service calls (aka when we have dialog boxes) has completed
     *
     * @lends pepper/services/serviceManager#
     */
    var manager = {

        /**
         * When a service call is made, this function is called to create and
         * return a new managed Deferred that does not resolve until completeRequest
         * is called. If the call exists in the registry already, return that Deferred
         *
         * @param {Query} [query] parameters for the service call
         * @return Deferred a service manager managed Deferred
         */
        addRequest: function (/* Object */ query) {
            // Grab the identifying token of the query
            var requestChainId = query.params.conversationId;

            // If the request chain already exists, return the Deferred
            if (requestChainId in serviceRegistry) {
                return serviceRegistry[requestChainId].deferred;
            }

            // Otherwise create a new one
            var managedServiceCall = new ManagedServiceCall(query.params);
            serviceRegistry[requestChainId] = managedServiceCall;
            serviceRegistrySize++;

            return managedServiceCall.deferred;
        },

        /**
         * Called when we are sure that the request chain has completed. We will
         * then resolve the stored Deferred
         *
         * @param response  the response object from the final service call
         */
        completeRequest: function (/* Object */ response) {
            var managedServiceCall = serviceRegistry[response.command.conversationId];
            if (managedServiceCall) {
                managedServiceCall.deferred.resolve(response);
                this._removeFromRegistry(response.command.conversationId);
            }
        },

        _removeFromRegistry: function (requestChainId) {
            delete serviceRegistry[requestChainId];
            serviceRegistrySize--;
        },

        /**
         * Called when the request fails. Reject the deferred and delete it
         *
         * @param response  the reponse object from the final service call
         */
        failRequest: function (/* Object */ response) {
            var managedServiceCall = serviceRegistry[response.command.conversationId];
            if (managedServiceCall) {
                managedServiceCall.deferred.reject(response);
                this._removeFromRegistry(response.command.conversationId);
            }
        },

        /**
         * Generate a unique token to identify a request chain
         *
         * @return String   the unique token
         */
        generateToken: function () {
            return (new Date().getTime()).toString() + uniqueCounter++;
        },

        /**
         * Tells you if the request with the given ID is finished (either with success or failure).
         * If the request doesn't exist, we assume that it is finished. Note that the term
         * "fulfilled" is borrowed from dojo/Deferred.
         * @param conversationId
         */
        isFulfilled: function (conversationId) {
            var serviceCall = serviceRegistry[conversationId];
            if (!serviceCall) {
                return true;
            }
            var def = serviceCall.deferred;
            return (!def || def.isFulfilled());
        }
    };

    // Listen for when the user clicks on the 'cancel' button of a dialog box
    topic.subscribe(events.services.canceledRequest, lang.hitch(manager, manager.failRequest));

    /**
     * @class pepper/services/serviceManager
     */
    return provide(module.id, manager);
});

},
'vodori/util/PageUnloadPauser':function(){
/**
 * @description
 * The purpose of this module is to allow users to defer execution if the page is currently being
 * unloaded.
 * Because detecting that a page is *ACTUALLY* being unloaded is difficult to do,
 * this module allows users to set a timeout.
 *
 * If, after the timeout has expired, javascript is still running,
 * the assumption is made that the page has not actually unloaded and the deferred code is executed.
 *
 * @example
 *  var pauser = new PageUnloadPauser();
 *  ...
 *  return pauser.pauseIfUnloading(function() {
 *      serviceManager.failRequest(errorContainer);
 *
 *      // Create the error message to display in the piece of toast popup
 *      response.message = buildErrorStatusMessage(params, response)
 *      return handleError(response);
 *  });
 *
 *
 * @module vodori/util/PageUnloadPauser
 */
define([
    'module',
    'dojo/Deferred', 'dojo/_base/unload',
    'vodori/provide'
], function (module, Deferred, unload, provide) {
    /**
     * The default timeout for the pauser is 20s
     * @type {number}
     */
    var DEFAULT_TIMEOUT = 20000;

    /**
     * @lends module:vodori/util/PageUnloadPauser#
     *
     */
    var PageUnloadParser = {

        /**
         * <p>A managing class for executing functions that shouldn't be run
         * while a page is unloading.</p>
         *
         * <p>Pending XHR requests are aborted when a page starts to unload.
         * This can result in erroneous error messages, if your XHR error handler displays
         * errors to users.</p>
         *
         * <p>Instead, you can use vodori.util.PageUnloadPauser#pauseIfUnloading to delay
         * error messages if the page is unloading. If the unloadTimeout expires, then the message
         * will still be displayed. However, if the page finishes unloading,
         * then you have nothing to worry about.</p>
         *
         * @function
         * @param {number} [unloadTimeout=20000] The number of millisecods to delay execution
         */
        constructor: function (unloadTimeout) {
            /*
             * Assume that an unload is not currently in progress by resolving the Deferred
             * immediately
             */
            this.noUnloadInProgress = undefined;
            unloadTimeout = unloadTimeout || DEFAULT_TIMEOUT;
            var that = this;
            unload.addOnUnload(function () {
                that.noUnloadInProgress = new Deferred();
                /*
                 * Reset to false, in case this is not a real unload
                 * See http://dojotoolkit.org/reference-guide/1.8/dojo/_base/unload.html
                 */
                setTimeout(function () {
                    if (!that.noUnloadInProgress.isFulfilled()) {
                        that.noUnloadInProgress.resolve();
                    }
                }, unloadTimeout);
            });
        },

        /**
         * Executes a function if the page is not currently unloading.
         * Otherwise it delays it until we know that the page is not actually unloading.
         *
         * @function
         * @param {Function} func A function to delay if the page is currently unloading
         *      (and execute if vodori.util.PageUnloadPauser#unloadTimeout expires)
         * @returns {Promise} A promise that will be resolved if this function gets executed
         */
        pauseIfUnloading: function (func) {
            if (this.noUnloadInProgress) {
                return this.noUnloadInProgress.then(func);
            } else {
                return func();
            }
        }
    };
    return provide(module.id, [], PageUnloadParser);
});

},
'pepper/utilities/createPayload':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'vodori/util/collections/mapAndFilter'
], function (module, provide, _, mapAndFilter) {
    /**
     * Takes whatever you provide it and returns an array of pepper payload objects:
     * [{ objectId: 1, versionSeriesId: 1}, { }, ... ]
     *
     * Can provide an additional mapper function to add to the payload after initial processing. Will
     * provide the initial mapped object and the original object to the additional mapper function,
     * in that order.
     *
     * Can also provide a criteria function to check a condition on each object. If the function
     * returns true, include it. If it doesn't, don't include it. The filter will be applied to
     * the created payload
     */
    var defaultMapper = function (o) {

        if (_.isObject(o)) {
            var payloadItem = {};
            if (o.objectId) {
                payloadItem.objectId = o.objectId;
            } else if (o.id) {
                payloadItem.objectId = o.id;
            }
            if (o.versionSeriesId) {
                payloadItem.versionSeriesId = o.versionSeriesId;
            }
            payloadItem.currentPage = o.currentPage || false;

            return payloadItem;
        } else { // assume it's an array of strings that are objectIDs
            return { objectId: o };
        }
    };

    return provide(module.id, function (things, mapper, criteria) {
        if (!_.isArray(things)) {
            things = [things];
        }
        return mapAndFilter(things, function (o) {
            var mapped = defaultMapper(o);
            if (mapper) {
                mapped = mapper(mapped, o);
            }
            return mapped;
        }, criteria);
    });
});

},
'vodori/util/collections/mapAndFilter':function(){
/**
 * @module vodori/util/collections/mapAndFilter
 */
define([
    'module', 'vodori/provide',
    'lodash'
], function (module, provide, _) {

    var addToObject = function (obj, newItem, key) {
        obj[key] = newItem;
        return obj;
    };

    var addToArray = function (array, newItem) {
        array.push(newItem);
        return array;
    };

    /**
     * @callback mappingFunction
     * @param {*} item An item of data to map onto another item of data
     * @return {*} The mapped item of data
     */
    /**
     * @callback filterFunction
     * @param {*} item An item of data to test to see whether it should pass a filter
     * @return {boolean} `true` if the item should pass through the filter, otherwise `false`
     */

    /**
     * Takes an array or an object, applies a mapper to it and then filters the mapped objects. The
     * resulting array is returned. If no filter is provided, will just perform a mapping.
     *
     * @name vodori/util/collections/mapAndFilter
     * @function
     * @param things {Array|Object}
     * @param mapper {mappingFunction}
     * @param [filter] {filterFunction}
     */
    return function (things, mapper, filter) {
        var result, addFunction;
        if (_.isArray(things)) {
            result = [];
            addFunction = addToArray;
        } else {
            result = {};
            addFunction = addToObject;
        }
        _.forEach(things, function (thing, key) {
            var mapped = mapper(thing);
            if (!filter || filter(mapped)) {
                addFunction(result, mapped, key);
            }
        });
        return result;
    };
});

},
'pepper/utilities/parseStringEnum':function(){
define(function () {
    'use strict';
    /**
     * Parses a string that essentially contains an enum, returning it as an array of strings
     * where each string is one of the values from the enum in the original string. The passed
     * in string would be of the form "[val1, val2, ...]" and will become ['val1', 'val2', ...].
     *
     * @param {string} str The enum-containing string to parse and transform into an array
     * @return {Array.<string>} An array containing string values from the original enum
     */
    return function (str) {
        // Remove the leading/trailing [ ], then effectively trim the values as they
        // are split on commas. This means the enum values cannot contain commas and
        // will not retain leading/trailing whitespace.
        // We want to use the {x,y} notation at the end of the second regex instead of *,
        // otherwise using a /* comment at the beginning of this line would be terminated
        // by the * coupled with the end / of the regex.
        return str.replace(/^\[|\]$/g, '').split(/\s*,\s{0,}/);
    };
});

},
'vodori/input/LogoutForm':function(){
define([
    'dojo/_base/lang', 'dojo/_base/declare', 'dojo/on',
    'dijit/_Widget',
    'dojo/dom-construct',
    'vodori/util/csrf', 'vodori/renderTemplate',
    'dojo/text!./templates/LogoutForm.html'
], function (
    lang, declare, on,
    _Widget,
    domConstruct,
    csrf, renderTemplate,
    LogoutFormTemplate) {

    return declare([_Widget], {
        templateString: LogoutFormTemplate,

        /**
         * URL to POST to in order to log out. optional: defaults to /j_spring_security_logout
         * @type string
         */
        logoutUrl: '/j_spring_security_logout',

        /**
         * form parameter name for the CSRF protection token. optional: defaults to vorodi/util/csrf value.
         * @type string
         */
        csrfParam: csrf.parameterName,

        /**
         * form parameter value for the CSRF protection token. optional: defaults to vorodi/util/csrf value.
         * @type string
         */
        csrfToken: csrf.token,

        _form: null,

        buildRendering: function() {
            this.domNode = this.srcNodeRef;
            if (!this.srcNodeRef) {
                this.domNode = domConstruct.create('a', {href: '#', innerHTML: 'Sign Out'});
            }
            this._form = domConstruct.place(renderTemplate(this.templateString, this), this.domNode);
        },

        postCreate: function() {
            this.inherited(arguments);

            this.own(on(this.domNode, 'click', lang.hitch(this, '_onLinkClick')));
        },

        _onLinkClick: function (e) {
            this._form.submit();
            if (e && e.preventDefault) {
                e.preventDefault();
                e.stopPropagation();
            }
        }
    });
});

},
'pepper/ui/DropDownButton':function(){
define([
    'module', 'vodori/provide',
    'vodori/ui/DropDownButton',
    './PopupTooltip',
    './_QuarantineMixin'
], function (module, provide, DropDownButton, PopupTooltip, _QuarantineMixin) {
    /**
     * Specialized dropdown button for Pepper with an option to dynamically update the
     * dropdown's available commands if using a _PepperServiceMenu
     */
    return provide(module.id, [DropDownButton, _QuarantineMixin], {
        // If not null, the parameter to send into the dropdown's updateCommandAvailability function,
        // otherwise the function will not be called
        commandAvailabilityParam: null,
        tooltipConstructor: PopupTooltip,

        /**
         * Overridden to run updateCommandAvailability on the dropdown if params are supplied
         */
        openDropDown: function () {
            if (this.commandAvailabilityParam) {
                this.dropDown.updateCommandAvailability(this.commandAvailabilityParam);
            }

            return this.inherited(arguments);
        }
    });
});

},
'vodori/ui/DropDownButton':function(){
define([
    'module', 'vodori/provide',
    'dojo/dom-class',
    'dijit/form/DropDownButton',
    'vodori/ui/_PopupButton'
], function (module, provide, domClass, DijitDropDownButton, _VodoriPopupButton) {
    return provide(module.id, [DijitDropDownButton, _VodoriPopupButton], {
        baseClass: 'vodoriDropDownButton',

        buildRendering: function () {
            this.inherited(arguments);

            domClass.add(this.domNode, 'vodoriDropDownButton');

            this.on('mousedown', function (evt) {
                evt.stopPropagation();
                evt.preventDefault();
            }); // Prevent the click from bubbling
        }
    });
});

},
'vodori/ui/_PopupButton':function(){
define([
    'module', 'vodori/provide',
    'dojo/dom-class',
    'dojo/query',
    'vodori/ui/_Button',
    'dojo/NodeList-dom'
], function (module, provide, domClass, query, _VodoriButton) {
    return provide(module.id, [_VodoriButton], {
        hideArrow: false,

        baseClass: 'vodoriPopupButton',
        OPEN_CLASS: 'open',

        buildRendering: function () {
            this.inherited(arguments);

            if (this.hideArrow) {
                var arrows = query('.dijitArrowButtonInner, .dijitArrowButton', this.domNode);
                arrows.style('display', 'none');
            }

            domClass.add(this.domNode, 'vodoriPopupButton');
        },

        startup: function () {
            this.inherited(arguments);

            this.repositionPopup();
        },

        // Open and close on load to get the popup's position right
        repositionPopup: function () {
            // If it's a dijit.TooltipDialog
            if ('_isShown' in this.dropDown) {
                this._repositionTooltipDialog();
            }
        },

        _repositionTooltipDialog: function () {
            var wasShown = this.dropDown._isShown();

            // Sometimes you have to do this twice
            this.closeDropDown();
            this.openDropDown();

            if (!wasShown) {
                this.closeDropDown();
            }
        },

        openDropDown: function () {
            this.inherited(arguments);

            domClass.add(this.domNode, this.OPEN_CLASS);
        },

        closeDropDown: function () {
            this.inherited(arguments);

            domClass.remove(this.domNode, this.OPEN_CLASS);
        }
    });
});

},
'pepper/ui/PopupTooltip':function(){
define([
    'module',
    'vodori/provide',
    'dijit/Tooltip',
    'pepper/ui/_QuarantineMixin'
], function (module, provide, Tooltip, _QuarantineMixin) {
    return provide(module.id, [Tooltip, _QuarantineMixin], {
        /**
         * Appending a specific className to the container, so we know which
         * quarantine nodes contain popups.
         */
        constructor: function () {
            this.quarantineAreaClassNames += ' popupContainer ';
        }
    });
});

},
'pepper/ui/Menu':function(){
define([
    'vodori/provide',
    'module',
    'vodori/ui/Menu',
    './_QuarantineMixin'
], function (provide, module, Menu, _QuarantineMixin) {
    return provide(module.id, [Menu, _QuarantineMixin], {});
});

},
'vodori/ui/Menu':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/has',
    'dojo/_base/lang', 'dojo/_base/window',
    'dojo/dom-attr', 'dojo/dom-class', 'dojo/dom-construct', 'dojo/dom-style',
    'dojo/query', 'dojo/on',
    'dijit/Menu', 'dijit/MenuItem', 'dijit/PopupMenuItem', 'dijit/MenuSeparator',
    'vodori/ui/KeyboardShortcut', 'vodori/util/string/getFunction'
], function (provide, module,
             _,
             has,
             lang, win,
             domAttr, domClass, domConstruct, domStyle,
             query, on,
             DijitMenu, DijitMenuItem, DijitPopupMenuItem, DijitMenuSeparator,
             KeyboardShortcut, getFunction) {
    // Automatically build a dijit.Menu from nested ULs and LIs.
    // No further widget declaration is required
    // Also handles commands, shortcuts, and icons automatically

    // Disable overriding context menus with "?disableContextMenus=1" in your URL.
    has.add('disable-context-menus', function () {
        return _.contains(location.search, 'disableContextMenus');
    });

    return provide(module.id, [DijitMenu], {
        contextMenuForParent: false, // Set this to the parent node's context menu?
        inline: false, // Is this menu just a normal part of the page?
        hoverMenuForParent: false, // open menu onmouseover for this.domNode.parentNode

        _shortcuts: null,

        /**
         *
         * Array elements:
         *      {label: 'Foo', icon: '/path/to/icon.png', shortcut: 'Cmd+F', command: function() {}},
         *      {label: 'More', items: [...]}
         *
         *  @type {Array.<Object.<*>>}
         */
        items: null,

        // A default command and args for items that don't have their own
        defaultCommand: null, // Should be a function
        defaultArgs: [],

        popupDelay: 100,

        baseClass: 'vodoriMenu',

        constructor: function () {
            this._shortcuts = {};
            this.items = [];
            this.defaultArgs = [];
        },

        /** We do custom processing of properties so we can create menus from markup
         */
        buildRendering: function () {
            if (this.items.length === 0 && this.srcNodeRef && this._isList(this.srcNodeRef)) {
                this.items = this.adoptMarkup(this.srcNodeRef);
                this.srcNodeRef.innerHTML = '';
            }

            this.inherited(arguments);

            domClass.add(this.domNode, this.baseClass);

            // Copy classes from the source node to the menu.
            if (this.srcNodeRef) {
                domClass.add(this.domNode, domAttr.get(this.srcNodeRef, 'class'));
            }

            // If it was declared in markup and not inline, hide it.
            if (this.srcNodeRef && !this.inline) {
                domStyle.set(this.domNode, 'display', 'none');
            }
        },

        startup: function () {
            this.inherited(arguments);

            // We can't adopt any items until we've got a node in the DOM.
            this.adoptItems(this.items);

            if (this.contextMenuForParent) {
                this.bindDomNode(this.domNode.parentNode);
            }
            if (this.hoverMenuForParent) {
                var target = this.domNode.parentNode;
                this.own(on(this.domNode.parentNode, 'mouseover', lang.hitch(this, function () {
                    this._openMyself({ target: target });
                })));
            }
        },

        /**
         * Turns the marked up menu into a list of menu items we can manipulate
         * @param ul the list node to process from as the root node
         */
        adoptMarkup: function (ul) {
            return query('> li', ul).map(function (li) {
                var liModel;
                // Blank items become separators.
                if (!li.textContent && !li.innerText) {
                    liModel = {};
                }
                else if (domClass.contains(li, 'heading')) {
                    // A "heading" classed item becomes a heading.
                    liModel = {
                        label: lang.trim(li.textContent || li.innerText),
                        heading: true
                    };
                }
                else if (li.children.length === 2 && this._isList(li.children[1])) {
                    // Items with two children, the second a list, become submenus.
                    liModel = {
                        label: lang.trim(li.children[0].textContent || li.children[0].innerText),
                        items: this.adoptMarkup(li.children[1])
                    };
                }
                else {
                    // Otherwise, it's just a normal item.
                    liModel = {
                        id:          domAttr.get(li, 'data-menu-id'),
                        icon:        domAttr.get(li, 'data-icon') || '',
                        shortcut:    domAttr.get(li, 'data-shortcut') || '',
                        commandName: domAttr.get(li, 'data-command-name'),
                        disabled:    domAttr.get(li, 'data-disabled'),
                        label:       lang.trim(li.textContent || li.innerText),
                        href:        '',
                        target:      ''
                    };

                    // The command will be the first thing in the list, the rest will be args.
                    var args = domAttr.get(li, 'data-command') || '';
                    args = _.map(args.split(','), lang.trim);

                    var command = args.shift();
                    if (command) {
                        liModel.command = getFunction(command);
                    }
                    liModel.args = args;

                    var childAnchor = query('> a[href]', li);
                    if (!!childAnchor.length) {
                        liModel.href = domAttr.get(childAnchor[0], 'href');
                        liModel.target = domAttr.get(childAnchor[0], 'target');
                    }
                }

                return liModel;

            }, this);
        },

        /**
         * Processes menu items (objects that come from markup) and builds the actual menu nodes in the DOM
         * @param items the items to process into DOM nodes
         */
        adoptItems: function (items) {
            _.forEach(items, function (item) {
                var menuItem = null,
                    shortcut = item.shortcut;

                if (!item.label) {
                    // Items with no labels become separators.
                    menuItem = new DijitMenuSeparator();
                } else if (item.heading) {
                    // "Headings" are deformed separators. Style them.
                    menuItem = new DijitMenuSeparator();
                    menuItem.set('class', 'heading');

                    // Insert the label.
                    domConstruct.create('div', {
                        'class': this.baseClass + 'Heading',
                        innerHTML: item.label
                    }, menuItem.domNode.children[1]);

                    // Hide the fact that this is a separator.
                    var separators = query('.dijitMenuSeparatorTop, .dijitMenuSeparatorBottom', menuItem.domNode);
                    separators.style('display', 'none');
                } else if (item.items) {
                    // Items with more items become submenus.
                    menuItem = new DijitPopupMenuItem({
                        label: item.label,
                        popup: new this.constructor({items: item.items})
                    });
                } else {
                    // Otherwise items are just items!
                    menuItem = new DijitMenuItem({
                        label: item.label,
                        accelKey: item.shortcut,
                        disabled: item.disabled,
                        onClick: lang.hitch(this, '_itemSelected', item)
                    });

                    // If the menu item has a shortcut associated with it, add it to the
                    // shortcuts map, with the shortcut string (e.g. "Ctrl+S") as the key,
                    // and the KeyboardShortcut object as the value.
                    if (shortcut) {
                        this._shortcuts[shortcut] = new KeyboardShortcut(shortcut, lang.hitch(this, function () {
                            this._itemSelected(item);
                        }));
                    }

                    // If there's an icon, apply it once the item is in the DOM.
                    if (item.icon) {
                        this.own(on(menuItem, 'startup', function () {
                            this.iconNode.src = item.icon;
                            this.set('iconClass', 'hasIcon');
                        }));
                    }
                }

                // Keep a reference accessible from the items array.
                item._menuItem = menuItem;

                this.addChild(menuItem); // Calls startup on the item
            }, this);
        },

        bindDomNode: function () {
            if (!has('disable-context-menus')) {
                return this.inherited(arguments);
            }
        },

        preOpen: function () {
            // Do something before the menu opens
        },

        _openMyself: function () {
            this.preOpen.apply(this, arguments);

            this.inherited(arguments);
        },

        /**
         * Fired on menu item selection. Applies that menu's command (if any) with the relevant arguments (if any)
         *
         * @param {Object} item the menu item that's selected
         */
        _itemSelected: function (item) {
            /*
             * Simple anchors should just behave like they are links.
             * Include support for target attributes
             */
            if (item.href) {
                var targetWindow;
                /*
                 * A link without a target is equivalent to a link targeting its own window.
                 * A link with a `_blank` target wants to open a brand new window every time
                 */
                if (!item.target) {
                    item.target = '_self';
                }
                else if (item.target !== '_blank') {
                    targetWindow = item.target;
                }

                /*
                 * _self, _parent and _top all update the current page
                 */
                if (_.indexOf(['_self', '_parent', '_top'], item.target) >= 0) {
                    win.doc.location.href = item.href;
                }
                else {
                    window.open(item.href, targetWindow);
                }
            }

            var command = (item.command && typeof item.command === 'function') ? item.command : this.defaultCommand;

            // Decide the arguments to provide the command
            var args;
            if (item.concatDefaultArgs) { // If we need to concatenate the default args with the provided args
                args = Array.prototype.concat(this.get('defaultArgs'), item.args);
            } else if (item.args && item.args.length > 0) { // If there are provided args
                args = item.args;
            } else { // Otherwise pull up the default args
                var localDefaultArgs = this.get('defaultArgs');
                args = [];

                // make a copy of each of the arguments so that defaultArgs remains unchanged
                _.forEach(localDefaultArgs, function(arg) {
                    args.push(_.cloneDeep(arg));
                });
            }

            // Do nothing if there is no command
            if (command) {
                return command.apply(item, args);
            }
        },

        /** Get a flat list of all the items and subitems in a menu.
         * @param children the child menus to get items from
         */
        getFlatChildren: function (children) {
            children = children || this.getChildren();

            var allItems = [];
            _.forEach(children, function (child) {
                allItems.push(child);
                if (child.popup) {
                    allItems = allItems.concat(this.getFlatChildren(child.popup.getChildren()));
                }
            }, this);

            return allItems;
        },

        /** Get a flat list of all the items, each of which will correspond to a menu item.
         */
        getFlatItems: function (items) {
            items = items || this.items;

            var allItems = [];
            _.forEach(items, function (item) {
                allItems.push(item);
                if (item.items) {
                    allItems = allItems.concat(this.getFlatItems(item.items));
                }
            }, this);

            return allItems;
        },

        /** Determines if this node a UL or an OL?
         * @param node the node to check
         */
        _isList: function (node) {
            return !!node.nodeName.match(/^ul$|^ol$/i);
        },

        /**
         * Return the default args for this menu. If there is a default args function, run that
         * instead for the arguments
         *
         * @return the arguments array
         * @private
         */
        _getDefaultArgsAttr: function () {
            if (this.defaultArgsFunction && _.isFunction(this.defaultArgsFunction)) {
                var generatedArguments = this.defaultArgsFunction();
                if (!_.isArray(generatedArguments)) {
                    generatedArguments = [generatedArguments];
                }
                return generatedArguments;
            }

            return this.defaultArgs;
        },

        destroy: function () {
            // Destroy this menu's items
            _.forEach(this.items, function (item) {
                if (item && item._menuItem && typeof item._menuItem.destroyRecursive === 'function') {
                    item._menuItem.destroyRecursive();
                }
            });
            this.inherited(arguments);
        }
    });
});

},
'dijit/PopupMenuItem':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-style", // domStyle.set
	"dojo/_base/lang",
	"dojo/query", // query
	"./popup",
	"./registry",	// registry.byNode
	"./MenuItem",
	"./hccss"
], function(declare, domStyle, lang, query, pm, registry, MenuItem){

	// module:
	//		dijit/PopupMenuItem

	return declare("dijit.PopupMenuItem", MenuItem, {
		// summary:
		//		An item in a Menu that spawn a drop down (usually a drop down menu)

		baseClass: "dijitMenuItem dijitPopupMenuItem",

		_fillContent: function(){
			// summary:
			//		When Menu is declared in markup, this code gets the menu label and
			//		the popup widget from the srcNodeRef.
			// description:
			//		srcNodeRef.innerHTML contains both the menu item text and a popup widget
			//		The first part holds the menu item text and the second part is the popup
			// example:
			// |	<div data-dojo-type="dijit/PopupMenuItem">
			// |		<span>pick me</span>
			// |		<popup> ... </popup>
			// |	</div>
			// tags:
			//		protected

			if(this.srcNodeRef){
				var nodes = query("*", this.srcNodeRef);
				this.inherited(arguments, [nodes[0]]);

				// save pointer to srcNode so we can grab the drop down widget after it's instantiated
				this.dropDownContainer = this.srcNodeRef;
			}
		},

		_openPopup: function(/*Object*/ params, /*Boolean*/ focus){
			// summary:
			//		Open the popup to the side of/underneath this MenuItem, and optionally focus first item
			// tags:
			//		protected

			var popup = this.popup;

			pm.open(lang.delegate(params, {
				popup: this.popup,
				around: this.domNode
			}));

			if(focus && popup.focus){
				popup.focus();
			}
		},

		_closePopup: function(){
			pm.close(this.popup);
			this.popup.parentMenu = null;
		},

		startup: function(){
			if(this._started){ return; }
			this.inherited(arguments);

			// We didn't copy the dropdown widget from the this.srcNodeRef, so it's in no-man's
			// land now.  Move it to <body>.
			if(!this.popup){
				var node = query("[widgetId]", this.dropDownContainer)[0];
				this.popup = registry.byNode(node);
			}
			this.ownerDocumentBody.appendChild(this.popup.domNode);
			this.popup.domNode.setAttribute("aria-labelledby", this.containerNode.id);
			this.popup.startup();

			this.popup.domNode.style.display="none";
			if(this.arrowWrapper){
				domStyle.set(this.arrowWrapper, "visibility", "");
			}
			this.focusNode.setAttribute("aria-haspopup", "true");
		},

		destroyDescendants: function(/*Boolean*/ preserveDom){
			if(this.popup){
				// Destroy the popup, unless it's already been destroyed.  This can happen because
				// the popup is a direct child of <body> even though it's logically my child.
				if(!this.popup._destroyed){
					this.popup.destroyRecursive(preserveDom);
				}
				delete this.popup;
			}
			this.inherited(arguments);
		}
	});
});

},
'vodori/ui/KeyboardShortcut':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/on',
    'vodori/util/string/getFunction',
    'dojo/sniff',
    'dijit/Destroyable'
], function (module, provide, _, lang, on, getFunction, sniff, Destroyable) {
    // Keep a record of all keyboard shortcuts
    var shortcuts = [];

    return provide(module.id, [Destroyable], {
        shortcut: '',           // Something like "Ctrl+Alt+R"
        command: function () {/* Default to do nothing */
        },

        key: '',            // Single-character key (e.g. '5', or 'R').
        ctrl: false,         // Booleans indicating if the corresponding modifier key is used
        alt: false,         // in this keyboard shortcut
        shift: false,

        shortcutList: shortcuts,  // Available via vodori.ui.KeyboardShortcut.prototype
        enabled: false,

        _keyDownHandler: null,  // keydown handler registered with dojo
        _keyUpHandler: null,    // keyup handler registered with dojo
        _index: NaN,            // Index of shortcut in the shortcuts array, allowing ease of shortcut destruction

        /**
         * Constructs a new KeyboardShortcut object, and connects it with the passed in command function.
         * @param shortcut The shortcut string that will fire the command (e.g. "Ctrl+S")
         * @param command The function to invoke when the keyboard shortcut is pressed
         */
        constructor: function (shortcut, command) {
            this.shortcut = shortcut;
            this._parseShortcut();

            this.command = getFunction(command);

            this.setEnabled(false);

            this._index = shortcuts.push(this) - 1;
        },

        /**
         * Parses over shortcut string to determine which of the 3 common modifier
         * keys are used, and which single-character key is used. Will log a warning
         * and not enable the shortcut if it is invalid (to be valid, must use an optional
         * combination of Ctrl, Alt, and/or Shift, and the last key must be a single-character
         * key such as a number or letter).
         */
        _parseShortcut: function () {
            // Strips the +('s) out
            var parts = this.shortcut.toLowerCase().split(/[^\w]/);

            _.forEach(['ctrl', 'alt', 'shift'], function (modifier) {
                var index = _.indexOf(parts, modifier);
                if (index >= 0) {
                    this[modifier] = true;
                    parts.splice(index, 1);
                }
            }, this);

            if (parts.length === 1 && parts[0].length === 1) {
                this.key = parts[0];
            } else {
                console.warn('Invalid shortcut', this.shortcut);
                this.enabled = false;
            }
        },

        /**
         * Checks to see if the passed-in event's character and modifier keys match this particular
         * shortcut's corresponding properties. Returns true if they match, false otherwise.
         * @param evt The keyboard event to check against
         */
        _keystrokesMatch: function (evt) {
            // Check to see if the modifier keys and character key match this shortcut's properties
            var matchKey = String.fromCharCode(evt.keyCode).toLowerCase() === this.key.toLowerCase();
            var matchCtrl = evt.ctrlKey === this.ctrl;
            var matchAlt = evt.altKey === this.alt;
            var matchShift = evt.shiftKey === this.shift;

            matchCtrl = (sniff('mac') && evt.metaKey) || matchCtrl;

            // If it all matches, return true, otherwise return false
            return matchKey && matchCtrl && matchAlt && matchShift;
        },

        /**
         * Completely destroys this shortcut and removes it from the internal shortcuts array
         */
        destroy: function () {
            this.inherited(arguments);

            shortcuts.slice(this._index, 1);
        },

        /**
         * Connects the keyboard shortcut handler, first removing default keydown functionality,
         */
        _enable: function () {
            // First we need to remove the default keydown functionality, which can be necessary to block
            // default keyboard shortcuts in some browsers (Chrome, for example).
            this._disable();

            // Set the handler to a function that checks the pressed keys against this shortcut's properties.
            this._keyUpHandler = on(document, 'keyup', lang.hitch(this, function (evt) {
                // If it all matches, invoke the command
                if (this._keystrokesMatch(evt)) {
                    this.command();
                }
            }));

            this.own(this._keyUpHandler);
        },

        /**
         * Disconnects the keyboard shortcut handler if the handler exists.
         * Blocks the shortcut from doing anything else (such as being passed to the browser) by then connecting
         * it to a function that does nothing else except halt the event. Will only halt the event if it matches
         * this keyboard shortcut (otherwise all keystrokes will be blocked!).
         */
        _disable: function () {
            if (this._keyUpHandler) {
                this._keyUpHandler.remove();
            }

            if (this._keyDownHandler) {
                this._keyDownHandler.remove();
            }

            this._keyDownHandler = on(document, 'keydown', lang.hitch(this, function (evt) {
                if (this._keystrokesMatch(evt)) {
                    evt.stopPropagation();
                    evt.preventDefault();
                }
            }));

            this.own(this._keyDownHandler);
        },

        /**
         * Returns boolean for whether the given keyboard shortcut is enabled
         */
        isEnabled: function () {
            return this.enabled;
        },

        /**
         * Set the keyboard shortcut to be enabled or not
         * @param isEnabled Boolean to set the keyboard shortcut to be enabled or not
         */
        setEnabled: function (isEnabled) {
            this.enabled = isEnabled;
            if (isEnabled) {
                this._enable();
            }
            else {
                this._disable();
            }
        }
    });
});

},
'pepper/commands':function(){
define([
    'module', 'dojo/_base/lang',

    'pepper/commands/changeUrlParams',
    'pepper/commands/executeStep',

    'pepper/commands/actions/cancelCheckOut',
    'pepper/commands/actions/checkIn',
    'pepper/commands/actions/checkOut',
    'pepper/commands/actions/copy',
    'pepper/commands/actions/copyTo',
    'pepper/commands/actions/deleteFolder',
    'pepper/commands/actions/deleteNavigation',
    'pepper/commands/actions/deleteObjects',
    'pepper/commands/actions/demote',
    'pepper/commands/actions/demoteAndCheckout',
    'pepper/commands/actions/distribute',
    'pepper/commands/actions/edit',
    'pepper/commands/actions/expire',
    'pepper/commands/actions/expressPromote',
    'pepper/commands/actions/moveNavigationElement',
    'pepper/commands/actions/moveTo',
    'pepper/commands/actions/open',
    'pepper/commands/actions/openInLibrary',
    'pepper/commands/actions/openLinkTarget',
    'pepper/commands/actions/peek',
    'pepper/commands/actions/promote',
    'pepper/commands/actions/publish',
    'pepper/commands/actions/redirect',
    'pepper/commands/actions/reinstate',
    'pepper/commands/actions/revive',
    'pepper/commands/actions/save',
    'pepper/commands/actions/saveAndCheckIn',
    'pepper/commands/actions/launchInNavigationManager',
    'pepper/commands/actions/viewAssociatedWorkflow',
    'pepper/commands/actions/navigation/cancelCheckOut',
    'pepper/commands/actions/navigation/checkIn',
    'pepper/commands/actions/navigation/checkOut',

	'pepper/commands/validations/validateWorkflowItems',
    'pepper/commands/dialogs/showLibrary',
    'pepper/commands/dialogs/showInfo',
    'pepper/commands/dialogs/showFlipThrough',
    'pepper/commands/dialogs/showReview',
    'pepper/commands/dialogs/showCheckInAssets',
    'pepper/commands/dialogs/showCreateURI',
    'pepper/commands/dialogs/showCreateTag',
    'pepper/commands/dialogs/showCreateCategory',
    'pepper/commands/dialogs/showFolderInfo',
    'pepper/commands/dialogs/showCreate',
    'pepper/commands/dialogs/showImportPepperDoc',
    'pepper/commands/dialogs/showImportRefDoc',
    'pepper/commands/dialogs/showWorkflowWizard'

], function (module, lang) {
    return lang.getObject(module.id.split('/').join('.'));
});
},
'pepper/commands/changeUrlParams':function(){
define([
    'dojo/_base/lang', 'dojo/io-query'
], function (lang, ioQuery) {

    /**
     * @memberOf pepper/commands
     *
     * @param {Object} newParams
     * @param {boolean} absolute
     */
    var changeUrlParams = function (newParams, absolute) {
        var params = ioQuery.queryToObject(location.search.slice(1));
        if (absolute) {
            params = {};
        }

        lang.mixin(params, newParams);

        setTimeout(function () {
            location.href = location.pathname + '?' + ioQuery.objectToQuery(params);
        }, 0);
    };

    lang.mixin(lang.getObject('pepper.commands', true), {

        changeUrlParams: changeUrlParams
    });

    return changeUrlParams;
});

},
'pepper/commands/executeStep':function(){
define([
    'vodori/provide',
    'module',
    'pepper/services'
], function (provide, module, services) {
    /**
     * This is a command used by dialog boxes to shuttle pepper AJAX commands
     * directly to the backend regardless of what command it is
     */
    return provide(module.id,
        /**
         * @memberOf pepper/commands
         * @param {Object} command
         * @return {*}
         */
            function executeStep(command) {
            return services.executeStep({params: command});
        }
    );
});

},
'pepper/commands/actions/cancelCheckOut':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/topic',
    'pepper/services', 'pepper/events',
    'pepper/data/PostDescriptorStore',
    'pepper/commands/updateCssState'
], function (
    provide, module,
    _,
    topic,
    services, events,
    postDescriptorStore,
    updateCssState) {
    return provide(module, function (objects) {

        var servicePromise = postDescriptorStore.cancelCheckOut(objects);

        servicePromise.then(function (response) {
            var resultsContainsCurrentPage = _.any(response.results, function (result) {
                return postDescriptorStore.isCurrentPage(result);
            });

            if (resultsContainsCurrentPage) {
                /*
                 * For a cancel checkout, we need to reload the page because the content could be
                 * different.
                 */
                location.reload();
                return;
            }

            // Don't need to publish a refresh event if page is reloading, so this should go below reload call.
            topic.publish(events.library.refresh);

            updateCssState();
        });

        return servicePromise;

    });
});

},
'pepper/commands/updateCssState':function(){
define([
    'require', // So we can register new status tools w/o explicit mods.
    'lodash',
    // Add your state here
    './states/editable'
], function (require, _) {
    /**
     * This handles the CSS classes in the documentElement.
     * @memberOf pepper/commands
     *
     * @see pepper/commands/states
     */
    return function updateCssState() {
        var dependencies = require.module.deps.slice(2);

        // Call each dependency.
        _.forEach(dependencies, function (dependency) {
            dependency.result();
        }, this);
    };
});
},
'pepper/commands/states/editable':function(){
define([
    'dojo/when', 'dojo/_base/lang', 'pepper/data/PostDescriptorStore', 'pepper/utilities', 'dojo/domReady!'
], function (when, lang, postDescriptorStore, utilities) {
    /**
     * @methodOf pepper/commands/states
     *
     * Handles setting the state of the documentElements class based on whether
     * the page is checked out.
     */
    return function editable() {


        when(postDescriptorStore.getCurrentPageObject(), lang.hitch(this, function (currentPage) {
            if (currentPage && currentPage.lockedByCurrentUser) {
                utilities.pageState.setPossibleToEdit();
            } else {
                utilities.pageState.clearReadyToEdit();
                utilities.pageState.clearPossibleToEdit();
            }
        }));


    };
});
},
'pepper/utilities':function(){
/**
 * Pepper-specific utilties
 */
define([
    'dojo/_base/lang',

    'pepper/utilities/createPayload',
    'pepper/utilities/dialogs',
    'pepper/utilities/pageState'
], function (lang) {
    /**
     * @namespace pepper.utilities
     *
     * @function  pepper.utilities.createPayload
     * @namespace pepper.utilities.dialogs
     * @function pepper.utilities.pageState
     */
    return lang.getObject('pepper.utilities');
});
},
'pepper/utilities/dialogs':function(){
define([
    'module',
    'vodori/provide',
    'dojo/_base/lang'
], function (module, provide, lang) {
    /**
     * Utilities for creating dialogs/notifications that will be passed to pepper/ui/handleNotification
     */
    return provide(module.id, {
        createUnsavedChangesModal: function (callback, message) {
            message = message || 'Unsaved changes exist. Any unsaved changes will be discarded.';
            return this.createConfirmationModal(callback, message, 'Are you sure?');
        },

        createConfirmationModal: function (callback, message, title) {
            var buttons = [
                { label: 'Cancel' },
                { label: 'Ok', action: callback }
            ];
            return this.createModal(message, title, buttons);
        },

        createModal: function (message, title, buttons) {
            return {
                type: 'modal',
                title: title,
                message: message,
                buttons: buttons
            };
        }
    });
});

},
'pepper/commands/actions/checkIn':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'dojo/topic',
    'pepper/services', 'pepper/events',
    'pepper/data/PostDescriptorStore', 'pepper/propertyManager',
    'pepper/ui/handleNotification',
    'pepper/commands/actions/saveAndCheckIn',
    'pepper/commands/updateCssState', 'pepper/commands/actions/peek'
], function (provide, module,
             _,
             lang,
             topic,
             services, events,
             postDescriptorStore, propertyManager,
             handleNotification,
             saveAndCheckIn,
             updateCssState, peek) {

    return provide(module, function (objects, ignoreDirty) {
        var stopped = false;

        if (!_.isArray(objects)) {
            objects = [objects];
        }

        _.forEach(objects, function (currentObject) {
            // only need to check the current page if it's actually open and being checked in
            if (!postDescriptorStore.isCurrentPage(currentObject)) {
                return;
            }

            // the checkIn and saveAndCheckIn methods take an array
            var checkinObjects = [ currentObject ];

            // Prevent editing if the current page is being checked in
            peek.preview();

            // Make sure the current page is clean before we check it in.
            if (!ignoreDirty && propertyManager.isDirty()) {
                stopped = true;

                handleNotification({
                    title: 'Unsaved changes in document',
                    message: 'There are unsaved changes. What should we do with them?',
                    type: 'modal',
                    buttons: [
                        {
                            label: 'Cancel',
                            command: null
                        },
                        {
                            label: 'Save and check-in',
                            command: lang.partial(saveAndCheckIn, checkinObjects)
                        },
                        {
                            label: 'Disregard changes and check-in',
                            command: function () {
                                postDescriptorStore.checkIn(checkinObjects).then(
                                    function () {
                                        window.location.reload();
                                    }
                                );
                            }
                        }
                    ]
                });
            }
        });

        if (!stopped) { // check in the current object OR the not-current page object

            // Run the checkIn command
            var checkInPromise = postDescriptorStore.checkIn(objects);

            // React to completion of the check in
            checkInPromise.then(lang.hitch(this, function () {
                topic.publish(events.library.refresh);
                updateCssState();
            }));

            return checkInPromise;
        }
    });


});

},
'pepper/commands/actions/saveAndCheckIn':function(){
define([
    'vodori/provide', 'module',
    'dojo/topic',
    'pepper/services', 'pepper/events',
    'pepper/data/PostDescriptorStore', 'pepper/propertyManager',
    'pepper/commands/updateCssState', 'pepper/commands/actions/peek'
], function (provide, module, topic, services, events, postDescriptorStore, propertyManager, updateCssState, peek) {
    return provide(module, function (objects) {
        // Prevent editing.
        peek.preview();

        var content = propertyManager.getContent();

        var servicePromise = postDescriptorStore.saveAndCheckIn(objects, '', content);

        servicePromise.then(function (response) {

            propertyManager.setCleanState();

            topic.publish(events.library.refresh);

            updateCssState();
        });

        return servicePromise;

    });
});

},
'pepper/commands/actions/peek':function(){
define([
    'vodori/provide', 'module', 'dojo/when',
    'pepper/data/PostDescriptorStore', 'pepper/utilities'
], function (provide, module, when, postDescriptorStore, utilities) {

    // Is the page in edit mode initially?
    return provide(module.id, {
        edit: function () {
            if (utilities.pageState.isPossibleToEdit()) {
                utilities.pageState.setReadyToEdit();

            } else {
                console.warn('Tried to show editMode when page isn\'t editable.');
            }
        },

        preview: function () {
            utilities.pageState.clearReadyToEdit();
        },

        toggle: function () {
            if (utilities.pageState.inAuthorMode()) { // switch to edit if we're in author mode
                if (utilities.pageState.isPossibleToEdit() && !utilities.pageState.isReadyToEdit()) {
                    this.edit();
                } else {
                    this.preview();
                }
            } else { // on a non-authoring domain, switch to it

                when(postDescriptorStore.getCurrentPageObject(), function (currentPage) {
                    window.location.href = currentPage.authorUrl;
                });

            }
        }
    });
});

},
'pepper/commands/actions/checkOut':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/topic',
    'pepper/events',
    'pepper/data/PostDescriptorStore',
    'pepper/utilities/pageState', 'pepper/commands/updateCssState'
], function (provide, module, _, topic, events, postDescriptorStore, pageState, updateCssState) {
    return provide(module, function (objects) {

        var checkOutPromise = postDescriptorStore.checkOut(objects);

        checkOutPromise.then(
            function (response) {
                var results = response.results;
                _.forEach(results, function (result) {
                    console.log('Checked out', result.objectId);

                    // If we're checking out the current page and in current subscription then flip it to edit mode
                    // see ContentUriService#getCrossChannelPrimaryUriInSubscription
                    var isInCurrentSubscription = (result.pathInCurrentSubscription !== null);

                    if (postDescriptorStore.isCurrentPage(result.objectId) && isInCurrentSubscription) {
                        pageState.setPossibleToEdit();
                        pageState.setReadyToEdit();
                    }
                });

                topic.publish(events.library.refresh);

                updateCssState();
            }
        );

        return checkOutPromise;

    });
});

},
'pepper/commands/actions/copy':function(){
define([
    'vodori/provide',
    'module',
    'pepper/data/PostDescriptorStore',
    'dojo/topic',
    'pepper/events'
], function (provide, module, PostDescriptorStore, topic, events) {

    return provide(module.id, function (objects) {

        var copyPromise = PostDescriptorStore.copy(objects);
        copyPromise.then(function () {
            topic.publish(events.library.refresh);
        });

        return copyPromise;
    });
});

},
'pepper/commands/actions/copyTo':function(){
define([
    'vodori/provide',
    'module',
    'lodash',
    'pepper/data/PostDescriptorStore'
], function (provide, module, _, PostDescriptorStore) {

    return provide(module.id, function (sourceObjectIds, targetObjectId, parentFolderId) {
        if (_.isObject(parentFolderId)) {
            parentFolderId = _.keys(parentFolderId)[0];
        }

        return PostDescriptorStore.copyTo(sourceObjectIds, targetObjectId, parentFolderId);
    });
});

},
'pepper/commands/actions/deleteFolder':function(){
define([
    'vodori/provide',
    'module',
    'pepper/services',
    'pepper/utilities'
], function (provide, module, services, utilities) {
    return provide(module.id, function (objects, callback) {
        var promise = services.deleteObjects({
            params: {
                objects: utilities.createPayload(objects)
            }
        });
        promise.then(callback);

        return promise;
    });
});

},
'pepper/commands/actions/deleteNavigation':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'pepper/services',
    'pepper/utilities'
], function (provide, module, _, lang, services, utilities) {
    return provide(module.id, function (objects) {
        return services.deleteNavigation({
            params: {
                objects: utilities.createPayload(objects)
            }
        }).then(lang.hitch(this, function (response) {
                var results = response.results;
                _.forEach(results, function (result) {
                    console.log('Deleting nav item: ' + result);
                });
            }));
    });
});

},
'pepper/commands/actions/deleteObjects':function(){
define([
    'vodori/provide', 'module',
    'pepper/services',
    'pepper/data/PostDescriptorStore'
], function (provide, module, services, postDescriptorStore) {
    return provide(module.id, function (objects) {

        var deleteObjectsPromise = postDescriptorStore.deleteObjects(objects);

        return deleteObjectsPromise;

    });
});

},
'pepper/commands/actions/demote':function(){
define([
    'vodori/provide',
    'module',
    'pepper/data/PostDescriptorStore'
], function (provide, module, postDescriptorStore) {
    return provide(module.id, function (objects) {

        var servicePromise = postDescriptorStore.demote(objects);

        return servicePromise;

    });
});

},
'pepper/commands/actions/demoteAndCheckout':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'pepper/utilities/pageState', 'pepper/data/PostDescriptorStore',
    'pepper/commands/updateCssState'
], function (provide, module, _, pageState, postDescriptorStore, updateCssState) {
    return provide(module.id, function (objects) {

        var servicePromise = postDescriptorStore.demoteAndCheckout(objects);

        servicePromise.then(function (response) {
            var results = response.results;
            _.forEach(results, function (result) {
                console.log('Demoted and checked out', result.objectId);
                // If we're checking out the current page, then flip it to edit mode
                if (postDescriptorStore.isCurrentPage(result.objectId)) {
                    pageState.setPossibleToEdit();
                    pageState.setReadyToEdit();
                }
            });

            updateCssState();
        });

        return servicePromise;
    });
});

},
'pepper/commands/actions/distribute':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang', 'dojo/promise/all', 'dojo/Deferred',
    'pepper/services',
    'pepper/data/getChannels', 'pepper/data/PostDescriptorStore', 'pepper/utilities/createPayload',
    'pepper/dialogs/distribute/DistributeDialog'
], function (provide, module,
             _,
             lang, all, Deferred,
             services,
             getChannels, PostDescriptorStore, createPayload,
             DistributeDialog) {
    return provide(module, function (objects) {
        var deferred = new Deferred();

        var payload = createPayload(objects);
        var objectIds = _.pluck(payload, 'objectId');

        /**
         * Ensure that every object has its linked assets as an array of objects
         * @param {Array.<Object>} Array of Pepper asset descriptions
         * @param {Array.<Object>} collection of linked assets associated with the asset
         */
        var attachLinkedAssetsToObjects = function(objects, linkedAssetsCollections) {
            _.forEach(objects, function(object) {
                var associatedLinks = _.where(linkedAssetsCollections, {'objectId': object.objectId});

                if (!_.isEmpty(associatedLinks)) {
                    object.links = associatedLinks[0].links;
                }
            });
        };

        all({
            objects: PostDescriptorStore.queryByIds(objectIds),
            channels: getChannels(payload),
            links: services.getLinksForDistribution({params: {objects: payload}})
        }).then(function(data) {
            attachLinkedAssetsToObjects(data.objects, data.links.results);

            var dialog = new DistributeDialog({
                objects: data.objects,
                availableChannels: data.channels
            });

            dialog.startup();
            dialog.show();
            dialog.get('result').then(lang.hitch(deferred, 'resolve'), lang.hitch(deferred, 'reject'));

        }, lang.hitch(deferred, 'reject'));

        return deferred.promise;
    });
});

},
'pepper/data/getChannels':function(){
define([
    'dojo/Deferred',
    'pepper/services'
], function (Deferred, services) {
    /**
     * This command returns all channels in the current tenant.
     * @return {Promise} A promise that resolves to an array of all channels. The format of each item in the array is
     * { id: string, name: string, description: string, network: { id: string, name: string } }.
     */
    return function(objects, type) {
        var deferred = new Deferred();

        var request = {params: { objects: objects, type: type }};

        services.getChannels(request).then(function(result) {
            deferred.resolve(result.results);
        }, function(error) {
            var message = error && error.message;
            deferred.reject(message || 'FAILED');
        });

        return deferred.promise;
    };
});

},
'pepper/dialogs/distribute/DistributeDialog':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'vodori/ui/wizard/WizardDialog',
    './DistributeWizard', 'pepper/ui/_QuarantineMixin'
], function (module, provide, _, WizardDialog, DistributeWizard, _QuarantineMixin) {

    return provide(module, [WizardDialog, _QuarantineMixin], {

        objects: null,
        availableChannels: null,

        useTrailingActionBar : true,

        postMixInProperties: function () {
            this.inherited(arguments);

            this.quarantineAreaClassNames += ' pepperDistributeDialog';

            this._wizard = new DistributeWizard({
                objects: this.objects,
                availableChannels: this.availableChannels
            });
        }
    });
});

},
'vodori/ui/wizard/WizardDialog':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/Deferred',
    'dojo/dom-construct', 'dojo/dom-class',
    'dijit/layout/ContentPane',
    'vodori/ui/ComposingDialog',
    'vodori/ui/ButtonSet', 'vodori/ui/buttonSet/ButtonStates'
],
    function (module, provide,
              _,
              lang, Deferred,
              domConstruct, domClass,
              ContentPane,
              ComposingDialog,
              ButtonSet, ButtonStates) {
        /*
         * @class vodori/ui/wizard/WizardDialog
         * @extends vodori/ui/LazyDialog
         * @extends vodori/ui/ComposingDialog
         */
        return provide(module.id, [ComposingDialog],
            /**
             *
             * @lends vodori/ui/wizard/WizardDialog.prototype
             */
            {
                /**
                 * @type {vodori.ui.wizard._Wizard}
                 */
                _wizard: null,

                /**
                 * If set to true, trails the buttons of the Dialog to the right
                 * @type {boolean}
                 */
                useTrailingActionBar: false,

                /**
                 * @type {Node}
                 */
                _actionBar: null,

                /**
                 * @type {vodori.ui.ButtonSet}
                 */
                _buttons: null,

                /**
                 * @type {dojo._base.Deferred}
                 */
                _resultDeferred: null,

                /**
                 * From _Composing
                 * Expose the `class` property so that _Wizards can set the class of the Dialog for styling
                 */
                _exposedProps: ['class', 'title'],

                buildRendering: function() {
                    this.widget = new ContentPane({
                        'class': 'dijitDialogPaneContentArea vodoriWizardDialogPane pepperInfoDialog'
                    });
                    this.inherited(arguments);
                    var actionBarPane = new ContentPane({
                        'class': 'dijitDialogPaneActionBar vodoriWizardDialogActionBar footer'
                    });
                    this._actionBar = domConstruct.create(
                        'div', {
                            'class': this.useTrailingActionBar?'trailing':''
                        }
                    );
                    actionBarPane.set('content',this._actionBar);
                    domConstruct.place(
                        actionBarPane.domNode,
                        this.widget.domNode,
                        'after'
                    );
                },

                /**
                 * _WidgetBase Lifecycle method
                 * @ignore
                 */
                startup: function () {
                    this.inherited(arguments);
                    this._buildButtonSet(this._actionBar);

                    this._addComposingNode(this._wizard);

                    this._wizard.set('contentPane', this.widget);
                    this.own(this._wizard.watch('state', lang.hitch(this,function(__,___, newState){
                        //noinspection JSPotentiallyInvalidUsageOfThis

                        /**
                         * Let's re-center on state change in case the overall width changes based on widgets being
                         * added\removed from the content pane
                         */
                        this._position();
                        this._buttons.set('state', this._wizard.getStateName(newState));
                    })));

                    this.own(
                        this._wizard.on('wizardCancel', lang.hitch(this,function() {

                            // this stops the pointless error in the console
                            this._resultDeferred.promise.otherwise(function() {});

                            //noinspection JSPotentiallyInvalidUsageOfThis
                            this._resultDeferred.cancel('Cancelled via a call to "hide"');
                            this.hide(true);
                        })),
                        this._wizard.on('wizardComplete', lang.hitch(this,function() {
                            //noinspection JSPotentiallyInvalidUsageOfThis
                            var payload = this._wizard.get('payload');
                            //noinspection JSPotentiallyInvalidUsageOfThis
                            this._resultDeferred.resolve(payload);
                            this.hide(true);
                        }))
                    );

                    this._resultDeferred = new Deferred();

                    this._wizard.start();

                },

                /**
                 *
                 * @return {*}
                 * @private
                 */
                _getResultAttr: function() {
                    return this._resultDeferred.promise;
                },

                /**
                 * This allows _Composables to set the class of this dialog in a decoupled way.
                 *
                 * Supports Obejcts of the following form:
                 *
                 * {
                 *    add: ['class1', 'class2', ...],
                 *    remove ['class3'],
                 *    toggle: [ 'class4', ['class5', true], ...],
                 *    replace: [ ['class6', 'class7'] ]
                 *  }
                 *
                 *  This would add 'class1' and 'class2', remove 'class3', toggle 'class4', add 'class5' and
                 *  replace 'class6' with 'class7'.
                 *
                 *  Any other keys for this object are ignored.
                 *
                 * @param {Object} classObject
                 */
                _setClassAttr: function(classObject) {
                    var dialogDomNode = this.domNode;
                    /*
                     * Each of the object keys corresponds to a domClass method
                     */
                    _.forEach(classObject,function(classes, action) {
                        var domAction = domClass[action];
                        if(_.isFunction(domAction)) {
                            _.forEach(classes, function(className) {
                                /*
                                 * NB: arr.concat('foo', 'bar') and arr.concat(['foo','bar']) work identically
                                 */
                                domAction.apply(null, [dialogDomNode].concat(className));
                            });
                        }
                    });
                },

                _buildButtonSet: function(domNode) {
                    var wizardActions    = this._wizard.get('actions');
                    var wizardStates     = this._wizard.get('states');
                    var actionVisibility = this._wizard.get('enabledActions');

                    /* All actions, by default, are not shown */
                    var BASE_VISIBILITY = {};
                    _.forEach(wizardActions, function(action) {
                        BASE_VISIBILITY[action] = ButtonStates.NOT_SHOWN;
                    });

                    var buttonStates = {};
                    _.forEach(wizardStates, function(state) {
                        var stateName = this._wizard.getStateName(state);
                        /* Get the possible actions for each substate in this state */
                        var actionsForState = _(actionVisibility).pick(state).values().value();

                        /*
                         * This function is used by merge to determine the correct visibility for an action
                         * given its visibility in each substate.
                         */
                        var buttonStateMapper = function(oldValue, newValue) {
                            if(_.isUndefined(oldValue)) {
                                oldValue =  ButtonStates.NOT_SHOWN;
                            }
                            if(!_.isNumber(newValue)) {
                                newValue = newValue?ButtonStates.SHOWN_ENABLED:ButtonStates.SHOWN_DISABLED;
                            }
                            return oldValue | newValue;
                        };
                        /* Associate action visibility with compound state name */
                        buttonStates[stateName] =
                            _.merge.apply(null, [{}, BASE_VISIBILITY].concat(actionsForState, buttonStateMapper));
                    }, this);

                    var wizardButtons = _.map(wizardActions, function(action) {
                        return {
                            name: action,
                            attrs: {
                                'class': this.get('actionClasses')[action] || ''
                            }
                        };
                    },this._wizard);

                    this._buttons =  new ButtonSet({
                        buttons: wizardButtons,
                        states:  buttonStates
                    },domNode);

                    _.forEach(wizardActions, function(action) {
                        var button = this._buttons.getButton(action);
                        this.own(button.on('click', lang.hitch(this,function(){
                            console.log('Firing %s', action);

                            //noinspection JSPotentiallyInvalidUsageOfThis
                            this._wizard.performAction(action);
                        })));
                    },this);
                },

                show: function() {
                    var showDeferred = this.inherited(arguments);
                    return showDeferred.then(lang.hitch(this,function() {
                        this.widget.resize();
                        return this._resultDeferred;
                    }));
                },

                hide: function(override) {
                    var hideDeferred;
                    if(_.isBoolean(override) && !!override) {
                        hideDeferred = this.inherited(arguments);
                    }
                    else {
                        console.log('Trying to hide WizardDialog');
                        this._wizard.cancel();
                    }
                    return hideDeferred;
                }



            });
    }
);

},
'vodori/ui/ComposingDialog':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/dom-construct', 'dojo/when', 'dojo/parser', 'dojo/query', 'dojo/on', 'dojo/dom-style',
    'dijit/registry',
    './Dialog', 'vodori/layout/_Composing'
], function (module, provide, _, lang, domConstruct, when, parser, query, on, domStyle,
             registry,
             Dialog, _Composing) {
    /**
     * The HTML class used to mark placeholders put into contained widgets.
     *
     * @const
     * @type {string}
     */
    var PLACEHOLDER_HTML_CLASS = 'composing-dialog-place-holder';

    /**
     * @class ComposingDialog
     *
     * Fires the borrow and unborrow events.
     */
    return provide(module, [Dialog, _Composing], {

        /**
         * Whether to call methods on this based on the compose event.
         *
         * @type {boolean}
         */
        upstreamDelegation: true,

        /**
         * @inheritDoc
         */
        destroyOnHide: true,

        /**
         * Optionally set this attribute and the domNode property will be placed inside the dialog.
         *
         * @type {dijit._WidgetBase}
         */
        widget: null,

        /**
         * Whether to run the parser when the dialog opens for the first time.
         *
         * @type {boolean}
         */
        parseOnFirstShow: false,

        /**
         * Whether to fetch the title from any widgets inside our container node.
         *
         * @type {boolean}
         */
        borrowTitle: true,

        /**
         * Whether the title should go back where it came from when dialog is closed.
         *
         * @type {boolean}
         */
        unBorrowTitleOnClose: false,

        /**
         * Event that'll be emitted on each title this widget borrows.
         *
         * @type {string}
         * @const
         */
        TITLE_BORROW_EVENT: 'borrowed',

        /**
         * A string that can be used to select the title pane of composed content.
         *
         * @type {string}
         * @const
         */
        TITLE_PANE_SELECTOR: '[data-vodori-dialog-title="true"]',

        /**
         * CSS class used for the wrapper of any borrowed titles.
         *
         * @type {string}
         * @const
         */
        TITLE_CONTAINER_CLASS: 'composing-dialog-title-container',

        /**
         * Used to hold the position of any borrowed titles.
         * (I'm considering this const even though it's sorta compile-time).
         *
         * @type {string}
         * @const
         */
        PLACEHOLDER: '<span class="' + PLACEHOLDER_HTML_CLASS + '"></span>',

        /**
         * @type {string}
         * @const
         */
        PLACEHOLDER_HTML_CLASS: PLACEHOLDER_HTML_CLASS,

        /**
         * The original contents of titleNode.
         *
         * @type {Element}
         */
        _titleNodeContent: null,

        /**
         * Properties that can be set via the event.
         *
         * @type {Array.<string>}
         */
        _exposedProps: ['title'],

        /**
         * A list of methods that will be called if truthy in a compose event.
         *
         * @type {Array.<string>}
         */
        _exposedMethods: ['hide', 'show'],

        /**
         * Whether I've parsed the contents of the dialog.
         *
         * @type {boolean}
         */
        _parsed: false,

        _eventTemplate: {
            bubbles: true,
            cancelable: true
        },

        postMixInProperties: function () {
            this.inherited(arguments);

            if (this.widget) {
                this._composingNodes.push(this.widget);
            }

            // We've been asked to be patient.
            if (this.parseOnFirstShow) {
                this.parseOnLoad = false;
            }
        },

        buildRendering: function () {
            this.inherited(arguments);

            if (!!this.widget) {
                domConstruct.place(this.widget.domNode, this.containerNode, 'only');
            }

            // Wait for the first show to transfer the titles
            if (this.borrowTitle && !this.parseOnFirstShow) {
                this._borrowTitles();
            }
        },

        startup: function () {
            this.inherited(arguments);

            if (this.widget) {
                this.widget.startup();
            }
        },

        /**
         * Adding lazy parsing and title transport.
         *
         * @inheritDoc
         */
        show: function () {
            if (this.widget) {
                // This shouldn't bubble, since it's pointed at a specific widget.
                on.emit(this.widget.domNode, 'beforeDialogOpen', {
                    bubbles: false,
                    cancelable: true,
                    dialog: this
                });
            }

            // Save the show deferred.
            var retVal = this.inherited(arguments);

            if (this.parseOnFirstShow && !this._parsed) {
                parser.parse(this.containerNode, {template:false});

                this._parsed = true;
                this._resizeIfOpen();
            }

            if (this.borrowTitle) {
                when(retVal, lang.hitch(this, '_borrowTitles'));
            }

            if (this.widget) {
                when(retVal, lang.hitch(this, function () {
                    // This shouldn't bubble, since it's pointed at a specific widget.
                    on.emit(this.widget.domNode, 'dialogOpen', {
                        bubbles: false,
                        cancelable: true,
                        dialog: this
                    });
                }), _.noop);
            }

            if (this.titleBar && this.draggable) {
                when(retVal, lang.hitch(this, '_skipFormElementsWithinMoveable'));
            }

            return retVal;
        },

        /**
         * Undoing title transport.
         *
         * @inheritDoc
         */
        hide: function () {
            if (this.widget) {
                on.emit(this.widget.domNode, 'beforeDialogClose', {
                    bubbles: false,
                    cancelable: true,
                    dialog: this
                });
            }

            var hideDef = this.inherited(arguments);


            if (this.borrowTitle) {
                when(hideDef, lang.hitch(this, '_returnTitles'));
            }

            when(hideDef, lang.hitch(this, function () {
                if (this.widget) {
                    on.emit(this.widget.domNode, 'dialogClose', {
                        bubbles: false,
                        cancelable: true,
                        dialog: this
                    });
                }
            }), _.noop);

            return hideDef;
        },

        /**
         * Overridden to expose the hide method.
         *
         * @param {Object} event
         * @private
         */
        _composeHandler: function (event) {
            this.inherited(arguments);

            if (this.upstreamDelegation) {
                this._callHashedMethods(event);
            }
            this._resizeIfOpen();
        },

        /**
         * Allows a contained widget to call white-listed methods by passing them in an event.
         *
         * @param {Object.<ArrayLike>} object
         * @private
         */
        _callHashedMethods: function (object) {
            _.forEach(this._exposedMethods, function (name) {
                var setting = !!object.methods && object.methods[name];
                if (!!setting) {
                    this[name].apply(
                        this,
                        _.isArray(setting) || _.isArguments(setting) ? setting : []
                    );
                }
            }, this);
        },

        _borrowTitles: function () {
            var titles = query(this.TITLE_PANE_SELECTOR, this.containerNode);

            var container = null,
                titleNodeHolder = null;
            if (titles.length > 0) {
                this._titleNodeContent = titleNodeHolder = (this._titleNodeContent || domConstruct.create('div'));

                container = domConstruct.create('div', {
                    'class': this.TITLE_CONTAINER_CLASS
                });

                titles.forEach(function (title) {
                    domConstruct.place(this.PLACEHOLDER, title, 'after');
                    domConstruct.place(title, container);
                }, this);

                if (this.unBorrowTitleOnClose) {
                    query('> *', this.titleNode).forEach(function (child) {
                        domConstruct.place(child, titleNodeHolder);
                    }, this);
                }

                domConstruct.place(container, this.titleNode, 'only');

                // Looping over them again, so the timing of the `borrow` is sane.
                titles.forEach(this._borrowingEmitFactory('borrow'), this);

                this._resizeIfOpen();
            }
        },

        _returnTitles: function () {
            if (!this.unBorrowTitleOnClose) {
                return;
            }

            // Reusing the CSS class for logical reasons, however, we placed it, so IMO it's ok.
            var titleContainer = query('.' + this.TITLE_CONTAINER_CLASS, this.titleNode).pop();
            var titles = query('> *', titleContainer);

            if (titles.length > 0) {
                query('.' + this.PLACEHOLDER_HTML_CLASS, this.containerNode).forEach(
                    function (placeholder, i) {
                        domConstruct.place(titles[i], placeholder, 'replace');
                    }
                );

                query('> *', this._titleNodeContent).forEach(function (child) {
                    domConstruct.place(child, this.titleNode);
                }, this);

                // Clean up the wrapper.
                domConstruct.destroy(titleContainer);

                //noinspection SpellCheckingInspection
                titles.forEach(this._borrowingEmitFactory('unborrow'), this);
            }
        },

        /**
         * Simple function factory for for our events.
         *
         * @param {string} type The eventName the emitter should emit.
         * @return {Function} The emitter
         * @private
         */
        _borrowingEmitFactory: function (type) {
            return lang.hitch(this, function (node) {
                on.emit(node, type, lang.mixin({
                    borrowedBy: this
                }), this._eventTemplate);
            });
        },

        /**
         * Ensures that any form inputs that are nested within the draggable title bar can receive clicks instead of
         * being used to drag and move the dialog.
         *
         * Without setting skip=true on the Moveable used for title bar, you would not be able to click anywhere in
         * the search input field in the Library dialog.
         *
         * @see {@link https://jira.vodori.com/browse/CAYENNE-6499|CAYENNE-6499}
         * @see {@link http://dojotoolkit.org/reference-guide/1.8/dojo/dnd/Moveable.html|dojo.dnd.Moveable}
         * @private
         */
        _skipFormElementsWithinMoveable: function() {
            if (typeof this._moveable === 'object') {
                this._moveable.skip = true;
            } else {
                console.warn('Could not find Moveable within ComposingDialog. As a result, you will not be able to ' +
                    'click inside any form inputs that are nested within the title bar.');
            }
        },

        _resizeIfOpen: function() {
            if (this.open) {
                this.resize();
                this._position();
            }
        },

        destroy: function () {
            if (this.widget) {
                this.widget.destroyRecursive();
            }

            domConstruct.destroy(this._titleNodeContent);

            this.inherited(arguments);
        }
    });

});

},
'vodori/layout/_Composing':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/declare', 'dojo/on', 'dojo/_base/lang'
], function (
    module, provide,
    _,
    declare, on, lang
) {

    /**
     * @class
     */
    return provide(module, null, {
        /**
         * Collections of properties that will have a setter called for them.
         *
         * @type {Array.<string>}
         */
        _exposedProps: ['buttonState'],

        /**
         * Property that points to this widget's buttonSet. If the property doesn't exist the setter
         * won't be called.
         *
         * @type {string}
         */
        _buttonSetProperty: '_buttons',

        /**
         * Attachpoints to set as the root of the event delegation. Defaults to this.domNode.
         *
         * @type {Array.<string|Element>}
         */
        _composingNodes: null,

        constructor: function () {
            this._composingNodes = ['domNode'];
            // Initialize for runtime manipulation.
            this._exposedProps = this._exposedProps.slice(0);
        },

        buildRendering: function () {
            this.inherited(arguments);

            // If this is a lazy widget, then handle that automatically, since it's so common.
            if (_.isFunction(this.lazy)) {
                this.lazy(function () {
                    _.forEach(_.map(this._composingNodes, this._addComposingNode, this), function(composingNode) {
                        this.own(composingNode);
                    }, this);
                });
            }
            else {
                _.forEach(_.map(this._composingNodes, this._addComposingNode, this), function(composingNode) {
                    this.own(composingNode);
                }, this);
            }

        },

        /**
         * Adds a handler for a node that might receive a compose method.
         *
         * @param {string|Element} node If a string, then assumed to point to a node or widget w/
         *     domNode on `this`.
         * @return {{remove: Function}}
         * @private
         */
        _addComposingNode: function (node) {
            node = _.isString(node) ? ((!!this[node] && this[node].domNode) ? this[node].domNode : this[node]) : node;

            if (!node) {
                throw new Error('ValueError: couldn\'t derive a node in _addComposingNode');
            }

            return on(node, 'compose', lang.hitch(this, '_composeHandler'));
        },

        /**
         * Takes the compose event and call a setter for each white-listed prop.
         *
         * @param {Object.<*>} event
         * @protected
         */
        _composeHandler: function (event) {
            _.forEach(event.props || {}, function (value, name) {
                if (_.contains(this._exposedProps, name)) {
                    this.set(name, value);
                }
            }, this);
        },

        /**
         * Calls the buttonSet's setter if it exists.
         *
         * @param {*} state
         * @return {*}
         * @private
         */
        _setButtonStateAttr: function (state) {
            var buttonSet = this[this._buttonSetProperty];
            if (!!buttonSet && buttonSet.set) {
                buttonSet.set('state', state);
            }
            return this.inherited(arguments);
        }
    });
});

},
'vodori/ui/ButtonSet':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/dom-construct', 'dojo/dom-class',
    'dijit/_WidgetBase',
    'vodori/util/string/capitalize',
    'vodori/ui/Button', 'vodori/ui/buttonSet/ButtonStates', 'vodori/ui/buttonSet/ButtonParts'
], function (
    module, provide,
    _,
    lang,
    domConstruct, domClass,
    _WidgetBase,
    capitalize,
    Button, ButtonStates, ButtonParts
) {

    /**
     * Manage a collection of buttons as a unit. Handles:
     *
     *  - Creation.
     *  - Visibility.
     *  - Enabledness.

        <pre>
             A button declaration.
            
                __Button = {
                    name: string,  MUST be unique.
                    [label: string],
                    [attrs: Object],
                    [title: string],
                    [ButtonConstructor: dijit.form.Button]
                };

             A specialized format for configuring a buttons visibility and enabled state. In all cases
             either a number or an object can be used to set nested portions. Where:
            
                00b (0) -> Everything is hidden.
                01b (1) -> NOT SUPPORTED
                10b (2) -> Everything is shown and disabled.
                11b (3) -> Everything is shown and enabled.
            
                See: vodori/ui/buttonSet/buttonStates for details on above.
            
                __State = number | {
                    {{buttonName}}: number | {
                        visible: boolean,
                        enabled: boolean
                    }
                };
        </pre>
    */

    //noinspection JSValidateJSDoc
    return provide(module.id, [_WidgetBase], {
        /**
         * A collection of buttons that can be setup either using the __Button object or w/ a
         * string, which results in label and title being the string capitalized.
         *
         * This is optional if all buttons are declared somewhere in the states collection and
         * custom properties aren't needed.
         *
         * @type {Array.<string|__Button>}
         */
        buttons: null,

        /**
         * A named collection of states. Usage: {hot: __State, cold: __State}.
         *
         * @type {Object.<string, __State>}
         */
        states: null,

        /**
         * If set to a string, will look up the state in this.states, otherwise applies it as is.
         * Note: Please prefer named states.
         *
         * @type {string|__State}
         */
        state: ButtonStates.SHOWN_ENABLED,

        /**
         * The constructor to call when creating our buttons. Defaults to vodori.ui.Button
         *
         * @type {dijit.form.Button}
         */
        ButtonConstructor: Button,

        /**
         * CSS class that wraps the containing widget.
         *
         * @type {string}
         */
        baseClass: 'vodoriButtonSet',

        /**
         * A CSS class that will hide a button contained by this.domNode.
         *
         * @type {string}
         * @const
         */
        HIDDEN_CLASS: 'hide',

        /**
         * Internal collection of buttons.
         *
         * @type {Array.<dijit.form.Button>}
         * @protected
         */
        _buttons: null,

        /**
         * Curried method that maps our buttons. Available after buildRendering.
         *
         * @type {Function}
         * @private
         */
        _mapButtons: null,

        /**
         * Whether we've already set the button state. Needed to ensure we don't apply the onLoad
         * state twice.
         *
         * @type {boolean}
         */
        _appliedState: false,

        /**
         * Init our collections.
         */
        constructor: function () {
            this.buttons = [];
            this.states = {};
            this._buttons = [];
        },

        /**
         * Create our buttons and curry them into _mapButtons.
         */
        buildRendering: function () {
            this.inherited(arguments);

            this._parseButtons();

            // Using map, so I always get the set back.
            this._mapButtons = lang.partial(_.map, this._buttons);
        },

        /**
         * Ensure a state is applied.
         */
        postCreate: function () {
            this.inherited(arguments);

            // Make sure the buttons have some sort of state applied.
            if (!this._appliedState) {
                this.set('state', this.state);
            }
        },

        /**
         * Get a button by name.
         *
         * @param {string} name The HTML name of the button sought.
         * @return {dijit.form.Button}
         */
        getButton: function (name) {
            return this._byName(name);
        },

        /**
         * Change the state to either a named state or a state literal. Numbers are accepted per
         * __State.
         *
         * @param {string|__State} state Either a name for a named state or a state literal.
         * @return {T}
         * @private
         */
        _setStateAttr: function (state) {
            this.state = state;
            this._appliedState = true;
            this._applyState(state);
            return this;
        },

        /**
         * Does the actual state application.
         *
         * @param {__State|string} state
         * @return {Array.<dijit.form.Button>}
         * @private
         */
        _applyState: function (state) {
            // If an object is passed, then apply it, else use as name.
            state = lang.isString(state) ? this.states[state] : state;

            // Minor perf gain from not fixing context.
            var HIDDEN_CLASS = this.HIDDEN_CLASS;
            var domClassAction  = (+state === ButtonStates.NOT_SHOWN)       ?   'add'
                                : (+state === ButtonStates.SHOWN_DISABLED)  ?   'remove'
                                : (+state === ButtonStates.SHOWN_ENABLED)   ?   'remove'
                                :                                               null;

            if(domClassAction) {
                return this._mapButtons(function (button) {
                    domClass[domClassAction](button.domNode, HIDDEN_CLASS);
                    button.set('disabled', +state === ButtonStates.SHOWN_DISABLED);
                });
            }
            else {
                return _.forEach(state, this._applyButtonState, this);
            }
        },

        /**
         * Apply the actual changes to our buttons.
         *
         * @param {number|{visible: boolean, enabled: boolean}} state
         * @param {string} key The buttons name.
         * @return {dijit.form.Button}
         * @private
         */
        _applyButtonState: function (state, key) {
            var button = this._byName(key),
                HIDDEN_CLASS = this.HIDDEN_CLASS,
                domClassAction  = (+state === ButtonStates.NOT_SHOWN)       ?   'add'
                                : (+state === ButtonStates.SHOWN_DISABLED)  ?   'remove'
                                : (+state === ButtonStates.SHOWN_ENABLED)   ?   'remove'
                                :                                               null,
                buttonDisabled  = (+state === ButtonStates.SHOWN_DISABLED);

            if(domClassAction === null) {
                domClassAction = !!state.visible ? 'remove' : 'add';
                buttonDisabled = !state.enabled;
            }
            domClass[domClassAction](button.domNode, HIDDEN_CLASS);
            button.set('disabled', buttonDisabled);

            return button;
        },

        /**
         * Gets a button under our control by name.
         *
         * @param {string} name The UNIQUE name of a button.
         * @return {dijit.form.Button}
         * @private
         */
        _byName: function (name) {
            return _.find(this._buttons, function (button) {
                return button.get('name') === name;
            }, this);
        },

        /**
         * Wraps _createButton and adds buttons to this object.
         *
         * @private
         */
        _parseButtons: function () {
            var buttons = this.buttons = this._findButtons();

            this._buttons = _.map(buttons, this._createButton, this);
        },

        /**
         * Creates an actual button using the conventions defined by __Button.
         *
         * @param {__Button} parts The pieces our button will be made of.
         * @return {Button} The newly created button.
         * @private
         */
        _createButton: function (parts) {
            // Support just passing a name, since it's a very common use case.
            parts = lang.isObject(parts) ? parts : {
                name: parts
            };

            var part = lang.hitch(this, '_getPart', parts),
                attrs = lang.mixin(part('attrs'), {
                    name: part('name'),
                    label: part('label'),
                    title: part('title')
                }),
                domNode = domConstruct.create('button', attrs, this.domNode),
                Button  = part('ButtonConstructor');

            return new Button(attrs, domNode);
        },

        /**
         * Gets either the named part or a reasonable default.
         *
         * @param {{name: string}} parts The parts of the button we're creating.
         * @param {string} name The name of the desired part.
         * @return {*}
         * @private
         */
        _getPart: function (parts, name) {
            var part =  (name === ButtonParts.NAME)         ?    parts.name
                    :   (name === ButtonParts.LABEL)        ?   (parts.label || capitalize(parts.name))
                    :   (name === ButtonParts.ATTRS)        ?   (parts.attrs || {})
                    :   (name === ButtonParts.TITLE)        ?   (parts.title || capitalize(parts.name))
                    :   (name === ButtonParts.CONSTRUCTOR)  ?   (parts.ButtonConstructor || this.ButtonConstructor)
                    :                                            null;
            if(part === null) {
                console.error('%o couldn\'t find part %s', this, name);
            }
            return part;
        },

        /**
         * Make sure we have a button for every button in our states declaration.
         *
         * @return {__Button}
         * @private
         */
        _findButtons: function () {
            var buttons = [];

            // Make sure we have all the buttons from the button states in our
            // collection.
            var states = this.states;
            _.forEach(states, function (state) {
                var buttonNames = [];

                // No need to forEach numbers.
                if (isFinite(state)) {
                    return;
                }

                _.forEach(state, function (_, name) {
                    return buttonNames.push(name);
                });

                buttons = buttons.concat(buttonNames);
            });

            // Add in declared buttons, then reverse, so we know declared
            // buttons have precedence.
            buttons = buttons.concat(this.buttons).reverse();

            // Make unique, then put back in order.
            buttons = _.unique(buttons, function (button) {
                // If button's a string, that's the same as if it's an object w/ the same name.
                return lang.isString(button) ? button : button.name;
            }).reverse();

            return buttons;
        },

        destroy: function () {
            _.forEach(this._buttons, function (button) {
                button.destroyRecursive();
            });

            domConstruct.destroy(this.domNode);

            this.inherited(arguments);
        }
    }, ButtonStates);
});

},
'vodori/util/string/capitalize':function(){
define(function () {
    return function (str) {
        return str.slice(0, 1).toUpperCase() + str.slice(1);
    };
});

},
'vodori/ui/buttonSet/ButtonStates':function(){
define(['../../util/Enum'], function (Enum) {
    'use strict';

    return new Enum(
        {'NOT_SHOWN': 0},
        {'SHOWN_DISABLED': 2},
        {'SHOWN_ENABLED': 3}
    );
});
},
'vodori/ui/buttonSet/ButtonParts':function(){
define(['../../util/Enum'], function (Enum) {
    'use strict';

    return new Enum(
        {'NAME': 'name'},
        {'ATTRS': 'attrs'},
        {'LABEL': 'label'},
        {'TITLE': 'title'},
        {'CONSTRUCTOR': 'ButtonConstructor'}
    );
});
},
'pepper/dialogs/distribute/DistributeWizard':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/dom-construct', 'dojo/on', 'dojo/query', 'dojo/dom-class', 'dojo/dom-style',
    'dijit/form/Form', 'dijit/registry',
    'vodori/ui/wizard/_Wizard', 'vodori/renderTemplate',
    'vodori/util/getDijitDescendantsByClass', 'vodori/util/string/isBlank',
    'pepper/data/PostDescriptorStore', './AssetsDisplay',
    'dojo/text!./templates/SelectChannelsPane.html', 'dojo/text!./templates/ReviewPane.html',
    'pepper/utilities/channels',
    /* widgets in template */
    'dijit/form/TextBox',
    'vodori/input/GroupedSelect', 'vodori/input/CheckBox'
], function (module, provide, _,
             lang,
             domConstruct, on, query, domClass, domStyle,
             Form, registry,
             _Wizard, renderTemplate,
             getDijitDescendantsByClass, isBlank,
             PostDescriptorStore, AssetsDisplay,
             selectChannelsPaneTemplate, reviewPaneTemplate,
             channels) {

    /**
     * Wizard for setting up and executing a distribute action, distributing a pre-selected set of posts to one or more
     * other channels.
     *
     * @class pepper/dialogs/distribute/DistributeWizard
     * @mixes vodori/ui/wizard/_Wizard
     */
    return provide(module, [_Wizard], {

        LINKED_ASSET_CHECKED_CLASS: 'include-linked-assets',

        title: 'Distribute Asset',

        /**
         * @type {Object}
         * @property {Array.<Object>} objects - one or more posts to distribute
         * @property {Array.<Object>} availableChannels - one or more destination channels for the user to choose from
         * @property {Array.<String>} selectedChannels - ids of the selected channels (populated after the
         *           selectChannels wizard step).
         */
        payload: null,

        initialState: 'selectChannels',

        stateMachine: [
            {
                'selectChannels' : {
                    'Distribute': 'executing',
                    'Cancel': 'CANCELED'
                },
                'executing' : {
                    'Distribute': null,
                    'Cancel': null,
                    '_invalid': 'selectChannels',
                    '_finished': 'review'
                },
                'review' : {
                    'Done': 'COMPLETED'
                }
            }
        ],

        actionClasses: {
            Cancel: 'standard cancel',
            'Distribute': 'standard distribute default action',
            'Done': 'standard done default action'
        },

        actionOrder: ['Cancel', 'Distribute', 'Done'],

        _linkedObjects: null,

        _selectChannelsPaneNode: null,

        /**
         * This value should be determined by an appropriate
         * form element contained within the channel select widget
         *
         * @type {boolean}
         * @private
         */
        _showLinkedAssets: true,

        renderState: function(state, contentPane) {
            switch(state[0]) {
                case 'selectChannels':
                    this.renderSelectChannelsState(contentPane);
                    break;
                case 'executing':
                    this._renderExecutingState();
                    break;
                case 'review':
                    this._renderReviewState(contentPane);
                    break;
            }

            this.fireCompose({
                props: {
                    title: this.title
                }
            });
        },

        renderSelectChannelsState: function(contentPane) {
            // We can only let the content pane be set once because the ContentPane content setter destroys whatever
            // was previously set as its content.
            var selectChannelsPane = this.getSelectChannelsPaneNode();
            if (contentPane.containerNode.firstChild !== selectChannelsPane) {
                contentPane.set('content', selectChannelsPane).then(lang.hitch(this, function() {
                    this._getSelectChannelsForm().onSubmit = lang.hitch(this, function() {
                        this.performAction('Distribute');
                        return false;
                    });
                }));
            }
        },

        getSelectChannelsPaneNode: function() {
            if (!this._selectChannelsPaneNode) {
                this._selectChannelsPaneNode = this.buildSelectChannelsPaneNode();
            }
            return this._selectChannelsPaneNode;
        },

        buildSelectChannelsPaneNode: function() {
            var node = domConstruct.create('div', {
                innerHTML: renderTemplate(selectChannelsPaneTemplate,
                                          this._getTemplateData(this.payload.availableChannels))
            });

            return node;
        },

        _renderExecutingState: function() {
            if (this._validateSelectChannelsForm()) {
                this._setSelectChannelsFormDisabled(true);
                this._executeDistribute();
            } else {
                this.performAction('_invalid');
            }
        },

        _validateSelectChannelsForm: function() {
            var NAME_MAX_LENGTH = 255;

            var form = this._getSelectChannelsForm();
            var formData = form.get('value');

            this._adjustPayloadForAnyLinkedAssets();

            this.payload.selectedChannels = formData.selectedChannels || [];
            this.payload.distributionName = formData.distributionName;

            var failureMessages = [];

            if (isBlank(this.payload.distributionName)) {
                failureMessages.push('Distribution Name is required.');
            } else if (this.payload.distributionName.length > NAME_MAX_LENGTH) {
                failureMessages.push('Distribution Name is too long. (' + NAME_MAX_LENGTH + ' character max)');
            }

            if (this.payload.selectedChannels.length === 0) {
                failureMessages.push('At least one channel must be selected.');
            }

            if (failureMessages.length > 0) {
                this._setSelectChannelValidationMessage(failureMessages.join('<br/>'));
                return false;
            } else {
                this._setSelectChannelValidationMessage('');
                return true;
            }
        },

        _adjustPayloadForAnyLinkedAssets: function() {
            // We need to delve into the select channel widget to get this value since form value get above
            // will not descend into nested widgets
            if (!!this._getSelectLinkedAssets().get('value')) {
                this._showLinkedAssets = true;
                this.payload.objectsToDistribute = this.payload.objects.concat(this._linkedObjects);
            } else {
                this._showLinkedAssets = false;
                this.payload.objectsToDistribute = this.payload.objects;
            }
        },

        _getLinkedObjects: function() {
            if (this._linkedObjects !== null) {
                return this._linkedObjects;
            }

            var linkedObjectIds = [];
            _.forEach(this.payload.objects, function(object) {
                _.forEach(object.links, function(link) {
                    linkedObjectIds.push(link.objectId);
                });
            });

            // Ensure that linked object ids are unique among themselves and among the "top level" selected assets
            linkedObjectIds = _.difference(_.unique(linkedObjectIds),
                                           _.pluck(this.payload.objects, 'objectId'));

            this._linkedObjects = _.map(linkedObjectIds, function(id) {
                return { objectId: id };
            });

            return this._linkedObjects;
        },

        _renderReviewState: function(contentPane) {
            var selectedChannels = _.filter(this.payload.availableChannels, function(channel) {
                return _.contains(this.payload.selectedChannels, channel.id);
            }, this);

            contentPane.set('content',
                renderTemplate(reviewPaneTemplate,
                    lang.mixin(this._getTemplateData(selectedChannels), this.payload)));
        },

        _getSelectChannelsForm: function() {
            return getDijitDescendantsByClass(this.getSelectChannelsPaneNode(), Form)[0];
        },

        _getAssetsDisplayWidget: function() {
            return getDijitDescendantsByClass(this.getSelectChannelsPaneNode(), AssetsDisplay)[0];
        },

        _setSelectChannelsFormDisabled: function(value) {
            _.forEach(this._getSelectChannelsForm().getChildren(), function(widget) {
                widget.set('disabled', value);
            });
        },

        _setSelectChannelValidationMessage: function(message) {
            var errorMsg = query('.errors', this.getSelectChannelsPaneNode())[0];
            errorMsg.innerHTML = message;
            domStyle.set(errorMsg, 'display', message ? '' : 'none');
        },

        _getSelectLinkedAssets: function() {
            return registry.byNode(query('.' + this.LINKED_ASSET_CHECKED_CLASS, this.getSelectChannelsPaneNode())[0]);
        },

        _getTemplateData: function(networks) {
            var assets = this.payload.objects,
                assetsCountWithoutLinks = assets.length,
                assetsCountWithLinks  = assetsCountWithoutLinks + this._getLinkedObjects().length;

            return {
                networks: channels.organizeByNetwork(networks),
                'assetsCountWithoutLinks': assetsCountWithoutLinks,
                'assetsCountWithLinks': assetsCountWithLinks,
                showLinkedAssets: this._showLinkedAssets,
                serializedObjects: JSON.stringify({objects: assets})
            };
        },

        _executeDistribute: function() {
            PostDescriptorStore.distribute(this.payload.objectsToDistribute, this.payload.selectedChannels,
                this.payload.distributionName).then(
                lang.hitch(this, function(result) {
                    this.performAction('_finished');
                }), lang.hitch(this, function(err) {
                    this.performAction('_finished');
                })
            );
        }

    });
});

},
'vodori/ui/wizard/_Wizard':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/Evented', 'dojo/Stateful', 'dojo/_base/lang',
    'vodori/util/collections/combine',
    'vodori/layout/_Composable',

    'vodori/exceptions/UnsupportedMethodCallException',
    'vodori/exceptions/InvalidActionException',
    'vodori/exceptions/InvalidStateException'
],
    function (
        module, provide,
        _,
        Evented, Stateful, lang,
        combine,
        _Composable,

        UnsupportedMethodCallException,
        InvalidActionException,
        InvalidStateException) {
        /**
         * Provides the basic functionality for a Wizard mediator object.
         *
         * The `_Wizard` mixin contains all of the states that a Wizard can be in. What these states represent depend on
         * the specific implementation, but generally, it'll correspond to what widgets are visible in the UI and what
         * actions can be taken (which will probably be represented by some button or other clickable UI element).
         *
         * The _Wizard will end when it is cancelled or when it is completed and it will emit an event accordingly.
         *
         * It can be fed a payload when it starts which will set its original data. Upon completion, its payload will
         * contain any final data. In many implementations, this will be accessed by whatever object instantiated the
         * `_Wizard` in the first place.
         *
         * @mixin vodori/ui/wizard/_Wizard
         * @mixes dojo/Evented
         * @mixes dojo/Stateful
         * @mixes vodori/layout/_Composable
         */
        return provide(module, [Evented, Stateful, _Composable],
            /**
             *
             * @lends vodori/ui/wizard/_Wizard.prototype
             */
            {
                /**
                 * A list of the various actions that can be applied to the Wizard by external entities.
                 * Actions that start with an underscore will not be included in this list.
                 *
                 * @type {Array.<string>}
                 */
                actions: null,

                /**
                 * A list of all of the states that the Wizard can be in.
                 *
                 * @type {Array.<string>}
                 */
                states: null,

                /**
                 * A list of orthogonal stateset definitions.
                 * An orthogonal stateset definition is a group of mutually exclusive states defined by an object
                 * with state names as keys and action mappings as values.
                 * An action mapping is an object that lists the actions that can be taken in a given state and the
                 * resulting state that follows this action.
                 *
                 * @type {Array.<Object.<string, Object.<string,string>>>}
                 */
                stateMachine: null,

                /**
                 * The current state of the wizard.
                 * This cannot be modified directly and should only be changed (internally)
                 * as the result of some action
                 * An exception will be thrown i users attempt to set this manually.
                 * @property {string} state
                 */
                /**
                 * @private
                 * @type {Array.<string>}
                 */
                _state: null,

                /**
                 * An optional ContentPane that can be used by the `_Wizard` to display widgets.
                 * An exception is thrown if users attempt to set this more than once.
                 *
                 * @type {dijit/layout/ContentPane}
                 */
                _contentPane: null,

                /**
                 * The initial state to use when starting the _Wizard, when one isn't provided to the start method.
                 * If initially undefined, it is set to whatever is passed to `start` the first time.
                 * @type {Array.<string>}
                 */
                initialState: null,

                /**
                 * Indicates whether the _Wizard has been started or not.
                 * @private
                 * @type {boolean}
                 */
                _started: false,

                /**
                 * This is the action that should be considered identical to the 'Complete' action
                 * @type {string}
                 */
                completeAlias: '',

                /**
                 * This maps an action to a string of classes.
                 * From a practical standpoint, these are really just expected to be used as CSS classes
                 * on buttons for the actions, but that's up to the user.
                 *
                 * @type Object.<string, string>
                 */
                actionClasses: null,

                /**
                 * List the displayable actions here to specify the order in which they should appear (ex: in the
                 * button set). Unspecified actions will still display, but the order is potentially random.
                 *
                 * @type Array.<string>
                 */
                actionOrder: null,

                /**
                 * @constructs
                 * @param {Object} payload
                 */
                constructor: function (payload) {

                    if (!_.isArray(this.stateMachine)) {
                        this.stateMachine = [this.stateMachine];
                    }
                    this.COMPLETED_STATE = _.times(_.size(this.stateMachine), function () {
                        return 'COMPLETED';
                    });
                    this.CANCELED_STATE = _.times(_.size(this.stateMachine), function () {
                        return 'CANCELED';
                    });

                    /*
                     * Make sure you have read and understood the stateMachine documentation above before trying
                     * to understand this.
                     */
                    this._state = [];
                    this.actionClasses = this.actionClasses || {};

                    /* Broken into a set of temp variables to make debugging simpler */
                    var _actionMappings = _(this.stateMachine).map(_.values).flatten();
                    var _allActions = _actionMappings.map(_.keys).flatten().uniq();
                    this.actions = _allActions.filter(function (action) {
                        return action.indexOf('_') !== 0;
                    }).value();
                    this._arrangeActions();

                    var _allOrthoganalStateValues = _(this.stateMachine).map(_.keys).value();
                    this.states = combine.apply(null, _allOrthoganalStateValues).concat(
                        [this.COMPLETED_STATE],
                        [this.CANCELED_STATE]
                    );

                    if (!this.initialState) {
                        this.initialState = [];
                    }

                    this.payload = payload || {};

                    _.forEach(['contentPane', 'initialState'], function (prop) {
                        if (this.payload[prop]) {
                            this[prop] = this.payload[prop];
                            delete this.payload[prop];
                        }
                    }, this);

                    if (_.isString(this.initialState)) {
                        this.initialState = [this.initialState];
                    }

                    this.watch('contentPane', lang.hitch(this, '_renderStateIfNotNull'));
                },

                _enterState: function(state) {
                    this.enterState(state);
                    this._renderStateIfNotNull();
                },

                _renderStateIfNotNull: function() {
                    var state = this.get('state');
                    var contentPane = this.get('contentPane');
                    if (state && state.length && contentPane) {
                        this.renderState(state, contentPane);
                    }
                },

                /*
                 * This is designed to be overriden to allow implementers to arrange the actions in a specific
                 * order to give callers to get('actions') a hint as to what order they should display actions in.
                 *
                 * The default implementation orders the actions based on the order specified in actionOrder.
                 */
                _arrangeActions: function () {
                    if (this.actions && this.actionOrder) {
                        var orderedActions = [];
                        // Add the actions from actionOrder
                        _.forEach(this.actionOrder, function(action) {
                            if (_.contains(this.actions, action)) {
                                orderedActions.push(action);
                            }
                        }, this);
                        // Add other actions that were not included in actionOrder to the end
                        _.forEach(this.actions, function(action) {
                            if (!_.contains(orderedActions, action)) {
                                orderedActions.push(action);
                            }
                        }, this);
                        this.actions = orderedActions;
                    }
                },

                /**
                 * Setter for 'actions' to prevent direct modification
                 * @private
                 */
                _actionsSetter: function () {
                    throw new UnsupportedMethodCallException('"actions" is read only');
                },
                /**
                 * Setter for 'states' to prevent direct modification
                 * @private
                 */
                _statesSetter: function () {
                    throw new UnsupportedMethodCallException('"states" is read only');
                },

                /**
                 * The ContentPane that the _Wizard can modify. Can only be set once
                 * @property contentPane
                 */
                _contentPaneSetter: function (contentPane) {
                    if (!!this._contentPane) {
                        throw new Error('Cannot set the contentPane of a _Wizard after instantiation');
                    }
                    else {
                        this._contentPane = contentPane;
                    }
                },

                /**
                 *
                 * @return {dijit/ContentPane}
                 * @private
                 */
                _contentPaneGetter: function () {
                    return this._contentPane;
                },

                /**
                 * Perform an action on this `_Wizard`. This will act to change the `_Wizard`'s state.
                 * @param {string} action
                 * @throws vodori/exception/InvalidActionException
                 * @returns {Array.<string>} the new state.
                 */
                performAction: function (action) {
                    if (!this._started) {
                        throw new InvalidActionException('Tried to apply action "' + action + '" to unstarted _Wizard');
                    }
                    var state = /** @type {Array.<string>} */ this._state;
                    /**
                     * If no action is provided, then the state doesn't change at all.
                     */
                    if (!action) {
                        return state;
                    }

                    var newState = null;
                    if (action.toLowerCase() === 'cancel') {
                        newState = this._cancel();
                    }
                    else if ((action.toLowerCase() === 'complete') || (action === this.completeAlias)) {
                        newState = this._complete();
                    }
                    else {
                        /*
                         * Get the action mappings for the current orthogonal states
                         *
                         * What happens here is that we zip the stateMachine together with the current state.
                         * Since `stateMachine` is a list of orthogonal statesets and their actions
                         * and `_state` is a list of orthogonal state values, we end up a series of
                         * stateset/state pairings.
                         * From this, we can determine the actionMappings available in the current _Wizard state.
                         * After that, it's a simple case of using the action to determine
                         * the next state for that stateSet
                         */
                        newState = _(this.stateMachine).zip(this._state).map(function (s) {
                            var stateSet = s[0];
                            var stateValue = s[1];
                            return stateSet[stateValue][action];
                        }).value();
                    }
                    /*
                     * If all of the new substates are null, then it means that we had an invalid action applied
                     */
                    if (!_.any(newState, Boolean)) {
                        throw new InvalidActionException('Attempt to apply action "' + action + '" while in state "' +
                                                         this.getStateName(state) + '"');
                    }
                    else {
                        newState = _.map(newState, function (value, index) {
                            return (_.isUndefined(value) || _.isNull(value)) ? this._state[index] : value;
                        }, this);
                    }

                    this._changeAttrValue('state', newState);
                    this._state = newState;

                    this._enterState(newState);

                    if (_.every(this._state, function(state) { return state === 'COMPLETED'; })) {
                        this.emit('wizardComplete', this.payload);
                    }

                    return this._state;
                },

                /**
                 * Called each time a state is entered. Override or aspect to add behavior at this point.
                 *
                 * @param {Array.<String>} state the new (current) state (never null or empty)
                 */
                enterState: function(state) {
                },

                /**
                 * Update the contentPane to reflect the current state. This is called whenever there is a new state
                 * or a new content pane.
                 *
                 * Override or aspect this to provide an implementation of the rendering for each state.
                 *
                 * @param {Array.<String>} state the new (current) state (never null or empty)
                 * @param {dijit/layout/ContentPane} contentPane the content pane (never null)
                 */
                renderState: function(state, contentPane) {
                },

                /**
                 * Returns the canonical name for a set of orthogonal states
                 * @param {Array.<string>|string} state The orthogonal states
                 * @return {string} A canonical name for these states
                 */
                getStateName: function (state) {
                    if (_.isString(state)) {
                        return state;
                    }
                    else {
                        return state.join(':');
                    }
                },

                /**
                 * Returns information about which actions are visible and enabled for a given state                 *
                 *
                 * @param {string} state
                 * @return {Object.<string, Object>}
                 * @private
                 */
                _enabledActionsGetter: function (state) {
                    var stateActions = {};
                    var publicActions = this.get('actions');
                    _.forEach(this.stateMachine, function (stateSet) {
                        _.forEach(stateSet, function (actions, state) {
                            var actionEnabled = {};
                            _.forEach(actions, function (resultingState, actionName) {
                                if (_.contains(publicActions, actionName)) {
                                    actionEnabled[actionName] = !!resultingState;
                                }
                            });
                            stateActions[state] = actionEnabled;
                        });
                    });
                    return stateActions;
                },

                /**
                 * Check to see if _Wizard is in the provide state
                 * @param {string|Array.<string>} state The state to check for.
                 * @return {boolean} `true` if _Wizard is in provided `state`. Otherwise `false`.
                 *                          If orthogonal states are provided, `true` is returned
                 *                          if _Wizard is in all states.
                 */
                isInState: function (state) {
                    var targetState;
                    if (_.isArray(state)) {
                        targetState = state;
                    } else {
                        targetState = [state];
                    }
                    return _(targetState).difference(this._state).size() === 0;
                },

                /**
                 * The current set of orthogonal states. For example ['a', 'one'].
                 * @returns {Array.<String>}
                 */
                _stateGetter: function () {
                    return this._state;
                },

                _stateSetter: function () {
                    throw new InvalidStateException('Setting the state directly is not allowed. ' +
                                                    'Please use `performAction`');
                },

                /**
                 * The canonical name for the current set of orthogonal states. For example current state ['a', 'one']
                 * would be stateId 'a:one'.
                 * @returns {string}
                 */
                _stateIdGetter: function () {
                    return this.getStateName(this._state);
                },

                _stateIdSetter: function () {
                    throw new InvalidStateException('Setting the state directly is not allowed. ' +
                        'Please use `performAction`');
                },

                /**
                 * @event vodori/ui/wizard/_Wizard#wizardCancel
                 * @type {object}
                 */
                /**
                 * Called to indicate that the Wizard has been cancelled. Any internal state will be thrown away as well
                 * as any data that has been collected by the Wizard.
                 * @param {string} [reason] The reason for cancelling the _Wizard
                 * @returns {Array.<string>} The 'CANCELED' state.
                 * @fires vodori/ui/wizard/_Wizard#wizardCancel
                 */
                cancel: function (reason) {
                    this._cancelationReason = reason || '';
                    return this.performAction('cancel');
                },
                _cancel: function () {
                    this.emit('wizardCancel', this._cancelationReason);
                    return this.CANCELED_STATE;
                },

                /**
                 * @event vodori/ui/wizard/_Wizard#wizardComplete
                 * @type {object}
                 */
                /**
                 * Called to indicate that the Wizard has 'successfully' completed. What constitutes 'success' is user
                 * specific.
                 * @returns {Array.<string>} The 'COMPLETED' state.
                 * @fires vodori/ui/wizard/_Wizard#wizardComplete
                 */
                complete: function () {
                    return this.performAction('complete');
                },
                _complete: function () {
                    return this.COMPLETED_STATE;
                },

                /**
                 * Starts the _Wizard state machine
                 *
                 * @param {Array.<string>|string} state The initial state of the _Wizard.
                 */
                start: function (state) {
                    var newState;
                    if (this._started) {
                        console.warn('Trying to start a _Wizard that is already started');
                    }
                    if (_.isUndefined(state)) {
                        newState = this.initialState;
                    }
                    else if (!_.isArray(state)) {
                        newState = state.split(':');
                    } else {
                        newState = /** @type {Array.<string>} */ state;
                    }
                    this._started = true;
                    if (!this.initialState) {
                        this.initialState = newState;
                    }
                    this._changeAttrValue('state', newState);
                    this._state = newState;

                    this._enterState(newState);
                    return this._state;
                },

                /**
                 * @{inheritDoc}
                 * @param name
                 * @param callback
                 * @return {*}
                 */
                watch: function (name, callback) {
                    if (name !== 'state') {
                        return this.inherited(arguments);
                    }
                    else {
                        return this.inherited(arguments, ['state', lang.hitch(this, function (__, ___, newValue) {
                            return callback(__, this._state, newValue);
                        })]);
                    }
                }
            });
    }
);

},
'vodori/util/collections/combine':function(){
/**
 * @module vodori/util/collections/combine
 *
 */
define([
    'lodash',
    'dojo/_base/lang'
], function (
    _,
    lang
    ) {
    'use strict';

    /*
     * Add an item to a list and then push that list onto a stack
     */
    var _addItemToStack = function (stack, list, item) {
        stack.push(list.concat(item));
    };

    /**
     * Takes any number of arrays and returns combinations of their elements
     *
     * @name vodori/util/collections/combine
     * @function
     *
     * @return {Array.<Array>}
     */
    /*
     * This may not be the most performance optimized version, but it works.
     *
     * We set up two FILO stacks (stack1 and stack2) and then iterate through the incoming arrays.
     * For each array, we go through values in stack1, and populate stack2 with a series of lists,
     * each of which is the combination of the stack1 value and each of the values in the current
     * array.
     * Then, we swap stack1 and 2 and start again.
     *
     * On each pass, we're draining stack1 and filling stack2. Then swap and repeat.
     *
     * NB Attempted a recursive version.
     * It was a little bit faster in FF and a little bit slower in Chrome.
     * Leaving this as a stack-based implementation for now
     */
    function combine() {
        var arrays = _.toArray(arguments);
        var stack1 = [ [] ],
            stack2 = [];
        _.forEach(arrays, function (array) {
            if (_.isNull(array) || _.isUndefined(array)) {
                array = [];
            }
            do {
                var head = stack1.shift();
                if (array.length > 0) {
                    _.forEach(array, lang.partial(_addItemToStack,stack2,head));
                }
                else {
                    stack2.push(head);
                }
            } while (stack1.length > 0);
            var tmp = stack2;
            stack2 = stack1;
            stack1 = tmp;
        });
        return stack1;
    }

    return combine;
});
},
'vodori/layout/_Composable':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/on', 'dojo/_base/lang'
], function (module, provide, _, on, lang) {
    var prototype = {
        /**
         * @type {string}
         * @const
         */
        COMPOSE_EVENT: 'compose',

        /**
         * Indicates to an enclosing widget whether this widget should fill maximum available
         * height.
         *
         * @type {Boolean}
         */
        shouldFillContainer: false,

        /**
         * The emitter to call against the widget.
         *
         * @type {Function}
         */
        _widgetEmitter: null,

        _eventTemplate: {
            bubbles: true,
            cancelable: true
        },

        /**
         * Fires the compose event, mixing in arbitrary properties.
         *
         * @param {Object} [event={}]
         */
        fireCompose: function (event) {
            // Overwrite the _eventTemplate, so we have defaulting, but clone it to prevent object
            // sharing.
            var collapsedEvent = _.extend(_.clone(this._eventTemplate, true), event);

            if (!this._widgetEmitter) {
                this._widgetEmitter = this._getEmitter();
            }

            this._widgetEmitter(collapsedEvent);
        },

        /**
         * @param {Object.<*>} event Simulates the compose event for those using non-evented widgets.
         */
        onCompose: function (event) {
        },

        /**
         * Wrapped in a factory to support non-Evented widgets.
         *
         * @private
         */
        _getEmitter: function () {
            this._widgetEmitter = _.isFunction(this.emit) ? lang.hitch(this, 'emit', this.COMPOSE_EVENT)
                                :                           lang.hitch(this, 'onCompose');
            return this._widgetEmitter;
        }
    };

    /**
     * Simplifies interaction w/ ./Composing by pre-fabing a _WidgetBase compatible emitter.
     */
    return provide(module, null, prototype);
});

},
'vodori/exceptions/UnsupportedMethodCallException':function(){
define([
    'module',
    'vodori/provide',
    'vodori/exceptions/_VodoriException'
],
    function (module, provide, _VodoriException) {
        /**
         * @class vodori/exceptions/UnsupportedMethodCallException
         */
        return provide(module, [_VodoriException],
            /**
             * @lends vodori/exceptions/UnsupportedMethodCallException.prototype
             */
            {
                /**
                 * @type {string}
                 */
                name: 'UnsupportedMethodCallException'
            });
    }
);

},
'vodori/exceptions/_VodoriException':function(){
define([
    'module',
    'vodori/provide'
],
    function (module, provide) {
        /**
         * The purpose of this module is to be an abstract class inheriting from the base JavaScript Error object.
         * Custom exceptions can then inherit from this object, providing their own name and nothing else.
         * @class vodori/exception/_VodoriException
         */
        return provide(module, [Error],
            /**
             *
             * @lends vodori/exception/_VodoriException.prototype
             */
            {
                /**
                 * Should be overridden by the message passed in via the constructor
                 * @type {string}
                 */
                message: 'An exception occurred',

                /**
                 * Should be overridden in subclass!
                 * @type {string}
                 */
                name: '_VodoriException',

                /**
                 * @ignore
                 */
                constructor: function (message) {
                    this.message = message;
                    this.stack = new Error(this.toString()).stack;
                }
            });
    }
);

},
'vodori/exceptions/InvalidActionException':function(){
define([
    'module',
    'vodori/provide',
    'vodori/exceptions/_VodoriException'
],
    function (module, provide, _VodoriException) {
        /**
         * @class vodori/exception/InvalidActionException
         */
        return provide(module, [_VodoriException],
            /**
             * @lends vodori/exception/InvalidActionException.prototype
             */
            {
                /**
                 * @type {string}
                 */
                name: 'InvalidActionException'
            });
    }
);

},
'vodori/exceptions/InvalidStateException':function(){
define([
    'module',
    'vodori/provide',
    'vodori/exceptions/_VodoriException'
],
    function (module, provide, _VodoriException) {
        /**
         * @class vodori/exception/InvalidStateException
         */
        return provide(module, [_VodoriException],
            /**
             * @lends vodori/exception/InvalidStateException.prototype
             */
            {
                /**
                 * @type {string}
                 */
                name: 'InvalidStateException'
            });
    }
);

},
'vodori/util/string/isBlank':function(){
define(function () {
    /**
     * Return true if the string is empty or contains only whitespace.
     *
     * @param {string} str
     * @return {boolean}
     */
    return function (str) {
        if (!str) {
            return true;
        } else {
            return !str.match(/\S/);
        }
    };
});
},
'pepper/dialogs/distribute/AssetsDisplay':function(){
define(['module', 'vodori/provide',
        'dojo/_base/lang',
        'dojo/dom-attr', 'dojo/dom-class', 'dojo/dom-construct',
        'dojo/query', 'dojo/on',
        'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
        'dijit/registry',
        'vodori/input/CheckBox', 'vodori/renderTemplate',
            'dojo/text!./templates/AssetsDisplay.html',
            'dojox/NodeList/delegate'
], function(module, provide,
            lang,
            domAttr, domClass, domConstruct,
            query, on,
            _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
            registry,
            CheckBox, renderTemplate,
                template) {
    /**
     * This widget is intended for use with the distribution wizard
     * dialog; it is responsible for display of assets in an
     * asset/linked asset hierarchy with show/hide capabilities.
     */
    return provide(module, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {

        ASSET_ITEM_CLASS: 'top-level-asset',

        HIDE_LINKED_ASSETS_CLASS: 'hide-linked-assets',

        SHOW_LINKED_ASSETS_CLASS: 'show-linked-assets',

        HIDE_SPECIFIC_ASSET_LINKS_CLASS: 'hide-associated-linked',

        /**
         * The number of unique assets, not including linked static assets.
         * Should be passed in declaratively.
         *
         * @type {number}
         */
        assetsCountWithoutLinks: 0,

        /**
         * The number of unique assets, including linked static assets.
         * Should be passed in declaratively.
         *
         * @type {number}
         */
        assetsCountWithLinks: 0,

        /**
         * The set of objects to render into the template.
         * Should be passed in declaratively.
         * a JSON serialization of asset descriptions
         *
         * @type {string}
         */
        serializedObjects: null,

        showLinkedAssets: true,

        enableToggler: false,

        templateString: template,

        buildRendering: function() {

            this.templateString = renderTemplate(template,
                                    lang.mixin(this.serializedObjects, {enableToggler: this.enableToggler }));


            this.inherited(arguments);

            query(this.assetsList).delegate('.' + this.ASSET_ITEM_CLASS, 'click', lang.hitch(this, function(e) {
                domClass.toggle(e.target, this.HIDE_SPECIFIC_ASSET_LINKS_CLASS);
            }));

            if (this.togglerNode) {
                this.togglerNode.on('change', lang.hitch(this, 'setLinkedVisibility'));
            }

            this.setLinkedVisibility(this.showLinkedAssets);
        },

        setLinkedVisibility: function(showLinked) {
            if (showLinked) {
                this.displayLinkedAssets();
            } else {
                this.hideLinkedAssets();
            }
        },

        hideLinkedAssets: function() {
            domClass.remove(this.domNode, this.SHOW_LINKED_ASSETS_CLASS);
            domClass.add(this.domNode, this.HIDE_LINKED_ASSETS_CLASS);
            domAttr.set(this.assetsCount, 'innerHTML', this.assetsCountWithoutLinks);
        },

        displayLinkedAssets: function() {
            domClass.remove(this.domNode, this.HIDE_LINKED_ASSETS_CLASS);
            domClass.add(this.domNode, this.SHOW_LINKED_ASSETS_CLASS);
            domAttr.set(this.assetsCount, 'innerHTML', this.assetsCountWithLinks);
        }
    });
});
},
'vodori/input/CheckBox':function(){
define([
    'vodori/provide', 'module',
    'dojo/_base/kernel',
    'dijit/form/CheckBox'
], function(provide, module,
            kernel,
            CheckBox) {

    kernel.deprecated('vodori/input/CheckBox', 'No longer needed, please use native dijit/form/CheckBox.');

    return provide(module, [CheckBox]);
});

},
'dojox/NodeList/delegate':function(){
define([
	"dojo/_base/lang",
	"dojo/query",
	"dojo/_base/NodeList",	// for this.connect()
	"dojo/NodeList-traverse"
], function(lang, query) {

// module:
//		dojox/NodeList/delegate

var NodeList = query.NodeList;

lang.extend(NodeList, {
	delegate: function(/*String*/ selector, /*String*/ eventName, /*Function*/ fn){
		// summary:
		//		Monitor nodes in this NodeList for [bubbled] events on nodes that match selector.
		//		Calls fn(evt) for those events, where (inside of fn()), this == the node
		//		that matches the selector.
		// description:
		//		Sets up event handlers that can catch events on any subnodes matching a given selector,
		//		including nodes created after delegate() has been called.
		//
		//		This allows an app to setup a single event handler on a high level node, rather than many
		//		event handlers on subnodes. For example, one onclick handler for a Tree widget, rather than separate
		//		handlers for each node in the tree.
		//		Since setting up many event handlers is expensive, this can increase performance.
		//
		//		Note that delegate() will not work for events that don't bubble, like focus.
		//		onmouseenter/onmouseleave also don't currently work.
		// selector:
		//		CSS selector valid to `dojo.query`, like ".foo" or "div > span".  The
		//		selector is relative to the nodes in this NodeList, not the document root.
		//		For example myNodeList.delegate("> a", "onclick", ...) will catch events on
		//		anchor nodes which are (immediate) children of the nodes in myNodeList.
		// eventName:
		//		Standard event name used as an argument to `dojo.connect`, like "onclick".
		// fn:
		//		Callback function passed the event object, and where this == the node that matches the selector.
		//		That means that for example, after setting up a handler via
		// |		 dojo.query("body").delegate("fieldset", "onclick", ...)
		//		clicking on a fieldset or *any nodes inside of a fieldset* will be reported
		//		as a click on the fieldset itself.
		// example:
		//	|	dojo.query("navbar").delegate("a", "onclick", function(evt){
		//	|			console.log("user clicked anchor ", this.node);
		//	|	});

		// Possible future tasks:
		//	- change signature of callback to be fn(node, evt), and then have scope argument
		//		to delegate(selector, eventName, scope, fn)?
		//	- support non-bubbling events like focus
		//	- support onmouseenter/onmouseleave
		// 	- maybe should return an array of connect handles instead, to allow undelegate()?
		//	- single node version

		return this.connect(eventName, function(evt){
			var closest = query(evt.target).closest(selector, this);
			if(closest.length){
				fn.call(closest[0], evt);
			}
		}); //dojo/NodeList
	}
});

return NodeList;
});

},
'pepper/utilities/channels':function(){
/**
 * @module pepper/utilities/channels
 */
define([
    'module', 'vodori/provide', 'lodash',
    'vodori/util/data/getSorter'
], function (module, provide, _, getSorter) {

    /**
     * @lends module:pepper/utilities/channels#
     */
    var channels = {

        sorter: getSorter({attribute: 'name', ignoreCase: true}),

        /**
         * @typedef NetworkObject
         * @type {object}
         * @property {string} name Name of network
         * @property {Array} channels The channels in that network
         */

        /**
         * Takes an array of channel objects and converts it to an array of network objects each having an array of all
         * the channels within it. Networks and Channels will be sorted alphabetically.
         *
         * @param {Array} channels
         * @returns {NetworkObject[]}
         */
        organizeByNetwork: function(channels) {
            var networksMap = {};
            var networksList = [];
            var sorter = this.sorter;

            _.forEach(channels, function(channel) {
                var network = networksMap[channel.network.id];
                if (!network) {
                    network = {
                        name: channel.network.name,
                        channels: []
                    };
                    networksMap[channel.network.id] = network;
                    networksList.push(network);
                }
                network.channels.push(channel);
            });

            networksList.sort(sorter);
            _.forEach(networksList, function(network) {
                network.channels.sort(sorter);
            });

            return networksList;
        }
    };

    return provide(module, channels);
});

},
'vodori/util/data/getSorter':function(){
/**
 * @module vodori/util/data/getSorter
 */
define(['lodash',
        'dojo/_base/lang'
], function (_,
            lang) {

    function _getValue(value, sort) {
        if (_.isNull(value) || _.isUndefined(value)) {
            return value;
        }

        if (sort.attribute) {
            value = lang.getObject(sort.attribute, false, value);
        }

        if (!_.isNull(value) && !_.isUndefined(value)) {
            value = value.valueOf();
        }

        var transformer = sort.transformer;
        if (_.isFunction(transformer)) {
            value = transformer(value);
        }

        if (sort.ignoreCase && !_.isNull(value) && !_.isUndefined(value)) {
            value = value.toString().toLowerCase();
        }

        return value;
    }

    /**
     * @callback comparatorFunction
     * @param a {*} a value
     * @param b {*} another value
     * @returns {number} The value -1, 0 or 1 to indicate that `a` is less than, the same as or greater than `b`
     *                   respectively
     */

    /**
     * Generate a comparator function that will sort according to the same kind of map collection accepted by
     * Dojo store queries, e.g.
     *
     *   [{attribute: 'foo', descending: false}, {attribute: 'bar', descending: true}]
     *
     * The generated comparison function is nearly identical to the one in dojo/store/util/SimpleQueryEngine, with these
     * differences:
     * - You can specify an additional attribute B that must be true of both objects to even attempt a comparison on A
     * - You can specify sort attributes nested to an arbitrary depth
     * - You can specify a transformer function to be applied before the comparison is attempted
     * - You can specify that the sort should ignore case
     *
     * Examples:
     * 1. Sort descending by city name but only compare two items if they both have the property US === true
     *
     *     ```
     *     [{attribute: 'location.city', descending: true, required: 'location.us' }]
     *     ```
     *
     * 2. Sort ascending by time and ensure that the time is parsed before comparison
     *
     *      ```
     *     [{attribute: 'eventTime', descending: false,
     *       transformer: function(eventDateStr) { return Date.parse(eventDateStr); }}]
     *      ```
     *
     * 3. Sort ascending by reversed name, then descending by city
     *
     *      ```
     *      [{attribute: 'some.deeply.nested.name', descending: false,
     *        transformer: function(name) { return name.split('').reverse().join(); } },
     *       {attribute: 'city', descending: true}]
     *      ```
     *
     * 4. Sort by name, ignoring case
     *
     *      ```
     *      [{attribute: name, ignoreCase: true}]
     *      ```
     *
     * 5. Sort on array elements themselves, ignoring case
     *
     *      ```
     *      ['b', 'C', 'a'].sort(getSorter({ignoreCase: true}));
     *      ```
     *
     * If you only want to sort on a single attribute and not a series of attributes, you can simply pass in an
     * object. Otherwise, the function should receive an array of attribute sort descriptors to be applied in order.
     *
     * @name vodori/util/data/getSorter
     * @function
     *
     * @param {Object | Array<Object>} description of attributes and other options to sort on
     * @return {comparatorFunction} a comparator function
     */
    return function (sortSet) {
        sortSet = _.isArray(sortSet) ? sortSet : [sortSet];
        return function(a, b) {
            for(var sort, i=0; i < sortSet.length; i++){
                sort = sortSet[i];
                var requiredAttr = sort.required;
                if (requiredAttr &&
                    (!lang.getObject(requiredAttr, false, a) || !lang.getObject(requiredAttr, false, b))) {
                    continue;
                }

                var aValue = _getValue(a, sort);
                var bValue = _getValue(b, sort);


                if (aValue != bValue) { // jshint ignore:line
                    var comparison = 0;
                    if (_.isNull(aValue) || _.isUndefined(aValue)) {
                        comparison = 1;
                    } else if (_.isNull(bValue) || _.isUndefined(bValue)) {
                        comparison = -1;
                    } else {
                        comparison = aValue < bValue ? -1 : 1;
                    }

                    return (sort.descending === true) ? -comparison : comparison;
                }
            }
            return 0;
        };
    };
});
},
'vodori/input/GroupedSelect':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/declare', 'dojo/_base/lang',
    'dojo/dom-class', 'dojo/dom-construct', 'dojo/dom-attr', 'dojo/dom-style',
    'dojo/on', 'dojo/string', 'dojo/when', 'dojo/query',
    'dojo/store/Memory', 'dojo/store/Observable',
    'dojo/Evented',
    'dijit/_Container', 'dijit/_WidgetBase',
    'dijit/form/CheckBox', 'dijit/form/RadioButton'
], function (module, provide,
             _,
             declare, lang,
             domClass, domConstruct, domAttr, domStyle,
             on, string, when, query,
             Memory, Observable,
             Evented,
             _Container, _WidgetBase,
             CheckBox, RadioButton) {

    /**
     * Encapsulates a selector widget and an optional label fragment.
     *
     * @mixes dijit/_WidgetBase
     * @mixes dijit/_Container
     */
    var _GroupedSelectItem = declare([_WidgetBase, _Container], {

        /**
         * The constructor for the input widget.
         * Either dijit/form/CheckBox, or dijit/form/RadioButton,
         * depending on whether or not parent GroupedSelect is in multiple mode.
         * @private
         * @type {function}
         */
        _inputControlConstructor: null,

        /**
         * The base CSS class for this widget.
         * @type {string}
         */
        baseClass: 'groupedSelectItem',

        /**
         * The child input widget instance.
         * @type {Object}
         */
        inputControl: null,

        /**
         * An optional template to use for generating this widget's label.
         * @type {string}
         */
        labelTemplate: null,

        /**
         * The name applied to the generated input element.
         * @type {string}
         */
        name: '',

        /**
         * The backing data object used to generate the this widget's elements.
         * @type {Object}
         */
        option: null,

        show: function() {
            domStyle.set(this.domNode, 'display', '');
        },

        hide: function() {
            domStyle.set(this.domNode, 'display', 'none');
        },

        postMixInProperties: function () {
            this.inherited(arguments);

            var name = this.name,
                option = this.option,
                inputControlParameters = {
                    value: option.value
                };

            if (option.selected) {
                inputControlParameters.checked = true;
            }

            if (name) {
                inputControlParameters.name = name;
            }

            this.inputControl = new this._inputControlConstructor(inputControlParameters);
        },

        postCreate: function () {
            this.inherited(arguments);

            /*
             * Add input widget.
             * We'll need to bootstrap it's appropriate style if it has a checked value to begin with.
             * We'll also need to proxy clicks to the overall widget down to this input widget.
             * We'll also need to make sure the input widget's checked state is always in line with the
             * appropriate style for the overall widget.
             */
            var inputControl = this.inputControl,
                baseClass = this.baseClass,
                domNode = this.domNode,
                labelTemplate = this.labelTemplate;

            if (inputControl.get('value')) {
                domClass.add(domNode, baseClass + 'Focused');
            }
            if (this.option.disabled) {
                this.set('disabled', true);
            }

            this.own(inputControl.watch('checked', function (property, oldValue, value) {
                domClass.toggle(domNode, baseClass + 'Focused', value);
            }));

            this.addChild(inputControl);

            /*
             * Generate label, with precedence placed on the existance of labelTemplate.
             * If just a string label is specified, we'll generate it as a standard label element.
             */
            if (labelTemplate) {
                var labelNode = domConstruct.create('span', {
                    'class': 'groupedSelectItemLabel'
                }, domNode);
                domConstruct.place(string.substitute(labelTemplate, this.option), labelNode);
                this.own(on(labelNode, 'click', lang.hitch(this, 'toggleSelected')));
            } else {
                var label = this.option.label;

                if (label) {
                    var labelProperties = {
                            innerHTML: label,
                            'class': 'groupedSelectItemLabel',
                            'for': this.inputControl.get('id')
                        };

                    domConstruct.create('label', labelProperties, domNode);
                }
            }
        },

        toggleSelected: function() {
            if(!this.get('disabled')) {
                this.inputControl.set('checked', !this.inputControl.get('checked'));
            }
        },

        _getValueAttr: function () {
            return this.inputControl.get('value'); // Just proxy through to the underlying input widget
        },

        _setValueAttr: function (value) {
            if(!this.get('disabled')) {
                this.inputControl.set('value', value); // Just proxy through to the underlying input widget
            }
        },

        _getDisabledAttr: function () {
            return this.inputControl.get('disabled');
        },

        _setDisabledAttr: function (value) {
            this.inputControl.set('disabled', value);
            domClass.toggle(this.domNode, this.baseClass + 'Disabled', value);
        }
    });

    /**
     * Contains a collection of _GroupedSelectItem widgets.
     *
     * Each _GroupedSelectItem will in turn contain either a dijit/form/RadioButton or a dijit/form/CheckBox,
     * depending on the value of this widget's 'multiple' attribute.
     *
     * All _GroupedSelectItem widgets encapsulated here will have the same name, and so be treated as a group.
     * Underlying data can be supplied in the form of a dojo/store/Memory store (with support for
     * dojo/store/Observable), or alternatively a store will be internally created as a convenience for data passed in
     * as a parameter called 'options' (see '_setOptionsAttr').
     *
     * Important: You should always ensure that each GroupedSelect is contained within an HTML form element, otherwise
     * operations performed on one GroupSelect may impact other GroupSelects in the DOM with the same name.
     *
     * @mixes dijit/_WidgetBase
     * @mixes dijit/_Container
     * @mixes dojo/Evented
     */
    return provide(module, [_WidgetBase, _Container, Evented], {
        /**
         * A hash of each _GroupedSelectItem widget by its underlying input element value.
         * @private
         * @type {Object}
         */
        _groupedSelectItemsByValue: null,

        /**
         * The observer associated with rendering observable results.
         * For cleanup purposes.
         * @type {Object}
         */
        _observer: null,

        /**
         * An observable memory store containing this widget's underlying data set.
         * @private
         * @type {Object}
         */
        _store: null,

        /**
         * The base CSS class for this widget.
         * @type {string}
         */
        baseClass: 'vodoriGroupedSelect',

        /**
         * If true and no items are selected, this widget's value will be empty string.
         * @type {boolean}
         */
        forceValue: false,

        /**
         * A flag to include\exclude disabled but selected items in this widget's reported value.
         * @type {boolean}
         */
        includeDisabled: false,

        /**
         * An optional template to use for generating the label of a _GroupedSelectItem.
         * @type {string}
         */
        labelTemplate: null,

        /**
         * A flag to allow for multiple or single selections within this widget.
         * true means that this widget will render dijit/form/CheckBox.
         * false means that this widget will render dijit/form/RadioButton.
         * @type {boolean}
         */
        multiple: false,

        /**
         * name of the widget to be submitted with a form.
         * @type {string}
         */
        name: '',

        constructor: function (args, sourceNode) {
            this._groupedSelectItemsByValue = {};
            if (sourceNode) {
                this._fillInDataFromSourceNode(args, sourceNode);
            }
        },

        _fillInDataFromSourceNode: function(args, sourceNode) {
            if (!args.options) {
                var options = this._getOptionsFromSourceNode(sourceNode);
                if (options.length > 0) {
                    args.options = options;
                }
            }
        },

        _getOptionsFromSourceNode: function(sourceNode) {
            var options = [];
            _.forEach(query('option', sourceNode), function(option) {
                options.push(this._getOptionFromOptionNode(option));
            }, this);
            return options;
        },

        _getOptionFromOptionNode: function(option) {
            return {
                value: domAttr.get(option, 'value'),
                label: option.innerHTML,
                selected: Boolean(domAttr.has(option, 'selected')),
                disabled: Boolean(domAttr.has(option, 'disabled'))
            };
        },

        buildRendering: function() {
            this.domNode = domConstruct.create('div');
            this.inherited(arguments);
        },

        /**
         * Adds an option to this widget's store, which will result in the rendering of a _GroupedSelectItem.
         * @param  {Object} option An object containing all necessary information to generate a _GroupedSelectItem.
         *                         If this param's 'value' is undefined, a horizontal rule will be generated.
         */
        addOption: function (option) {
            if (typeof option.value === 'undefined') {
                domConstruct.create('hr', {
                    'class': 'checked-select-separator'
                }, this.domNode);
            } else {
                this._createStore().put(option);
            }
        },

        /**
         * Removes an option from this widget's store, which will result in the destruction of the
         * corresponding _GroupedSelectItem.
         * @param  {Object} option An object with a value matching that of an existing _GroupedSelectItem.
         */
        removeOption: function (option) {
            var store = this.get('store');

            store.remove(option[store.idProperty]);
        },

        /**
         * Proxies through to this widget's store to allow for filtering of displayed items.
         * @param  {Object} query Some query object digestable by dojo/store.query().
         * @return {Array.<Object>} The query results.
         */
        filter: function (query) {
            return this._renderResults(this.get('store').query(query));
        },

        /**
         * Handles generation of the _GroupedSelectItem itself.
         * @private
         * @param  {Object} option An object containing all necessary information to generate a _GroupedSelectItem.
         */
        _createGroupedSelectItem: function (option) {
            if(!this._groupedSelectItemsByValue[option.value]) {
                /* jshint -W055 */
                var groupedSelectItem = new _GroupedSelectItem({
                    option: option,
                    labelTemplate: this.labelTemplate,
                    name: this.name,
                    disabled: this.disabled,
                    _inputControlConstructor: this.multiple ? CheckBox : RadioButton
                });
                /* jshint +W055 */

                /*
                 * Broadcast changes from the underlying input widget.
                 */
                groupedSelectItem.inputControl.on('change', lang.hitch(this, function () {
                    this.emit('change', this.get('value'));
                }));

                this._groupedSelectItemsByValue[option.value] = groupedSelectItem;

                this.addChild(groupedSelectItem);

                if (option.selected) {
                    this.emit('change', this.get('value'));
                }
            } else {
                this._groupedSelectItemsByValue[option.value].show();
            }
        },

        /**
         * Handles destruction of a _GroupedSelectItem.
         * @private
         * @param  {Object} option An object with a value matching that of an existing _GroupedSelectItem.
         */
        _destroyGroupedSelectItem: function (option) {
            var value = option.value,
                groupedSelectItem = this._groupedSelectItemsByValue[value];

            if (groupedSelectItem) {
                this.removeChild(groupedSelectItem);

                groupedSelectItem.destroyRecursive();

                delete this._groupedSelectItemsByValue[value];
            }
        },

        /**
         * Creates this widget's store from a collection of options.
         * @private
         * @param  {Array.<Object>} options The data collection with which to populate the store.
         * @param  {boolean} force          Force the creation of a new store even if one already exists.
         * @return {Object} The store.
         */
        _createStore: function (options, force) {
            if (!this.get('store') || force) {
                this.set('store', new Observable(new Memory({
                    idProperty: 'value',
                    data: options
                })));
            } else {
                console.warn('GroupedSelect already has a store, skipping new store creation...');
            }

            return this.get('store');
        },

        _renderResults: function (results) {
            var observe = results.observe;

            this._hideAllGroupedSelectItems();

            return when(results, lang.hitch(this, function (options) {
                _.forEach(options, lang.hitch(this, '_createGroupedSelectItem'));

                if (observe) {
                    var observer = this._observer;

                    if (observer) {
                        observer.cancel();
                    }

                    this._observer = observe(lang.hitch(this, function (object, deletedFrom, insertedInto) {
                        if (deletedFrom > -1 || deletedFrom === insertedInto) {
                            this._destroyGroupedSelectItem(object);
                        }

                        if (insertedInto > -1) {
                            this._createGroupedSelectItem(object);
                        }
                    }), true);
                }
            }));
        },

        /**
         * Convenience for internally creating a store based on supplied data.
         * @private
         * @param  {Array.<Object>} options The underlying data collection.
         */
        _setOptionsAttr: function (options) {
            this._createStore(options, true);
        },

        _getStoreAttr: function () {
            return this._store;
        },

        _setStoreAttr: function (store) {
            this._store = store;

            this._renderResults(store.query());
        },

        /**
         * Returns a single arbitrary value, if > 0 values are selected.
         * @private
         * @return {string}
         */
        _getSingleValueAttr: function () {
            var singleValue,
                includeDisabled = this.includeDisabled;

            _.forEach(this.getItems(), function (child) {
                var value = child.inputControl.get('value');

                if (value && (includeDisabled || !child.get('disabled'))) {
                    singleValue = value;

                    return false;
                }
            });

            if (this.forceValue && !singleValue) {
                singleValue = '';
            }

            return singleValue;
        },

        /**
         * Returns an Array of values based on each checked input element.
         * @private
         * @return {Array.<string>}
         */
        _getValueAttr: function () {
            if (!this.multiple) {
                console.warn('Calling multi-value getter on non-multiple instance of GroupedSelect.' +
                             'May want to use get(\'singleValue\')!');
            }

            var values = [],
                includeDisabled = this.includeDisabled;

            _.forEach(this.getItems(), function (child) {
                var value = child.inputControl.get('value');

                if (value && (includeDisabled || !child.get('disabled'))) {
                    values.push(value);
                }
            });

            if (this.forceValue && values.length === 0) {
                values.push('');
            }

            return values;
        },

        /**
         * Checks each input element appropriately.
         * @private
         * @param {Array.<string>|string} value A falsey value\empty array to uncheck everything,
         *                                      or a single value, or an array of values.
         */
        _setValueAttr: function (value) {
            // first deselect all children, then select only the value(s) specified
            this._deselectChildren();

            if(!value) {
                value = [];
            }

            if (!_.isArray(value)) {
                value = [ value ];
            }

            _.forEach(value, lang.hitch(this, function(singleValue) {
                var child = this._groupedSelectItemsByValue[singleValue];

                if (child) {
                    child.set('value', true);
                }
            }));
        },

        _deselectChildren: function() {
            _.forEach(this.getItems(), function (child) {
                var currentValue = child.get('value');
                if (currentValue) {
                    child.set('value', false);
                }
            });
        },

        _setDisabledAttr: function (value) {
            this.disabled = value;
            _.forEach(this.getItems(), function(item) {
                item.set('disabled', value);
            });
        },

        /**
         * Get all of the individual select items (representing checkboxes or radios) that make up this widget.
         * @returns {Array.<_GroupedSelectItem>}
         */
        getItems: function() {
            return _.filter(this.getChildren(), function(child) {
                return child.isInstanceOf(_GroupedSelectItem);
            });
        },

        _hideAllGroupedSelectItems: function() {
            _.forEach(this._groupedSelectItemsByValue, function (child) {
                child.hide();
            });
        }
    });
});

},
'pepper/commands/actions/edit':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'pepper/services',
    'pepper/utilities'
], function (provide, module, _, lang, services, utilities) {
    return provide(module.id, function (objects) {
        return services.edit({
            params: {
                objects: utilities.createPayload(objects)
            }
        }).then(lang.hitch(this, function (response) {
                var results = response.results;
                _.forEach(results, function (result) {
                    console.log('Edit', result.objectId);
                });
            }));
    });
});

},
'pepper/commands/actions/expire':function(){
define([
    'vodori/provide',
    'module',
    'pepper/data/PostDescriptorStore'
], function (provide, module, postDescriptorStore) {
    return provide(module.id, function (objects) {

        var servicePromise = postDescriptorStore.expire(objects);

        return servicePromise;
    });
});

},
'pepper/commands/actions/expressPromote':function(){
define([
    'vodori/provide',
    'module',
    'pepper/data/PostDescriptorStore'
], function (provide, module, postDescriptorStore) {
    return provide(module.id, function (objects) {

        var servicePromise = postDescriptorStore.expressPromote(objects);

        return servicePromise;

    });
});

},
'pepper/commands/actions/moveNavigationElement':function(){
define([
    'vodori/provide',
    'module',
    'pepper/services',
    'pepper/utilities'
], function (provide, module, services, utilities) {

    return provide(module.id, function (sourceObjectIds, parentElementId) {
        return services.moveNavigationElement({
            params: {
                objects: utilities.createPayload(sourceObjectIds),
                parentElementId: parentElementId
            }
        });
    });
});

},
'pepper/commands/actions/moveTo':function(){
define([
    'vodori/provide',
    'module',
    'pepper/data/PostDescriptorStore'
], function (provide, module, PostDescriptorStore) {

    return provide(module.id, function (sourceObjectIds, targetObjectId, parentRowId) {
        return PostDescriptorStore.moveTo(sourceObjectIds, targetObjectId, parentRowId);
    });
});

},
'pepper/commands/actions/open':function(){
define([
    'vodori/provide', 'module',
    'lodash'
], function (provide, module, _) {
    /**
     * Open the 1st object supplied in author mode
     *
     * @param objects   an array of page objects
     * @param external  whether to open in a new window or not
     */
    return provide(module.id, function (/* Array */ objects, /* Boolean */ external) {
        if (!_.isArray(objects)) {
            objects = [objects];
        }
        var url = objects[0].authorUrl;
        if (url) {
            if (external) {
                // Open in new window
                window.open(url, '_blank');
            } else {
                // Open in this window
                document.location.href = url;
            }
        }
    });
});

},
'pepper/commands/actions/openInLibrary':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/topic', 'dojo/when',
    'pepper/events',
    'pepper/data/PostDescriptorStore',
    'pepper/commands/dialogs/showLibrary'
], function (module, provide, _, topic, when, events, postDescriptorStore, showLibrary) {

    var openLibraryWithObjectPath = function (objectPath) {
        showLibrary({query:{search:objectPath}});
    };

    /**
     * Opens a single object in the library using the object's objectId
     */
    return provide(module.id, function (object) {

        // Default is the current page
        var objectId = postDescriptorStore.getCurrentPageObjectId();
        var objectPath = null;

        // Fetch the object to display
        if (_.has(object, 'objectId')) {
            objectId = object.objectId;
            objectPath = object.path;
        }
        else if (_.isArray(object)) {
            objectId = object[0].objectId;
            objectPath = object[0].path;
        }

        if (objectPath) {
            openLibraryWithObjectPath(objectPath);
        } else if (objectId) {
            when(postDescriptorStore.get(objectId), function (obj) {
                openLibraryWithObjectPath(obj.path);
            });
        } else {
            console.log('"Open In Library" called with no object.');
        }

    });
});

},
'pepper/commands/dialogs/showLibrary':function(){
/**
 * This command opens the library with a specific channel
 */

define([
    'module', 'require', 'dojo/_base/lang', 'dojo/Deferred',
    'vodori/provide',
    'pepper/library/LibraryDialog'
], function (module, require, lang, Deferred,
             provide, LibraryDialog) {

    /**
     *
     * @type {LibraryDialog}
     * @private
     */
    var _libraryDialog = null;

    // just a small helper
    function setOptionsOnWidgetsAndShowIfNecessary(options){
        if(options.refresh){
            _libraryDialog.widget.clearAllFilters();
        }

        if(options.query){
            _libraryDialog.widget.set('query', options.query);
        }

        if(!_libraryDialog.open){
            _libraryDialog.show();
        }
    }

    return provide(module.id,

            /**
             * Command to show the library and optionally open to a particular channel.
             * If no channel is selected, then the default channel for the current subscription will be shown.
             *
             *
             * @memberOf pepper/commands/dialogs
             *
             * @param {object} options The options
             * @param {string} [options.channelId=null] The parent folder from where this dialog was launched
             * @param {string} [options.query=null] An optional query to apply to the library.
             * @param {boolean} [options.refresh=null] Whether to refresh the library before show or not.
             */
            function showLibrary(options) {

                options = options || {};
                var deferred = new Deferred();

                // if the library was ever destroyed, reset the closure reference
                if(!_libraryDialog || _libraryDialog._destroyed){

                    // requiring directly because there is some sort of issue when importing at the top
                    // level - potentially a circular dependency?
                    require(['pepper/library/LibraryNouveau'], lang.hitch(this, function (LibraryNouveau) {

                        var library = null;
                        if(options.channelId){
                            library = new LibraryNouveau({currentChannel: {id: options.channelId}});
                        } else {
                            library = new LibraryNouveau();
                        }

                        _libraryDialog = new LibraryDialog({
                            widget: library,
                            destroyOnHide: false
                        });

                        _libraryDialog.startup();

                        setOptionsOnWidgetsAndShowIfNecessary(options);
                        deferred.resolve(_libraryDialog);
                    }));

                } else {

                    // we only need to call to set the channel if it already existed.
                    if(options.channelId){
                        _libraryDialog.widget.selectCurrentChannel(options.channelId);
                    }

                    setOptionsOnWidgetsAndShowIfNecessary(options);
                    deferred.resolve(_libraryDialog);
                }

                return deferred.promise;
            }

    );
});

},
'pepper/library/LibraryDialog':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'lodash',
    'dojo/_base/lang', 'dojo/_base/declare',
    'pepper/ui/ComposingDialog'
], function (
    _,
    lang, declare, ComposingDialog) {

    /**
     * @class pepper/library/LibraryDialog
     *
     * Dialog for use displaying a library widget. The "widget" property must be set to the Library widget to display.
     * Set destroyOnHide as needed; the default is true.
     */
    return declare([ComposingDialog], {

        'class': 'library-dialog',

        dialogExternalHeightAsPercentageOfViewport: 0.99,
        dialogExternalWidthAsPercentageOfViewport: 0.99,

        resizeable: true,
        parseOnFirstShow: false,
        destroyOnHide: true
    });
});
},
'pepper/ui/ComposingDialog':function(){
define([
    'dojo/_base/declare',
    'vodori/ui/ComposingDialog',
    './_QuarantineMixin'
], function (declare, ComposingDialog, _QuarantineMixin) {
    return declare([ComposingDialog, _QuarantineMixin], {
        constructor: function () {
            this.quarantineAreaClassNames += ' dialogContainer';
        }
    });
});

},
'pepper/commands/actions/openLinkTarget':function(){
define([
    'vodori/provide',
    'module'
], function (provide, module) {
    /**
     * Redirects a user to an object's URL. This is used for navigation elements
     */
    return provide(module.id, function (navigationElement) {

        var url = navigationElement.openTargetLink;
        if (url) {
            document.location.href = url;
        }
    });
});

},
'pepper/commands/actions/promote':function(){
define([
    'vodori/provide',
    'module',
    'pepper/data/PostDescriptorStore'
], function (provide, module, postDescriptorStore) {
    return provide(module.id, function (objects) {

        var servicePromise = postDescriptorStore.promote(objects);

        return servicePromise;

    });
});

},
'pepper/commands/actions/publish':function(){
define([
    'vodori/provide', 'module',
    'dojo/topic'
], function (provide, module, topic) {

    /**
     * A command to let the BE tell the FE to publish an event
     */
    return provide(module.id, function (commandObject) {
        var event = commandObject.event;
        topic.publish(event, [commandObject.objects]);
    });
});

},
'pepper/commands/actions/redirect':function(){
define([
    'vodori/provide',
    'module',
    'dojo/request/iframe'
], function (provide, module, iframe) {

    /**
     * A command to redirect the user to a new URL
     */
    return provide(module.id, function (commandObject) {

        var url = commandObject.redirectUrl;
        if (url === 'REFRESH') {
            url = window.location.toString().split('#')[0];
        }

        console.log('About to redirect the user to: ' + url);

        // If the openInIFrame value is set to true, open the URL in a hidden iframe
        if (commandObject.openInIFrame) {
            var deferred = iframe.get(url);

            // We need to cancel the deferred that comes back from the iframe.get, because dojo's iframe won't send off
            // another request from iframe if the current deferred is not resolved.
            deferred.cancel();
        } else {
            // Otherwise, just go to the url
            document.location.href = url;
        }
    });
});

},
'dojo/request/iframe':function(){
define([
	'module',
	'require',
	'./watch',
	'./util',
	'./handlers',
	'../_base/lang',
	'../io-query',
	'../query',
	'../has',
	'../dom',
	'../dom-construct',
	'../_base/window',
	'../NodeList-dom'/*=====,
	'../request',
	'../_base/declare' =====*/
], function(module, require, watch, util, handlers, lang, ioQuery, query, has, dom, domConstruct, win/*=====, NodeList, request, declare =====*/){
	var mid = module.id.replace(/[\/\.\-]/g, '_'),
		onload = mid + '_onload';

	if(!win.global[onload]){
		win.global[onload] = function(){
			var dfd = iframe._currentDfd;
			if(!dfd){
				iframe._fireNextRequest();
				return;
			}

			var response = dfd.response,
				options = response.options,
				formNode = dom.byId(options.form) || dfd._tmpForm;

			if(formNode){
				// remove all the hidden content inputs
				var toClean = dfd._contentToClean;
				for(var i=0; i<toClean.length; i++){
					var key = toClean[i];
					//Need to cycle over all nodes since we may have added
					//an array value which means that more than one node could
					//have the same .name value.
					for(var j=0; j<formNode.childNodes.length; j++){
						var childNode = formNode.childNodes[j];
						if(childNode.name === key){
							domConstruct.destroy(childNode);
							break;
						}
					}
				}

				// restore original action + target
				dfd._originalAction && formNode.setAttribute('action', dfd._originalAction);
				if(dfd._originalMethod){
					formNode.setAttribute('method', dfd._originalMethod);
					formNode.method = dfd._originalMethod;
				}
				if(dfd._originalTarget){
					formNode.setAttribute('target', dfd._originalTarget);
					formNode.target = dfd._originalTarget;
				}
			}

			if(dfd._tmpForm){
				domConstruct.destroy(dfd._tmpForm);
				delete dfd._tmpForm;
			}

			dfd._finished = true;
		};
	}

	function create(name, onloadstr, uri){
		if(win.global[name]){
			return win.global[name];
		}

		if(win.global.frames[name]){
			return win.global.frames[name];
		}

		if(!uri){
			if(has('config-useXDomain') && !has('config-dojoBlankHtmlUrl')){
				console.warn('dojo/request/iframe: When using cross-domain Dojo builds,' +
					' please save dojo/resources/blank.html to your domain and set dojoConfig.dojoBlankHtmlUrl' +
					' to the path on your domain to blank.html');
			}
			uri = (has('config-dojoBlankHtmlUrl')||require.toUrl('dojo/resources/blank.html'));
		}

		var frame = domConstruct.place(
			'<iframe id="'+name+'" name="'+name+'" src="'+uri+'" onload="'+onloadstr+
			'" style="position: absolute; left: 1px; top: 1px; height: 1px; width: 1px; visibility: hidden">',
			win.body());

		win.global[name] = frame;

		return frame;
	}

	function setSrc(_iframe, src, replace){
		var frame = win.global.frames[_iframe.name];

		if(frame.contentWindow){
			// We have an iframe node instead of the window
			frame = frame.contentWindow;
		}

		try{
			if(!replace){
				frame.location = src;
			}else{
				frame.location.replace(src);
			}
		}catch(e){
			console.log('dojo/request/iframe.setSrc: ', e);
		}
	}

	function doc(iframeNode){
		if(iframeNode.contentDocument){
			return iframeNode.contentDocument;
		}
		var name = iframeNode.name;
		if(name){
			var iframes = win.doc.getElementsByTagName('iframe');
			if(iframeNode.document && iframes[name].contentWindow && iframes[name].contentWindow.document){
				return iframes[name].contentWindow.document;
			}else if(win.doc.frames[name] && win.doc.frames[name].document){
				return win.doc.frames[name].document;
			}
		}
		return null;
	}

	function createForm(){
		return domConstruct.create('form', {
			name: mid + '_form',
			style: {
				position: 'absolute',
				top: '-1000px',
				left: '-1000px'
			}
		}, win.body());
	}

	function fireNextRequest(){
		// summary:
		//		Internal method used to fire the next request in the queue.
		var dfd;
		try{
			if(iframe._currentDfd || !iframe._dfdQueue.length){
				return;
			}
			do{
				dfd = iframe._currentDfd = iframe._dfdQueue.shift();
			}while(dfd && (dfd.canceled || (dfd.isCanceled && dfd.isCanceled())) && iframe._dfdQueue.length);

			if(!dfd || dfd.canceled || (dfd.isCanceled && dfd.isCanceled())){
				iframe._currentDfd = null;
				return;
			}

			var response = dfd.response,
				options = response.options,
				c2c = dfd._contentToClean = [],
				formNode = dom.byId(options.form),
				notify = util.notify,
				data = options.data || null,
				queryStr;

			if(!dfd._legacy && options.method === 'POST' && !formNode){
				formNode = dfd._tmpForm = createForm();
			}else if(options.method === 'GET' && formNode && response.url.indexOf('?') > -1){
				queryStr = response.url.slice(response.url.indexOf('?') + 1);
				data = lang.mixin(ioQuery.queryToObject(queryStr), data);
			}

			if(formNode){
				if(!dfd._legacy){
					var parentNode = formNode;
					do{
						parentNode = parentNode.parentNode;
					}while(parentNode && parentNode !== win.doc.documentElement);

					// Append the form node or some browsers won't work
					if(!parentNode){
						formNode.style.position = 'absolute';
						formNode.style.left = '-1000px';
						formNode.style.top = '-1000px';
						win.body().appendChild(formNode);
					}

					if(!formNode.name){
						formNode.name = mid + '_form';
					}
				}

				// if we have things in data, we need to add them to the form
				// before submission
				if(data){
					var createInput = function(name, value){
						domConstruct.create('input', {
							type: 'hidden',
							name: name,
							value: value
						}, formNode);
						c2c.push(name);
					};
					for(var x in data){
						var val = data[x];
						if(lang.isArray(val) && val.length > 1){
							for(var i=0; i<val.length; i++){
								createInput(x, val[i]);
							}
						}else{
							if(!formNode[x]){
								createInput(x, val);
							}else{
								formNode[x].value = val;
							}
						}
					}
				}

				//IE requires going through getAttributeNode instead of just getAttribute in some form cases,
				//so use it for all.  See #2844
				var actionNode = formNode.getAttributeNode('action'),
					methodNode = formNode.getAttributeNode('method'),
					targetNode = formNode.getAttributeNode('target');

				if(response.url){
					dfd._originalAction = actionNode ? actionNode.value : null;
					if(actionNode){
						actionNode.value = response.url;
					}else{
						formNode.setAttribute('action', response.url);
					}
				}

				if(!dfd._legacy){
					dfd._originalMethod = methodNode ? methodNode.value : null;
					if(methodNode){
						methodNode.value = options.method;
					}else{
						formNode.setAttribute('method', options.method);
					}
				}else{
					if(!methodNode || !methodNode.value){
						if(methodNode){
							methodNode.value = options.method;
						}else{
							formNode.setAttribute('method', options.method);
						}
					}
				}

				dfd._originalTarget = targetNode ? targetNode.value : null;
				if(targetNode){
					targetNode.value = iframe._iframeName;
				}else{
					formNode.setAttribute('target', iframe._iframeName);
				}
				formNode.target = iframe._iframeName;

				notify && notify.emit('send', response, dfd.promise.cancel);
				iframe._notifyStart(response);
				formNode.submit();
			}else{
				// otherwise we post a GET string by changing URL location for the
				// iframe

				var extra = '';
				if(response.options.data){
					extra = response.options.data;
					if(typeof extra !== 'string'){
						extra = ioQuery.objectToQuery(extra);
					}
				}
				var tmpUrl = response.url + (response.url.indexOf('?') > -1 ? '&' : '?') + extra;
				notify && notify.emit('send', response, dfd.promise.cancel);
				iframe._notifyStart(response);
				iframe.setSrc(iframe._frame, tmpUrl, true);
			}
		}catch(e){
			dfd.reject(e);
		}
	}

	// dojo/request/watch handlers
	function isValid(response){
		return !this.isFulfilled();
	}
	function isReady(response){
		return !!this._finished;
	}
	function handleResponse(response, error){
		if(!error){
			try{
				var options = response.options,
					doc = iframe.doc(iframe._frame),
					handleAs = options.handleAs;

				if(handleAs !== 'html'){
					if(handleAs === 'xml'){
						// IE6-8 have to parse the XML manually. See http://bugs.dojotoolkit.org/ticket/6334
						if(doc.documentElement.tagName.toLowerCase() === 'html'){
							query('a', doc.documentElement).orphan();
							var xmlText = doc.documentElement.innerText;
							xmlText = xmlText.replace(/>\s+</g, '><');
							response.text = lang.trim(xmlText);
						}else{
							response.data = doc;
						}
					}else{
						// 'json' and 'javascript' and 'text'
						response.text = doc.getElementsByTagName('textarea')[0].value; // text
					}
					handlers(response);
				}else{
					response.data = doc;
				}
			}catch(e){
				error = e;
			}
		}

		if(error){
			this.reject(error);
		}else if(this._finished){
			this.resolve(response);
		}else{
			this.reject(new Error('Invalid dojo/request/iframe request state'));
		}
	}
	function last(response){
		this._callNext();
	}

	var defaultOptions = {
		method: 'POST'
	};
	function iframe(url, options, returnDeferred){
		var response = util.parseArgs(url, util.deepCreate(defaultOptions, options), true);
		url = response.url;
		options = response.options;

		if(options.method !== 'GET' && options.method !== 'POST'){
			throw new Error(options.method + ' not supported by dojo/request/iframe');
		}

		if(!iframe._frame){
			iframe._frame = iframe.create(iframe._iframeName, onload + '();');
		}

		var dfd = util.deferred(response, null, isValid, isReady, handleResponse, last);
		dfd._callNext = function(){
			if(!this._calledNext){
				this._calledNext = true;
				iframe._currentDfd = null;
				iframe._fireNextRequest();
			}
		};
		dfd._legacy = returnDeferred;

		iframe._dfdQueue.push(dfd);
		iframe._fireNextRequest();

		watch(dfd);

		return returnDeferred ? dfd : dfd.promise;
	}

	/*=====
	iframe = function(url, options){
		// summary:
		//		Sends a request using an iframe element with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/iframe.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	iframe.__BaseOptions = declare(request.__BaseOptions, {
		// form: DOMNode?
		//		A form node to use to submit data to the server.
		// data: String|Object?
		//		Data to transfer. When making a GET request, this will
		//		be converted to key=value parameters and appended to the
		//		URL.
	});
	iframe.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request. Must be
		//		uppercase. Only `"GET"` and `"POST"` are accepted.
		//		Default is `"POST"`.
	});
	iframe.__Options = declare([iframe.__BaseOptions, iframe.__MethodOptions]);

	iframe.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using an iframe element with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/iframe.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	iframe.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using an iframe element with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/iframe.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	iframe.create = create;
	iframe.doc = doc;
	iframe.setSrc = setSrc;

	// TODO: Make these truly private in 2.0
	iframe._iframeName = mid + '_IoIframe';
	iframe._notifyStart = function(){};
	iframe._dfdQueue = [];
	iframe._currentDfd = null;
	iframe._fireNextRequest = fireNextRequest;

	util.addCommonMethods(iframe, ['GET', 'POST']);

	return iframe;
});

},
'pepper/commands/actions/reinstate':function(){
define([
    'vodori/provide',
    'module',
    'pepper/utilities',
    'pepper/data/PostDescriptorStore'
], function (provide, module, utilities, postDescriptorStore) {
    return provide(module.id, function (objects) {

        var servicePromise = postDescriptorStore.reinstate(objects);

        return servicePromise;

    });
});

},
'pepper/commands/actions/revive':function(){
define([
    'vodori/provide',
    'module',
    'pepper/data/PostDescriptorStore'
], function (provide, module, postDescriptorStore) {
    return provide(module.id, function (objects) {

        var servicePromise = postDescriptorStore.revive(objects);

        return servicePromise;

    });
});

},
'pepper/commands/actions/save':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'pepper/propertyManager',
    'pepper/data/PostDescriptorStore'
], function (provide, module, _, propertyManager, postDescriptorStore) {
    return provide(module.id, function (objects) {

        if (!_.isArray(objects)) {
            objects = [objects];
        }

        /* Only save the current page. */
        _.filter(objects, function (o) {
            return (postDescriptorStore.isCurrentPage(o.objectId));
        });

        // Save the page
        var saveResultsPromise = postDescriptorStore.save(objects, propertyManager.getContent());


        // Mark all of the page inputs as saved
        saveResultsPromise.then(function (response) {

            var results = response.results;
            _.forEach(results, function (result) {
                console.log('Saved', result.objectId);
                if (postDescriptorStore.isCurrentPage(result)) {
                    propertyManager.setCleanState();
                }
            });

        });
    });
});

},
'pepper/commands/actions/launchInNavigationManager':function(){
define([
    'module', 'require', 'vodori/provide',
    'lodash',
    'dojo/when',
    'pepper/data/PostDescriptorStore', 'pepper/ui/ComposingDialog'
], function (
    module, require, provide,
    _,
    when,
    PostDescriptorStore, ComposingDialog
) {

    var navManagerSingleton;
    var navManagerDialogSingleton;

    /**
     * Open the navigation manager and optionally expand the pane with the navigation element that has the given
     * object as its target.
     * @param {string|{objectId: string}|Array} [openTo] URI path that is the target of a navigation element
     *        (ex: '/index.html', 'http://www.vodori.com') or object with objectId property referencing a post
     *        descriptor that would be the link target. Or this can be an array of either of these, in which case
     *        panes will be expanded for all the elements in the array. (Optional -- do not expand the nav manager if
     *        nothing is specified here, or if it's null or empty.)
     */
    function launchInNavigationManager(openTo) {
        /*
         * Lazy loading to avoid a circular dependency
         */
        require(['pepper/navigation/NavigationManager'], function (NavigationManager) {
            if (!navManagerSingleton) {
                navManagerSingleton = new NavigationManager();
                navManagerDialogSingleton = new ComposingDialog({
                    destroyOnHide: false,
                    parseOnFirstShow: false,
                    widget: navManagerSingleton
                });
                navManagerDialogSingleton.startup();
            }

            navManagerDialogSingleton.show();
            expandNavManagerTo(openTo);
        });
    }

    /**
     * Expand the navigation manager pane with the navigation element that has the given object as its target. This
     * assumes the nav manager has already been instantiated.
     *
     * @param {string|{objectId: string}|Array} [openTo] URI path that is the target of a navigation element
     *        (ex: '/index.html', 'http://www.vodori.com') or object with objectId property referencing a post
     *        descriptor that would be the link target. Or this can be an array of either of these, in which case
     *        panes will be expanded for all the elements in the array. (Optional -- do not expand the nav manager if
     *        nothing is specified here, or if it's null or empty.)
     */
    function expandNavManagerTo(openTo) {
        if (_.isArray(openTo)) {
            _.forEach(openTo, function(item) {
                expandNavManagerTo(item);
            });
        } else if (_.isObject(openTo)) {
            if (openTo.objectId) {
                when(PostDescriptorStore.get(openTo.objectId), function(postDescriptor) {
                    expandNavManagerTo(postDescriptor.path);
                });
            }
        } else if (openTo) {
            navManagerSingleton.openToTargetUrl(openTo);
        }
    }

    // expose expandNavManagerTo function, especially for testing
    launchInNavigationManager.expandNavManagerTo = expandNavManagerTo;

    return provide(module.id, launchInNavigationManager);
});

},
'pepper/commands/actions/viewAssociatedWorkflow':function(){
define([
    'dojo/when',
    'vodori/provide', 'module',
    'pepper/data/PostDescriptorStore'
], function(
    when,
    provide, module,
    postDescriptorStore
) {
    return provide(module, function(objects) {
        var result = postDescriptorStore.get(objects[0].objectId);

        when(result, function(object) {
            if (object) {
                var taskId = object.lifecycle.workflow.tasks[0].id;
                window.open('/pepper/inbox#/tasks/' + taskId, 'pepperInboxWindow' + taskId);
            }
        });
    });
});

},
'pepper/commands/actions/navigation/cancelCheckOut':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'pepper/services', 'pepper/utilities'
], function (provide, module, _, lang, services, utilities) {
    return provide(module.id, function (objects) {
        return services.cancelCheckOut({
            params: {
                objects: utilities.createPayload(objects)
            }
        }).then(lang.hitch(this, function (response) {
                var results = response.results;
                _.forEach(results, function (result) {
                    console.log('Canceled checkout', result);
                });
            }));
    });
});

},
'pepper/commands/actions/navigation/checkIn':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'pepper/services', 'pepper/utilities'
], function (provide, module, _, lang, services, utilities) {

    /**
     * Performs a checkout of a navigation element
     */
    return provide(module.id, function (objects) {
        if (!(objects instanceof Array)) {
            objects = [objects];
        }

        return services.checkIn({
            params: {
                objects: utilities.createPayload(objects)
            }
        }).then(lang.hitch(this, function (response) {
                var results = response.results;
                _.forEach(results, function (result) {
                    console.log('Checked in', result);
                });
            }));
    });
});

},
'pepper/commands/actions/navigation/checkOut':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'pepper/services', 'pepper/utilities'
], function (provide, module, _, lang, services, utilities) {
    return provide(module.id, function (objects) {
        return services.checkOut({
            params: {
                objects: utilities.createPayload(objects)
            }
        }).then(lang.hitch(this, function (response) {
                var results = response.results;
                _.forEach(results, function (result) {
                    console.log('Checked out', result.objectId);
                });
            }));
    });
});

},
'pepper/commands/validations/validateWorkflowItems':function(){
define([
	'../../../vodori/provide',
	'module', 'lodash',
	'dojo/_base/lang',
	'pepper/services',
	'pepper/ui/handleNotification'
], function (provide,
             module, _,
             lang,
             services,
             handleNotification) {

	// this is executable upon require
	return provide(module.id, function (data) {

		var parameters = {
			currentlySelected: data.currentlySelected,
			currentlyValidated: data.currentlyValidated,
			currentlyInvalidated: data.currentlyInvalidated
		};

		parameters = lang.mixin(parameters, data.extraParams || {});

		var promise = services.validateWorkflowItems({
			params: parameters
		});

		promise.then(function (response) {

			var toastedItems = [];
			var validatedIds = [];
			var invalidatedIds = [];

			var results = response.results;

			_.forEach(results, function (resultInfo) {
				if (resultInfo.success) {
					validatedIds.push(resultInfo.objectId);
				} else {
					var message;
					invalidatedIds.push(resultInfo.objectId);
					var obj = data.objects[resultInfo.objectId].object;
					var name = obj.description || obj.name || '';

					if (resultInfo.rejectionReason) {
						message = name + '-' + resultInfo.rejectionReason;
					} else {
						message = name;
					}
					toastedItems.push('<li>' + message + '</li>');
				}
			});

			if (invalidatedIds.length > 0) {
				handleNotification({
					title: 'Unable To Add Objects',
					message: 'The following were not able to be added: ' + '<ul>' + toastedItems.join('') + '</ul>',
					expireAfter: 6000
				});
			}

			var VERIFIED = data.maxSelections > 0 ? validatedIds.slice(0, data.maxSelections) : validatedIds;

			data.callback(VERIFIED);
		});

		return promise;
	});

});

},
'pepper/commands/dialogs/showInfo':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/when',
    'dojo/_base/lang',
    'pepper/data/PostDescriptorStore',
    'pepper/dialogs/Info',
    'pepper/dialogs/info/configs/views',
    'pepper/ui/ComposingDialog'
], function (provide, module, _, when, lang, postDescriptorStore, Info, views, ComposingDialog) {

    return provide(module.id,
        /**
         * @memberOf pepper/commands/dialogs
         *
         * @param {(string|number)}tab  (optional) the tab to open
         * @param {Array.<Object>} [objects] the objects to show info for, defaults to the page's object
         */
            function showInfo(tab, objects) {

            // If a tab index was not passed in, move the object to the objects var, and default to first tab's index
            if (tab === null || _.isObject(tab)) {
                objects = tab;
                tab = 0;
            }

            // If no objects were passed in, default to a list of one object (which is the current page)
            objects = objects || postDescriptorStore.getCurrentPageObject();

            when(objects, lang.hitch(this, function (objectsToParse) {

                if (!_.isArray(objectsToParse)) {
                    objectsToParse = [objectsToParse];
                }

                // Sets the tab to open the Info dialog on
                // Sets the list of objects whose info is to be displayed (bulk or single mode)
                // Sets config mode depending on how many objects were passed in

                var objectsCount = objectsToParse.length;

                var infoWidget = new Info({
                    objects: objectsToParse,
                    tab: tab,
                    config: (objectsCount > 1) ? views.info.bulk : views.info.single
                });

                var modal = new ComposingDialog({
                    destroyOnHide: true,
                    parseOnFirstShow: false,
                    widget: infoWidget,
                    title: (objectsCount > 1) ?
                        'Info for multiple items (' + objectsToParse.length + ' selected)': ''
                });

                modal.startup();
                modal.show();
            }));


        });
});

},
'pepper/dialogs/Info':function(){
/**
 * Widget for displaying and editing information for pieces of content.
 * Encapsulates the Info view and Review view.
 * Both queue (flip through) and bulk mode are supported
 */

define([
    'module','vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/dom-class', 'dojo/dom-style', 'dojo/topic', 'dojo/on', 'dojo/when',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'vodori/layout/_Composable', 'vodori/layout/_Composing',
    'pepper/data/PostDescriptorStore', 'pepper/events', 'pepper/utilities', 'pepper/ui/handleNotification',
    'pepper/dialogs/info/TemplateSelector', 'pepper/dialogs/info/InfoState',
    'pepper/utilities/isInReception',
    'dojo/text!pepper/dialogs/templates/Info-content.html',
    /* unreferenced MIDs */
    'dijit/form/Textarea',
    'dijit/form/ValidationTextBox',
    'dijit/layout/BorderContainer',
    'dijit/layout/ContentPane',
    'dijit/layout/TabContainer',
    'dijit/TitlePane',
    'vodori/input/CheckedSelect',
    'vodori/input/DateAndTime',
    'vodori/input/DateTextBox',
    'vodori/input/GroupedSelect',
    'vodori/input/Select',
    'vodori/input/TimeTextBox',
    'vodori/input/WhatsThis',
    'vodori/ui/Button',
    'pepper/utilities/DateFormatWrapper',
    'pepper/input/FileInput',
    'pepper/dialogs/info/PropertyViewer',
    'pepper/dialogs/info/Footer'
], function (
    module, provide,
    _,
    lang,
    domClass, domStyle, topic, on, when,
    _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
    _Composable, _Composing,
    postDescriptorStore, events, utilities, handleNotification,
    TemplateSelector, InfoState,
    isInReception,
    template
    ) {
    return provide(module.id, [ _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, _Composable, _Composing ], {

        handleNotification: handleNotification,
        index: null,
        objects: null,
        objectIds: null,

        /* Attach points */
        propertyViewer: null,
        templateSelector: null,
        footer: null,
        borderContainer: null,

        height: 680,
        width: 1307,

        baseClass: 'pepperInfoDialog',

        // _Composing API - fireCompose({ props: { heading: ... }}) is called from PropertiesProxyPane
        // this essentially connects the fireCompose call to the _setHeadingAttr method
        _exposedProps: ['heading'],

        // this is the default title for when this widget is used in a composing dialog
        // the title should be overridden by internal tabs (see _exposedProps above)
        title: 'Properties',

        templateString: template,

        // the tab to show in PropertyViewer
        tab: 0,

        // this is used by the template selector to 'preselect' a template
        _previousTemplate: null,

        _templateChanged: false,

        /**
         * Set to true when the "Next" button is clicked so that the widget knows that some additional work
         * might need to be done after the next asset form finishes downloading.
         *
         * @type {boolean}
         * @private
         */
        _nextFlag: false,

        /**
         * Set to true on the form update that occurs after clicking "Next" so that the module knows
         * to attempt a template auto-select once the new form downloads.
         *
         * @type {boolean}
         * @private
         */
        _shouldAttemptAutoSelect: false,

        /**
         * This is the handle to the template changed event for the TemplateSelector.
         * When the TemplateSelector is updated, the handle gets removed and a new one created.
         */
        _templateChangeHandle: null,

        /**
         * A collection of object ids for those assets that are in reception when the Info dialog starts up.
         * Will be used for comparison when performing check-ins for items that had once been in reception.
         *
         * @type {Array.<String>}
         * @private
         */
        _initialReceptionIds: null,

        /**
         * InfoState instance for holding and communicating state between components.
         */
        _infoState: null,

        constructor: function() {
            this._infoState = new InfoState();
        },

        postMixInProperties: function () {

            if (this.index === null) {
                this.index = 0;
            }

            this.objectIds = _.pluck(this.objects, 'objectId');
            this._initialReceptionIds = this._getReceptionIds(this.objects);

            if (this.config.mode === 'queue') {
                this._infoState.set('flipThrough', true);
            }
            this._updateStateForCurrentItem();

            this.inherited(arguments);
        },

        postCreate: function () {
            // the border container cannot be resized until the template selector has been rendered
            this.own(this.templateSelector.on('rendered', lang.hitch(this.borderContainer, 'resize')));

            // subscribe to formProxyPane events being publish from internal tabs
            this._attachToFormProxyPaneEvents([
                'submitInProgress',
                'submitComplete',
                'formDownloadStart',
                'formDownloadEnd'
            ]);

            this._initializeTemplateSelector();
            this.footer.set('infoState', this._infoState);

            this._updateStyling();
            this._attachToFooterEvents([ 'Save', 'Cancel', 'Previous', 'Next', 'Skip', 'Done', 'Exit' ]);

            this.inherited(arguments);
        },

        /**
         * Forward any resize calls with explicit dimensions to
         * the contained BorderContainer.
         *
         * @param {Object|undefined}
         * @param currentSize
         */
        resize: function(dimensions) {
            if (dimensions) {
                this.borderContainer.resize(dimensions);
            }
        },

        startup: function() {
            if(this._started) {
                return;
            }

            this._createPropertyViewer();

            this.own(on(this.domNode, 'dialogOpen', lang.hitch(this, function() {
                this.switchTab(this.tab);
                topic.publish(events.properties.actions.flip, [this.objects[this.index]]);
            })));

            this.inherited(arguments);
        },

        _initializeTemplateSelector: function() {
            domClass.toggle(this.templateSelector.domNode, 'disabled', !this.config.templateSelector.enabled);

            if (this.config.templateSelector.enabled) {
                // Need to disable any kind of 'saving' buttons for when no template is selected.
                // An added benefit is that 'saving' buttons are disabled for part of the time
                // while the dialog is loading, just in case users go crazy.
                this._updateStateForCurrentItem();

                // Re-enables all buttons when a template has been selected.
                // For dialogs like Info > Properties, this should and will fire since the template is selected
                // on loading the dialog, which is what we want since 'saving' buttons should be
                // available in that kind of scenario where a template selection already exists.
                // Note that this forcibly re-enables all buttons each time the template changes!
                var event = TemplateSelector.SELECTION_CHANGED_EVENT;

                this.own(on(this.templateSelector, event, lang.hitch(this, '_updateStateForCurrentItem')));
            }

            this.populateTemplateSelector();
        },

        /**
         * Populates the template selector using the appropriate objects, type and selections
         */
        populateTemplateSelector: function () {
            var selectedTemplate = null;
            var previousTemplate = null;
            var objects = [];

            if (this.objects.length === 1) {
                objects = this.objects;
                selectedTemplate = this.objects[0].templateId;
            } else if (this.objects.length > 1) {
                if (this.config.mode === 'queue') {
                    objects = [ this.objects[this.index] ];

                    var template = this._previousTemplate;

                    if (template !== null) {
                        previousTemplate = template.id;
                    }
                } else { // bulk
                    objects = this.objects;
                    selectedTemplate = this.objects[0].templateId;

                    for (var i = 1; i < this.objects.length; i++) { // determine if every object has the same template
                        if (selectedTemplate !== this.objects[i].selectedTemplate) {
                            selectedTemplate = null;
                            break;
                        }
                    }
                }
            }

            var deferred = this.templateSelector.populate({
                pathId: this.pathId,
                objects: objects,
                selectedTemplate: selectedTemplate,
                previousTemplate: previousTemplate
            });

            deferred.then(lang.hitch(this, function() {
                this.update();

                this._templateChangeHandle = on(
                    this.templateSelector,
                    TemplateSelector.SELECTION_CHANGED_EVENT,
                    lang.hitch(this, '_onTemplateChange')
                );
            }));
        },

        _attachToFormProxyPaneEvents: function(theEvents) {
            var proxyEvents = events.ui.formProxyPane;

            _.forEach(theEvents, lang.hitch(this, function(eventName) {
                this.own(topic.subscribe(proxyEvents[eventName], lang.hitch(this, '_' + eventName + 'Handler')));
            }));
        },


        _attachToFooterEvents: function(events) {
            _.forEach(events, lang.hitch(this, function(event) {
                this.own(on(this.footer, event.toLowerCase(), lang.hitch(this, '_on' + event)));
            }));
        },

        /**
         * Creates the property viewer from the config
         */
        _createPropertyViewer: function() {
            this.propertyViewer.set('config', this.config);

            this.own(
                on(this.propertyViewer, 'tabChange', lang.hitch(this, '_onTabChangeHandler')),
                on(this.propertyViewer, 'dirty', lang.hitch(this, '_onDirtyHandler'))
            );

            this.propertyViewer.startup();
            this.propertyViewer.populate();
        },

        /**
         * Handles when a tab in the property viewer changes
         */
        _onTabChangeHandler: function(tab) {
            // determine if the tab is saveable and then alter the available buttons
            var isCurrentTabSavable = this.propertyViewer.isCurrentTabSavable(tab);
            this._infoState.set('currentTabSavable', isCurrentTabSavable);
        },

        _onDirtyHandler: function() {
            this.set('suppressWarnings', !this.propertyViewer.isDirty());
        },

        /**
         * Suppresses warnings for the dialog
         *
         * Note: The suppress warnings code may not have been fully converted from Pepper 3.2.
         * Much of the code in TemplateList.js is missing now in 3.4, which could have been a legitimate refactor.
         *
         * @param suppress true/false
         */
        _setSuppressWarningsAttr: function(suppress) {
            if (this.config.view === 'info') {
                suppress = false; // never suppress in info mode
            }

            this.templateSelector.set('suppressWarnings', suppress);
        },

        /**
         * Updates the styling of the widget based on configuration
         */
        _updateStyling: function() {
            domClass.add(this.domNode, this.config.mode);

            // this is just the initial height
            domStyle.set(this.borderContainer.domNode, {
                height: this.height + 'px',
                width: this.width + 'px'
            });
        },

        _updateStateForCurrentItem: function() {
            var currentItem = this.objects[this.index];
            this._infoState.set('readOnly', !(currentItem && currentItem.lockedByCurrentUser));
            this._infoState.set('hasPrevious', this.index !== 0);
            this._infoState.set('hasNext', this.index < this.objects.length - 1);
            this._infoState.set('valid', this._isValidSaveState());
        },

        /**
         * Determine whether the asset corresponding to the current property viewer
         * form is in a savable state.
         *
         * @private
         */
        _isValidSaveState: function() {
            var currentIndex = this.index;

            var objectHasTemplate = this.objects &&
                this.objects[currentIndex] &&
                this.objects[currentIndex].templateId;

            var templateSelected = this.templateSelector && this.templateSelector.get('selectedTemplate');

            return Boolean(objectHasTemplate || templateSelected);
        },

        /**
         * This method works with _exposedProps, implementing the _Composing API so that
         * the title of the dialog can be adjusted when some containing tab indicates
         * that this dialog title should change.
         *
         * @param {string}
         * @return {pepper.dialogs.Info}
         * @private
         */
        _setHeadingAttr: function(title) {
            // if we are in flip through mode, we want to display which item we are on
            // e.g. Info for /foo.png (1 of 10 in queue)
            if (this.config.mode === 'queue') {
                title = title + ' (' + (this.index + 1) + ' of ' + this.objects.length + ' in queue)';
            }

            this.fireCompose({
                props: {
                    title: title
                }
            });

            return this;
        },

        /**
         * Triggered on form load and save
         */
        _formDownloadStartHandler: function() {
            this._infoState.startLoading();
        },

        /**
         * Triggered on form save only
         */
        _submitInProgressHandler: function() {
            this._infoState.startLoading();
            this.templateSelector.set('disabled', true);
        },

        /**
         * Triggered on form load and save
         */
        _formDownloadEndHandler: function(formProxyPane) {
            this._infoState.endLoading();
        },

        /**
         * Triggered on form save only
         */
        _submitCompleteHandler: function(formProxyPane) {
            if (formProxyPane) {
                this._updateObjectIdFromResponse(formProxyPane);
            }

            when(postDescriptorStore.queryByIds(this.objectIds, { forceRefresh: true }),
                lang.hitch(this, function(objects) {
                    this.objects = objects;

                    this._maybeAutoSelectTemplate();
                    this._updateStateForCurrentItem();
                    this._infoState.endLoading();
                }));
            this.templateSelector.set('disabled', false);
        },

        _updateObjectIdFromResponse: function(formProxyPane) {

            // getting new ids off of the proxy pane which updates after submit
            var objectIds = formProxyPane.get('objectIds');

            if (objectIds && objectIds.length === 1) {

                var newId = objectIds[0];
                var currentId = this.objectIds[this.index];

                if (currentId !== newId) {

                    this.objectIds[this.index] = newId;
                    var promise = postDescriptorStore.get(newId, {forceRefresh: true});

                    promise.then(lang.hitch(this, function (newObject) {

                        // replace the object with the new backing object
                        this.objects[this.index] = newObject;

                        // update all the panes
                        this.update();

                        // replacing the properties pane href to point to the new object
                        // since it's not covered by the this.update()
                        this._replaceProxyPaneHrefObjectId(formProxyPane, currentId, newId);
                    }));
                }
            }
        },

        _replaceProxyPaneHrefObjectId: function(formProxyPane, oldId, newId){
            var href = formProxyPane.href;
            href = href.replace(oldId, newId);
            formProxyPane.set('href', href);
        },

        _maybeAutoSelectTemplate: function() {
            if (this._shouldAttemptAutoSelect) {
                this._shouldAttemptAutoSelect = false;
                var templateId = this._determineAutoSelectTemplate();
                if (templateId) {
                    this.templateSelector.set('selectedTemplate', templateId);
                }
            }
        },

        /**
         * Return a template id based on the previous asset in Info's objects list, but only
         * under certain conditions.
         *
         * @return {String} a templateId string, empty if no appropriate template
         * @private
         */
        _determineAutoSelectTemplate: function() {
            if (this.index < 1) {
                return '';
            }

            var currentObj = this.objects[this.index];
            var previousObj = this.objects[this.index-1];

            if (currentObj.templateId || !currentObj.lockedByCurrentUser || (currentObj.type !== previousObj.type)) {
                return '';
            }

            return previousObj.templateId;
        },

        _onSave: function() {
            var options = {
                saveParams: [
                    {
                        name: 'button',
                        value: 'save',
                        type: 'URL'
                    }
                ]
            };

            this.save(options);
        },

        _onCancel: function() {
            var callback = lang.hitch(this, '_closeDialog', { afterSave: false });
            var notification = utilities.dialogs.createUnsavedChangesModal(callback);
            this._checkDirty(callback, notification);
        },

        _onPrevious: function() {
            var callback = lang.hitch(this, function() {
                this.index--;
                this._onFlipThrough();
            });

            var notification = utilities.dialogs.createUnsavedChangesModal(callback);
            this._checkDirty(callback, notification);
        },

        _onNext: function() {
            this._nextFlag = true;
            if (this.objects[this.index].lockedByCurrentUser) {
                var options = {
                    callBack: lang.hitch(this, '_onFlipThrough'),
                    indexChange: 1
                };

                this.save(options);
            } else {
                this.index++;
                this._onFlipThrough();
            }
        },

        _onSkip: function() {
            var callback = lang.hitch(this, function() {
                this.index++;
                this._onFlipThrough();
            });

            var notification = utilities.dialogs.createUnsavedChangesModal(callback);
            this._checkDirty(callback, notification);
        },

        _onDone: function() {
            // We want to check in everything else that is savable and then deal with the current asset
            when(this._checkInAllButCurrent(), lang.hitch(this, function() {
                var options = {
                    callBack: lang.hitch(this, '_closeDialog', { afterSave: true }),
                    indexChange: 0,
                    saveParams: [
                        {
                            name: 'button',
                            value: 'done',
                            type: 'URL'
                        }
                    ]
                };

                this.save(options);
            }));
        },

        _checkInAllButCurrent: function() {
            var otherAssetsToCheckIn = _.filter(this.objects, function(asset, index) {
                return index !== this.index &&
                       this._isReviewedAssetThatCanBeCheckedIn(asset);
            }, this);

            if (otherAssetsToCheckIn.length) {
                return postDescriptorStore.checkIn(otherAssetsToCheckIn, {state: 'CONFIRMED'});
            } else {
                return;
            }
        },

        /**
         * Determines whether an asset was in the original set of "in reception" objects and has
         * any other necessary conditions to be checked in.
         *
         * @param {Object} asset descriptor object
         * @private
         */
        _isReviewedAssetThatCanBeCheckedIn: function(asset) {
            return asset.lockedByCurrentUser &&
                   !isInReception(asset) &&
                   _.contains(this._initialReceptionIds, asset.objectId);
        },

        _onExit: function() {
            this._closeDialog({ afterSave: false });
        },

        _closeDialog: function(options) {
            topic.publish(events.properties.actions.close);

            this.fireCompose({
                methods: {
                    hide: {}
                }
            });
        },

        /**
         * Things that need to be done when Previous, Next or Skip is used
         */
        _onFlipThrough: function() {
            this._infoState.set('loading', true); // this will get unset when the properties form finishes loading
            topic.publish(events.properties.actions.flip, [this.objects[this.index]]);

            // clear the contents of the child widgets
            if (this.config.templateSelector.enabled) {
                if (this._templateChangeHandle) {
                    this.disconnect(this._templateChangeHandle);
                    delete this._templateChangeHandle;
                    this._templateChanged = false;
                }

                // we don't need to clear the templateSelector here
                // because the call to populateTemplateSelector below will clear it
            }

            this.propertyViewer.clear();

            this.populateTemplateSelector();
            this._updateStateForCurrentItem();
        },

        save: function(options) {
            var baseOptions = {
                saveParams: null,
                errorBack: null,
                callBack: null,
                indexChange: null
            };

            var opts = _.extend({}, baseOptions, options);

            var saveDeferred = this.propertyViewer.save(opts.saveParams);

            if (saveDeferred) { // null if save isn't implemented
                saveDeferred.then(
                    lang.partial(lang.hitch(this, '_onSaveSuccessHandler'), opts.indexChange, opts.callBack),
                    lang.partial(lang.hitch(this, '_onSaveFailureHandler'), opts.errorBack)
                );
            }

            return saveDeferred;
        },

        /**
         * Things to do by default after a save occurs
         * @param indexChange how to change the index
         * @param callback callback to execute
         */
        _onSaveSuccessHandler: function(indexChange, callback) {
            topic.publish(events.library.refresh);

            this._templateChanged = false;
			this.templateSelector.applyReadOnlyExceptForSelected();

            if (indexChange) {
                this.index = this.index + indexChange;
            }

            if (callback) {
                callback.call();
            }
        },

        /**
         * Things to do by default on failure
         * @param {function} callback callback to execute
         */
        _onSaveFailureHandler: function(callback) {
            if (callback) {
                callback.call();
            }
        },

        /**
         * Handler for when the template selector's template has changed
         * @param {{template: Object}} event the event containing the newly selected template.
         */
        _onTemplateChange: function(event) {
            var template = event ? event.template : null;

            if (template && template.id !== this.objects[this.index].templateId) {
                this._templateChanged = true;
                this.previousTemplate = template; // this looks weird, but we want to maintain "no template"
                this.update();
            }
        },

        /**
         * Determines if the dialog is dirty. Executes the callback if not, or creates the notification if it is.
         * @param continueCallback
         * @param notification
         */
        _checkDirty: function(continueCallback, notification) {
            var dirty = this.propertyViewer.isDirty();
            if (dirty || this._templateChanged) { // properties are dirty or just the template changed
                this.handleNotification(notification);
            } else {
                continueCallback();
            }
        },

        /**
         * Go through a collection of asset object descriptors and return a collection of the ids of those
         * whose lifecycle state is "in reception"
         *
         * @param {Array.<Object>} assets
         * @returns {Array.<String>} collection of asset ids
         * @private
         */
        _getReceptionIds: function(assets) {
            return _.pluck(_.filter(assets, isInReception), 'objectId');
        },


        /**
         * Updates propertyViewer with the current object and template
         */
        update: function() {
            var data = this.objects;

            if (this.config.mode === 'queue') {
                data = [ this.objects[this.index] ];
            }

            this.propertyViewer.update(data, this.templateSelector.get('selectedTemplate'));

            if (this._nextFlag) {
                this._shouldAttemptAutoSelect = true;
                this._nextFlag = false;
            }
        },

        /**
         * Switches the displayed tab
         * @param {number|string} tab the tab to switch to
         */
        switchTab: function(tab) {
            var tabs = this.propertyViewer.getChildren();
            var switchToTab = tabs[0];

            if (typeof tab === 'number') {
                switchToTab = tabs[tab];
            } else if (typeof tab === 'string') {
                var tabMap = _.map(tabs, function(tab) {
                    return tab.get('title').toLowerCase();
                });

                var tabIndex = _.indexOf(tabMap, tab.toLowerCase());

                switchToTab = tabs[tabIndex];
            }

            this.propertyViewer.selectChild(switchToTab);
            this.tab = switchToTab;

            return this;
        },

        destroy: function() {
            if (this.footer) {
                this.footer.destroy();
            }

            if (this.templateSelector) {
                this.templateSelector.destroy();
            }

            if (this.propertyViewer) {
                this.propertyViewer.destroy();
            }

            this.inherited(arguments);
        }

    });
});

},
'pepper/dialogs/info/TemplateSelector':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/dom-construct', 'dojo/dom-class', 'dojo/aspect', 'dojo/on',
    'pepper/data/TransformableStore',
    'dojo/Evented',
    'dijit/layout/BorderContainer',
    'pepper/dialogs/info/TemplateSelectorList', 'pepper/dialogs/info/TemplateList',
    'pepper/services', 'pepper/utilities'
], function (module, provide,
             _,
             lang,
             domConstruct, domClass, aspect, on,
             TransformableStore,
             Evented,
             BorderContainer,
             TemplateSelectorList, TemplateList,
             services, utilities) {

    var DEFAULT_POPULATE_PARAMS = {
        objects: [],
        selectedTemplate: null,
        previousTemplate: null,
        readOnly: false,
        pathId: null
    };

    /**
     * @class pepper/dialogs/info/TemplateSelector
     * @extends dijit/layout/BorderContainer
     */
    var TemplateSelector = provide(module, [BorderContainer, Evented],
        /**
         * @lends pepper/dialogs/info/TemplateSelector#
         */
        {
            selectedCategory: null,
            selectedTemplate: null,

            categoryList: null,
            templateList: null,

            categoryStore: null,
            templateStore: null,

            _categoryListRendered: false,
            _templateListRendered: false,

            _hasBeenPopulated: false,

            constructor: function () {
                this.categoryStore = new TransformableStore();
                this.templateStore = new TransformableStore();

                // Setting "content" doesn't work on BorderContainers.
                // You've got to "addChild" everything.
                // We'll create all the sub-widgets manually.
                this.categoryList = new TemplateSelectorList({
                    region: 'leading',
                    'class': 'pepperGrid templateSelectorList',
                    showHeader: false,
                    selectionMode: 'single',
                    store: this.categoryStore,
                    query: {},
                    columns: [
                        {
                            label: 'Category',
                            field: 'label',
                            renderCell: function (object, label, td, options) {
                                domConstruct.create('span', {
                                    'class': 'label',
                                    innerHTML: label
                                }, td);

                                domConstruct.create('span', {
                                    'class': 'arrow',
                                    innerHTML: '&gt;'
                                }, td);

                                domClass.toggle(td, 'unavailable', !object.available);
                            }
                        }
                    ]
                });

                this.own(this.categoryList.on('selectionChange', lang.hitch(this, 'categoryChanged')));

                this.templateList = new TemplateList({
                    region: 'center',
                    'class': 'pepperGrid templateList',
                    showHeader: false,
                    store: this.templateStore,
                    query: {category: '_NO_CATEGORY_SELECTED_'},
                    columns: [
                        {
                            label: 'Template',
                            field: 'label',
                            renderCell: function (object, label, td, options) {
                                domConstruct.create('img', {
                                    'class': 'thumb',
                                    src: object.thumbnail
                                }, td);

                                domConstruct.create('span', {
                                    'class': 'label',
                                    innerHTML: label
                                }, td);

                                domClass.toggle(td, 'unavailable', !object.available);
                            }
                        }
                    ]
                });


                this.own(aspect.after(this.categoryList, 'renderComplete',
                    lang.hitch(this, '_childRenderingComplete', 'categoryList')));

                this.own(aspect.after(this.templateList, 'renderComplete',
                    lang.hitch(this, '_childRenderingComplete', 'templateList')));

                this.own(this.templateList.on('dgrid-select', lang.hitch(this, '_templateListChangeHandler')));

                this.own(aspect.after(this.categoryList,
                    'beforeChange',
                    lang.hitch(this, '_categoryListBeforeChangeHandler'),
                    true));
                this.own(aspect.after(this.templateList,
                    'beforeChange',
                    lang.hitch(this, '_templateListBeforeChangeHandler'),
                    true));
            },

            postCreate: function () {
                this.inherited(arguments);

                this.addChild(this.categoryList);
                this.addChild(this.templateList);
            },

            _templateListBeforeChangeHandler: function () {

            },

            _categoryListBeforeChangeHandler: function () {

            },

            /**
             * The aspect run after the category and template dgrid renderComplete methods - once both dgrids complete
             * their rendering then emit a 'rendered' event so that the Info widget can resize
             *
             * @param childType
             * @private
             */
            _childRenderingComplete: function(childType) {
                if(childType === 'categoryList') {
                    this._categoryListRendered = true;
                } else {
                    this._templateListRendered = true;
                }

                if(this._categoryListRendered && this._templateListRendered) {
                    this.emit('rendered');
                }
            },

            /**
             * This method updates the data in store to indicate that
             * any templates other than the currently selected are not available
             * to be selected.
             *
             * @private
             */
            applyReadOnlyExceptForSelected: function(){
                var idProperty = this.templateStore.idProperty;
                var selectedId = null;
                var selectedTemplate = this.get('selectedTemplate');

                if(selectedTemplate && selectedTemplate.hasOwnProperty(idProperty)){
                    selectedId = selectedTemplate[idProperty];
                }

                this.templateStore.transform(function(template){
                    if(template[idProperty] === selectedId){
                        template.selected = true;
                        template.available = true;
                    } else {
                        template.available = false;
                        template.selected = false;
                    }
                });

                // lastly, since we've changed the availability in the store the selection is removed
                // so we reselect their selection so it still appears selected.
                if(selectedId){
                    // the selection is getting unset and yet the ids are persisted in selectedIds
                    // when the observable store is changed. due to the implementation of allowSelect,
                    // an id cannot be selected if it already exists in the list.
                    // So, in this case we clear the list.
                    this.templateList.set('selectedIds', []);
                    this.templateList.set('selectedItems', []);
                    this.templateList.selectByIds(selectedId, true);
                }
            },

            /**
             * Populates the template selector stores
             *
             * Params: an object with the following (all optional) properties
             *    objects: (Array) the objects to generate available templates for. only optional if getAll is true,
             *                     default []
             *    selectedTemplate: (String) the pre-selected template, default null
             *    previousTemplate: (String) the previously selected template, default null
             *    readOnly: (Boolean) if the entire selector should be read-only
             * @return the deferred from populating the selector
             */
            populate: function (params) {

                var populationParams = lang.mixin({}, DEFAULT_POPULATE_PARAMS, params);


                if (!_.isArray(populationParams.objects)) {
                    populationParams.objects = [];
                }

                this._clearWithoutRefresh();

                return services.getTemplates({
                    params: {
                        objects: utilities.createPayload(populationParams.objects),
                        pathId: populationParams.pathId,
                        networkId: populationParams.networkId,
                        channelId: populationParams.channelId
                    }
                }).then(lang.hitch(this, function (response) {
                    if (response.multipleTemplates) {
                        populationParams.readOnly = true;

                        var template = {
                            available: false,
                            selected: true,
                            id: 'UI_multipleTemplate',
                            label: 'Multiple Templates Applied',
                            thumbnail: '/static/js/pepper/images/MultiAsset.png',
                            category: 'multiple'
                        };
                        var category = { label: 'Multiple', templates: [template], id: 'multiple' };
                        response.results.push(category);
                        populationParams.selectedTemplate = 'UI_multipleTemplate';
                    }

                    _.forEach(response.results, function (category) {
                        category.available = !((category.templates.length === 0) || populationParams.readOnly);

                        // Generate an ID for each category so we can use it in an object store & add it
                        category.id = category.label.toUpperCase().replace(/\W/g, '_');
                        this.categoryStore.add(category);

                        // Add each template of each category to the templateStore.
                        // Give it a reference back to the category so we can filter.
                        _.forEach(category.templates, function (template) {
                            // If it's desired to pre-select with the previously used template, do so
                            if (!populationParams.selectedTemplate && populationParams.previousTemplate) {
                                if (template.id === populationParams.previousTemplate) {
                                    populationParams.selectedTemplate = populationParams.previousTemplate;
                                }
                            } else if (template.selected) {
                                populationParams.selectedTemplate = template.id;
                            }

                            template.category = category.id;
                            if (populationParams.readOnly) {
                                template.available = false;
                            }
                            this.templateStore.add(template);
                        }, this);
                    }, this);

                    this.categoryList.refresh();

                    // we only need to refresh the templateList if the templateSelector has been populated before
                    if(this._hasBeenPopulated) {
                        this.templateList.refresh();
                    }

                    // If there's a template, select it after the stores and grid have been built
                    if (populationParams.selectedTemplate) {
                        this.set('selectedTemplate', populationParams.selectedTemplate);
                    } else if (response.results.length === 1) {
                        this.categoryList.select(response.results[0].id);
                    }

                    this._hasBeenPopulated = true;
                }));
            },

            /**
             * Clears out the grids' data stores and the selected items.
             */
            clear: function () {
                this._clearWithoutRefresh();

                this.categoryList.refresh();
                this.templateList.refresh();
            },

            _clearWithoutRefresh: function() {
                this.categoryStore.setData([]);
                this.categoryList.set('selectedItems', []);
                this.selectedCategory = null;

                this.templateStore.setData([]);
                this.templateList.set('selectedItems', []);
                this.selectedTemplate = null;
            },

            _setSelectedCategoryAttr: function (id) {
                this.categoryList.set('selectedItems', [id]);
            },

            categoryChanged: function () {
                this.selectedCategory = this.categoryList.get('selectedItems')[0] || null;

                // Filter the templatesList to only show templates in the selected category.
                if (this.selectedCategory) {
                    this.templateList.set('query', {category: this.selectedCategory.id});

                    // Make sure that any selected template in the new category appears as selected - this is
                    // necessary to address the template list clearing that takes place for various events
                    if (this.selectedTemplate && this.selectedTemplate.category === this.selectedCategory.id) {
                        this.set('selectedTemplate', this.selectedTemplate.id);
                    }

                } else {
                    this.templateList.set('query', {category: '_NO_CATEGORY_SELECTED_'});
                }
            },

            /**
             * Sets the selected template by ID programmatically
             * @param id the ID of the template in the data store
             */
            _setSelectedTemplateAttr: function (id) {
                var newCategoryId;

                if (id) {
                    var templateObject = this.templateStore.get(id);

                    newCategoryId = templateObject && templateObject.category;
                    if (!newCategoryId) {
                        return;
                    }
                }

                var selectedCategory = this.get('selectedCategory');
                if (selectedCategory && selectedCategory.id === newCategoryId) {
                    this._setTemplateListSelection(id);
                } else {
                    // wait for the category to change before updating the template list selection.
                    var handle = aspect.after(this, 'categoryChanged', lang.hitch(this, function() {
                        this._setTemplateListSelection(id);
                        handle.remove();
                    }));

                    this.categoryList.set('selectedItems', [newCategoryId]);
                }
            },

            _setTemplateListSelection: function(id) {
                this.templateList.clearSelection();
                this.templateList.select(id);
                this._templateListChangeHandler();
            },

            /**
             * Fired when the selected template changes. DO NOT CONNECT TO THIS. Connect to onChange
             */
            _templateListChangeHandler: function () {
                var newTemplateSelection = this.templateList.get('selectedItems')[0];
                if (newTemplateSelection === this.selectedTemplate) {
                    return;
                }

                this.selectedTemplate = newTemplateSelection;
                this.onChange(this.selectedTemplate);
                this.emit(TemplateSelector.SELECTION_CHANGED_EVENT, { template: this.selectedTemplate });
            },


            /**
             * The selected template has changed. Connect to this
             */
            onChange: function (template) {
            },

            /**
             * Set "disabled" to a string to have that show up.
             */
            _setDisabledAttr: function (disabled) {
                this.inherited(arguments);

                // We can't actually call disabling on the children because that will result in a selection mode
                // change that clears all the current selections. Unfortunately dGrid does not provide a way
                // to just disable clicking while saving current selection state.

                domClass.toggle(this.domNode, 'disabled', disabled);
            },

            _setSuppressWarningsAttr: function (suppress) {
                this.templateList.set('suppressWarnings', suppress);
            }
        });

    TemplateSelector.SELECTION_CHANGED_EVENT = 'selectionChanged';

    return TemplateSelector;
});

},
'pepper/data/TransformableStore':function(){
define(['dojo/_base/declare', 'dojo/_base/lang', 'dojo/store/Memory'
], function (declare, lang, Memory) {

	/**
	 * This wraps a Memory store with an added transform function which takes
	 * a function to iterate against the objects in the store and perform any data
	 * transformation against the objects.
	 *
	 * @class TransformableStore
	 * @extends Memory
	 */
	return declare([Memory], {

		/**
		 * Performs data transformations of the underlying objects. The transforming function
		 * can either manipulate the object it is provided, or it can return the object that should
		 * be used. If it does return an object, it must share the same id as the object that it received.
		 *
		 * @param {function(*):*} transformer
		 * @param {object} [query={}]
		 */
		transform: function (transformer, query) {

			query = query || {};

			var items = this.query(query);

			items.forEach(lang.hitch(this, function (item) {

				var idProperty = this.idProperty;

				var originalId = item[idProperty];

				var result = transformer(item);
				item = result || item;

				var idAfterTransformation = item[idProperty];

				if(originalId !== idAfterTransformation){
					var error = 'You cannot perform a transformation that manipulates the id of an item in the store.';
					throw Error(error);
				} else {
					this.put(item, {overwrite: true});
				}

			}));

		}

	});

});

},
'dijit/layout/BorderContainer':function(){
define([
	"dojo/_base/array", // array.filter array.forEach array.map
	"dojo/cookie", // cookie
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove domClass.toggle
	"dojo/dom-construct", // domConstruct.destroy domConstruct.place
	"dojo/dom-geometry", // domGeometry.marginBox
	"dojo/dom-style", // domStyle.style
	"dojo/keys",
	"dojo/_base/lang", // getObject() hitch() delegate()
	"dojo/on",
	"dojo/touch",
	"../_WidgetBase",
	"../_Widget",
	"../_TemplatedMixin",
	"./LayoutContainer",
	"./utils"        // layoutUtils.layoutChildren
], function(array, cookie, declare, domClass, domConstruct, domGeometry, domStyle, keys, lang, on, touch,
			_WidgetBase, _Widget, _TemplatedMixin, LayoutContainer, layoutUtils){

	// module:
	//		dijit/layout/BorderContainer

	var _Splitter = declare("dijit.layout._Splitter", [_Widget, _TemplatedMixin ], {
		// summary:
		//		A draggable spacer between two items in a `dijit/layout/BorderContainer`.
		// description:
		//		This is instantiated by `dijit/layout/BorderContainer`.  Users should not
		//		create it directly.
		// tags:
		//		private

		/*=====
		 // container: [const] dijit/layout/BorderContainer
		 //		Pointer to the parent BorderContainer
		 container: null,

		 // child: [const] dijit/layout/_LayoutWidget
		 //		Pointer to the pane associated with this splitter
		 child: null,

		 // region: [const] String
		 //		Region of pane associated with this splitter.
		 //		"top", "bottom", "left", "right".
		 region: null,
		 =====*/

		// live: [const] Boolean
		//		If true, the child's size changes and the child widget is redrawn as you drag the splitter;
		//		otherwise, the size doesn't change until you drop the splitter (by mouse-up)
		live: true,

		templateString: '<div class="dijitSplitter" data-dojo-attach-event="onkeydown:_onKeyDown,press:_startDrag,onmouseenter:_onMouse,onmouseleave:_onMouse" tabIndex="0" role="separator"><div class="dijitSplitterThumb"></div></div>',

		constructor: function(){
			this._handlers = [];
		},

		postMixInProperties: function(){
			this.inherited(arguments);

			this.horizontal = /top|bottom/.test(this.region);
			this._factor = /top|left/.test(this.region) ? 1 : -1;
			this._cookieName = this.container.id + "_" + this.region;
		},

		buildRendering: function(){
			this.inherited(arguments);

			domClass.add(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V"));

			if(this.container.persist){
				// restore old size
				var persistSize = cookie(this._cookieName);
				if(persistSize){
					this.child.domNode.style[this.horizontal ? "height" : "width"] = persistSize;
				}
			}
		},

		_computeMaxSize: function(){
			// summary:
			//		Return the maximum size that my corresponding pane can be set to

			var dim = this.horizontal ? 'h' : 'w',
				childSize = domGeometry.getMarginBox(this.child.domNode)[dim],
				center = array.filter(this.container.getChildren(), function(child){
					return child.region == "center";
				})[0];

			// Can expand until center is crushed.  But always leave room for center's padding + border,
			//  otherwise on the next call domGeometry methods start to lie about size.
			var spaceAvailable = domGeometry.getContentBox(center.domNode)[dim] - 10;

			return Math.min(this.child.maxSize, childSize + spaceAvailable);
		},

		_startDrag: function(e){
			if(!this.cover){
				this.cover = domConstruct.place("<div class=dijitSplitterCover></div>", this.child.domNode, "after");
			}
			domClass.add(this.cover, "dijitSplitterCoverActive");

			// Safeguard in case the stop event was missed.  Shouldn't be necessary if we always get the mouse up.
			if(this.fake){
				domConstruct.destroy(this.fake);
			}
			if(!(this._resize = this.live)){ //TODO: disable live for IE6?
				// create fake splitter to display at old position while we drag
				(this.fake = this.domNode.cloneNode(true)).removeAttribute("id");
				domClass.add(this.domNode, "dijitSplitterShadow");
				domConstruct.place(this.fake, this.domNode, "after");
			}
			domClass.add(this.domNode, "dijitSplitterActive dijitSplitter" + (this.horizontal ? "H" : "V") + "Active");
			if(this.fake){
				domClass.remove(this.fake, "dijitSplitterHover dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover");
			}

			//Performance: load data info local vars for onmousevent function closure
			var factor = this._factor,
				isHorizontal = this.horizontal,
				axis = isHorizontal ? "pageY" : "pageX",
				pageStart = e[axis],
				splitterStyle = this.domNode.style,
				dim = isHorizontal ? 'h' : 'w',
				childCS = domStyle.getComputedStyle(this.child.domNode),
				childStart = domGeometry.getMarginBox(this.child.domNode, childCS)[dim],
				max = this._computeMaxSize(),
				min = Math.max(this.child.minSize, domGeometry.getPadBorderExtents(this.child.domNode, childCS)[dim] + 10),
				region = this.region,
				splitterAttr = region == "top" || region == "bottom" ? "top" : "left", // style attribute of splitter to adjust
				splitterStart = parseInt(splitterStyle[splitterAttr], 10),
				resize = this._resize,
				layoutFunc = lang.hitch(this.container, "_layoutChildren", this.child.id),
				de = this.ownerDocument;

			this._handlers = this._handlers.concat([
				on(de, touch.move, this._drag = function(e, forceResize){
					var delta = e[axis] - pageStart,
						childSize = factor * delta + childStart,
						boundChildSize = Math.max(Math.min(childSize, max), min);

					if(resize || forceResize){
						layoutFunc(boundChildSize);
					}
					// TODO: setting style directly (usually) sets content box size, need to set margin box size
					splitterStyle[splitterAttr] = delta + splitterStart + factor * (boundChildSize - childSize) + "px";
				}),
				on(de, "dragstart", function(e){
					e.stopPropagation();
					e.preventDefault();
				}),
				on(this.ownerDocumentBody, "selectstart", function(e){
					e.stopPropagation();
					e.preventDefault();
				}),
				on(de, touch.release, lang.hitch(this, "_stopDrag"))
			]);
			e.stopPropagation();
			e.preventDefault();
		},

		_onMouse: function(e){
			// summary:
			//		Handler for onmouseenter / onmouseleave events
			var o = (e.type == "mouseover" || e.type == "mouseenter");
			domClass.toggle(this.domNode, "dijitSplitterHover", o);
			domClass.toggle(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover", o);
		},

		_stopDrag: function(e){
			try{
				if(this.cover){
					domClass.remove(this.cover, "dijitSplitterCoverActive");
				}
				if(this.fake){
					domConstruct.destroy(this.fake);
				}
				domClass.remove(this.domNode, "dijitSplitterActive dijitSplitter"
					+ (this.horizontal ? "H" : "V") + "Active dijitSplitterShadow");
				this._drag(e); //TODO: redundant with onmousemove?
				this._drag(e, true);
			}finally{
				this._cleanupHandlers();
				delete this._drag;
			}

			if(this.container.persist){
				cookie(this._cookieName, this.child.domNode.style[this.horizontal ? "height" : "width"], {expires: 365});
			}
		},

		_cleanupHandlers: function(){
			var h;
			while(h = this._handlers.pop()){
				h.remove();
			}
		},

		_onKeyDown: function(/*Event*/ e){
			// should we apply typematic to this?
			this._resize = true;
			var horizontal = this.horizontal;
			var tick = 1;
			switch(e.keyCode){
				case horizontal ? keys.UP_ARROW : keys.LEFT_ARROW:
					tick *= -1;
//				break;
				case horizontal ? keys.DOWN_ARROW : keys.RIGHT_ARROW:
					break;
				default:
//				this.inherited(arguments);
					return;
			}
			var childSize = domGeometry.getMarginSize(this.child.domNode)[ horizontal ? 'h' : 'w' ] + this._factor * tick;
			this.container._layoutChildren(this.child.id, Math.max(Math.min(childSize, this._computeMaxSize()), this.child.minSize));
			e.stopPropagation();
			e.preventDefault();
		},

		destroy: function(){
			this._cleanupHandlers();
			delete this.child;
			delete this.container;
			delete this.cover;
			delete this.fake;
			this.inherited(arguments);
		}
	});

	var _Gutter = declare("dijit.layout._Gutter", [_Widget, _TemplatedMixin], {
		// summary:
		//		Just a spacer div to separate side pane from center pane.
		//		Basically a trick to lookup the gutter/splitter width from the theme.
		// description:
		//		Instantiated by `dijit/layout/BorderContainer`.  Users should not
		//		create directly.
		// tags:
		//		private

		templateString: '<div class="dijitGutter" role="presentation"></div>',

		postMixInProperties: function(){
			this.inherited(arguments);
			this.horizontal = /top|bottom/.test(this.region);
		},

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode, "dijitGutter" + (this.horizontal ? "H" : "V"));
		}
	});

	var BorderContainer = declare("dijit.layout.BorderContainer", LayoutContainer, {
		// summary:
		//		A BorderContainer is a `dijit/LayoutContainer` that can have draggable splitters between the children,
		//		in order to adjust their sizes.
		//
		//		In addition, it automatically adds some space between the children even
		//		if they don't have a draggable splitter between them, and space between the edge of the BorderContainer
		//		and the children that are adjacent to the edge.  Note that the intended style is that all the children
		//		have borders, but (despite the name) the BorderContainer itself does not.
		//
		//		See `BorderContainer.ChildWidgetProperties` for details on the properties that can be set on
		//		children of a `BorderContainer`.

		// gutters: [const] Boolean
		//		Give each pane a border and margin.
		//		Margin determined by domNode.paddingLeft.
		//		When false, only resizable panes have a gutter (i.e. draggable splitter) for resizing.
		gutters: true,

		// liveSplitters: [const] Boolean
		//		Specifies whether splitters resize as you drag (true) or only upon mouseup (false)
		liveSplitters: true,

		// persist: Boolean
		//		Save splitter positions in a cookie.
		persist: false,

		baseClass: "dijitBorderContainer",

		// _splitterClass: Function||String
		//		Optional hook to override the default Splitter widget used by BorderContainer
		_splitterClass: _Splitter,

		postMixInProperties: function(){
			// change class name to indicate that BorderContainer is being used purely for
			// layout (like LayoutContainer) rather than for pretty formatting.
			if(!this.gutters){
				this.baseClass += "NoGutter";
			}
			this.inherited(arguments);
		},

		_setupChild: function(/*dijit/_WidgetBase*/ child){
			// Override LayoutContainer._setupChild().

			this.inherited(arguments);

			var region = child.region, ltr = child.isLeftToRight();
			if(region == "leading"){
				region = ltr ? "left" : "right";
			}
			if(region == "trailing"){
				region = ltr ? "right" : "left";
			}

			if(region){
				// Create draggable splitter for resizing pane,
				// or alternately if splitter=false but BorderContainer.gutters=true then
				// insert dummy div just for spacing
				if(region != "center" && (child.splitter || this.gutters) && !child._splitterWidget){
					var _Splitter = child.splitter ? this._splitterClass : _Gutter;
					if(lang.isString(_Splitter)){
						_Splitter = lang.getObject(_Splitter);	// for back-compat, remove in 2.0
					}
					var splitter = new _Splitter({
						id: child.id + "_splitter",
						container: this,
						child: child,
						region: region,
						live: this.liveSplitters
					});
					splitter.isSplitter = true;
					child._splitterWidget = splitter;

					// Make the tab order match the visual layout by placing the splitter before or after the pane,
					// depending on where the splitter is visually compared to the pane.
					var before = region == "bottom" || region == (this.isLeftToRight() ? "right" : "left");
					domConstruct.place(splitter.domNode, child.domNode, before ? "before" : "after");

					// Splitters aren't added as Contained children, so we need to call startup explicitly
					splitter.startup();
				}
			}
		},

		layout: function(){
			// Implement _LayoutWidget.layout() virtual method.
			this._layoutChildren();
		},

		removeChild: function(/*dijit/_WidgetBase*/ child){
			// Override _LayoutWidget.removeChild().

			var splitter = child._splitterWidget;
			if(splitter){
				splitter.destroy();
				delete child._splitterWidget;
			}

			this.inherited(arguments);
		},

		getChildren: function(){
			// Override _LayoutWidget.getChildren() to only return real children, not the splitters.
			return array.filter(this.inherited(arguments), function(widget){
				return !widget.isSplitter;
			});
		},

		// TODO: remove in 2.0
		getSplitter: function(/*String*/region){
			// summary:
			//		Returns the widget responsible for rendering the splitter associated with region
			// tags:
			//		deprecated
			return array.filter(this.getChildren(), function(child){
				return child.region == region;
			})[0]._splitterWidget;
		},

		resize: function(newSize, currentSize){
			// Overrides _LayoutWidget.resize().

			// resetting potential padding to 0px to provide support for 100% width/height + padding
			// TODO: this hack doesn't respect the box model and is a temporary fix
			if(!this.cs || !this.pe){
				var node = this.domNode;
				this.cs = domStyle.getComputedStyle(node);
				this.pe = domGeometry.getPadExtents(node, this.cs);
				this.pe.r = domStyle.toPixelValue(node, this.cs.paddingRight);
				this.pe.b = domStyle.toPixelValue(node, this.cs.paddingBottom);

				domStyle.set(node, "padding", "0px");
			}

			this.inherited(arguments);
		},

		_layoutChildren: function(/*String?*/ changedChildId, /*Number?*/ changedChildSize){
			// summary:
			//		This is the main routine for setting size/position of each child.
			// description:
			//		With no arguments, measures the height of top/bottom panes, the width
			//		of left/right panes, and then sizes all panes accordingly.
			//
			//		With changedRegion specified (as "left", "top", "bottom", or "right"),
			//		it changes that region's width/height to changedRegionSize and
			//		then resizes other regions that were affected.
			// changedChildId:
			//		Id of the child which should be resized because splitter was dragged.
			// changedChildSize:
			//		The new width/height (in pixels) to make specified child

			if(!this._borderBox || !this._borderBox.h){
				// We are currently hidden, or we haven't been sized by our parent yet.
				// Abort.   Someone will resize us later.
				return;
			}

			// Combining the externally specified children with splitters and gutters
			var childrenAndSplitters = [];
			array.forEach(this._getOrderedChildren(), function(pane){
				childrenAndSplitters.push(pane);
				if(pane._splitterWidget){
					childrenAndSplitters.push(pane._splitterWidget);
				}
			});

			// Compute the box in which to lay out my children
			var dim = {
				l: this.pe.l,
				t: this.pe.t,
				w: this._borderBox.w - this.pe.w,
				h: this._borderBox.h - this.pe.h
			};

			// Layout the children, possibly changing size due to a splitter drag
			layoutUtils.layoutChildren(this.domNode, dim, childrenAndSplitters,
				changedChildId, changedChildSize);
		},

		destroyRecursive: function(){
			// Destroy splitters first, while getChildren() still works
			array.forEach(this.getChildren(), function(child){
				var splitter = child._splitterWidget;
				if(splitter){
					splitter.destroy();
				}
				delete child._splitterWidget;
			});

			// Then destroy the real children, and myself
			this.inherited(arguments);
		}
	});

	BorderContainer.ChildWidgetProperties = {
		// summary:
		//		These properties can be specified for the children of a BorderContainer.

		// splitter: [const] Boolean
		//		Parameter for children where region != "center".
		//		If true, enables user to resize the widget by putting a draggable splitter between
		//		this widget and the region=center widget.
		splitter: false,

		// minSize: [const] Number
		//		Specifies a minimum size (in pixels) for this widget when resized by a splitter.
		minSize: 0,

		// maxSize: [const] Number
		//		Specifies a maximum size (in pixels) for this widget when resized by a splitter.
		maxSize: Infinity
	};
	lang.mixin(BorderContainer.ChildWidgetProperties, LayoutContainer.ChildWidgetProperties);

	// Since any widget can be specified as a BorderContainer child, mix it
	// into the base widget class.  (This is a hack, but it's effective.)
	// This is for the benefit of the parser.   Remove for 2.0.  Also, hide from doc viewer.
	lang.extend(_WidgetBase, /*===== {} || =====*/ BorderContainer.ChildWidgetProperties);

	// For monkey patching
	BorderContainer._Splitter = _Splitter;
	BorderContainer._Gutter = _Gutter;

	return BorderContainer;
});

},
'dijit/layout/LayoutContainer':function(){
define([
	"dojo/_base/array",
	"dojo/_base/declare", // declare
	"dojo/dom-class",
	"dojo/dom-style",
	"dojo/_base/lang",
	"../_WidgetBase",
	"./_LayoutWidget",
	"./utils" // layoutUtils.layoutChildren
], function(array, declare, domClass, domStyle, lang, _WidgetBase, _LayoutWidget, layoutUtils){

	// module:
	//		dijit/layout/LayoutContainer

	var LayoutContainer = declare("dijit.layout.LayoutContainer", _LayoutWidget, {
		// summary:
		//		A LayoutContainer is a box with a specified size, such as style="width: 500px; height: 500px;",
		//		that contains a child widget marked region="center" and optionally children widgets marked
		//		region equal to "top", "bottom", "leading", "trailing", "left" or "right".
		//		Children along the edges will be laid out according to width or height dimensions. The remaining
		//		space is designated for the center region.
		//
		//		The outer size must be specified on the LayoutContainer node.  Width must be specified for the sides
		//		and height for the top and bottom, respectively.  No dimensions should be specified on the center;
		//		it will fill the remaining space.  Regions named "leading" and "trailing" may be used just like
		//		"left" and "right" except that they will be reversed in right-to-left environments.
		//
		//		For complex layouts, multiple children can be specified for a single region.   In this case, the
		//		layoutPriority flag on the children determines which child is closer to the edge (low layoutPriority)
		//		and which child is closer to the center (high layoutPriority).   layoutPriority can also be used
		//		instead of the design attribute to control layout precedence of horizontal vs. vertical panes.
		//
		//		See `LayoutContainer.ChildWidgetProperties` for details on the properties that can be set on
		//		children of a `LayoutContainer`.
		//
		//		If layoutPriority is not set, lays out each child in the natural order the children occur in.
		//		Basically each child is laid out into the "remaining space", where "remaining space" is initially
		//		the content area of this widget, but is reduced to a smaller rectangle each time a child is added.

		// design: String
		//		Which design is used for the layout:
		//
		//		- "headline" (default) where the top and bottom extend the full width of the container
		//		- "sidebar" where the left and right sides extend from top to bottom.
		//
		//		However, a `layoutPriority` setting on child panes overrides the `design` attribute on the parent.
		//		In other words, if the top and bottom sections have a lower `layoutPriority` than the left and right
		//		panes, the top and bottom panes will extend the entire width of the box.
		design: "headline",

		baseClass: "dijitLayoutContainer",

		startup: function(){
			if(this._started){
				return;
			}
			array.forEach(this.getChildren(), this._setupChild, this);
			this.inherited(arguments);
		},

		_setupChild: function(/*dijit/_WidgetBase*/ child){
			// Override _LayoutWidget._setupChild().

			this.inherited(arguments);

			var region = child.region;
			if(region){
				domClass.add(child.domNode, this.baseClass + "Pane");
			}
		},

		_getOrderedChildren: function(){
			// summary:
			//		Return list of my children in the order that I want layoutChildren()
			//		to process them (i.e. from the outside to the inside)

			var wrappers = array.map(this.getChildren(), function(child, idx){
				return {
					pane: child,
					weight: [
						child.region == "center" ? Infinity : 0,
						child.layoutPriority,
						(this.design == "sidebar" ? 1 : -1) * (/top|bottom/.test(child.region) ? 1 : -1),
						idx
					]
				};
			}, this);
			wrappers.sort(function(a, b){
				var aw = a.weight, bw = b.weight;
				for(var i = 0; i < aw.length; i++){
					if(aw[i] != bw[i]){
						return aw[i] - bw[i];
					}
				}
				return 0;
			});

			return array.map(wrappers, function(w){ return w.pane; });
		},

		layout: function(){
			layoutUtils.layoutChildren(this.domNode, this._contentBox, this._getOrderedChildren());
		},

		addChild: function(/*dijit/_WidgetBase*/ child, /*Integer?*/ insertIndex){
			this.inherited(arguments);
			if(this._started){
				this.layout();
			}
		},

		removeChild: function(/*dijit/_WidgetBase*/ child){
			this.inherited(arguments);
			if(this._started){
				this.layout();
			}

			// Clean up whatever style changes we made to the child pane.
			// Unclear how height and width should be handled.
			domClass.remove(child.domNode, this.baseClass + "Pane");
			domStyle.set(child.domNode, {
				top: "auto",
				bottom: "auto",
				left: "auto",
				right: "auto",
				position: "static"
			});
			domStyle.set(child.domNode, /top|bottom/.test(child.region) ? "width" : "height", "auto");
		}
	});

	LayoutContainer.ChildWidgetProperties = {
		// summary:
		//		These properties can be specified for the children of a LayoutContainer.

		// region: [const] String
		//		Values: "top", "bottom", "leading", "trailing", "left", "right", "center".
		//		See the `dijit/layout/LayoutContainer` description for details.
		region: '',

		// layoutAlign: [const deprecated] String
		//		Synonym for region, except using "client" instead of "center".  Deprecated; use region instead.
		layoutAlign: '',

		// layoutPriority: [const] Number
		//		Children with a higher layoutPriority will be placed closer to the LayoutContainer center,
		//		between children with a lower layoutPriority.
		layoutPriority: 0
	};

	// Since any widget can be specified as a LayoutContainer child, mix it
	// into the base widget class.  (This is a hack, but it's effective.)
	// This is for the benefit of the parser.   Remove for 2.0.  Also, hide from doc viewer.
	lang.extend(_WidgetBase, /*===== {} || =====*/ LayoutContainer.ChildWidgetProperties);

	return LayoutContainer;
});

},
'pepper/dialogs/info/TemplateSelectorList':function(){
define([
    'lodash',
    'module', 'vodori/provide',
    'dijit/_WidgetBase',
    'vodori/ui/grid/_BaseGrid',
    'vodori/ui/grid/GridFactory!keyboard,selection',
    'pepper/ui/handleNotification'
], function (_, module, provide, _WidgetBase, _BaseGrid, GridModules, handleNotification) {

    return provide(module, _.flatten([_WidgetBase, GridModules, _BaseGrid]), {
        selectionMode: 'single',
        _reportDisallowedSelection: handleNotification
    });
});

},
'vodori/ui/grid/_BaseGrid':function(){
/**
 * @module vodori/ui/grid/_BaseGrid
 */
define([
    'lodash',
    'dojo/_base/declare', 'dojo/_base/lang',
    'dojo/dom', 'dojo/dom-class',
    'dojo/aspect', 'dojo/on', 'dojo/query', 'dojo/when',
    'dojo/Stateful',
    'dojo/store/Memory', 'dojo/store/Observable',
    '../../data/ForestStore',
    'dgrid/tree'
], function (_,
             declare, lang,
             dom, domClass,
             aspect, on, query, when,
             Stateful,
             Memory, Observable,
             ForestStore,
             tree) {

    var DEFAULT_MIN_ROWS = 25;
    var RESIZE_DEBOUNCE_PERIOD = 250;
    // This is a simple wrapper for the dgrid.
    // It's also layout widget, so use it like you'd use a ContentPane.

    // This is a nice guide to the mighty dgrid:
    // http://www.sitepen.com/blog/2011/10/26/introducing-the-next-grid-dgrid
    //noinspection JSUnusedLocalSymbols,JSUnusedGlobalSymbols

    /**
     * The _BaseGrid is a foundational mixin that provides the general grid functionality that we want to use in our
     * Vodori grids.
     *
     * @lends module:vodori/ui/grid/_BaseGrid#
     */
    var _BaseGrid = {

        selectionMode: 'extended',       // If selections are enabled, whether to make selections 'single' or 'extended'
        selectionLimit: -1,              // If greater than -1, the grid will limit how many selections you can make
        minRowsPerPage: DEFAULT_MIN_ROWS,   // Number of rows to load per request

        columns: null,  // Set up columns here
        treeColumn: -1, // Index of the "tree" column, if it's not set in the columns array.

        noDataMessage: '',

        store: null, // A data store
        query: null, // A query in that data store

        /**
         * When true, calls to refresh will have no effect. However, if refresh is
         * called while paused, a refresh will occur as soon as this is switched to false.
         * @type {boolean}
         */
        _refreshPaused: false,

        /**
         * Keeps track of whether refresh is called while refresh is paused.
         * @type {boolean}
         * @private
         */
        _refreshHasBeenCalledSincePaused: false,

        /**
         * Foundation for a store, if one is not already defined
         *  @type Array
         */
        array: null, // (Optional) Converted to a store if no store is set

        /**
         *
         * @type Array.<Object>
         */
        selectedItems: null, // An array of the currently selected rows

        /**
         *
         * @type Array.<string>
         */
        selectedIds: null, // An array of the current selected rows' ids

        /**
         *
         * @type Array.<Object>
         */
        reselect: null, // To hold an array of items that should be selected after a refresh

        disabled: false,     // Disables interaction with the grid

        /**
         * @type {string}
         */
        baseClass: null,  // a CSS class that will be appended to the root node of the grid

        _expanderIconClass: 'dgrid-expando-icon', // The general CSS class of the tree expander icon
        _expandedNodeIconClass: 'ui-icon-triangle-1-se', // The CSS class of the tree expander icon when expanded

        /**
         * @ignore
         */
        constructor: function () {
            this.selectedItems = [];
            this.selectedIds = [];
            this.reselect = [];
        },

        /**
         * @ignore
         */
        postMixInProperties: function () {
            this.inherited(arguments);
            // If this.treeColumn is an index, set up the tree column.
            // You could also set a standard tree column in the columns array.
            if (this.treeColumn >= 0) {
                this.setUpTree();
            }
            // Make sure we're working with a store, not an array.
            // If we think we're dealing with a tree, make a ForestStore.
            if (!this.store) {
                var arrayContainsParents = _.some(this.array, function (item) {
                    return 'children' in item;
                });
                var StoreType = (this.treeColumn >= 0 || arrayContainsParents) ? ForestStore : Memory;

                //noinspection NestedFunctionCallJS
                this.store = new Observable(new StoreType({
                    data: this.array || []
                }));

                this.array = null;
            }

            this._chosenSelectionMode = this.selectionMode;
        },

        /**
         * @ignore
         */
        buildRendering: function () {
            this.inherited(arguments);
            this.containerNode = this.domNode; // For the _ResizeMixin
        },

        /**
         * @ignore
         */
        postCreate: function () {
            this.inherited(arguments);

            if (this.baseClass) {
                domClass.add(this.domNode, this.baseClass);
            }

            this._renderRowList = this.renderRow;

            this._connectToGrid();
        },

        /**
         *
         * @param {string|Row} row row or something that can be turned into a row by this.row.
         * @param {?Object} options options to pass to ancestor methods.
         * @return {Row} the row after it has been rendered.
         */
        renderRow: function (row, options) {
            var args = _.toArray(arguments);
            args[0] = this.preRenderRow(row);

            var rendered = this.inherited(arguments, args);

            return this.postRenderRow(rendered, row);
        },

        /**
         * A hook for mutating the data prior to rendering.
         *
         * @param {*} row Grid row.
         * @return {*} the same Grid row.
         */
        preRenderRow: function (row) {
            return row;
        },

        /**
         * A hook for mutating the rendered DOM.
         *
         * @param {Element} rendered Rendered element that represents the row.
         * @param {*} row Grid row.
         * @return {*} the rendered Element.
         */
        postRenderRow: function (rendered, row) {
            return rendered;
        },

        /**
         * @private
         */
        _connectToGrid: function () {
            // Prevent expanding/collapsing a tree row from changing the selection.
            // NOTE: This only works if a treeColumn is specified.
            if (this.treeColumn >= 0) {
                this.own(aspect.after(this.columns[this.treeColumn], 'renderCell', function (object, value, td) {
                    var expanderIcon = query('.dgrid-expando-icon', td)[0];
                    if (expanderIcon) {
                        on(expanderIcon, 'mousedown', function (evt) {
                            evt.stopPropagation();
                            evt.preventDefault();
                        });
                        on(expanderIcon, 'mouseup', this._handleExpand);
                    }
                }));
            }
        },

        /**
         *
         * @return {*} the rendered array.
         */
        renderArray: function () {

            this.renderBegin(arguments);

            var results = this.inherited(arguments);

            return this._postRenderArray(results);
        },

        /**
         * Hook to be run when the grid is shown
         */
        onShow: function () {
            this.inherited(arguments);
            this.startup();
        },

        /**
         * Converts the grid into a tree by adding the dgrid tree plugin to the specified tree column
         */
        setUpTree: function () {
            // Set up the tree column.
            this.columns[this.treeColumn] = tree(this.columns[this.treeColumn]);

            // Define a default getChildren function if the object store does not support it
            if (!this.store.getChildren) {
                this.store.getChildren = function (item) {
                    return item.children;
                };
            }

            // Define a default mayHaveChildren function if the object store does not support it
            if (!this.store.mayHaveChildren) {
                this.store.mayHaveChildren = function (item) {
                    return item.children && item.children.length > 0;
                };
            }
        },

        resize: function () {
            if (arguments.length > 0) {
                // don't use debounced version if there are arguments.
                this.inherited(arguments);
            } else {
                var debouncedResize = this._getDebouncedResize();
                debouncedResize(arguments);
            }
        },

        _getDebouncedResize: function() {
            if (!this._debouncedResize) {
                this._debouncedResize = _.debounce(lang.hitch(this, function (args) {
                    this.inherited('resize', args);
                }), RESIZE_DEBOUNCE_PERIOD);
            }
            return this._debouncedResize;
        },

        /**
         *
         *
         * @return {Array.<string>} a list of all of the selected ids; elements are unique.
         * @private
         */
        _buildSelectedIds: function () {
            'use strict';
            //noinspection ChainedFunctionCallJS
            return _(this.selection)
                .map(function (selected, id) {
                    return (selected) ? id : null;
                })
                .compact()
                .uniq()
                .value();
        },

        /**
         * Selects all items in the grid, and fills the selected items list
         * with the ids of the items in the dgrid's selection list (which should
         * be all of them after the call to dgrid.selectAll()).
         */
        selectAll: function () {
            // Select all items in the dgrid
            this.inherited(arguments);

            // Push all of the ids of the dgrid's selection list to the selected
            // items list to reflect that they have all been selected.
            //noinspection NestedFunctionCallJS
            this.set('selectedIds', this._buildSelectedIds());
        },

        /**
         * Deselects all items in the grid, and clears the selected items list
         */
        selectNone: function () {
            this.clearSelection();
            this.set('selectedIds', []);
        },

        /**
         *
         * @private
         */
        _onChange: function () {
            //noinspection ChainedFunctionCallJS
            var selectedIds = this._buildSelectedIds().sort();

            // Only fire "onChange" if the selection actually changed,
            // and change the selected items list to what is currently selected.
            //noinspection ChainedFunctionCallJS
            if (selectedIds.join(',') !== this.selectedIds.sort().join(',')) {
                this.set('selectedIds', selectedIds);
                this.onChange(this.selectedIds);
            }
        },

        /**
         * Called before the dgrid is refreshed. Will handle prepping the grid for
         * reselecting nodes and/or expanding a specified tree node
         *
         * @param {?string} expandNode object id of a folder we want to explicitly expand.
         */
        _onRefresh: function (/* String */ expandNode) {
            this._pushSelectionsToReselect(null);
        },

        // Argument is an array of selected items' IDs.
        // Use get('selectedItems') for the actual objects.
        onChange: function (selectedIds) {
            // "Hey, something changed!"
        },

        /**
         * Called after the grid's rows have been rendered. Calls the
         * custom "renderComplete" event.
         *
         * @param {Deferred} rowsRendered  a promise to when the rows have been rendered.
         */
        _postRenderArray: function (/* Deferred */ rowsRendered) {
            // When the rows have been rendered, fire the event
            //noinspection NestedFunctionCallJS
            when(rowsRendered, lang.hitch(this, function () {
                this.renderComplete.apply(this, arguments);
            }));

            return rowsRendered; // This is important since this is an aspect
        },

        /**
         * Called when the grid's rows have been rendered and are ready to
         * be manipulated. Hook here.
         *
         * @param {Array} rows an array of DOM nodes for each row.
         */
        renderComplete: function (rows) {
            // Reselect saved selections in this.reselect
            this._makeSelections();
        },

        /**
         * Called when the grid begins rendering. Hook here to get
         * the results
         *
         * @param {Array} results   the array of results.
         */
        renderBegin: function (results) {
            // Stuff
        },

        /**
         * Refresh the dgrid
         *
         * @param {?string} expandFolder  the object id of a folder node to expand in a tree.
         */
        refresh: function (/* String */ expandFolder) {
            if (this._refreshPaused) {
                this._refreshHasBeenCalledSincePaused = true;
                return;
            }
            this._onRefresh(arguments);

            return this.inherited(arguments);
        },

        /**
         * Refresh the grid and select items with matching IDs
         *
         * @param {?Array.<string>} selections an array of IDs.
         */
        refreshAndSelect: function (/* Array */ selections) {
            // Add selections to the reselect list
            this._pushSelectionsToReselect(selections);

            this.refresh();
        },

        /**
         * Selects the selections in this.reselect. This is called multiple times in tree grids because
         * child nodes call renderArray for each new tree level.
         */
        _makeSelections: function () {
            var notRendered = [];

            _.forEach(this.reselect, function (reselect) {
                var row = this.row(reselect);

                // If the row has not been rendered yet, keep track of it for the next pass
                if (!row.data || !row.element) {
                    notRendered.push(reselect);
                    return;
                }

                this.select(row);
            }, this);

            this.reselect = notRendered;
        },

        /**
         * Add the current selections or given selections to the reselect array
         *
         * @param {?Array.<string>} selections an array of selections to make.
         */
        _pushSelectionsToReselect: function (/* Array */ selections) {
            // Use either the selections array or the currently selected items if selections is not an array
            var selectionArray = (_.isArray(selections) && selections) || this.get('selectedItems');

            // Add the selections to the reselect array
            //noinspection NestedFunctionCallJS
            this.reselect.push(_.map(selectionArray, function (selection) {
                // Need to handle the case when selection is an object or just a string
                return selection.objectId || selection;
            }));
        },

        /**
         * Hook in some special functionality when the user expands the tree to fix some bugs
         *
         * @param {MouseEvent} mouseEvent the MouseEvent from clicking on the expander icon.
         */
        _handleExpand: function (mouseEvent) {
            // Prevent selecting the row
            mouseEvent.stopPropagation();
            mouseEvent.preventDefault();

            if (domClass.contains(mouseEvent.target, this._expandedNodeIconClass)) {
                // If collapsing a tree node, check to see if the currently selected item belongs
                // in the collapsed nodes. If yes, then deselect it
                // NOTE: this will most likely blow up if we allow multiselections in trees
                var row = this.row(mouseEvent.target);
                var isSelected = _.some(this.selectedIds, function (selection) {
                    return selection === row.id;
                });

                if (!isSelected) {
                    this.reset();
                }
            } else {
                // If expanding the tree node, add the current selection to the reselect array
                // so the selection will be preserved on node expand
                this._pushSelectionsToReselect(null);
            }
        },

        /**
         * Returns references to the actual selected objects in the store.
         * @return {Array} currently selected objects from the grid.
         * @private
         */
        _getSelectedItems: function () {
            return  _.compact(_.map(this.selection, function (selected, id) {
                'use strict';
                return selected ? this.row(id).data : undefined;
            }, this));

        },

        /**
         * Set the current selection by passing IDs
         * @param {Array.<string>} ids IDs of rows that the user wishes to select.
         * @private
         */
        _setSelectedItems: function (ids) {

            this.clearSelection();
            _.forEach(ids, function (id) {
                // Check to see if the row exists
                var row = this.row(id);

                // If the row has been deleted, move on
                if (!row.data) {
                    return;
                }

                // If this is a tree grid, the row might not be visible
                if (this.treeColumn > -1) {
                    // If the row isn't visible, expand the tree before selecting it!
                    if (!row.element) {
                        this.toggleRow(id, true);
                    }
                }

                this.select(id);
            }, this);
        },

        /**
         *
         * @return {Array} Paths to the currently selected items.
         * @private
         */
        _getSelectedPaths: function () {
            //noinspection NestedFunctionCallJS
            return _.map(this.get('selectedItems'), this.store.getPath, this.store);
        },

        /**
         *
         * @param {Array} paths new value for selectedPaths.
         * @private
         */
        _setSelectedPaths: function (paths) {
            var selection = [];

            _.forEach(paths, function (path) {
                selection.push(path[path.length - 1]);

                _.forEach(path, function (segment) {
                    this.toggleRow(segment, true);
                }, this);
            }, this);

            this.set('selectedItems', selection);
        },

        /**
         * Toggle the collapsed state of a tree row.
         * @param {Row} object the row to toggle.
         * @param {?boolean} expand  to expand or not - default to toggle the expansion.
         */
        toggleRow: function (object, expand) {
            var row = this.row(object);
            var rowNode = row.element;
            if (!rowNode) {
                if (this.store) {
                    var path = this._determinePathToRow(row, this.store.idProperty);

                    _.forEach(path, function (x) {
                        var node = dom.byId(this.id + '-row-' + x);
                        this._toggleRow(node, expand);
                    }, this);
                }
                return;
            }

            this._toggleRow(rowNode, expand);
        },

        /**
         * Toggles a tree node
         *
         * @param {Node} rowNode the row to toggle.
         * @param {?boolean} expand  force the row to be expanded.
         */
        _toggleRow: function (/* DOM node */ rowNode, /* boolean */ expand) {
            var expando = query(this._expanderIconClass, rowNode)[0];

            if (!expando) { // Not a tree row!
                return;
            }

            // If we don't pass in a value, toggle it.
            if (_.isUndefined(expand)) {
                //noinspection AssignmentToFunctionParameterJS
                expand = !expando.expanded;
            }

            // Seriously, dgrid sets an "expanded" property right on the DOM node.
            //noinspection JSHint
            if (Boolean(expando.expanded) === Boolean(!!expand)) {
                return;
            }

            // Finally expand the row!
            this.expand(expando, true);
        },

        /**
         * Takes a row which is currently not actually visible, and creates a path to that row. The path is an array
         * of objectIds. Note that the returned array will not include the array of the row at the end
         *
         * @param {Row} row the row to ultimately expand.
         * @param {string} idProperty the property to use for the ID in the row object.
         */
        _determinePathToRow: function (row, idProperty) {
            var traverse = true;
            var path = [];
            while (traverse) {
                var data = this.store.get(row.id);
                if (data && data._parent) {
                    var id = data._parent[idProperty];
                    row = this.row(id);
                    path.push(id);
                } else {
                    traverse = false;
                }
            }
            path.reverse();
            return path;
        },

        /**
         *
         * @param {Array<string|Row>} idOrRows  a list of grid rows.
         * @return {Array<string>} a list of IDs.
         * @private
         */
        _convertToObjectIds: function (idOrRows) {
            'use strict';
            return _.map(idOrRows, function (idOrRow) {
                return _.isString(idOrRow) ? idOrRow : this.row(idOrRow).id;
            }, this);
        },

        /**
         * Change the query on the Dgrid and refresh it.
         */
        _setQuery: function (query) {
            this.query = query;
            if (this._started) {
                this.refresh();
            }
        },

        /**
         * When paused, calls to refresh will have no effect. However, if refresh is
         * called while paused, a refresh will occur as soon as refreshing is resumed.
         * @see resumeRefreshing()
         * @see _refreshPaused
         */
        pauseRefreshing: function () {
            this._refreshPaused = true;
        },

        /**
         * Resume from pause. When paused, calls to refresh will have no effect. However, if refresh
         * was called while paused, a refresh will occur as soon as refreshing is resumed.
         * @see pauseRefreshing()
         * @see _refreshPaused
         */
        resumeRefreshing: function () {
            this._refreshPaused = false;

            if (this._refreshHasBeenCalledSincePaused) {
                this._refreshHasBeenCalledSincePaused = false;
                this.refresh();
            }
        },

        /**
         *
         * @param {boolean} disabled new value for disabled.
         * @private
         */
        _setDisabled: function (disabled) {
            this.disabled = disabled;
            domClass.toggle(this.domNode, 'disabled', disabled);
            this.set('selectionMode', disabled ? 'none' : this._chosenSelectionMode);
        },

        /**
         * Reset the selection.
         */
        reset: function () {
            this.set('selectedItems', []);
            this._lastSelected = null;
        },

        /**
         * Provide a shortcut for attaching an event handler. Attaches it to the domNode, since this is where events
         * will be emitted from.
         *
         * However, if this is a dgrid event, we pass the handling down to the dgrid itself
         *
         * @param {String|Function} type This is the name of the event to listen for or an extension event type.
         * @param {Function} listener This is the function that should be called when the event fires.
         * @return {Object} handle for dettaching event handler.
         */
        on: function (type, listener) {
            var isDgridEvent = (typeof type) === 'string' && type.indexOf('dgrid-') === 0;
            if (isDgridEvent) {
                return this.inherited(arguments);
            }
            else {
                var args = _.flatten([this.domNode].concat(_.toArray(arguments)));
                return on.apply(null, args);
            }
        }
    };

    /**
     * This is the Vodori mixin for controlling Selection within a dgrid grid.
     *
     * Primarily, it synthesizes the `selectionChanged` event for us,
     * as well as allowing selection and deselection by object ID. It also supports limiting the maximum number of
     * rows that users can select.
     *
     * @mixin vodori/ui/grid/_BaseGrid
     * @extends dojo/Stateful
     */
    return declare([Stateful], _BaseGrid);
});

},
'vodori/data/ForestStore':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/store/Memory',
    'dojo/store/util/QueryResults'
], function (provide, module, _, Memory, QueryResults) {
    /**
     * This Store stores data in tree form. It can actually store multiple trees. Hence.. ForestStore :)
     *
     * @class vodori/data/ForestStore
     * @extends dojo/store/Memory
     */
    return provide(module.id, [Memory],
        /**
         * @lends vodori/data/ForestStore.prototype
         */
        {

            // Identifier for an item's parent. This gets applied by the store.
            parentProperty: '_parent',

            // Identifier for an item's children. This comes with the data.
            childrenProperty: 'children',

            // Map of IDs to objects, regardless of their nesting depth or order.
            flatData: null,

            // NOTE: This store keeps track of its objects three ways:
            //
            // this.data
            // An array of root nodes
            // Part of the Memory store
            //
            // this.index
            // An object mapping an object's ID to its index in this.data
            // Also part of the Memory store
            //
            // this.flatData
            // A flattened map of IDs to objects
            // Unique to the ForestStore

            /**
             * Called on init. Will traverse the data trees and assign parent relations with children
             *
             * @param data  the data to process
             */
            setData: function (data) {
                this.flatData = {};

                // Traverse the trees and make parent-child associations
                _.forEach(data, function (object) {
                    this._assignParentToChild(null, object);
                }, this);

                this.inherited(arguments);
            },

            /**
             * Traverse the tree recursively and inform a node of its parent object
             * and register it in the flat "deepData" property.
             * NOTE: The original object is modified.
             * @private
             **/
            _assignParentToChild: function (parent, child) {
                // Add this node to the flatData object
                this.flatData[child[this.idProperty]] = child;

                // Assign the parent reference
                child[this.parentProperty] = parent;

                // Traverse the child nodes
                if (child[this.childrenProperty]) {
                    _.forEach(child[this.childrenProperty], function (subChild) {
                        this._assignParentToChild(child, subChild);
                    }, this);
                }
            },

            /**
             * Overridden so we can get an object by its ID or by an object containing the ID
             *
             * @param {(string|Object)} id the ID or an object containing the ID.
             * @returns {Object} the object requested.
             */
            get: function (/* String or Object */ id) {
                if (typeof id === 'object' && this.idProperty in id) {
                    return this.get(id[this.idProperty]);
                }

                return this.flatData[id];
            },

            // Get all the items up the object's "_parent" tree.
            getPath: function (object) {
                var path = [];

                var parent = object;
                while (parent) {
                    path.unshift(parent);
                    parent = parent[this.parentProperty];
                }

                return path;
            },

            /**
             * Update an object.
             * This is also called by "add".
             * @param {Object} object The object to put.
             * @param {Object} options   contains the overwrite option if the node should overwrite an old one.
             * @return {string} the ID of the appended object
             */
            put: function (object, options) {
                return this._appendToTree(object, options);
            },

            /**
             * The logic for adding or updating a node to the tree is here
             *
             * @param {Object} object    the node to add.
             * @param {Object} options   contains the overwrite option if the node should overwrite an old one.
             * @return {string} the ID of the appended object
             * @private
             */
            _appendToTree: function (object, options) {
                // Generate or get a unique id for this node
                var id = Math.random();
                if (options && 'id' in options) {
                    id = options.id;
                }
                if (this.idProperty in object) {
                    id = object[this.idProperty];
                }

                if (id in this.flatData) {
                    // An object already exists with this ID.
                    if (options && options.overwrite === false) {
                        // This call came from "add", not "put", so don't update it.
                        throw new Error('Object already exists');
                    } else {
                        // Update an existing object.
                        // We'll need to change its parent's "children" array, too.
                        var parent = this.flatData[id][this.parentProperty];
                        for (var i = 0; i < parent[this.childrenProperty].length; i++) {
                            if (parent[this.childrenProperty][i][this.idProperty] === id) {
                                parent[this.childrenProperty].splice(i, 1, object);
                                break;
                            }
                        }

                        this.flatData[id] = object;
                    }
                } else {
                    // Add a brand new object to the root level.
                    this.data.push(object);
                    this.index[id] = this.data.length - 1;
                    this._assignParentToChild(null, object);
                }

                return id;
            },

            // Set an object's parent, keeping the "data" and "index" properties up to date.
            // This essentially "moves" the object.
            /**
             * @ignore
             */
            setParent: function (object, parentId) {
            },

            /**
             * Delete an object from the store and its parent's "children" array.
             * @param {string} id The ID of the object to remove
             * @return {boolean} the outcome of the operation.
             */
            remove: function (id) {
                var object = this.get(id);
                var parent = object[this.parentProperty];

                if (parent) {
                    for (var i = 0; i < parent[this.childrenProperty].length; i++) {
                        if (parent[this.childrenProperty][i] === object) {
                            parent[this.childrenProperty].splice(i, 1);
                            break;
                        }
                    }
                }

                var deleted = delete this.flatData[id];

                // If it's root-level, take care of the index and data properties.
                if (id in this.index) {
                    this.data.splice(this.index[id], 1);
                    delete this.index[id];
                }

                return deleted;
            },

            /**
             * Run a query on all the objects in the store. This follows the ObjectStore API.
             * The difference in this implementation is that if the query is empty, it will only
             * return an array of the root nodes
             * @param {Object} query A query to run against this Store.
             * @param {Object} options A collection of options to apply to this query
             * @return {dojo.store.util.QueryResults} The results of the query.
             */
            query: function (/* Object */ query, /* Object */ options) {
                // Create an array of objects from our "flatData" property.
                var flatArray = [];

                if (query && _.size(query) !== 0) {
                    // Supply all the nodes in this tree in a flat array if there is a query
                    flatArray = _.values(this.flatData);
                } else {
                    // If there is no query, only supply the root nodes
                    flatArray = this.data;
                }

                return new QueryResults(this.queryEngine(query, options)(flatArray));
            },

            /**
             * Return an object's children.
             * @param {Object} object An arbitrary object.
             * @return {dojo.store.util.QueryResults} `object`'s children
             */
            getChildren: function (object) {
                return new QueryResults(object[this.childrenProperty]);
            },

            /**
             * Check if an object has children.
             * @param {Object} object An arbitrary object.
             * @return {boolean} `true` if `object` has children. Otherwise, `false`.
             */
            mayHaveChildren: function (object) {
                return object[this.childrenProperty] && object[this.childrenProperty].length > 0;
            }
        }
    );
});

},
'dgrid/tree':function(){
define([
	"dojo/_base/declare",
	"dojo/_base/array",
	"dojo/_base/Deferred",
	"dojo/query",
	"dojo/on",
	"dojo/aspect",
	"./util/has-css3",
	"./Grid",
	"dojo/has!touch?./util/touch",
	"put-selector/put"
], function(declare, arrayUtil, Deferred, querySelector, on, aspect, has, Grid, touchUtil, put){

function defaultRenderExpando(level, hasChildren, expanded, object){
	// summary:
	//		Provides default implementation for column.renderExpando.
	
	var dir = this.grid.isRTL ? "right" : "left",
		cls = ".dgrid-expando-icon",
		node;
	if(hasChildren){
		cls += ".ui-icon.ui-icon-triangle-1-" + (expanded ? "se" : "e");
	}
	node = put("div" + cls + "[style=margin-" + dir + ": " +
		(level * (this.indentWidth || 9)) + "px; float: " + dir + "]");
	node.innerHTML = "&nbsp;"; // for opera to space things properly
	return node;
}

function ontransitionend(event){
	var container = this,
		height = this.style.height;
	if(height){
		// After expansion, ensure display is correct;
		// after collapse, set display to none to improve performance
		this.style.display = height == "0px" ? "none" : "block";
	}
	
	// Reset height to be auto, so future height changes (from children
	// expansions, for example), will expand to the right height.
	if(event){
		// For browsers with CSS transition support, setting the height to
		// auto or "" will cause an animation to zero height for some
		// reason, so temporarily set the transition to be zero duration
		put(this, ".dgrid-tree-resetting");
		setTimeout(function(){
			// Turn off the zero duration transition after we have let it render
			put(container, "!dgrid-tree-resetting");
		});
	}
	// Now set the height to auto
	this.style.height = "";
}

function tree(column){
	// summary:
	//		Adds tree navigation capability to a column.
	
	var originalRenderCell = column.renderCell || Grid.defaultRenderCell;
	
	var currentLevel, // tracks last rendered item level (for aspected insertRow)
		clicked; // tracks row that was clicked (for expand dblclick event handling)
		
	if(!column){ column = {}; }
	
	column.shouldExpand = column.shouldExpand || function(row, level, previouslyExpanded){
		// summary:
		//		Function called after each row is inserted to determine whether
		//		expand(rowElement, true) should be automatically called.
		//		The default implementation re-expands any rows that were expanded
		//		the last time they were rendered (if applicable).
		
		return previouslyExpanded;
	};
	
	aspect.after(column, "init", function(){
		var grid = column.grid,
			colSelector = ".dgrid-content .dgrid-column-" + column.id,
			listeners = []; // to be removed when this column is destroyed

		// Turn off automatic cleanup of empty observers, to prevent confusion
		// due to observers operating at multiple hierarchy levels.
		grid.cleanEmptyObservers = false;
		
		if(!grid.store){
			throw new Error("dgrid tree column plugin requires a store to operate.");
		}
		
		if (!column.renderExpando){
			column.renderExpando = defaultRenderExpando;
		}
		
		// Set up the event listener once and use event delegation for better memory use.
		listeners.push(grid.on(
			column.expandOn || ".dgrid-expando-icon:click," + colSelector + ":dblclick," + colSelector + ":keydown",
			function(event){
				var row = grid.row(event);	
				if((!grid.store.mayHaveChildren || grid.store.mayHaveChildren(row.data)) &&
						(event.type != "keydown" || event.keyCode == 32) &&
						!(event.type == "dblclick" && clicked && clicked.count > 1 &&
							row.id == clicked.id && event.target.className.indexOf("dgrid-expando-icon") > -1)){
					grid.expand(row);
				}
				
				// If the expando icon was clicked, update clicked object to prevent
				// potential over-triggering on dblclick (all tested browsers but IE < 9).
				if(event.target.className.indexOf("dgrid-expando-icon") > -1){
					if(clicked && clicked.id == grid.row(event).id){
						clicked.count++;
					}else{
						clicked = {
							id: grid.row(event).id,
							count: 1
						};
					}
				}
			})
		);
		
		if(has("touch")){
			// Also listen on double-taps of the cell.
			listeners.push(grid.on(touchUtil.selector(colSelector, touchUtil.dbltap),
				function(){ grid.expand(this); }));
		}
		
		// Set up hash to store IDs of expanded rows
		if(!grid._expanded){ grid._expanded = {}; }
		
		listeners.push(aspect.after(grid, "insertRow", function(rowElement){
			// Auto-expand (shouldExpand) considerations
			var row = this.row(rowElement),
				expanded = column.shouldExpand(row, currentLevel, this._expanded[row.id]);
			
			if(expanded){ this.expand(rowElement, true, true); }
			return rowElement; // pass return value through
		}));
		
		listeners.push(aspect.before(grid, "removeRow", function(rowElement, justCleanup){
			var connected = rowElement.connected;
			if(connected){
				// if it has a connected expando node, we process the children
				querySelector(">.dgrid-row", connected).forEach(function(element){
					grid.removeRow(element, true);
				});
				// now remove the connected container node
				if(!justCleanup){
					put(connected, "!");
				}
			}
		}));
		
		if(column.collapseOnRefresh){
			// Clear out the _expanded hash on each call to cleanup
			// (which generally coincides with refreshes, as well as destroy).
			listeners.push(aspect.after(grid, "cleanup", function(){
				this._expanded = {};
			}));
		}
		
		grid._calcRowHeight = function(rowElement){
			// we override this method so we can provide row height measurements that
			// include the children of a row
			var connected = rowElement.connected;
			// if connected, need to consider this in the total row height
			return rowElement.offsetHeight + (connected ? connected.offsetHeight : 0); 
		};
		
		grid.expand = function(target, expand, noTransition){
			// summary:
			//		Expands the row corresponding to the given target.
			// target: Object
			//		Row object (or something resolvable to one) to expand/collapse.
			// expand: Boolean?
			//		If specified, designates whether to expand or collapse the row;
			//		if unspecified, toggles the current state.
			
			var row = target.element ? target : grid.row(target),
				hasTransitionend = has("transitionend"),
				dfd = new Deferred(),
				promise = dfd.promise;
			
			// Resolve initial promise immediately;
			// promise will be reassigned later if necessary to only resolve
			// after data is retrieved
			dfd.resolve();
			
			target = row.element;
			target = target.className.indexOf("dgrid-expando-icon") > -1 ? target :
				querySelector(".dgrid-expando-icon", target)[0];
			
			noTransition = noTransition || column.enableTransitions === false;
			
			if(target && target.mayHaveChildren &&
					(noTransition || expand !== !!this._expanded[row.id])){
				// toggle or set expand/collapsed state based on optional 2nd argument
				var expanded = expand === undefined ? !this._expanded[row.id] : expand;
				
				// update the expando display
				put(target, ".ui-icon-triangle-1-" + (expanded ? "se" : "e") +
					"!ui-icon-triangle-1-" + (expanded ? "e" : "se"));
				
				var rowElement = row.element,
					container = rowElement.connected,
					containerStyle,
					scrollHeight,
					options = {
						originalQuery: this.query
					};
				
				if(!container){
					// if the children have not been created, create a container, a preload node and do the 
					// query for the children
					container = options.container = rowElement.connected =
						put(rowElement, '+div.dgrid-tree-container');
					var query = function(options){
						return grid.store.getChildren(row.data, options);
					};
					if(column.allowDuplicates){
						// If allowDuplicates is specified, include parentId in options
						// in order to facilitate unique IDs for each occurrence of the
						// same item under multiple different parents.
						options.parentId = row.id;
					}
					// Include level information on query for renderQuery case
					if("level" in target){
						query.level = target.level;
					}
					// Add the query to the promise chain.
					promise = promise.then(function(){
						if(grid.renderQuery){
							return grid.renderQuery(query, options);
						}
						
						// If not using OnDemandList, we don't need preload nodes,
						// but we still need a beforeNode to pass to renderArray,
						// so create a temporary one
						var firstChild = put(container, "div");
						var rows = grid.renderArray(query(options), firstChild,
							"level" in query ? { queryLevel: query.level } : {});
						Deferred.when(rows, function(){
							put(firstChild, "!");
						});
						return rows;
					});
					
					if(hasTransitionend){
						on(container, hasTransitionend, ontransitionend);
					}else{
						ontransitionend.call(container);
					}
				}
				
				// Show or hide all the children.
				
				container.hidden = !expanded;
				containerStyle = container.style;
				
				// make sure it is visible so we can measure it
				if(!hasTransitionend || noTransition){
					containerStyle.display = expanded ? "block" : "none";
					containerStyle.height = "";
				}else{
					if(expanded){
						containerStyle.display = "block";
						scrollHeight = container.scrollHeight;
						containerStyle.height = "0px";
					}
					else{
						// if it will be hidden we need to be able to give a full height
						// without animating it, so it has the right starting point to animate to zero
						put(container, ".dgrid-tree-resetting");
						containerStyle.height = container.scrollHeight + "px";
					}
					// Perform a transition for the expand or collapse.
					setTimeout(function(){
						put(container, "!dgrid-tree-resetting");
						containerStyle.height =
							expanded ? (scrollHeight ? scrollHeight + "px" : "auto") : "0px";
					});
				}
				
				// Update _expanded map.
				if(expanded){
					this._expanded[row.id] = true;
				}else{
					delete this._expanded[row.id];
				}
			}
			return promise;
		}; // end function grid.expand
		
		// Set up a destroy function on column to tear down the listeners/aspects
		// established above if the grid's columns are redefined later.
		aspect.after(column, "destroy", function(){
			arrayUtil.forEach(listeners, function(l){ l.remove(); });
			// Delete methods we added/overrode on the instance.
			delete grid.expand;
			delete grid._calcRowHeight;
		});
	});
	
	column.renderCell = function(object, value, td, options){
		// summary:
		//		Renders a cell that can be expanded, creating more rows
		
		var grid = column.grid,
			level = Number(options && options.queryLevel) + 1,
			mayHaveChildren = !grid.store.mayHaveChildren || grid.store.mayHaveChildren(object),
			parentId = options.parentId,
			expando, node;
		
		level = currentLevel = isNaN(level) ? 0 : level;
		expando = column.renderExpando(level, mayHaveChildren,
			grid._expanded[(parentId ? parentId + "-" : "") + grid.store.getIdentity(object)], object);
		expando.level = level;
		expando.mayHaveChildren = mayHaveChildren;
		
		node = originalRenderCell.call(column, object, value, td, options);
		if(node && node.nodeType){
			put(td, expando);
			put(td, node);
		}else{
			td.insertBefore(expando, td.firstChild);
		}
	};
	return column;
}

tree.defaultRenderExpando = defaultRenderExpando;
return tree;
});

},
'dgrid/util/has-css3':function(){
define(["dojo/has"],
function(has){
	// This module defines feature tests for CSS3 features such as transitions.
	// The css-transitions, css-transforms, and css-transforms3d has-features
	// can report either boolean or string:
	// * false indicates no support
	// * true indicates prefix-less support
	// * string indicates the vendor prefix under which the feature is supported

	var cssPrefixes = ["ms", "O", "Moz", "Webkit"];
	
	function testStyle(element, property) {
		var style = element.style,
			i;
		
		if (property in style) {
			// Standard, no prefix
			return true;
		}
		property = property.slice(0, 1).toUpperCase() + property.slice(1);
		for (i = cssPrefixes.length; i--;) {
			if ((cssPrefixes[i] + property) in style) {
				// Vendor-specific css property prefix
				return cssPrefixes[i];
			}
		}
		
		// Otherwise, not supported
		return false;
	}
	
	has.add("css-transitions", function(global, doc, element){
		return testStyle(element, "transitionProperty");
	});
	
	has.add("css-transforms", function(global, doc, element){
		return testStyle(element, "transform");
	});
	
	has.add("css-transforms3d", function(global, doc, element){
		return testStyle(element, "perspective");
	});
	
	has.add("transitionend", function(){
		// Infer transitionend event name based on CSS transitions has-feature.
		var tpfx = has("css-transitions");
		if(!tpfx){ return false; }
		if(tpfx === true){ return "transitionend"; }
		return {
			ms: "MSTransitionEnd",
			O: "oTransitionEnd",
			Moz: "transitionend",
			Webkit: "webkitTransitionEnd"
		}[tpfx];
	});
	
	return has;
});

},
'vodori/ui/grid/GridFactory':function(){
define([
    'lodash',
    'dojo/_base/declare', 'dojo/_base/lang', 'dojo/_base/kernel', 'dojo/Deferred',
    'dijit/_WidgetBase', 'dijit/layout/_ContentPaneResizeMixin',
    'dgrid/OnDemandGrid', 'dgrid/extensions/DijitRegistry', 'dgrid/Selection',
    'dgrid/Keyboard', 'dgrid/ColumnSet', 'dgrid/extensions/ColumnResizer', 'dgrid/extensions/DnD',
    './_Selection', 'vodori/ui/grid/_DnD', 'vodori/ui/grid/_BaseGrid'
], function (
        _,
        declare, lang, kernel, Deferred,
        _WidgetBase, _ContentPaneResizeMixin,
        OnDemandGrid, DijitRegistry, Selection,
        Keyboard, ColumnSet, ColumnResizer, DnD,
        _Selection, _DnD, _BaseGrid
        ) {

        var STANDARD_MIXINS = {
            dgridSelection: Selection,
            selection:      _Selection,
            keyboard:       Keyboard,
            columnSet:      ColumnSet,
            columnResizer:  ColumnResizer,
            dgridDnd:       DnD,
            dnd:            _DnD
        };

        /**
         * Resolves an arbitrary list of modules, MIDs and shortcuts into a list of modules (if we know about them) and
         * MIDs (if we don't)
         * @param {Array<string|Object>} midsAndModules a list of MIDs, shortcuts and/or modules that
         *                               may or may not be known
         * @return {Array<string|Object>} a list of unknown MIDs and shortcuts as well as known modules
         * @private
         */
        var _resolveKnownModules = function (midsAndModules) {
            return _.map(midsAndModules, function (midOrModule) {
                var mid;
                /*
                 * If we have a string then it is a mid, not a module
                 */
                if(_.isString(midOrModule)) {
                    mid = lang.trim(midOrModule);
                }
                return  _.isUndefined(mid)      ?   midOrModule /* i.e. a module, not a mid */
                    :   !!STANDARD_MIXINS[mid]  ?   STANDARD_MIXINS[mid]
                    :                               mid;
            });
        };

        /**
         * Load all of the mixins that have not yet been loaded
         *
         * @param {Array<string>} unloadedMixins a list of MIDs that need to be loaded
         * @param {Function} require the Dojo Loader `require` function
         * @param {function(Object)} callback the function to call once the modules have been loaded.
         *                           Callback should take an object with MIDs mapping to the loaded module
         * @private
         */
        var _getUnloadedMixins = function (unloadedMixins, require, callback) {
            require(unloadedMixins, function (/* Required modules are accessed via 'arguments' */) {
                /*
                 * Create a map of requested MID to actual module and pass it to the callback
                 */
                callback(_.object(unloadedMixins, arguments));

            });
        };

        /*
         * @param {string|Array.<string>} mixins a list of MIDs or shortcuts (per `STANDARD_MIXINS`) for loading.
         *                                       Can be an array of strings or a comma-separated list in a string
         * @param {Function} require the Dojo Loader `require` function
         * @param {Function} loadBack the function to call once all of the mixins have been loaded
         */
        var _loadRequestMixins = function (mixins, require, loadBack) {
            var mixinList = _resolveKnownModules(_.isString(mixins) ? mixins.split(',') : mixins);

            /*
             * Get a list of the mixins that we don't know about and have to require
             */
            var unloadedMixins = _.filter(mixinList, _.isString);


            _getUnloadedMixins(unloadedMixins, require, function (mixinMap) {
                /*
                 * Generate a list of the requested modules (request either by MID or by shortcut name
                 */
                var requestedMixins = _.map(mixinList, function (mixin) {
                    return  _.isString(mixin) ? mixinMap[mixin]
                        :                       mixin;
                });

                /*
                 * Use a clone of the mixins to ensure no weirdness
                 */
                loadBack([OnDemandGrid, DijitRegistry].concat(lang.clone(requestedMixins)));
            });
        };

        /**
         * @lends vodori/ui/grid/GridFactory
         */
        var GridFactory =  {
            /**
             * AMD plugin for loading a dgrid/OnDemandGrid which has been augmented with the DijitRegistry mixin, plus
             * others defined by the plugin invocation
             *
             * Provide a comma separated list of MIDs that represent the mixins that you want to include with the Grid.
             *
             * Plugin returns an array of constructors that you can use as the dependencies of a call to
             * declare, like so:
             *
             *
             *     require(['vodori/ui/Grid!dgrid/Selection,dgridKeyboard'], function(GridCtors) {
             *         return declare(GridCtors, { // implementation  });
             *     });
             *
             * This will produce the same as
             *
             *     require(['dgrid/OnDemandGrid', 'dgrid/DijitRegistry', 'dgrid/Selection', 'dgridKeyboard'],
             *              function(OnDemand, DijitRegistry, Selection, Keyboard) {
             *         return declare([OnDemand, DijitRegistry, Selection, Keyboard], { // implementation  });
             *     });
             *
             * Note that the order of the mixins is maintained.
             * You can always manipulate `GridCtors` in order to add other mixins before using it in your declare

             * For convenience, a number of shortcut names have been provided in STANDARD_MIXINS:
             *
             * * dgridSelection : dgrid/Selection
             * * selection : vodori/ui/grid/_Selection
             * * keyboard : dgrid/Keyboard
             * * columnSet : dgrid/ColumnSet
             * * columnResizer : dgrid/ColumnResizer
             * * dnd: vodori/ui/grid/_DnD
             * * dgridDnd : dgrid/extensions/DnD
             *
             *
             * @method
             * @param {string|Array.<string>} mixins a list of MIDs or shortcuts (per `STANDARD_MIXINS`) for loading.
             *                                       Can be an array of strings or a comma-separated list in a string
             * @param {Function} require the Dojo Loader `require` function
             * @param {Function} loadBack the function to call once all of the mixins have been loaded
             */
            load: _loadRequestMixins,

            /**
             * Get a constructor for a Grid based on the request mixins. Allows Grid constructors to be generated at
             * run-time with arbitrary mixins selected.
             *
             * @method
             * @param {string|Array.<string>} mixins a list of MIDs or shortcuts (per `STANDARD_MIXINS`) for loading.
             *                                       Can be an array of strings or a comma-separated list in a string
             * @param {?Object} basis
             * @return {dojo/promise/promise} a Promise that will resolve once all of the requested mixins
             *                                have been loaded.
             *                                Resolves to a class per dojo/_base/declare
             */
            getGrid: function (mixins, basis) {
                if(!_.isObject(basis)) {
                    basis = {};
                }

                var loadDeferred = new Deferred(function (reason) {
                    console.error('GridFactory failed to build a Grid: %o', reason);
                });

                _loadRequestMixins(mixins, kernel.global.require, function (mixinArray) {
                    var ancestors = _.flatten([_WidgetBase, _ContentPaneResizeMixin, mixinArray, _BaseGrid]);
                    loadDeferred.resolve(declare(ancestors, basis));
                });

                return loadDeferred.promise;
            }
        };

        /** @class vodori/ui/grid/GridFactory */
        return GridFactory;
    }
);

},
'dgrid/extensions/DijitRegistry':function(){
define(["dojo/_base/declare", "dojo/dom-geometry", "dijit/registry"],
function(declare, domGeometry, registry){
	return declare(null, {
		// summary:
		//		A dgrid extension which will add the grid to the dijit registry,
		//		so that startup() will be successfully called by dijit layout widgets
		//		with dgrid children.
		
		// Defaults normally imposed on _WidgetBase by container widget modules:
		minSize: 0, // BorderContainer
		maxSize: Infinity, // BorderContainer
		layoutPriority: 0, // BorderContainer
		showTitle: true, // StackContainer
		
		buildRendering: function(){
			registry.add(this);
			this.inherited(arguments);
			// Note: for dojo 2.0 may rename widgetId to dojo._scopeName + "_widgetId"
			this.domNode.setAttribute("widgetId", this.id);
		},
		
		startup: function(){
			if(this._started){ return; }
			this.inherited(arguments);
			
			var widget = registry.getEnclosingWidget(this.domNode.parentNode);
			// If we have a parent layout container widget, it will handle resize,
			// so remove the window resize listener added by List.
			if(widget && widget.isLayoutContainer){
				this._resizeHandle.remove();
			}
		},

		destroyRecursive: function() {
			this.destroy();
		},
		
		destroy: function(){
			this.inherited(arguments);
			registry.remove(this.id);
		},
		
		getChildren: function(){
			// provide hollow implementation for logic which assumes its existence
			// (e.g. dijit/form/_FormMixin)
			return [];
		},
		
		isLeftToRight: function(){
			// Implement method expected by Dijit layout widgets
			return !this.isRTL;
		},
		
		resize: function(changeSize){
			// Honor changeSize parameter used by layout widgets, and resize grid
			if(changeSize){
				domGeometry.setMarginBox(this.domNode, changeSize);
			}
			
			this.inherited(arguments);
		},
		
		_set: function(prop, value){
			// summary:
			//		Simple analogue of _WidgetBase#_set for compatibility with some
			//		Dijit layout widgets which assume its existence.
			this[prop] = value;
		},
		
		watch: function(){
			// summary:
			//		dgrid doesn't support watch; this is a no-op for compatibility with
			//		some Dijit layout widgets which assume its existence.
		},
		
		getParent: function(){
			// summary:
			//		Analogue of _WidgetBase#getParent for compatibility with for example
			//		dijit._KeyNavContainer.
			return registry.getEnclosingWidget(this.domNode.parentNode);
		}
	});
});

},
'dgrid/Selection':function(){
define(["dojo/_base/kernel", "dojo/_base/declare", "dojo/_base/Deferred", "dojo/on", "dojo/has", "dojo/aspect", "./List", "dojo/has!touch?./util/touch", "put-selector/put", "dojo/query", "dojo/_base/sniff"],
function(kernel, declare, Deferred, on, has, aspect, List, touchUtil, put){

has.add("dom-comparedocumentposition", function(global, doc, element){
	return !!element.compareDocumentPosition;
});

has.add("pointer", function(global){
	return "PointerEvent" in global ? "pointer" :
		"MSPointerEvent" in global ? "MSPointer" : false;
});

// Add feature test for user-select CSS property for optionally disabling
// text selection.
// (Can't use dom.setSelectable prior to 1.8.2 because of bad sniffs, see #15990)
has.add("css-user-select", function(global, doc, element){
	var style = element.style,
		prefixes = ["Khtml", "O", "ms", "Moz", "Webkit"],
		i = prefixes.length,
		name = "userSelect";

	// Iterate prefixes from most to least likely
	do{
		if(typeof style[name] !== "undefined"){
			// Supported; return property name
			return name;
		}
	}while(i-- && (name = prefixes[i] + "UserSelect"));

	// Not supported if we didn't return before now
	return false;
});

// Also add a feature test for the onselectstart event, which offers a more
// graceful fallback solution than node.unselectable.
has.add("dom-selectstart", typeof document.onselectstart !== "undefined");

var ctrlEquiv = has("mac") ? "metaKey" : "ctrlKey",
	hasUserSelect = has("css-user-select"),
	hasPointer = has("pointer"),
	hasMSPointer = hasPointer && hasPointer.slice(0, 2) === "MS",
	downType = hasPointer ? hasPointer + (hasMSPointer ? "Down" : "down") : "mousedown",
	upType = hasPointer ? hasPointer + (hasMSPointer ? "Up" : "up") : "mouseup";

function makeUnselectable(node, unselectable){
	// Utility function used in fallback path for recursively setting unselectable
	var value = node.unselectable = unselectable ? "on" : "",
		elements = node.getElementsByTagName("*"),
		i = elements.length;
	
	while(--i){
		if(elements[i].tagName === "INPUT" || elements[i].tagName === "TEXTAREA"){
			continue; // Don't prevent text selection in text input fields.
		}
		elements[i].unselectable = value;
	}
}

function setSelectable(grid, selectable){
	// Alternative version of dojo/dom.setSelectable based on feature detection.
	
	// For FF < 21, use -moz-none, which will respect -moz-user-select: text on
	// child elements (e.g. form inputs).  In FF 21, none behaves the same.
	// See https://developer.mozilla.org/en-US/docs/CSS/user-select
	var node = grid.bodyNode,
		value = selectable ? "text" : has("ff") < 21 ? "-moz-none" : "none";
	
	// In IE10+, -ms-user-select: none will block selection from starting within the
	// element, but will not block an existing selection from entering the element.
	// When using a modifier key, IE will select text inside of the element as well
	// as outside of the element, because it thinks the selection started outside.
	// Therefore, fall back to other means of blocking selection for IE10+.
	if(hasUserSelect && hasUserSelect !== "msUserSelect"){
		node.style[hasUserSelect] = value;
	}else if(has("dom-selectstart")){
		// For browsers that don't support user-select but support selectstart (IE<10),
		// we can hook up an event handler as necessary.  Since selectstart bubbles,
		// it will handle any child elements as well.
		// Note, however, that both this and the unselectable fallback below are
		// incapable of preventing text selection from outside the targeted node.
		if(!selectable && !grid._selectstartHandle){
			grid._selectstartHandle = on(node, "selectstart", function(evt){
				var tag = evt.target && evt.target.tagName;
				
				// Prevent selection except where a text input field is involved.
				if(tag !== "INPUT" && tag !== "TEXTAREA"){
					evt.preventDefault();
				}
			});
		}else if(selectable && grid._selectstartHandle){
			grid._selectstartHandle.remove();
			delete grid._selectstartHandle;
		}
	}else{
		// For browsers that don't support either user-select or selectstart (Opera),
		// we need to resort to setting the unselectable attribute on all nodes
		// involved.  Since this doesn't automatically apply to child nodes, we also
		// need to re-apply it whenever rows are rendered.
		makeUnselectable(node, !selectable);
		if(!selectable && !grid._unselectableHandle){
			grid._unselectableHandle = aspect.after(grid, "renderRow", function(row){
				makeUnselectable(row, true);
				return row;
			});
		}else if(selectable && grid._unselectableHandle){
			grid._unselectableHandle.remove();
			delete grid._unselectableHandle;
		}
	}
}

return declare(null, {
	// summary:
	//		Add selection capabilities to a grid. The grid will have a selection property and
	//		fire "dgrid-select" and "dgrid-deselect" events.
	
	// selectionDelegate: String
	//		Selector to delegate to as target of selection events.
	selectionDelegate: ".dgrid-row",
	
	// selectionEvents: String|Function
	//		Event (or comma-delimited events, or extension event) to listen on
	//		to trigger select logic.
	selectionEvents: downType + "," + upType + ",dgrid-cellfocusin",
	
	// selectionTouchEvents: String|Function
	//		Event (or comma-delimited events, or extension event) to listen on
	//		in addition to selectionEvents for touch devices.
	selectionTouchEvents: has("touch") ? touchUtil.tap : null,
	
	// deselectOnRefresh: Boolean
	//		If true, the selection object will be cleared when refresh is called.
	deselectOnRefresh: true,
	
	// allowSelectAll: Boolean
	//		If true, allow ctrl/cmd+A to select all rows.
	//		Also consulted by the selector plugin for showing select-all checkbox.
	allowSelectAll: false,
	
	// selection:
	//		An object where the property names correspond to 
	//		object ids and values are true or false depending on whether an item is selected
	selection: {},
	
	// selectionMode: String
	//		The selection mode to use, can be "none", "multiple", "single", or "extended".
	selectionMode: "extended",
	
	// allowTextSelection: Boolean
	//		Whether to still allow text within cells to be selected.  The default
	//		behavior is to allow text selection only when selectionMode is none;
	//		setting this property to either true or false will explicitly set the
	//		behavior regardless of selectionMode.
	allowTextSelection: undefined,
	
	// _selectionTargetType: String
	//		Indicates the property added to emitted events for selected targets;
	//		overridden in CellSelection
	_selectionTargetType: "rows",
	
	create: function(){
		this.selection = {};
		return this.inherited(arguments);
	},
	postCreate: function(){
		this.inherited(arguments);
		
		this._initSelectionEvents();
		
		// Force selectionMode setter to run
		var selectionMode = this.selectionMode;
		this.selectionMode = "";
		this._setSelectionMode(selectionMode);
	},
	
	destroy: function(){
		this.inherited(arguments);
		
		// Remove any extra handles added by Selection.
		if(this._selectstartHandle){ this._selectstartHandle.remove(); }
		if(this._unselectableHandle){ this._unselectableHandle.remove(); }
		if(this._removeDeselectSignals){ this._removeDeselectSignals(); }
	},
	
	_setSelectionMode: function(mode){
		// summary:
		//		Updates selectionMode, resetting necessary variables.
		if(mode == this.selectionMode){ return; } // prevent unnecessary spinning
		
		// Start selection fresh when switching mode.
		this.clearSelection();
		
		this.selectionMode = mode;
		
		// Compute name of selection handler for this mode once
		// (in the form of _fooSelectionHandler)
		this._selectionHandlerName = "_" + mode + "SelectionHandler";
		
		// Also re-run allowTextSelection setter in case it is in automatic mode.
		this._setAllowTextSelection(this.allowTextSelection);
	},
	setSelectionMode: function(mode){
		kernel.deprecated("setSelectionMode(...)", 'use set("selectionMode", ...) instead', "dgrid 0.4");
		this.set("selectionMode", mode);
	},
	
	_setAllowTextSelection: function(allow){
		if(typeof allow !== "undefined"){
			setSelectable(this, allow);
		}else{
			setSelectable(this, this.selectionMode === "none");
		}
		this.allowTextSelection = allow;
	},
	
	_handleSelect: function(event, target){
		// Don't run if selection mode doesn't have a handler (incl. "none"), target can't be selected,
		// or if coming from a dgrid-cellfocusin from a mousedown
		if(!this[this._selectionHandlerName] || !this.allowSelect(this.row(target)) ||
				(event.type === "dgrid-cellfocusin" && event.parentType === "mousedown") ||
				(event.type === upType && target != this._waitForMouseUp)){
			return;
		}
		this._waitForMouseUp = null;
		this._selectionTriggerEvent = event;
		
		// Don't call select handler for ctrl+navigation
		if(!event.keyCode || !event.ctrlKey || event.keyCode == 32){
			// If clicking a selected item, wait for mouseup so that drag n' drop
			// is possible without losing our selection
			if(!event.shiftKey && event.type === downType && this.isSelected(target)){
				this._waitForMouseUp = target;
			}else{
				this[this._selectionHandlerName](event, target);
			}
		}
		this._selectionTriggerEvent = null;
	},
	
	_singleSelectionHandler: function(event, target){
		// summary:
		//		Selection handler for "single" mode, where only one target may be
		//		selected at a time.
		
		var ctrlKey = event.keyCode ? event.ctrlKey : event[ctrlEquiv];
		if(this._lastSelected === target){
			// Allow ctrl to toggle selection, even within single select mode.
			this.select(target, null, !ctrlKey || !this.isSelected(target));
		}else{
			this.clearSelection();
			this.select(target);
			this._lastSelected = target;
		}
	},
	
	_multipleSelectionHandler: function(event, target){
		// summary:
		//		Selection handler for "multiple" mode, where shift can be held to
		//		select ranges, ctrl/cmd can be held to toggle, and clicks/keystrokes
		//		without modifier keys will add to the current selection.
		
		var lastRow = this._lastSelected,
			ctrlKey = event.keyCode ? event.ctrlKey : event[ctrlEquiv],
			value;
		
		if(!event.shiftKey){
			// Toggle if ctrl is held; otherwise select
			value = ctrlKey ? null : true;
			lastRow = null;
		}
		this.select(target, lastRow, value);

		if(!lastRow){
			// Update reference for potential subsequent shift+select
			// (current row was already selected above)
			this._lastSelected = target;
		}
	},
	
	_extendedSelectionHandler: function(event, target){
		// summary:
		//		Selection handler for "extended" mode, which is like multiple mode
		//		except that clicks/keystrokes without modifier keys will clear
		//		the previous selection.
		
		// Clear selection first for right-clicks outside selection and non-ctrl-clicks;
		// otherwise, extended mode logic is identical to multiple mode
		if(event.button === 2 ? !this.isSelected(target) :
				!(event.keyCode ? event.ctrlKey : event[ctrlEquiv])){
			this.clearSelection(null, true);
		}
		this._multipleSelectionHandler(event, target);
	},
	
	_toggleSelectionHandler: function(event, target){
		// summary:
		//		Selection handler for "toggle" mode which simply toggles the selection
		//		of the given target.  Primarily useful for touch input.
		
		this.select(target, null, null);
	},

	_initSelectionEvents: function(){
		// summary:
		//		Performs first-time hookup of event handlers containing logic
		//		required for selection to operate.
		
		var grid = this,
			contentNode = this.contentNode,
			selector = this.selectionDelegate;
		
		this._selectionEventQueues = {
			deselect: [],
			select: []
		};
		
		if(has("touch") && !has("pointer") && this.selectionTouchEvents){
			// Listen for taps, and also for mouse/keyboard, making sure not
			// to trigger both for the same interaction
			on(contentNode, touchUtil.selector(selector, this.selectionTouchEvents), function(evt){
				grid._handleSelect(evt, this);
				grid._ignoreMouseSelect = this;
			});
			on(contentNode, on.selector(selector, this.selectionEvents), function(event){
				if(grid._ignoreMouseSelect !== this){
					grid._handleSelect(event, this);
				}else if(event.type === upType){
					grid._ignoreMouseSelect = null;
				}
			});
		}else{
			// Listen for mouse/keyboard actions that should cause selections
			on(contentNode, on.selector(selector, this.selectionEvents), function(event){
				grid._handleSelect(event, this);
			});
		}
		
		// Also hook up spacebar (for ctrl+space)
		if(this.addKeyHandler){
			this.addKeyHandler(32, function(event){
				grid._handleSelect(event, event.target);
			});
		}
		
		// If allowSelectAll is true, bind ctrl/cmd+A to (de)select all rows,
		// unless the event was received from an editor component.
		// (Handler further checks against _allowSelectAll, which may be updated
		// if selectionMode is changed post-init.)
		if(this.allowSelectAll){
			this.on("keydown", function(event) {
				if(event[ctrlEquiv] && event.keyCode == 65 &&
						!/\bdgrid-input\b/.test(event.target.className)){
					event.preventDefault();
					grid[grid.allSelected ? "clearSelection" : "selectAll"]();
				}
			});
		}
		
		// Update aspects if there is a store change
		if(this._setStore){
			aspect.after(this, "_setStore", function(){
				grid._updateDeselectionAspect();
			});
		}
		this._updateDeselectionAspect();
	},
	
	_updateDeselectionAspect: function(){
		// summary:
		//		Hooks up logic to handle deselection of removed items.
		//		Aspects to an observable store's notify method if applicable,
		//		or to the list/grid's removeRow method otherwise.
		
		var self = this,
			store = this.store,
			beforeSignal,
			afterSignal;

		function ifSelected(object, idToUpdate, methodName){
			// Calls a method if the row corresponding to the object is selected.
			var id = idToUpdate || (object && object[self.idProperty || "id"]);
			if(id != null){
				var row = self.row(id),
					selection = row && self.selection[row.id];
				// Is the row currently in the selection list.
				if(selection){
					self[methodName](row, null, selection);
				}
			}
		}
		
		// Remove anything previously configured
		if(this._removeDeselectSignals){
			this._removeDeselectSignals();
		}

		// Is there currently an observable store?
		if(store && store.notify){
			beforeSignal = aspect.before(store, "notify", function(object, idToUpdate){
				if(!object){
					// Call deselect on the row if the object is being removed.  This allows the
					// deselect event to reference the row element while it still exists in the DOM.
					ifSelected(object, idToUpdate, "deselect");
				}
			});
			afterSignal = aspect.after(store, "notify", function(object, idToUpdate){
				// When List updates an item, the row element is removed and a new one inserted.
				// If at this point the object is still in grid.selection, then call select on the row so the
				// element's CSS is updated.  If the object was removed then the aspect-before has already deselected it.
				ifSelected(object, idToUpdate, "select");
			}, true);
			
			this._removeDeselectSignals = function(){
				beforeSignal.remove();
				afterSignal.remove();
			};
		}else{
			beforeSignal = aspect.before(this, "removeRow", function(rowElement, justCleanup){
				var row;
				if(!justCleanup){
					row = this.row(rowElement);
					// if it is a real row removal for a selected item, deselect it
					if(row && (row.id in this.selection)){
						this.deselect(row);
					}
				}
			});
			this._removeDeselectSignals = function(){
				beforeSignal.remove();
			};
		}
	},
	
	allowSelect: function(row){
		// summary:
		//		A method that can be overriden to determine whether or not a row (or 
		//		cell) can be selected. By default, all rows (or cells) are selectable.
		return true;
	},
	
	_fireSelectionEvent: function(type){
		// summary:
		//		Fires an event for the accumulated rows once a selection
		//		operation is finished (whether singular or for a range)
		
		var queue = this._selectionEventQueues[type],
			triggerEvent = this._selectionTriggerEvent,
			eventObject;
		
		eventObject = {
			bubbles: true,
			grid: this
		};
		if(triggerEvent){
			eventObject.parentType = triggerEvent.type;
		}
		eventObject[this._selectionTargetType] = queue;
		
		on.emit(this.contentNode, "dgrid-" + type, eventObject);
		
		// Clear the queue so that the next round of (de)selections starts anew
		this._selectionEventQueues[type] = [];
	},
	
	_fireSelectionEvents: function(){
		var queues = this._selectionEventQueues,
			type;
		
		for(type in queues){
			if(queues[type].length){
				this._fireSelectionEvent(type);
			}
		}
	},
	
	_select: function(row, toRow, value){
		// summary:
		//		Contains logic for determining whether to select targets, but
		//		does not emit events.  Called from select, deselect, selectAll,
		//		and clearSelection.
		
		var selection,
			previousValue,
			element,
			toElement,
			direction;
		
		if(typeof value === "undefined"){
			// default to true
			value = true;
		} 
		if(!row.element){
			row = this.row(row);
		}
		
		// Check whether we're allowed to select the given row before proceeding.
		// If a deselect operation is being performed, this check is skipped,
		// to avoid errors when changing column definitions, and since disabled
		// rows shouldn't ever be selected anyway.
		if(value === false || this.allowSelect(row)){
			selection = this.selection;
			previousValue = !!selection[row.id];
			if(value === null){
				// indicates a toggle
				value = !previousValue;
			}
			element = row.element;
			if(!value && !this.allSelected){
				delete this.selection[row.id];
			}else{
				selection[row.id] = value;
			}
			if(element){
				// add or remove classes as appropriate
				if(value){
					put(element, ".dgrid-selected" +
						(this.addUiClasses ? ".ui-state-active" : ""));
				}else{
					put(element, "!dgrid-selected!ui-state-active");
				}
			}
			if(value !== previousValue && element){
				// add to the queue of row events
				this._selectionEventQueues[(value ? "" : "de") + "select"].push(row);
			}
			
			if(toRow){
				if(!toRow.element){
					toRow = this.row(toRow);
				}
				
				if(!toRow){
					this._lastSelected = element;
					console.warn("The selection range has been reset because the " +
						"beginning of the selection is no longer in the DOM. " +
						"If you are using OnDemandList, you may wish to increase " +
						"farOffRemoval to avoid this, but note that keeping more nodes " +
						"in the DOM may impact performance.");
					return;
				}
				
				toElement = toRow.element;
				if(toElement){
					direction = this._determineSelectionDirection(element, toElement);
					if(!direction){
						// The original element was actually replaced
						toElement = document.getElementById(toElement.id);
						direction = this._determineSelectionDirection(element, toElement);
					}
					while(row.element != toElement && (row = this[direction](row))){
						this._select(row, null, value);
					}
				}
			}
		}
	},
	
	// Implement _determineSelectionDirection differently based on whether the
	// browser supports element.compareDocumentPosition; use sourceIndex for IE<9
	_determineSelectionDirection: has("dom-comparedocumentposition") ? function (from, to) {
		var result = to.compareDocumentPosition(from);
		if(result & 1){
			return false; // Out of document
		}
		return result === 2 ? "down" : "up";
	} : function(from, to) {
		if(to.sourceIndex < 1){
			return false; // Out of document
		}
		return to.sourceIndex > from.sourceIndex ? "down" : "up";
	},
	
	select: function(row, toRow, value){
		// summary:
		//		Selects or deselects the given row or range of rows.
		// row: Mixed
		//		Row object (or something that can resolve to one) to (de)select
		// toRow: Mixed
		//		If specified, the inclusive range between row and toRow will
		//		be (de)selected
		// value: Boolean|Null
		//		Whether to select (true/default), deselect (false), or toggle
		//		(null) the row
		
		this._select(row, toRow, value);
		this._fireSelectionEvents();
	},
	deselect: function(row, toRow){
		// summary:
		//		Deselects the given row or range of rows.
		// row: Mixed
		//		Row object (or something that can resolve to one) to deselect
		// toRow: Mixed
		//		If specified, the inclusive range between row and toRow will
		//		be deselected
		
		this.select(row, toRow, false);
	},
	
	clearSelection: function(exceptId, dontResetLastSelected){
		// summary:
		//		Deselects any currently-selected items.
		// exceptId: Mixed?
		//		If specified, the given id will not be deselected.
		
		this.allSelected = false;
		for(var id in this.selection){
			if(exceptId !== id){
				this._select(id, null, false);
			}
		}
		if(!dontResetLastSelected){
			this._lastSelected = null;
		}
		this._fireSelectionEvents();
	},
	selectAll: function(){
		this.allSelected = true;
		this.selection = {}; // we do this to clear out pages from previous sorts
		for(var i in this._rowIdToObject){
			var row = this.row(this._rowIdToObject[i]);
			this._select(row.id, null, true);
		}
		this._fireSelectionEvents();
	},
	
	isSelected: function(object){
		// summary:
		//		Returns true if the indicated row is selected.
		
		if(typeof object === "undefined" || object === null){
			return false;
		}
		if(!object.element){
			object = this.row(object);
		}
		
		// First check whether the given row is indicated in the selection hash;
		// failing that, check if allSelected is true (testing against the
		// allowSelect method if possible)
		return (object.id in this.selection) ? !!this.selection[object.id] :
			this.allSelected && (!object.data || this.allowSelect(object));
	},
	
	refresh: function(){
		if(this.deselectOnRefresh){
			this.clearSelection();
		}
		this._lastSelected = null;
		return this.inherited(arguments);
	},
	
	renderArray: function(){
		var grid = this,
			rows = this.inherited(arguments);
		
		Deferred.when(rows, function(rows){
			var selection = grid.selection,
				i, row, selected;
			for(i = 0; i < rows.length; i++){
				row = grid.row(rows[i]);
				selected = row.id in selection ? selection[row.id] : grid.allSelected;
				if(selected){
					grid._select(row, null, selected);
				}
			}
			grid._fireSelectionEvents();
		});
		return rows;
	}
});

});

},
'dgrid/Keyboard':function(){
define([
	"dojo/_base/declare",
	"dojo/aspect",
	"dojo/on",
	"dojo/_base/lang",
	"dojo/has",
	"put-selector/put",
	"./util/misc",
	"dojo/_base/Deferred",
	"dojo/_base/sniff"
], function(declare, aspect, on, lang, has, put, miscUtil, Deferred){

var delegatingInputTypes = {
		checkbox: 1,
		radio: 1,
		button: 1
	},
	hasGridCellClass = /\bdgrid-cell\b/,
	hasGridRowClass = /\bdgrid-row\b/;

var Keyboard = declare(null, {
	// summary:
	//		Adds keyboard navigation capability to a list or grid.
	
	// pageSkip: Number
	//		Number of rows to jump by when page up or page down is pressed.
	pageSkip: 10,
	
	tabIndex: 0,
	
	// keyMap: Object
	//		Hash which maps key codes to functions to be executed (in the context
	//		of the instance) for key events within the grid's body.
	keyMap: null,
	
	// headerKeyMap: Object
	//		Hash which maps key codes to functions to be executed (in the context
	//		of the instance) for key events within the grid's header row.
	headerKeyMap: null,
	
	postMixInProperties: function(){
		this.inherited(arguments);
		
		if(!this.keyMap){
			this.keyMap = lang.mixin({}, Keyboard.defaultKeyMap);
		}
		if(!this.headerKeyMap){
			this.headerKeyMap = lang.mixin({}, Keyboard.defaultHeaderKeyMap);
		}
	},
	
	postCreate: function(){
		this.inherited(arguments);
		var grid = this;
		
		function handledEvent(event){
			// text boxes and other inputs that can use direction keys should be ignored and not affect cell/row navigation
			var target = event.target;
			return target.type && (!delegatingInputTypes[target.type] || event.keyCode == 32);
		}
		
		function enableNavigation(areaNode){
			var cellNavigation = grid.cellNavigation,
				isFocusableClass = cellNavigation ? hasGridCellClass : hasGridRowClass,
				isHeader = areaNode === grid.headerNode,
				initialNode = areaNode;
			
			function initHeader(){
				if(grid._focusedHeaderNode){
					// Remove the tab index for the node that previously had it.
					grid._focusedHeaderNode.tabIndex = -1;
				}
				if(grid.showHeader){
					if(cellNavigation){
						// Get the focused element. Ensure that the focused element
						// is actually a grid cell, not a column-set-cell or some
						// other cell that should not be focused
						for(var i = 0, element, elements = grid.headerNode.getElementsByTagName("th"); (element = elements[i]); ++i){
							if(isFocusableClass.test(element.className)){
								grid._focusedHeaderNode = initialNode = element;
								break;
							}
						}
					}
					else{
						grid._focusedHeaderNode = initialNode = grid.headerNode;
					}

					// Set the tab index only if the header is visible.
					if(initialNode){
						initialNode.tabIndex = grid.tabIndex;
					}
				}
			}
			
			if(isHeader){
				// Initialize header now (since it's already been rendered),
				// and aspect after future renderHeader calls to reset focus.
				initHeader();
				aspect.after(grid, "renderHeader", initHeader, true);
			}else{
				aspect.after(grid, "renderArray", function(ret){
					// summary:
					//		Ensures the first element of a grid is always keyboard selectable after data has been
					//		retrieved if there is not already a valid focused element.
					
					return Deferred.when(ret, function(ret){
						var focusedNode = grid._focusedNode || initialNode;
						
						// do not update the focused element if we already have a valid one
						if(isFocusableClass.test(focusedNode.className) && miscUtil.contains(areaNode, focusedNode)){
							return ret;
						}
						
						// ensure that the focused element is actually a grid cell, not a
						// dgrid-preload or dgrid-content element, which should not be focusable,
						// even when data is loaded asynchronously
						for(var i = 0, elements = areaNode.getElementsByTagName("*"), element; (element = elements[i]); ++i){
							if(isFocusableClass.test(element.className)){
								focusedNode = grid._focusedNode = element;
								break;
							}
						}
						
						focusedNode.tabIndex = grid.tabIndex;
						return ret;
					});
				});
			}
			
			grid._listeners.push(on(areaNode, "mousedown", function(event){
				if(!handledEvent(event)){
					grid._focusOnNode(event.target, isHeader, event);
				}
			}));
			
			grid._listeners.push(on(areaNode, "keydown", function(event){
				// For now, don't squash browser-specific functionalities by letting
				// ALT and META function as they would natively
				if(event.metaKey || event.altKey) {
					return;
				}
				
				var handler = grid[isHeader ? "headerKeyMap" : "keyMap"][event.keyCode];
				
				// Text boxes and other inputs that can use direction keys should be ignored and not affect cell/row navigation
				if(handler && !handledEvent(event)){
					handler.call(grid, event);
				}
			}));
		}
		
		if(this.tabableHeader){
			enableNavigation(this.headerNode);
			on(this.headerNode, "dgrid-cellfocusin", function(){
				grid.scrollTo({ x: this.scrollLeft });
			});
		}
		enableNavigation(this.contentNode);
	},
	
	removeRow: function(rowElement){
		if(!this._focusedNode){
			// Nothing special to do if we have no record of anything focused
			return this.inherited(arguments);
		}
		
		var self = this,
			isActive = document.activeElement === this._focusedNode,
			focusedTarget = this[this.cellNavigation ? "cell" : "row"](this._focusedNode),
			focusedRow = focusedTarget.row || focusedTarget,
			sibling;
		rowElement = rowElement.element || rowElement;
		
		// If removed row previously had focus, temporarily store information
		// to be handled in an immediately-following insertRow call, or next turn
		if(rowElement === focusedRow.element){
			sibling = this.down(focusedRow, true);
			
			// Check whether down call returned the same row, or failed to return
			// any (e.g. during a partial unrendering)
			if (!sibling || sibling.element === rowElement) {
				sibling = this.up(focusedRow, true);
			}
			
			this._removedFocus = {
				active: isActive,
				rowId: focusedRow.id,
				columnId: focusedTarget.column && focusedTarget.column.id,
				siblingId: !sibling || sibling.element === rowElement ? undefined : sibling.id
			};
			
			// Call _restoreFocus on next turn, to restore focus to sibling
			// if no replacement row was immediately inserted.
			// Pass original row's id in case it was re-inserted in a renderArray
			// call (and thus was found, but couldn't be focused immediately)
			setTimeout(function() {
				if(self._removedFocus){
					self._restoreFocus(focusedRow.id);
				}
			}, 0);
			
			// Clear _focusedNode until _restoreFocus is called, to avoid
			// needlessly re-running this logic
			this._focusedNode = null;
		}
		
		this.inherited(arguments);
	},
	
	insertRow: function(object){
		var rowElement = this.inherited(arguments);
		if(this._removedFocus && !this._removedFocus.wait){
			this._restoreFocus(rowElement);
		}
		return rowElement;
	},
	
	_restoreFocus: function(row) {
		// summary:
		//		Restores focus to the newly inserted row if it matches the
		//		previously removed row, or to the nearest sibling otherwise.
		
		var focusInfo = this._removedFocus,
			newTarget,
			cell;
		
		row = row && this.row(row);
		newTarget = row && row.element && row.id === focusInfo.rowId ? row :
			typeof focusInfo.siblingId !== "undefined" && this.row(focusInfo.siblingId);
		
		if(newTarget && newTarget.element){
			if(!newTarget.element.parentNode.parentNode){
				// This was called from renderArray, so the row hasn't
				// actually been placed in the DOM yet; handle it on the next
				// turn (called from removeRow).
				focusInfo.wait = true;
				return;
			}
			// Should focus be on a cell?
			if(typeof focusInfo.columnId !== "undefined"){
				cell = this.cell(newTarget, focusInfo.columnId);
				if(cell && cell.element){
					newTarget = cell;
				}
			}
			if(focusInfo.active && newTarget.element.offsetHeight !== 0){
				// Row/cell was previously focused and is visible, so focus the new one immediately
				this._focusOnNode(newTarget, false, null);
			}else{
				// Row/cell was not focused or is not visible, but we still need to
				// update _focusedNode and the element's tabIndex/class
				put(newTarget.element, ".dgrid-focus");
				newTarget.element.tabIndex = this.tabIndex;
				this._focusedNode = newTarget.element;
			}
		}
		
		delete this._removedFocus;
	},
	
	addKeyHandler: function(key, callback, isHeader){
		// summary:
		//		Adds a handler to the keyMap on the instance.
		//		Supports binding additional handlers to already-mapped keys.
		// key: Number
		//		Key code representing the key to be handled.
		// callback: Function
		//		Callback to be executed (in instance context) when the key is pressed.
		// isHeader: Boolean
		//		Whether the handler is to be added for the grid body (false, default)
		//		or the header (true).
		
		// Aspects may be about 10% slower than using an array-based appraoch,
		// but there is significantly less code involved (here and above).
		return aspect.after( // Handle
			this[isHeader ? "headerKeyMap" : "keyMap"], key, callback, true);
	},
	
	_focusOnNode: function(element, isHeader, event){
		var focusedNodeProperty = "_focused" + (isHeader ? "Header" : "") + "Node",
			focusedNode = this[focusedNodeProperty],
			cellOrRowType = this.cellNavigation ? "cell" : "row",
			cell = this[cellOrRowType](element),
			inputs,
			input,
			numInputs,
			inputFocused,
			i;
		
		element = cell && cell.element;
		if(!element){ return; }
		
		if(this.cellNavigation){
			inputs = element.getElementsByTagName("input");
			for(i = 0, numInputs = inputs.length; i < numInputs; i++){
				input = inputs[i];
				if((input.tabIndex != -1 || "_dgridLastValue" in input) && !input.disabled){
					// Employ workaround for focus rectangle in IE < 8
					if(has("ie") < 8){ input.style.position = "relative"; }
					input.focus();
					if(has("ie") < 8){ input.style.position = ""; }
					inputFocused = true;
					break;
				}
			}
		}
		
		// Set up event information for dgrid-cellfocusout/in events.
		// Note that these events are not fired for _restoreFocus.
		if(event !== null){
			event = lang.mixin({ grid: this }, event);
			if(event.type){
				event.parentType = event.type;
			}
			if(!event.bubbles){
				// IE doesn't always have a bubbles property already true.
				// Opera throws if you try to set it to true if it is already true.
				event.bubbles = true;
			}
		}
		
		if(focusedNode){
			// Clean up previously-focused element
			// Remove the class name and the tabIndex attribute
			put(focusedNode, "!dgrid-focus[!tabIndex]");
			if(has("ie") < 8){
				// Clean up after workaround below (for non-input cases)
				focusedNode.style.position = "";
			}
			
			// Expose object representing focused cell or row losing focus, via
			// event.cell or event.row; which is set depends on cellNavigation.
			if(event){
				event[cellOrRowType] = this[cellOrRowType](focusedNode);
				on.emit(focusedNode, "dgrid-cellfocusout", event);
			}
		}
		focusedNode = this[focusedNodeProperty] = element;
		
		if(event){
			// Expose object representing focused cell or row gaining focus, via
			// event.cell or event.row; which is set depends on cellNavigation.
			// Note that yes, the same event object is being reused; on.emit
			// performs a shallow copy of properties into a new event object.
			event[cellOrRowType] = cell;
		}
		
		var isFocusableClass = this.cellNavigation ? hasGridCellClass : hasGridRowClass;
		if(!inputFocused && isFocusableClass.test(element.className)){
			if(has("ie") < 8){
				// setting the position to relative magically makes the outline
				// work properly for focusing later on with old IE.
				// (can't be done a priori with CSS or screws up the entire table)
				element.style.position = "relative";
			}
			element.tabIndex = this.tabIndex;
			element.focus();
		}
		put(element, ".dgrid-focus");
		
		if(event){
			on.emit(focusedNode, "dgrid-cellfocusin", event);
		}
	},
	
	focusHeader: function(element){
		this._focusOnNode(element || this._focusedHeaderNode, true);
	},
	
	focus: function(element){
		var node = element || this._focusedNode;
		if(node){
			this._focusOnNode(node, false);
		}else{
			this.contentNode.focus();
		}
	}
});

// Common functions used in default keyMap (called in instance context)

var moveFocusVertical = Keyboard.moveFocusVertical = function(event, steps){
	var cellNavigation = this.cellNavigation,
		target = this[cellNavigation ? "cell" : "row"](event),
		columnId = cellNavigation && target.column.id,
		next = this.down(this._focusedNode, steps, true);
	
	// Navigate within same column if cell navigation is enabled
	if(cellNavigation){ next = this.cell(next, columnId); }
	this._focusOnNode(next, false, event);
	
	event.preventDefault();
};

var moveFocusUp = Keyboard.moveFocusUp = function(event){
	moveFocusVertical.call(this, event, -1);
};

var moveFocusDown = Keyboard.moveFocusDown = function(event){
	moveFocusVertical.call(this, event, 1);
};

var moveFocusPageUp = Keyboard.moveFocusPageUp = function(event){
	moveFocusVertical.call(this, event, -this.pageSkip);
};

var moveFocusPageDown = Keyboard.moveFocusPageDown = function(event){
	moveFocusVertical.call(this, event, this.pageSkip);
};

var moveFocusHorizontal = Keyboard.moveFocusHorizontal = function(event, steps){
	if(!this.cellNavigation){ return; }
	var isHeader = !this.row(event), // header reports row as undefined
		currentNode = this["_focused" + (isHeader ? "Header" : "") + "Node"];
	
	this._focusOnNode(this.right(currentNode, steps), isHeader, event);
	event.preventDefault();
};

var moveFocusLeft = Keyboard.moveFocusLeft = function(event){
	moveFocusHorizontal.call(this, event, -1);
};

var moveFocusRight = Keyboard.moveFocusRight = function(event){
	moveFocusHorizontal.call(this, event, 1);
};

var moveHeaderFocusEnd = Keyboard.moveHeaderFocusEnd = function(event, scrollToBeginning){
	// Header case is always simple, since all rows/cells are present
	var nodes;
	if(this.cellNavigation){
		nodes = this.headerNode.getElementsByTagName("th");
		this._focusOnNode(nodes[scrollToBeginning ? 0 : nodes.length - 1], true, event);
	}
	// In row-navigation mode, there's nothing to do - only one row in header
	
	// Prevent browser from scrolling entire page
	event.preventDefault();
};

var moveHeaderFocusHome = Keyboard.moveHeaderFocusHome = function(event){
	moveHeaderFocusEnd.call(this, event, true);
};

var moveFocusEnd = Keyboard.moveFocusEnd = function(event, scrollToTop){
	// summary:
	//		Handles requests to scroll to the beginning or end of the grid.
	
	// Assume scrolling to top unless event is specifically for End key
	var self = this,
		cellNavigation = this.cellNavigation,
		contentNode = this.contentNode,
		contentPos = scrollToTop ? 0 : contentNode.scrollHeight,
		scrollPos = contentNode.scrollTop + contentPos,
		endChild = contentNode[scrollToTop ? "firstChild" : "lastChild"],
		hasPreload = endChild.className.indexOf("dgrid-preload") > -1,
		endTarget = hasPreload ? endChild[(scrollToTop ? "next" : "previous") + "Sibling"] : endChild,
		endPos = endTarget.offsetTop + (scrollToTop ? 0 : endTarget.offsetHeight),
		handle;
	
	if(hasPreload){
		// Find the nearest dgrid-row to the relevant end of the grid
		while(endTarget && endTarget.className.indexOf("dgrid-row") < 0){
			endTarget = endTarget[(scrollToTop ? "next" : "previous") + "Sibling"];
		}
		// If none is found, there are no rows, and nothing to navigate
		if(!endTarget){ return; }
	}
	
	// Grid content may be lazy-loaded, so check if content needs to be
	// loaded first
	if(!hasPreload || endChild.offsetHeight < 1){
		// End row is loaded; focus the first/last row/cell now
		if(cellNavigation){
			// Preserve column that was currently focused
			endTarget = this.cell(endTarget, this.cell(event).column.id);
		}
		this._focusOnNode(endTarget, false, event);
	}else{
		// In IE < 9, the event member references will become invalid by the time
		// _focusOnNode is called, so make a (shallow) copy up-front
		if(!has("dom-addeventlistener")){
			event = lang.mixin({}, event);
		}
		
		// If the topmost/bottommost row rendered doesn't reach the top/bottom of
		// the contentNode, we are using OnDemandList and need to wait for more
		// data to render, then focus the first/last row in the new content.
		handle = aspect.after(this, "renderArray", function(rows){
			handle.remove();
			return Deferred.when(rows, function(rows){
				var target = rows[scrollToTop ? 0 : rows.length - 1];
				if(cellNavigation){
					// Preserve column that was currently focused
					target = self.cell(target, self.cell(event).column.id);
				}
				self._focusOnNode(target, false, event);
			});
		});
	}
	
	if(scrollPos === endPos){
		// Grid body is already scrolled to end; prevent browser from scrolling
		// entire page instead
		event.preventDefault();
	}
};

var moveFocusHome = Keyboard.moveFocusHome = function(event){
	moveFocusEnd.call(this, event, true);
};

function preventDefault(event){
	event.preventDefault();
}

Keyboard.defaultKeyMap = {
	32: preventDefault, // space
	33: moveFocusPageUp, // page up
	34: moveFocusPageDown, // page down
	35: moveFocusEnd, // end
	36: moveFocusHome, // home
	37: moveFocusLeft, // left
	38: moveFocusUp, // up
	39: moveFocusRight, // right
	40: moveFocusDown // down
};

// Header needs fewer default bindings (no vertical), so bind it separately
Keyboard.defaultHeaderKeyMap = {
	32: preventDefault, // space
	35: moveHeaderFocusEnd, // end
	36: moveHeaderFocusHome, // home
	37: moveFocusLeft, // left
	39: moveFocusRight // right
};

return Keyboard;
});
},
'dgrid/ColumnSet':function(){
define(["dojo/_base/kernel", "dojo/_base/declare", "dojo/_base/lang", "dojo/_base/Deferred", "dojo/on", "dojo/aspect", "dojo/query", "dojo/has", "./util/misc", "put-selector/put", "xstyle/has-class", "./Grid", "dojo/_base/sniff", "xstyle/css!./css/columnset.css"],
function(kernel, declare, lang, Deferred, listen, aspect, query, has, miscUtil, put, hasClass, Grid){
	has.add("event-mousewheel", function(global, document, element){
		return typeof element.onmousewheel !== "undefined";
	});
	has.add("event-wheel", function(global, document, element){
		var supported = false;
		// From https://developer.mozilla.org/en-US/docs/Mozilla_event_reference/wheel
		try{
			WheelEvent("wheel");
			supported = true;
		}catch(e){
			// empty catch block; prevent debuggers from snagging
		}
		return supported;
	});

	var colsetidAttr = "data-dgrid-column-set-id";
	
	hasClass("safari", "ie-7");
	
	function adjustScrollLeft(grid, row){
		var scrollLefts = grid._columnSetScrollLefts;
		function doAdjustScrollLeft(){
			query(".dgrid-column-set", row).forEach(function(element){
				element.scrollLeft = scrollLefts[element.getAttribute(colsetidAttr)];
			});
		}
		if(has("ie") < 8 || has("quirks")){
			setTimeout(doAdjustScrollLeft, 1);
		}else{
			doAdjustScrollLeft();
		}
	}
	
	function scrollColumnSetTo(grid, columnSetNode, offsetLeft){
		var id = columnSetNode.getAttribute(colsetidAttr);
		var scroller = grid._columnSetScrollers[id];

		scroller.scrollLeft = offsetLeft < 0 ? 0 : offsetLeft;
	}

	function getColumnSetSubRows(subRows, columnSetId){
		// Builds a subRow collection that only contains columns that correspond to
		// a given column set id.
		if(!subRows || !subRows.length){
			return;
		}
		var subset = [];
		var idPrefix = columnSetId + "-";
		for(var i = 0, numRows = subRows.length; i < numRows; i++){
			var row = subRows[i];
			var subsetRow = [];
			subsetRow.className = row.className;
			for(var k = 0, numCols = row.length; k < numCols; k++){
				var column = row[k];
				// The column id begins with the column set id.
				if(column.id != null && column.id.indexOf(idPrefix) === 0){
					subsetRow.push(column);
				}
			}
			subset.push(subsetRow);
		}
		return subset;
	}

	var horizMouseWheel = has("event-mousewheel") || has("event-wheel") ? function(grid){
		return function(target, listener){
			return listen(target, has("event-wheel") ? "wheel" : "mousewheel", function(event){
				var node = event.target, deltaX;
				// WebKit will invoke mousewheel handlers with an event target of a text
				// node; check target and if it's not an element node, start one node higher
				// in the tree
				if(node.nodeType !== 1){
					node = node.parentNode;
				}
				while(!query.matches(node, ".dgrid-column-set[" + colsetidAttr + "]", target)){
					if(node === target || !(node = node.parentNode)){
						return;
					}
				}
				
				// Normalize reported delta value:
				// wheelDeltaX (webkit, mousewheel) needs to be negated and divided by 3
				// deltaX (FF17+, wheel) can be used exactly as-is
				deltaX = event.deltaX || -event.wheelDeltaX / 3;
				if(deltaX){
					// only respond to horizontal movement
					listener.call(null, grid, node, deltaX);
				}
			});
		};
	} : function(grid){
		return function(target, listener){
			return listen(target, ".dgrid-column-set[" + colsetidAttr + "]:MozMousePixelScroll", function(event){
				if(event.axis === 1){
					// only respond to horizontal movement
					listener.call(null, grid, this, event.detail);
				}
			});
		};
	};
	
	return declare(null, {
		// summary:
		//		Provides column sets to isolate horizontal scroll of sets of 
		//		columns from each other. This mainly serves the purpose of allowing for
		//		column locking.
		
		postCreate: function(){
			var self = this;
			this.inherited(arguments);
			
			this.on(horizMouseWheel(this), function(grid, colsetNode, amount){
				var id = colsetNode.getAttribute(colsetidAttr),
					scroller = grid._columnSetScrollers[id],
					scrollLeft = scroller.scrollLeft + amount;
				
				scroller.scrollLeft = scrollLeft < 0 ? 0 : scrollLeft;
			});
			this.on('.dgrid-column-set:dgrid-cellfocusin', function (event) {
				self._onColumnSetCellFocus(event, this);
			});
		},
		columnSets: [],
		createRowCells: function(tag, each, subRows, object){
			var row = put("table.dgrid-row-table");
			var tr = put(row, "tbody tr");
			for(var i = 0, l = this.columnSets.length; i < l; i++){
				// iterate through the columnSets
				var cell = put(tr, tag + ".dgrid-column-set-cell.dgrid-column-set-" + i +
					" div.dgrid-column-set[" + colsetidAttr + "=" + i + "]");
				var subset = getColumnSetSubRows(subRows || this.subRows , i) || this.columnSets[i];
				cell.appendChild(this.inherited(arguments, [tag, each, subset, object]));
			}
			return row;
		},
		renderArray: function(){
			var grid = this,
				rows = this.inherited(arguments);

			Deferred.when(rows, function(rows){
				for(var i = 0; i < rows.length; i++){
					adjustScrollLeft(grid, rows[i]);
				}
			});
			return rows;
		},

		renderHeader: function(){
			// summary:
			//		Setup the headers for the grid
			this.inherited(arguments);
			
			var columnSets = this.columnSets,
				domNode = this.domNode,
				scrollers = this._columnSetScrollers,
				scrollerContents = this._columnSetScrollerContents = {},
				scrollLefts = this._columnSetScrollLefts = {},
				grid = this,
				i, l;
			
			function reposition(){
				grid._positionScrollers();
			}
			
			if (scrollers) {
				// this isn't the first time; destroy existing scroller nodes first
				for(i in scrollers){
					put(scrollers[i], "!");
				}
			} else {
				// first-time-only operations: hook up event/aspected handlers
				aspect.after(this, "resize", reposition, true);
				aspect.after(this, "styleColumn", reposition, true);
				this._columnSetScrollerNode = put(this.footerNode, "+div.dgrid-column-set-scroller-container");
			}
			
			// reset to new object to be populated in loop below
			scrollers = this._columnSetScrollers = {};
			
			for(i = 0, l = columnSets.length; i < l; i++){
				this._putScroller(columnSets[i], i);
			}
			
			this._positionScrollers();
		},
		
		styleColumnSet: function(colsetId, css){
			// summary:
			//		Dynamically creates a stylesheet rule to alter a columnset's style.
			
			var rule = this.addCssRule("#" + miscUtil.escapeCssIdentifier(this.domNode.id) +
				" .dgrid-column-set-" + miscUtil.escapeCssIdentifier(colsetId, "-"), css);
			this._positionScrollers();
			return rule;
		},
		
		_destroyColumns: function(){
			var columnSetsLength = this.columnSets.length,
				i, j, k, subRowsLength, len, columnSet, subRow, column;
			for(i = 0; i < columnSetsLength; i++){
				columnSet = this.columnSets[i];
				for(j = 0, subRowsLength = columnSet.length; j < subRowsLength; j++){
					subRow = columnSet[j];
					for(k = 0, len = subRow.length; k < len; k++){
						column = subRow[k];
						if(typeof column.destroy === "function"){ column.destroy(); }
					}
				}
			}
			this.inherited(arguments);
		},

		configStructure: function(){
			// Squash the column sets together so the grid and other dgrid extensions and mixins can
			// configure the columns and create any needed subrows.
			this.columns = {};
			this.subRows = [];
			for(var i = 0, l = this.columnSets.length; i < l; i++){
				var columnSet = this.columnSets[i];
				for(var j = 0; j < columnSet.length; j++){
					columnSet[j] = this._configColumns(i + "-" + j + "-", columnSet[j]);
				}
			}
			this.inherited(arguments);
		},

		_positionScrollers: function (){
			var domNode = this.domNode,
				scrollers = this._columnSetScrollers,
				scrollerContents = this._columnSetScrollerContents,
				columnSets = this.columnSets,
				scrollerWidth = 0,
				numScrollers = 0, // tracks number of visible scrollers (sets w/ overflow)
				i, l, columnSetElement, contentWidth;
			
			for(i = 0, l = columnSets.length; i < l; i++){
				// iterate through the columnSets
				columnSetElement = query('.dgrid-column-set[' + colsetidAttr + '="' + i +'"]', domNode)[0];
				scrollerWidth = columnSetElement.offsetWidth;
				contentWidth = columnSetElement.firstChild.offsetWidth;
				scrollerContents[i].style.width = contentWidth + "px";
				scrollers[i].style.width = scrollerWidth + "px";
				
				if(has("ie") < 9){
					// IE seems to need scroll to be set explicitly
					scrollers[i].style.overflowX = contentWidth > scrollerWidth ? "scroll" : "auto";
				}
				
				// Keep track of how many scrollbars we're showing
				if(contentWidth > scrollerWidth){ numScrollers++; }
			}
			
			this._columnSetScrollerNode.style.bottom = this.showFooter ? this.footerNode.offsetHeight + "px" : "0";
			
			// Align bottom of body node depending on whether there are scrollbars
			this.bodyNode.style.bottom = numScrollers ?
				(has("dom-scrollbar-height") + (has("ie") ? 1 : 0) + "px") :
				"0";
		},

		_putScroller: function (columnSet, i){
			// function called for each columnSet
			var scroller = this._columnSetScrollers[i] =
				put(this._columnSetScrollerNode, "span.dgrid-column-set-scroller.dgrid-column-set-scroller-" + i +
					"[" + colsetidAttr + "=" + i +"]");
			this._columnSetScrollerContents[i] = put(scroller, "div.dgrid-column-set-scroller-content");
			listen(scroller, "scroll", lang.hitch(this, '_onColumnSetScroll'));
		},

		_onColumnSetScroll: function (evt){
			var scrollLeft = evt.target.scrollLeft,
				colSetId = evt.target.getAttribute(colsetidAttr),
				newScrollLeft;

			if(this._columnSetScrollLefts[colSetId] != scrollLeft){
				query('.dgrid-column-set[' + colsetidAttr + '="' + colSetId + '"],.dgrid-column-set-scroller[' + colsetidAttr + '="' + colSetId + '"]', this.domNode).
					forEach(function(element, i){
						element.scrollLeft = scrollLeft;
						if(!i){
							// Compute newScrollLeft based on actual resulting
							// value of scrollLeft, which may be different than
							// what we assigned under certain circumstances
							// (e.g. Chrome under 33% / 67% / 90% zoom).
							// Only need to compute this once, as it will be the
							// same for every row.
							newScrollLeft = element.scrollLeft;
						}
					});
				this._columnSetScrollLefts[colSetId] = newScrollLeft;
			}
		},
		
		_setColumnSets: function(columnSets){
			this._destroyColumns();
			this.columnSets = columnSets;
			this._updateColumns();
		},
		setColumnSets: function(columnSets){
			kernel.deprecated("setColumnSets(...)", 'use set("columnSets", ...) instead', "dgrid 0.4");
			this.set("columnSets", columnSets);
		},

		_onColumnSetCellFocus: function(event, columnSetNode){
			var focusedNode = event.target;
			var columnSetId = columnSetNode.getAttribute(colsetidAttr);
			// columnSetNode's offsetLeft is not always correct,
			// so get the columnScroller to check offsetLeft against
			var columnScroller = this._columnSetScrollers[columnSetId];
			var elementEdge = focusedNode.offsetLeft - columnScroller.scrollLeft + focusedNode.offsetWidth;

			if (elementEdge > columnSetNode.offsetWidth ||
				columnScroller.scrollLeft > focusedNode.offsetLeft) {
				scrollColumnSetTo(this, columnSetNode, focusedNode.offsetLeft);
			}
		}
	});
});

},
'dgrid/extensions/ColumnResizer':function(){
define(["dojo/_base/declare", "dojo/on", "dojo/query", "dojo/_base/lang", "dojo/dom", "dojo/dom-geometry", "dojo/has", "../util/misc", "put-selector/put", "dojo/_base/html", "xstyle/css!../css/extensions/ColumnResizer.css"],
function(declare, listen, query, lang, dom, geom, has, miscUtil, put){

function addRowSpan(table, span, startRow, column, id){
	// loop through the rows of the table and add this column's id to
	// the rows' column
	for(var i=1; i<span; i++){
		table[startRow+i][column] = id;
	}
}
function subRowAssoc(subRows){
	// Take a sub-row structure and output an object with key=>value pairs
	// The keys will be the column id's; the values will be the first-row column
	// that column's resizer should be associated with.

	var i = subRows.length,
		l = i,
		numCols = subRows[0].length,
		table = new Array(i);

	// create table-like structure in an array so it can be populated
	// with row-spans and col-spans
	while(i--){
		table[i] = new Array(numCols);
	}

	var associations = {};

	for(i=0; i<l; i++){
		var row = table[i],
			subRow = subRows[i];

		// j: counter for table columns
		// js: counter for subrow structure columns
		for(var j=0, js=0; j<numCols; j++){
			var cell = subRow[js], k;

			// if something already exists in the table (row-span), skip this
			// spot and go to the next
			if(typeof row[j] != "undefined"){
				continue;
			}
			row[j] = cell.id;

			if(cell.rowSpan && cell.rowSpan > 1){
				addRowSpan(table, cell.rowSpan, i, j, cell.id);
			}

			// colSpans are only applicable in the second or greater rows
			// and only if the colSpan is greater than 1
			if(i>0 && cell.colSpan && cell.colSpan > 1){
				for(k=1; k<cell.colSpan; k++){
					// increment j and assign the id since this is a span
					row[++j] = cell.id;
					if(cell.rowSpan && cell.rowSpan > 1){
						addRowSpan(table, cell.rowSpan, i, j, cell.id);
					}
				}
			}
			associations[cell.id] = subRows[0][j].id;
			js++;
		}
	}

	return associations;
}

function resizeColumnWidth(grid, colId, width, parentType, doResize){
	// don't react to widths <= 0, e.g. for hidden columns
	if(width <= 0){ return; }

	var column = grid.columns[colId],
		event,
		rule;
	
	if(!column){
		return;
	}
	
	event = {
		grid: grid,
		columnId: colId,
		width: width,
		bubbles: true,
		cancelable: true
	};
	
	if(parentType){
		event.parentType = parentType;
	}
	
	if(!grid._resizedColumns || listen.emit(grid.headerNode, "dgrid-columnresize", event)){
		// Update width on column object, then convert value for CSS
		if(width === "auto"){
			delete column.width;
		}else{
			column.width = width;
			width += "px";
		}
		
		rule = grid._columnSizes[colId];
		
		if(rule){
			// Modify existing, rather than deleting + adding
			rule.set("width", width);
		}else{
			// Use miscUtil function directly, since we clean these up ourselves anyway
			rule = miscUtil.addCssRule("#" + miscUtil.escapeCssIdentifier(grid.domNode.id) +
				" .dgrid-column-" + miscUtil.escapeCssIdentifier(colId, "-"),
				"width: " + width + ";");
		}

		// keep a reference for future removal
		grid._columnSizes[colId] = rule;
		
		if(doResize !== false){
			grid.resize();
		}
		
		return true;
	}
}

// Functions for shared resizer node

var resizerNode, // DOM node for resize indicator, reused between instances
	resizableCount = 0; // Number of ColumnResizer-enabled grid instances
var resizer = {
	// This object contains functions for manipulating the shared resizerNode
	create: function(){
		resizerNode = put("div.dgrid-column-resizer");
	},
	destroy: function(){
		put(resizerNode, "!");
		resizerNode = null;
	},
	show: function(grid){
		var pos = geom.position(grid.domNode, true);
		resizerNode.style.top = pos.y + "px";
		resizerNode.style.height = pos.h + "px";
		put(document.body, resizerNode);
	},
	move: function(x){
		resizerNode.style.left = x + "px";
	},
	hide: function(){
		resizerNode.parentNode.removeChild(resizerNode);
	}
};

return declare(null, {
	resizeNode: null,
	
	// minWidth: Number
	//		Minimum column width, in px.
	minWidth: 40,
	
	// adjustLastColumn: Boolean
	//		If true, adjusts the last column's width to "auto" at times where the
	//		browser would otherwise stretch all columns to span the grid.
	adjustLastColumn: true,
	
	_resizedColumns: false, // flag indicating if resizer has converted column widths to px
	
	buildRendering: function(){
		this.inherited(arguments);
		
		// Create resizerNode when first grid w/ ColumnResizer is created
		if(!resizableCount++){
			resizer.create();
		}
	},
	
	destroy: function(){
		this.inherited(arguments);
		
		// Remove any applied column size styles since we're tracking them directly
		for(var name in this._columnSizes){
			this._columnSizes[name].remove();
		}
		
		// If this is the last grid on the page with ColumnResizer, destroy the
		// shared resizerNode
		if(!--resizableCount){
			resizer.destroy();
		}
	},
	
	resizeColumnWidth: function(colId, width){
		// Summary:
		//      calls grid's styleColumn function to add a style for the column
		// colId: String
		//      column id
		// width: Integer
		//      new width of the column
		return resizeColumnWidth(this, colId, width);
	},
	
	configStructure: function(){
		var oldSizes = this._oldColumnSizes = lang.mixin({}, this._columnSizes), // shallow clone
			k;
		
		this._resizedColumns = false;
		this._columnSizes = {};
		
		this.inherited(arguments);
		
		// Remove old column styles that are no longer relevant; this is specifically
		// done *after* calling inherited so that _columnSizes will contain keys
		// for all columns in the new structure that were assigned widths.
		for(k in oldSizes){
			if(!(k in this._columnSizes)){
				oldSizes[k].remove();
			}
		}
		delete this._oldColumnSizes;
	},
	
	_configColumn: function(column){
		this.inherited(arguments);
		
		var colId = column.id,
			rule;
		
		if("width" in column){
			// Update or add a style rule for the specified width
			if((rule = this._oldColumnSizes[colId])){
				rule.set("width", column.width + "px");
			}else{
				rule = miscUtil.addCssRule("#" + miscUtil.escapeCssIdentifier(this.domNode.id) +
					" .dgrid-column-" + miscUtil.escapeCssIdentifier(colId, "-"),
					"width: " + column.width + "px;");
			}
			this._columnSizes[colId] = rule;
		}
	},
	
	renderHeader: function(){
		this.inherited(arguments);
		
		var grid = this;
		
		var assoc;
		if(this.columnSets && this.columnSets.length){
			var csi = this.columnSets.length;
			while(csi--){
				assoc = lang.mixin(assoc||{}, subRowAssoc(this.columnSets[csi]));
			}
		}else if(this.subRows && this.subRows.length > 1){
			assoc = subRowAssoc(this.subRows);
		}

		var colNodes = query(".dgrid-cell", grid.headerNode),
			i = colNodes.length;
		while(i--){
			var colNode = colNodes[i],
				id = colNode.columnId,
				col = grid.columns[id],
				childNodes = colNode.childNodes,
				resizeHandle;

			if(!col || col.resizable === false){ continue; }

			var headerTextNode = put("div.dgrid-resize-header-container");
			colNode.contents = headerTextNode;

			// move all the children to the header text node
			while(childNodes.length > 0){
				put(headerTextNode, childNodes[0]);
			}

			resizeHandle = put(colNode, headerTextNode, "div.dgrid-resize-handle.resizeNode-" +
				miscUtil.escapeCssIdentifier(id, "-"));
			resizeHandle.columnId = assoc && assoc[id] || id;
		}

		if(!grid.mouseMoveListen){
			// establish listeners for initiating, dragging, and finishing resize
			listen(grid.headerNode,
				".dgrid-resize-handle:mousedown" +
					(has("touch") ? ",.dgrid-resize-handle:touchstart" : ""),
				function(e){
					grid._resizeMouseDown(e, this);
					grid.mouseMoveListen.resume();
					grid.mouseUpListen.resume();
				}
			);
			grid._listeners.push(grid.mouseMoveListen = listen.pausable(document,
				"mousemove" + (has("touch") ? ",touchmove" : ""),
				miscUtil.throttleDelayed(function(e){ grid._updateResizerPosition(e); })
			));
			grid._listeners.push(grid.mouseUpListen = listen.pausable(document,
				"mouseup" + (has("touch") ? ",touchend" : ""),
				function(e){
					grid._resizeMouseUp(e);
					grid.mouseMoveListen.pause();
					grid.mouseUpListen.pause();
				}
			));
			// initially pause the move/up listeners until a drag happens
			grid.mouseMoveListen.pause();
			grid.mouseUpListen.pause();
		}
	}, // end renderHeader

	_resizeMouseDown: function(e, target){
		// Summary:
		//      called when mouse button is pressed on the header
		// e: Object
		//      mousedown event object
		
		// preventDefault actually seems to be enough to prevent browser selection
		// in all but IE < 9.  setSelectable works for those.
		e.preventDefault();
		dom.setSelectable(this.domNode, false);
		this._startX = this._getResizeMouseLocation(e); //position of the target
		
		this._targetCell = query(".dgrid-column-" + miscUtil.escapeCssIdentifier(target.columnId, "-"),
			this.headerNode)[0];

		// Show resizerNode after initializing its x position
		this._updateResizerPosition(e);
		resizer.show(this);
	},
	_resizeMouseUp: function(e){
		// Summary:
		//      called when mouse button is released
		// e: Object
		//      mouseup event object
		
		var columnSizes = this._columnSizes,
			colNodes, colWidths, gridWidth;
		
		if(this.adjustLastColumn){
			// For some reason, total column width needs to be 1 less than this
			gridWidth = this.headerNode.clientWidth - 1;
		}
		
		//This is used to set all the column widths to a static size
		if(!this._resizedColumns){
			colNodes = query(".dgrid-cell", this.headerNode);
			
			if(this.columnSets && this.columnSets.length){
				colNodes = colNodes.filter(function(node){
					var idx = node.columnId.split("-");
					return idx[0] == "0" && !(node.columnId in columnSizes);
				});
			}else if(this.subRows && this.subRows.length > 1){
				colNodes = colNodes.filter(function(node){
					return node.columnId.charAt(0) == "0" && !(node.columnId in columnSizes);
				});
			}
			
			// Get a set of sizes before we start mutating, to avoid
			// weird disproportionate measures if the grid has set
			// column widths, but no full grid width set
			colWidths = colNodes.map(function(colNode){
				return colNode.offsetWidth;
			});
			
			// Set a baseline size for each column based on
			// its original measure
			colNodes.forEach(function(colNode, i){
				resizeColumnWidth(this, colNode.columnId, colWidths[i], null, false);
			}, this);
			
			this._resizedColumns = true;
		}
		dom.setSelectable(this.domNode, true);
		
		var cell = this._targetCell,
			delta = this._getResizeMouseLocation(e) - this._startX, //final change in position of resizer
			newWidth = cell.offsetWidth + delta, //the new width after resize
			obj = this._getResizedColumnWidths(),//get current total column widths before resize
			totalWidth = obj.totalWidth,
			lastCol = obj.lastColId,
			lastColWidth = query(".dgrid-column-" + miscUtil.escapeCssIdentifier(lastCol, "-"),
				this.headerNode)[0].offsetWidth;
		
		if(newWidth < this.minWidth){
			//enforce minimum widths
			newWidth = this.minWidth;
		}
		
		if(resizeColumnWidth(this, cell.columnId, newWidth, e.type)){
			if(cell.columnId != lastCol && this.adjustLastColumn){
				if(totalWidth + delta < gridWidth) {
					//need to set last column's width to auto
					resizeColumnWidth(this, lastCol, "auto", e.type);
				}else if(lastColWidth-delta <= this.minWidth) {
					//change last col width back to px, unless it is the last column itself being resized...
					resizeColumnWidth(this, lastCol, this.minWidth, e.type);
				}
			}
		}
		resizer.hide();
		
		// Clean up after the resize operation
		delete this._startX;
		delete this._targetCell;
	},
	
	_updateResizerPosition: function(e){
		// Summary:
		//      updates position of resizer bar as mouse moves
		// e: Object
		//      mousemove event object

		if(!this._targetCell){ return; } // Release event was already processed
		
		var mousePos = this._getResizeMouseLocation(e),
			delta = mousePos - this._startX, //change from where user clicked to where they drag
			width = this._targetCell.offsetWidth,
			left = mousePos;
		if(width + delta < this.minWidth){ 
			left = this._startX - (width - this.minWidth); 
		}
		resizer.move(left);
	},

	_getResizeMouseLocation: function(e){
		//Summary:
		//      returns position of mouse relative to the left edge
		// e: event object
		//      mouse move event object
		var posX = 0;
		if(e.pageX){
			posX = e.pageX;
		}else if(e.clientX){
			posX = e.clientX + document.body.scrollLeft +
				document.documentElement.scrollLeft;
		}
		return posX;
	},
	_getResizedColumnWidths: function (){
		//Summary:
		//      returns object containing new column width and column id
		var totalWidth = 0,
			colNodes = query(
				(this.columnSets ? ".dgrid-column-set-cell " : "") + "tr:first-child .dgrid-cell",
				this.headerNode);

		var i = colNodes.length;
		if(!i){ return {}; }

		var lastColId = colNodes[i-1].columnId;

		while(i--){
			totalWidth += colNodes[i].offsetWidth;
		}
		return {totalWidth: totalWidth, lastColId: lastColId};
	}
});
});

},
'dgrid/extensions/DnD':function(){
define([
	"dojo/_base/declare",
	"dojo/_base/lang",
	"dojo/_base/array",
	"dojo/_base/Deferred",
	"dojo/aspect",
	"dojo/on",
	"dojo/topic",
	"dojo/has",
	"dojo/dnd/Source",
	"dojo/dnd/Manager",
	"dojo/_base/NodeList",
	"put-selector/put",
	"../Selection",
	"dojo/has!touch?../util/touch",
	"dojo/has!touch?./_DnD-touch-autoscroll",
	"xstyle/css!dojo/resources/dnd.css"
], function(declare, lang, arrayUtil, Deferred, aspect, on, topic, has, DnDSource, DnDManager, NodeList, put, Selection, touchUtil){
	// Requirements
	// * requires a store (sounds obvious, but not all Lists/Grids have stores...)
	// * must support options.before in put calls
	//   (if undefined, put at end)
	// * should support copy
	//   (copy should also support options.before as above)
	
	// TODOs
	// * consider sending items rather than nodes to onDropExternal/Internal
	// * consider emitting store errors via OnDemandList._trackError
	
	var GridDnDSource = declare(DnDSource, {
		grid: null,
		
		getObject: function(node){
			// summary:
			//		getObject is a method which should be defined on any source intending
			//		on interfacing with dgrid DnD.
			
			var grid = this.grid;
			// Extract item id from row node id (gridID-row-*).
			return grid.store.get(node.id.slice(grid.id.length + 5));
		},
		_legalMouseDown: function(evt){
			// Fix _legalMouseDown to only allow starting drag from an item
			// (not from bodyNode outside contentNode).
			var legal = this.inherited(arguments);
			return legal && evt.target != this.grid.bodyNode;
		},

		// DnD method overrides
		onDrop: function(sourceSource, nodes, copy){
			var targetSource = this,
				targetRow = this._targetAnchor = this.targetAnchor, // save for Internal
				grid = this.grid,
				store = grid.store;
			
			if(!this.before && targetRow){
				// target before next node if dropped within bottom half of this node
				// (unless there's no node to target at all)
				targetRow = targetRow.nextSibling;
			}
			targetRow = targetRow && grid.row(targetRow);
			
			Deferred.when(targetRow && store.get(targetRow.id), function(target){
				// Note: if dropping after the last row, or into an empty grid,
				// target will be undefined.  Thus, it is important for store to place
				// item last in order if options.before is undefined.
				
				// Delegate to onDropInternal or onDropExternal for rest of logic.
				// These are passed the target item as an additional argument.
				if(targetSource != sourceSource){
					targetSource.onDropExternal(sourceSource, nodes, copy, target);
				}else{
					targetSource.onDropInternal(nodes, copy, target);
				}
			});
		},
		onDropInternal: function(nodes, copy, targetItem){
			var grid = this.grid,
				store = grid.store,
				targetSource = this,
				anchor = targetSource._targetAnchor,
				targetRow,
				nodeRow;
			
			if(anchor){ // (falsy if drop occurred in empty space after rows)
				targetRow = this.before ? anchor.previousSibling : anchor.nextSibling;
			}
			
			// Don't bother continuing if the drop is really not moving anything.
			// (Don't need to worry about edge first/last cases since dropping
			// directly on self doesn't fire onDrop, but we do have to worry about
			// dropping last node into empty space beyond rendered rows.)
			nodeRow = grid.row(nodes[0]);
			if(!copy && (targetRow === nodes[0] ||
					(!targetItem && nodeRow && grid.down(nodeRow).element == nodes[0]))){
				return;
			}
			
			nodes.forEach(function(node){
				Deferred.when(targetSource.getObject(node), function(object){
					var id = store.getIdentity(object);
					
					// For copy DnD operations, copy object, if supported by store;
					// otherwise settle for put anyway.
					// (put will relocate an existing item with the same id, i.e. move).
					store[copy && store.copy ? "copy" : "put"](object, {
						before: targetItem
					});
					
					// Self-drops won't cause the dgrid-select handler to re-fire,
					// so update the cached node manually
					if(targetSource._selectedNodes[id]){
						targetSource._selectedNodes[id] = grid.row(id).element;
					}
				});
			});
		},
		onDropExternal: function(sourceSource, nodes, copy, targetItem){
			// Note: this default implementation expects that two grids do not
			// share the same store.  There may be more ideal implementations in the
			// case of two grids using the same store (perhaps differentiated by
			// query), dragging to each other.
			var store = this.grid.store,
				sourceGrid = sourceSource.grid;
			
			// TODO: bail out if sourceSource.getObject isn't defined?
			nodes.forEach(function(node, i){
				Deferred.when(sourceSource.getObject(node), function(object){
					if(!copy){
						if(sourceGrid){
							// Remove original in the case of inter-grid move.
							// (Also ensure dnd source is cleaned up properly)
							Deferred.when(sourceGrid.store.getIdentity(object), function(id){
								!i && sourceSource.selectNone(); // deselect all, one time
								sourceSource.delItem(node.id);
								sourceGrid.store.remove(id);
							});
						}else{
							sourceSource.deleteSelectedNodes();
						}
					}
					// Copy object, if supported by store; otherwise settle for put
					// (put will relocate an existing item with the same id).
					// Note that we use store.copy if available even for non-copy dnd:
					// since this coming from another dnd source, always behave as if
					// it is a new store item if possible, rather than replacing existing.
					store[store.copy ? "copy" : "put"](object, {
						before: targetItem
					});
				});
			});
		},
		
		onDndStart: function(source, nodes, copy){
			// Listen for start events to apply style change to avatar.
			
			this.inherited(arguments); // DnDSource.prototype.onDndStart.apply(this, arguments);
			if(source == this){
				// If TouchScroll is in use, cancel any pending scroll operation.
				if(this.grid.cancelTouchScroll){ this.grid.cancelTouchScroll(); }
				
				// Set avatar width to half the grid's width.
				// Kind of a naive default, but prevents ridiculously wide avatars.
				DnDManager.manager().avatar.node.style.width =
					this.grid.domNode.offsetWidth / 2 + "px";
			}
		},
		
		onMouseDown: function(evt){
			// Cancel the drag operation on presence of more than one contact point.
			// (This check will evaluate to false under non-touch circumstances.)
			if(has("touch") && this.isDragging &&
					touchUtil.countCurrentTouches(evt, this.grid.touchNode) > 1){
				topic.publish("/dnd/cancel");
				DnDManager.manager().stopDrag();
			}else{
				this.inherited(arguments);
			}
		},
		
		onMouseMove: function(evt){
			// If we're handling touchmove, only respond to single-contact events.
			if(!has("touch") || touchUtil.countCurrentTouches(evt, this.grid.touchNode) <= 1){
				this.inherited(arguments);
			}
		},
		
		checkAcceptance: function(source, nodes){
			// Augment checkAcceptance to block drops from sources without getObject.
			return source.getObject &&
				DnDSource.prototype.checkAcceptance.apply(this, arguments);
		},
		getSelectedNodes: function(){
			// If dgrid's Selection mixin is in use, synchronize with it, using a
			// map of node references (updated on dgrid-[de]select events).
			
			if(!this.grid.selection){
				return this.inherited(arguments);
			}
			var t = new NodeList(),
				id;
			for(id in this.grid.selection){
				t.push(this._selectedNodes[id]);
			}
			return t;	// NodeList
		}
		// TODO: could potentially also implement copyState to jive with default
		// onDrop* implementations (checking whether store.copy is available);
		// not doing that just yet until we're sure about default impl.
	});
	
	// Mix in Selection for more resilient dnd handling, particularly when part
	// of the selection is scrolled out of view and unrendered (which we
	// handle below).
	var DnD = declare(Selection, {
		// dndSourceType: String
		//		Specifies the type which will be set for DnD items in the grid,
		//		as well as what will be accepted by it by default.
		dndSourceType: "dgrid-row",
		
		// dndParams: Object
		//		Object containing params to be passed to the DnD Source constructor.
		dndParams: null,
		
		// dndConstructor: Function
		//		Constructor from which to instantiate the DnD Source.
		//		Defaults to the GridSource constructor defined/exposed by this module.
		dndConstructor: GridDnDSource,
		
		postMixInProperties: function(){
			this.inherited(arguments);
			// ensure dndParams is initialized
			this.dndParams = lang.mixin({ accept: [this.dndSourceType] }, this.dndParams);
		},
		
		postCreate: function(){
			this.inherited(arguments);
			
			// Make the grid's content a DnD source/target.
			this.dndSource = new (this.dndConstructor || GridDnDSource)(
				this.bodyNode,
				lang.mixin(this.dndParams, {
					// add cross-reference to grid for potential use in inter-grid drop logic
					grid: this,
					dropParent: this.contentNode
				})
			);
			
			// Set up select/deselect handlers to maintain references, in case selected
			// rows are scrolled out of view and unrendered, but then dragged.
			var selectedNodes = this.dndSource._selectedNodes = {};
			
			function selectRow(row){
				selectedNodes[row.id] = row.element;
			}
			function deselectRow(row){
				delete selectedNodes[row.id];
				// Re-sync dojo/dnd UI classes based on deselection
				// (unfortunately there is no good programmatic hook for this)
				put(row.element, '!dojoDndItemSelected!dojoDndItemAnchor');
			}
			
			this.on("dgrid-select", function(event){
				arrayUtil.forEach(event.rows, selectRow);
			});
			this.on("dgrid-deselect", function(event){
				arrayUtil.forEach(event.rows, deselectRow);
			});
			
			aspect.after(this, "destroy", function(){
				delete this.dndSource._selectedNodes;
				selectedNodes = null;
				this.dndSource.destroy();
			}, true);
		},
		
		insertRow: function(object){
			// override to add dojoDndItem class to make the rows draggable
			var row = this.inherited(arguments),
				type = typeof this.getObjectDndType == "function" ?
					this.getObjectDndType(object) : [this.dndSourceType];
			
			put(row, ".dojoDndItem");
			this.dndSource.setItem(row.id, {
				data: object,
				type: type instanceof Array ? type : [type]
			});
			return row;
		},
		
		removeRow: function (rowElement) {
			this.dndSource.delItem(this.row(rowElement));
			this.inherited(arguments);
		}
	});
	DnD.GridSource = GridDnDSource;
	
	return DnD;
});

},
'vodori/ui/grid/_Selection':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/has', 'dojo/on',
    'dgrid/Selection'
], function(module, provide,
            _,
            lang, has, on,
            Selection) {

    /**
     * This is the Vodori mixin for controlling Selection within a dgrid grid.
     *
     * Primarily, it synthesizes the `selectionChanged` event for us, as well as allowing selection and
     * deselection by object ID.
     * It also supports limiting the maximum number of rows that users can select.
     *
     * @mixin vodori/ui/grid/_Selection
     * @extends dgrid/Selection
     */
    return provide(module.id, [Selection],
        /**
         * @lends vodori/ui/grid/_Selection.prototype
         */
        {

            /**
             * Max allowed selections. -1 is a magic value that means unlimited.
             *
             * @type {number}
             */
            selectionLimit: -1,

            /**
             * @type {Array}
             * @private
             */
            _previousSelection: null,

            /**
             * @ignore
             */
            constructor: function() {
                /*
                 * Prepopulate so that this array is not empty, but won't accidentally match some arbitrary string
                 * down the line.
                 */
                this._previousSelection = [null];
            },

            /**
             * Selection change event
             *
             * @event _Selection#selectionChange
             * @type {object}
             * @property {Array} selection current selection
             * @property {Grid} grid dgrid
             */

            /**
             * Create a handler that will emit a 'selectionChange' event once and once only for
             * and changes to the grid selection.
             *
             * @param {Event} evt dgrid selection event
             * @fires _Selection#selectionChange
             * @private
             */
            _selectionEventHandler : function(evt) {
                _.defer(lang.hitch(this, function() {
                    if (!this.domNode) {
                        return; // if the widget has already been destroyed.
                    }

                    var currentSelection = _.keys(this.selection);
                    if(!_.isEqual(this._previousSelection, currentSelection)) {
                        on.emit(this.domNode, 'selectionChange', {
                            bubbles: true,
                            cancelable: true,
                            selection: this.selection,
                            grid: this
                        });
                        this._previousSelection = currentSelection;
                    }
                }));

                /*
                 * Have to call `_onChange` to support legacy code
                 */
                this._onChange();
            },

            /**
             * @inheritDoc
             */
            postCreate: function() {
                this.inherited(arguments);

                this.on('dgrid-select', lang.hitch(this,'_selectionEventHandler'));
                this.on('dgrid-deselect', lang.hitch(this,'_selectionEventHandler'));
            },

            /**
             * @inheritDoc
             * @param {string|Row} row
             * @return {boolean}
             */
            allowSelect: function(row) {
                var allowed = this.inherited(arguments);
                if(!allowed) {
                    return false;
                }

                // NOTE: if this.selectionLimit is -1 then unlimited selections are allowed.
                var selected = _.keys(this.selection),
                    confirmedRow = this.row(row),
                    overLimit = ((this.selectionLimit !== -1) &&
                                 (!_.contains(selected, confirmedRow.id)) &&
                                 (selected.length >= this.selectionLimit));

                // Notify the user if the selection is over the limit
                if (overLimit) {
                    this._reportDisallowedSelection({
                        title: 'Unable to make selection',
                        message: 'You can only select ' + this.selectionLimit + ' items.',
                        expireAfter: 6000
                    });
                    return false;
                }

                return true;
            },

            /**
             * This can be overridden to report problems in a more obvious way
             * @param {Object} message The message to report
             * @param {string} message.title A title string to place in any kind of pop-up or dialog that might render
             *                               the message
             * @param {string} message.message The actual message to report
             * @param {number} message.expireAfter The number of milliseconds, after which this message expires
             * @private
             */
            _reportDisallowedSelection: function(message) {
                console.warn(message);
            },

            /**
             * Perform an action on the items corresponding to the given IDs based on `action`.
             *
             * @param {Array.<string>} ids List of IDs that correspond to grid items.
             * @param {boolean} action Select if `true`, otherwise Deselect.
             */
            selectByIds: function(ids, action) {
                'use strict';
                if (!_.isArray(ids)) {
                    ids = [ ids ];
                }
                _.forEach(ids, function(id) {
                    this.select(id, null, action);
                }, this);
            },

            /**
             * Deselect the items that correspond to the provided IDs.
             *
             * @param {Array.<string>} ids List of IDs that correspond to grid items.
             */
            deselectByIds: function(ids) {
                'use strict';
                this.selectByIds(ids, false);
            }
        });
});

},
'vodori/ui/grid/_DnD':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/dom-class',
    'dgrid/extensions/DnD',
    'vodori/ui/GridDnDSource'
], function (module, provide, _, domClass, DnD, GridDnDSource) {

    /**
     * @mixin vodori/ui/grid/_DnD
     * @extends dgrid/extensions/DnD
     */
    return provide(module.id, [DnD],
        /**
         * @lends vodori/ui/grid/_DnD.prototype
         */
        {

            // DnD Setup Parameters
            dndParams: {
                selfAccept: true,   // Whether you can drop items into items in the grid it was dragged from
                withHandles: false, // Whether to use drag handles or not
                copyOnly: true      // Since moving is all handled in the backend, don't do any moving in the frontend
            },

            dndConstructor: GridDnDSource,
            dndSourceType: 'result',   // A string ID for the rows of this grid used for DnD
                                       // (also, dndParams.accept is set to match dndSourceType,
                                       //  so no reason to set both)

            /**
             * NOTE: OVERRIDE THIS IF YOU WANT DRAG/DROP IN THE GRID
             * This is the handler for dropping items into this grid. We will usually be
             * using this to call the relevant service calls
             *
             * @param {string} sourceType        the dnd type of the source objects
             * @param {Array} sourceObjectIds   array of object ids of the source items
             * @param {Array} targetObjectId    the object id to drop into
             */
            executeDropCommand: function (sourceType, sourceObjectIds, targetObjectId) {
            }

        });
});

},
'vodori/ui/GridDnDSource':function(){
define([
    'lodash', 'dojo/_base/declare', 'dojo/_base/html', 'dojo/_base/lang', 'dojo/_base/NodeList', 'dojo/_base/query',
    'dojo/dnd/Source', 'dojo/dnd/Manager',
    'xstyle/css!dojo/resources/dnd.css'
], function (_, declare, html, lang, NodeList, query, Source, Manager) {

    /**
     * This is a custom drag and drop implementation of dojo.dnd.Source, customized to fit our
     * own purposes for Pepper. We don't need seamless drag and drop between grids since
     * different grids have different types of items and we need error handling.
     */
    return declare(Source, {
        grid: null,

        /**
         * Grab the node's objectId using the node's grid
         *
         * @param grid  the grid the node belongs to
         * @param node  the node containing the row
         */
        getObjectId: function (/* dgrid */ grid, /* DOM node */ node) {
            // summary:
            //   getObject is a method which should be defined on any source intending
            //   on interfacing with dgrid DnD
            return grid.row(node).id;
        },

        _legalMouseDown: function (evt) {
            // summary:
            //   fix _legalMouseDown to only allow starting drag from an item
            //   (not from bodyNode outside contentNode)
            var legal = this.inherited('_legalMouseDown', arguments);
            // Source.prototype._legalMouseDown.apply(this, arguments);
            return legal && evt.target !== this.grid.bodyNode;
        },

        /**
         * Overriding to fix odd out of sync issue with dnd and multiple rows
         *
         * @return NodeList an array of the selected nodes
         */
        getSelectedNodes: function () {
            var nodeList = new NodeList();
            for (var row in this.grid.selection) {
                nodeList.push(this.grid.row(row).element);
            }
            return nodeList;
        },

        /**
         * Called when the user lets go of the mouse while dragging an item over another item
         *
         * @param sourceSource  reference to the Source of the source item(s) being dropped
         * @param nodes         the source item(s)
         */
        onDrop: function (sourceSource, nodes) {
            // summary:
            //   on drop, determine where to move/copy the objects
            var targetSource = this;
            var targetRow = this.targetAnchor;

            // Note: if dropping  into an empty grid, targetRow will be undefined.
            targetSource.handleDrop(sourceSource, nodes, targetRow);
        },

        /**
         * Initiate moving object(s) after dropping
         *
         * @param sourceSource  the Source of the nodes being dragged
         * @param nodes         the nodes being dragged
         * @param target        the node the nodes were dragged into
         */
        handleDrop: function (sourceSource, nodes, target) {
            var targetSource = this;

            // Feed the source grid into this.getObjectId to pass into the following dojo.map callback
            var getSourceObjectId = lang.partial(this.getObjectId, sourceSource.grid);

            var sourceObjectIds = _.map(nodes, getSourceObjectId, this);
            var targetObjectId = this.getObjectId(targetSource.grid, target);

            console.log('Dropped %O from %s onto %s from %s', sourceObjectIds,
                                                              sourceSource.grid.dndSourceType,
                                                              targetObjectId,
                                                              targetSource.grid.dndSourceType);

            // Delegate all request handling to the grid
            this.grid.executeDropCommand(sourceSource, sourceObjectIds, targetObjectId);
        },

        onDndStart: function (source, nodes, copy) {
            // summary:
            //   listen for start events to apply style change to avatar

            this.inherited(arguments); // Source.prototype.onDndStart.apply(this, arguments);
            if (source === this) {
                // Make the avatar the same width as the grid it was dragged from
                Manager.manager().avatar.node.style.width = html.contentBox(nodes[0]).w + 'px';

                // Make the row nodes fade out more aggressively than the default
                query('.dojoDndAvatarItem', Manager.manager().avatar.node).forEach(function (node, i) {
                    html.style(node, 'opacity', (9 - (i * 2)) / 10);
                });
            }
        },

        checkAcceptance: function (source, nodes) {
            // summary:
            //   augment checkAcceptance to block drops from sources without getObject
            return source.getObjectId &&
                Source.prototype.checkAcceptance.apply(this, arguments);
        }
    });
});
},
'dojo/_base/query':function(){
define(["../query", "./NodeList"], function(query){
	// module:
	//		dojo/_base/query

	/*=====
	return {
		// summary:
		//		Deprecated.   Use dojo/query instead.
	};
	=====*/

	return query;
});

},
'pepper/dialogs/info/TemplateList':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/query',
    'dojo/dom-style',
    'pepper/dialogs/info/TemplateSelectorList'
], function (module, provide, _, query, domStyle, TemplateSelectorList) {

    /**
     * This is the template selector's 2nd column, the one listing the templates.
     *
     * @class pepper/dialogs/info/TemplateList
     * @mixes pepper/dialogs/info/TemplateSelectorList
     */
    return provide(module, [TemplateSelectorList],
        /**
         * @lends pepper/dialogs/info/TemplateList#
         */
        {
            selectionMode: 'single',

            /**
             * Sets all of the nodes to be opacity 1 or .4 depending on if the list is being disabled.
             * @param disabled
             */
            _setDisabledAttr: function (disabled) {
                this.inherited(arguments);

                var opacity = '';
                if (disabled) {
                    opacity = '.4';
                }
                query('span', this.domNode).forEach(function (node) {
                    if (this.row(node).data.available) {
                        /**
                         * opacity has already been set, and should remain, on disabled nodes
                         */
                        domStyle.set(node, 'opacity', opacity);
                    }
                }, this);
            },

            /**
             * this implements the dgrid allowSelect method to determine whether a row can be selected or not
             *
             * @param row
             * @returns {*}
             */
            allowSelect: function(row) {
                if (this.selectedIds.length > 0 && row.id === this.selectedIds[0]) {
                    // don't allow the already selected template to be reselected
                    return false;
                } else {
                    var dataUnavailable = !(row && !(_.isUndefined(row.data) || _.isUndefined(row.data.available)));

                    return  dataUnavailable || row.data.available;
                }
            }
        });
});

},
'pepper/dialogs/info/InfoState':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'dojo/_base/declare',
    'vodori/util/LazyStateful'
], function (
    declare,
    LazyStateful) {

    /**
     * @class pepper/dialogs/info/InfoState
     *
     * Model for communicating the state of the Info dialog between its various components.
     */
    return declare([LazyStateful], {
        /**
         * The form, etc. is currently loading
         */
        loading: false,
        /**
         * It's in flip-through mode
         */
        flipThrough: false,
        /**
         * It's flip-through and not the fist item
         */
        hasPrevious: false,
        /**
         * It's flip-through and not the last item
         */
        hasNext: false,
        /**
         * The asset is read only. there is not action that can be taken within the dialog to make it writable
         */
        readOnly: false,
        /**
         * True when selection (ex: template) is valid for a save to take place
         */
        valid: false,
        /**
         * True only when on the properties tab
         */
        currentTabSavable: false,

        _loadingQueueDepth: 0,

        startLoading: function() {
            this._loadingQueueDepth++;
            this.set('loading', true);
        },

        endLoading: function() {
            this._loadingQueueDepth--;
            if (this._loadingQueueDepth === 0) {
                this.set('loading', false);
            }
        }

    });
});

},
'vodori/util/LazyStateful':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'lodash',
    'dojo/_base/lang', 'dojo/_base/declare', 'dojo/Stateful'
], function (
    _,
    lang, declare, Stateful) {

    /**
     * Extends dojo/Stateful but will not call setters or trigger watchers when set() is called with the same value that
     * the property already has. This prevents code extra cycles when nothing is really changing.
     *
     * @module vodori/util/LazyStateful
     * @mixin
     */
    var LazyStateful = {

        set: function (name, value) {
            if (typeof name === 'string' && value === this.get(name)) {
                return;
            } else {
                return this.inherited(arguments);
            }
        }

    };
    return declare([Stateful], LazyStateful);
});
},
'pepper/utilities/isInReception':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'lodash'
], function (
    _) {

    /**
     * Returns true if the given object is in reception by checking the inReception property on the objects lifecycle.
     * Returns false if the lifecycle is missing. Something that
     * is considered in reception will look like
     * {
     *     ...
     *     lifecycle: {
     *         ...
     *         inReception: true,
     *         ...
     *     }
     *     ...
     * }
     *
     * @param object The object to test.
     * @returns {boolean} true if in reception, false otherwise.
     */
    return function isInReception(object) {

        if (!object) {
            return false;
        }

        var lifecycle = object.lifecycle;
        if (!lifecycle) {
            return false;
        }

        return !!lifecycle.inReception;
    };
});

},
'dijit/TitlePane':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-attr", // domAttr.set or get domAttr.remove
	"dojo/dom-class", // domClass.replace
	"dojo/dom-geometry", // domGeometry.setMarginBox domGeometry.getMarginBox
	"dojo/fx", // fxUtils.wipeIn fxUtils.wipeOut
	"dojo/has",
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/keys", // keys.DOWN_ARROW keys.ENTER
	"./_CssStateMixin",
	"./_TemplatedMixin",
	"./layout/ContentPane",
	"dojo/text!./templates/TitlePane.html",
	"./_base/manager",    // defaultDuration
	"./a11yclick"	// template uses ondijitclick
], function(array, declare, dom, domAttr, domClass, domGeometry, fxUtils, has, kernel, keys,
			_CssStateMixin, _TemplatedMixin, ContentPane, template, manager){

	// module:
	//		dijit/TitlePane

	var TitlePane = declare("dijit.TitlePane", [ContentPane, _TemplatedMixin, _CssStateMixin], {
		// summary:
		//		A pane with a title on top, that can be expanded or collapsed.
		//
		// description:
		//		An accessible container with a title Heading, and a content
		//		section that slides open and closed. TitlePane is an extension to
		//		`dijit/layout/ContentPane`, providing all the useful content-control aspects from it.
		//
		// example:
		//	|	// load a TitlePane from remote file:
		//	|	var foo = new dijit.TitlePane({ href: "foobar.html", title:"Title" });
		//	|	foo.startup();
		//
		// example:
		//	|	<!-- markup href example: -->
		//	|	<div data-dojo-type="dijit/TitlePane" data-dojo-props="href: 'foobar.html', title: 'Title'"></div>
		//
		// example:
		//	|	<!-- markup with inline data -->
		//	|	<div data-dojo-type="dijit/TitlePane" title="Title">
		//	|		<p>I am content</p>
		//	|	</div>

		// title: String
		//		Title of the pane
		title: "",
		_setTitleAttr: { node: "titleNode", type: "innerHTML" }, // override default where title becomes a hover tooltip

		// open: Boolean
		//		Whether pane is opened or closed.
		open: true,

		// toggleable: Boolean
		//		Whether pane can be opened or closed by clicking the title bar.
		toggleable: true,

		// tabIndex: String
		//		Tabindex setting for the title (so users can tab to the title then
		//		use space/enter to open/close the title pane)
		tabIndex: "0",

		// duration: Integer
		//		Time in milliseconds to fade in/fade out
		duration: manager.defaultDuration,

		// baseClass: [protected] String
		//		The root className to be placed on this widget's domNode.
		baseClass: "dijitTitlePane",

		templateString: template,

		// doLayout: [protected] Boolean
		//		Don't change this parameter from the default value.
		//		This ContentPane parameter doesn't make sense for TitlePane, since TitlePane
		//		is never a child of a layout container, nor should TitlePane try to control
		//		the size of an inner widget.
		doLayout: false,

		// Tooltip is defined in _WidgetBase but we need to handle the mapping to DOM here
		_setTooltipAttr: {node: "focusNode", type: "attribute", attribute: "title"}, // focusNode spans the entire width, titleNode doesn't

		buildRendering: function(){
			this.inherited(arguments);
			dom.setSelectable(this.titleNode, false);
		},

		postCreate: function(){
			this.inherited(arguments);

			// Hover and focus effect on title bar, except for non-toggleable TitlePanes
			// This should really be controlled from _setToggleableAttr() but _CssStateMixin
			// doesn't provide a way to disconnect a previous _trackMouseState() call
			if(this.toggleable){
				this._trackMouseState(this.titleBarNode, this.baseClass + "Title");
			}

			// setup open/close animations
			var hideNode = this.hideNode, wipeNode = this.wipeNode;
			this._wipeIn = fxUtils.wipeIn({
				node: wipeNode,
				duration: this.duration,
				beforeBegin: function(){
					hideNode.style.display = "";
				}
			});
			this._wipeOut = fxUtils.wipeOut({
				node: wipeNode,
				duration: this.duration,
				onEnd: function(){
					hideNode.style.display = "none";
				}
			});
		},

		_setOpenAttr: function(/*Boolean*/ open, /*Boolean*/ animate){
			// summary:
			//		Hook to make set("open", boolean) control the open/closed state of the pane.
			// open: Boolean
			//		True if you want to open the pane, false if you want to close it.

			array.forEach([this._wipeIn, this._wipeOut], function(animation){
				if(animation && animation.status() == "playing"){
					animation.stop();
				}
			});

			if(animate){
				var anim = this[open ? "_wipeIn" : "_wipeOut"];
				anim.play();
			}else{
				this.hideNode.style.display = this.wipeNode.style.display = open ? "" : "none";
			}

			// load content (if this is the first time we are opening the TitlePane
			// and content is specified as an href, or href was set when hidden)
			if(this._started){
				if(open){
					this._onShow();
				}else{
					this.onHide();
				}
			}

			this.containerNode.setAttribute("aria-hidden", open ? "false" : "true");
			this.focusNode.setAttribute("aria-pressed", open ? "true" : "false");

			this._set("open", open);

			this._setCss();
		},

		_setToggleableAttr: function(/*Boolean*/ canToggle){
			// summary:
			//		Hook to make set("toggleable", boolean) work.
			// canToggle: Boolean
			//		True to allow user to open/close pane by clicking title bar.

			this.focusNode.setAttribute("role", canToggle ? "button" : "heading");
			if(canToggle){
				this.focusNode.setAttribute("aria-controls", this.id + "_pane");
				this.focusNode.setAttribute("tabIndex", this.tabIndex);
				this.focusNode.setAttribute("aria-pressed", this.open);
			}else{
				domAttr.remove(this.focusNode, "aria-controls");
				domAttr.remove(this.focusNode, "tabIndex");
				domAttr.remove(this.focusNode, "aria-pressed");
			}

			this._set("toggleable", canToggle);

			this._setCss();
		},

		_setContentAttr: function(/*String|DomNode|Nodelist*/ content){
			// summary:
			//		Hook to make set("content", ...) work.
			//		Typically called when an href is loaded.  Our job is to make the animation smooth.

			if(!this.open || !this._wipeOut || this._wipeOut.status() == "playing"){
				// we are currently *closing* the pane (or the pane is closed), so just let that continue
				this.inherited(arguments);
			}else{
				if(this._wipeIn && this._wipeIn.status() == "playing"){
					this._wipeIn.stop();
				}

				// freeze container at current height so that adding new content doesn't make it jump
				domGeometry.setMarginBox(this.wipeNode, { h: domGeometry.getMarginBox(this.wipeNode).h });

				// add the new content (erasing the old content, if any)
				this.inherited(arguments);

				// call _wipeIn.play() to animate from current height to new height
				if(this._wipeIn){
					this._wipeIn.play();
				}else{
					this.hideNode.style.display = "";
				}
			}
		},

		toggle: function(){
			// summary:
			//		Switches between opened and closed state
			// tags:
			//		private

			this._setOpenAttr(!this.open, true);
		},

		_setCss: function(){
			// summary:
			//		Set the open/close css state for the TitlePane
			// tags:
			//		private

			var node = this.titleBarNode || this.focusNode;
			var oldCls = this._titleBarClass;
			this._titleBarClass = this.baseClass + "Title" + (this.toggleable ? "" : "Fixed") + (this.open ? "Open" : "Closed");
			domClass.replace(node, this._titleBarClass, oldCls || "");

			// Back compat, remove for 2.0
			domClass.replace(node, this._titleBarClass.replace("TitlePaneTitle", ""), (oldCls || "").replace("TitlePaneTitle", ""));

			this.arrowNodeInner.innerHTML = this.open ? "-" : "+";
		},

		_onTitleKey: function(/*Event*/ e){
			// summary:
			//		Handler for when user hits a key
			// tags:
			//		private

			if(e.keyCode == keys.DOWN_ARROW && this.open){
				this.containerNode.focus();
				e.preventDefault();
			}
		},

		_onTitleClick: function(){
			// summary:
			//		Handler when user clicks the title bar
			// tags:
			//		private
			if(this.toggleable){
				this.toggle();
			}
		},

		setTitle: function(/*String*/ title){
			// summary:
			//		Deprecated.  Use set('title', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.TitlePane.setTitle() is deprecated.  Use set('title', ...) instead.", "", "2.0");
			this.set("title", title);
		}
	});

	if(has("dojo-bidi")){
		TitlePane.extend({
			_setTitleAttr: function(/*String*/ title){
				// Override default where title becomes a hover tooltip
				this._set("title", title);
				this.titleNode.innerHTML = title;
				this.applyTextDir(this.titleNode);
			},

			_setTooltipAttr: function(/*String*/ tooltip){
				this._set("tooltip", tooltip);
				if(this.textDir){
					tooltip = this.enforceTextDirWithUcc(null, tooltip);
				}
				domAttr.set(this.focusNode, "title", tooltip);			// focusNode spans the entire width, titleNode doesn't
			},

			_setTextDirAttr: function(textDir){
				if(this._created && this.textDir != textDir){
					this._set("textDir", textDir);
					this.set("title", this.title);
					this.set("tooltip", this.tooltip);
				}
			}
		});
	}

	return TitlePane;
});

},
'vodori/input/DateAndTime':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'dojo/on', 'dojo/date/stamp',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'dojo/text!./templates/DateAndTime.html',
    /* unreferenced mids */
    'vodori/input/DateTextBox',
    'vodori/input/TimeTextBox',
    'vodori/ui/Button'
], function (module, provide,
             lang, on, stamp,
             _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
             template) {
    /**
     * @class vodori/input/DateAndTime
     * @extends dijit/_Widget
     * @mixes dijit/_TemplatedMixin
     * @mixes dijit/_WidgetsInTemplateMixin
     */
    return provide(module.id, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin],
        /**
         * @lends vodori/input/DateAndTime#
         */
        {

            /**
             * @ignore
             */
            templateString: template,

            /**
             * @ignore
             */
            widgetsInTemplate: true,

            /**
             * Wrapped DateTextBox widget used to represent a date
             * (separately from the time of day on that date, although not setting a time of day in the time input
             * will cause the date input to keep a time of day of 0000 hours)
             * @type {vodori/input/DateTextBox}
             */
            dateInput: null,

            /**
             * Wrapped TimeTextBox widget used to represent a time of day (separately from the date of that day)
             * @type {vodori/input/TimeTextBox}
             */
            timeInput: null,

            /**
             * Saves the updated date value each time this widget's 'value' field's getter is called.
             * @type {Date}
             */
            date: null,

            /**
             * Saves the updated time value each time this widget's 'value' field's getter is called.
             * @type {Date}
             */
            time: null,

            /**
             * Set to true if the value returned from get('value') should be an iso formatted string representation.
             * false will return a normal javascript Date object.
             */
            useIsoFormat: false,

            /**
             * @ignore
             */
            postCreate: function() {
                this.inherited(arguments);

                // Attach wrapped input value-clearing handler to the clear button (from template)
                on(this.clearButton, 'click', lang.hitch(this, 'clearValues'));
            },

            /**
             * Overrides getter for 'value'. Fetches the wrapped date and time input values, extracts the time values,
             * and sets them on the date value which is then returned as this widget's 'value'.
             * @return {Date} A Date object representing this widget's date & time 'value'
             * @private
             */
            _getValueAttr: function () {
                this.date = this.dateInput.get('value');
                this.time = this.timeInput.get('value');

                // If both inputs are submitted, combine the time's hours and minutes into the date
                if (this.date && this.time) {
                    this.date.setHours(this.time.getHours());
                    this.date.setMinutes(this.time.getMinutes());
                }

                if (this.useIsoFormat && this.date) {
                    return stamp.toISOString(this.date, {zulu: true});
                }

                return this.date;
            },

            /**
             * Overrides setter for 'value'. Converts the new value to a Date object, and passes that off to the wrapped
             * date and time inputs' 'value' setters.
             * @param {string} value The formatted string indicating to what values the date/time inputs are to be set
             * @private
             */
            _setValueAttr: function (value) {
                var date;
                if (this.useIsoFormat && value) {
                    date = stamp.fromISOString(value);
                } else {
                    date = new Date(value);
                }

                /**
                 * The date & time widgets we use here are smart enough to extract what they need from
                 * the basic Date object
                 */
                this.dateInput.set('value', date);
                this.timeInput.set('value', date);
            },

            /**
             * Simply clears the values in the wrapped date and time inputs.
             */
            clearValues: function() {
                this.dateInput.set('value', null);
                this.timeInput.set('value', null);
            }

        });
});

},
'vodori/input/DateTextBox':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'dojo/on', 'dojo/date/stamp',
    'dijit/form/DateTextBox',
    'vodori/ui/_InheritQuarantineMixin'
], function (
    module, provide,
    lang, on, stamp,
    DateTextBox,
    _InheritQuarantineMixin) {

    /**
     * This version of the DateTextBox returns an empty string instead of null if no date is selected
     * It also applies the pepper quarantine styling to the dropdown if in the pepper context.
     */
    return provide(module.id, [DateTextBox, _InheritQuarantineMixin], {


        /**
         * Set to true if the value returned from get('value') should be an iso formatted string representation.
         * false will return a normal javascript Date object.
         */
        useIsoFormat: false,


        postCreate: function() {
            this.inherited(arguments);

            this.own(on(this.textbox, 'click', lang.hitch(this, '_onDropDownClick')));
            this.own(on(this.textbox, 'mousedown', lang.hitch(this, '_onDropDownMouseDown')));
            this.own(on(this.textbox, 'mouseup', lang.hitch(this, '_onDropDownMouseUp')));
        },

        /**
         * Overrides getter for 'value'. Fetches the wrapped date and sets it on the date
         * value which is then returned as this widget's 'value'.
         *
         * @return {Date} A Date object representing this widget's date 'value'
         * @private
         */
        _getValueAttr: function () {
            var value = this.inherited(arguments);

            if (this.useIsoFormat && value) {
                return stamp.toISOString(value, {zulu: true});
            }

            return value;
        },

        /**
         * Overriding _TextBoxMixin._setBlurValue to not set a value if the current value is falsy (in this case, it is
         * likely an empty string). This prevents a cascade of value setters in this class' inheritance chain that
         * ends up setting the value to the Unix Epoch (in dojo/date/stamp.fromISOString). Now the value will stay
         * blank on blur.
         * @private
         */
        _setBlurValue: function () {
            var val = this.get('value');
            if (val) {
                this.inherited(arguments);
            }
        },

        toggleDropDown: function () {
            this.inherited(arguments);
            this.applyInheritedQuarantineClassesToNode(this.dropDown.domNode.parentNode);
        }
    });
});

},
'dijit/form/DateTextBox':function(){
define([
	"dojo/_base/declare", // declare
	"../Calendar",
	"./_DateTimeTextBox"
], function(declare, Calendar, _DateTimeTextBox){

	// module:
	//		dijit/form/DateTextBox

	return declare("dijit.form.DateTextBox", _DateTimeTextBox, {
		// summary:
		//		A validating, serializable, range-bound date text box with a drop down calendar
		// example:
		// |	new DateTextBox({value: new Date(2009, 0, 20)})
		// example:
		// |	<input data-dojo-type='dijit/form/DateTextBox' value='2009-01-20'>

		baseClass: "dijitTextBox dijitComboBox dijitDateTextBox",
		popupClass: Calendar,
		_selector: "date",

		// Prevent scrollbar on Calendar dropdown.  On iPad it often gets a scrollbar unnecessarily because Viewport
		// thinks the keyboard is showing.  Even if the keyboard is showing, it disappears when the calendar gets focus.
		maxHeight: Infinity,

		// value: Date
		//		The value of this widget as a JavaScript Date object, with only year/month/day specified.
		//		If specified in markup, use the format specified in `stamp.fromISOString`.
		//		set("value", ...) accepts either a Date object or a string.
		value: new Date("")	// value.toString()="NaN"
	});
});

},
'dijit/Calendar':function(){
define([
	"dojo/_base/array", // array.map
	"dojo/date",
	"dojo/date/locale",
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.get
	"dojo/dom-class", // domClass.add domClass.contains domClass.remove domClass.toggle
	"dojo/dom-construct",	// create
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/keys", // keys
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie")
	"./CalendarLite",
	"./_Widget",
	"./_CssStateMixin",
	"./_TemplatedMixin",
	"./form/DropDownButton"
], function(array, date, local, declare, domAttr, domClass, domConstruct, kernel, keys, lang, on, has,
			CalendarLite, _Widget, _CssStateMixin, _TemplatedMixin, DropDownButton){

	// module:
	//		dijit/Calendar

	// _Widget for deprecated methods like setAttribute()
	var Calendar = declare("dijit.Calendar", [CalendarLite, _Widget, _CssStateMixin], {
		// summary:
		//		A simple GUI for choosing a date in the context of a monthly calendar.
		//
		// description:
		//		See CalendarLite for general description.   Calendar extends CalendarLite, adding:
		//
		//		- month drop down list
		//		- keyboard navigation
		//		- CSS classes for hover/mousepress on date, month, and year nodes
		//		- support of deprecated methods (will be removed in 2.0)

		baseClass: "dijitCalendar",

		// Set node classes for various mouse events, see dijit._CssStateMixin for more details
		cssStateNodes: {
			"decrementMonth": "dijitCalendarArrow",
			"incrementMonth": "dijitCalendarArrow",
			"previousYearLabelNode": "dijitCalendarPreviousYear",
			"nextYearLabelNode": "dijitCalendarNextYear"
		},

		setValue: function(/*Date*/ value){
			// summary:
			//		Deprecated.   Use set('value', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.Calendar:setValue() is deprecated.  Use set('value', ...) instead.", "", "2.0");
			this.set('value', value);
		},

		_createMonthWidget: function(){
			// summary:
			//		Creates the drop down button that displays the current month and lets user pick a new one

			return new Calendar._MonthDropDownButton({
				id: this.id + "_mddb",
				tabIndex: -1,
				onMonthSelect: lang.hitch(this, "_onMonthSelect"),
				lang: this.lang,
				dateLocaleModule: this.dateLocaleModule
			}, this.monthNode);
		},

		postCreate: function(){
			this.inherited(arguments);

			// Events specific to Calendar, not used in CalendarLite
			this.own(
				on(this.domNode, "keydown", lang.hitch(this, "_onKeyDown")),
				on(this.dateRowsNode, "mouseover", lang.hitch(this, "_onDayMouseOver")),
				on(this.dateRowsNode, "mouseout", lang.hitch(this, "_onDayMouseOut")),
				on(this.dateRowsNode, "mousedown", lang.hitch(this, "_onDayMouseDown")),
				on(this.dateRowsNode, "mouseup", lang.hitch(this, "_onDayMouseUp"))
			);
		},

		_onMonthSelect: function(/*Number*/ newMonth){
			// summary:
			//		Handler for when user selects a month from the drop down list
			// tags:
			//		protected

			// move to selected month, bounding by the number of days in the month
			// (ex: jan 31 --> feb 28, not feb 31)
			var date = new this.dateClassObj(this.currentFocus);
			date.setDate(1);
			date.setMonth(newMonth);
			var daysInMonth = this.dateModule.getDaysInMonth(date);
			var currentDate = this.currentFocus.getDate();
			date.setDate(Math.min(currentDate, daysInMonth));
			this._setCurrentFocusAttr(date);
		},

		_onDayMouseOver: function(/*Event*/ evt){
			// summary:
			//		Handler for mouse over events on days, sets hovered style
			// tags:
			//		protected

			// event can occur on <td> or the <span> inside the td,
			// set node to the <td>.
			var node =
				domClass.contains(evt.target, "dijitCalendarDateLabel") ?
					evt.target.parentNode :
					evt.target;

			if(node && (
				(node.dijitDateValue && !domClass.contains(node, "dijitCalendarDisabledDate"))
					|| node == this.previousYearLabelNode || node == this.nextYearLabelNode
				)){
				domClass.add(node, "dijitCalendarHoveredDate");
				this._currentNode = node;
			}
		},

		_onDayMouseOut: function(/*Event*/ evt){
			// summary:
			//		Handler for mouse out events on days, clears hovered style
			// tags:
			//		protected

			if(!this._currentNode){
				return;
			}

			// if mouse out occurs moving from <td> to <span> inside <td>, ignore it
			if(evt.relatedTarget && evt.relatedTarget.parentNode == this._currentNode){
				return;
			}
			var cls = "dijitCalendarHoveredDate";
			if(domClass.contains(this._currentNode, "dijitCalendarActiveDate")){
				cls += " dijitCalendarActiveDate";
			}
			domClass.remove(this._currentNode, cls);
			this._currentNode = null;
		},

		_onDayMouseDown: function(/*Event*/ evt){
			var node = evt.target.parentNode;
			if(node && node.dijitDateValue && !domClass.contains(node, "dijitCalendarDisabledDate")){
				domClass.add(node, "dijitCalendarActiveDate");
				this._currentNode = node;
			}
		},

		_onDayMouseUp: function(/*Event*/ evt){
			var node = evt.target.parentNode;
			if(node && node.dijitDateValue){
				domClass.remove(node, "dijitCalendarActiveDate");
			}
		},

		handleKey: function(/*Event*/ evt){
			// summary:
			//		Provides keyboard navigation of calendar.
			// description:
			//		Called from _onKeyDown() to handle keydown on a stand alone Calendar,
			//		and also from `dijit/form/_DateTimeTextBox` to pass a keydown event
			//		from the `dijit/form/DateTextBox` to be handled in this widget
			// returns:
			//		False if the key was recognized as a navigation key,
			//		to indicate that the event was handled by Calendar and shouldn't be propagated
			// tags:
			//		protected
			var increment = -1,
				interval,
				newValue = this.currentFocus;
			switch(evt.keyCode){
				case keys.RIGHT_ARROW:
					increment = 1;
				//fallthrough...
				case keys.LEFT_ARROW:
					interval = "day";
					if(!this.isLeftToRight()){
						increment *= -1;
					}
					break;
				case keys.DOWN_ARROW:
					increment = 1;
				//fallthrough...
				case keys.UP_ARROW:
					interval = "week";
					break;
				case keys.PAGE_DOWN:
					increment = 1;
				//fallthrough...
				case keys.PAGE_UP:
					interval = evt.ctrlKey || evt.altKey ? "year" : "month";
					break;
				case keys.END:
					// go to the next month
					newValue = this.dateModule.add(newValue, "month", 1);
					// subtract a day from the result when we're done
					interval = "day";
				//fallthrough...
				case keys.HOME:
					newValue = new this.dateClassObj(newValue);
					newValue.setDate(1);
					break;
				default:
					return true;
			}

			if(interval){
				newValue = this.dateModule.add(newValue, interval, increment);
			}

			this._setCurrentFocusAttr(newValue);

			return false;
		},

		_onKeyDown: function(/*Event*/ evt){
			// summary:
			//		For handling keydown events on a stand alone calendar
			if(!this.handleKey(evt)){
				evt.stopPropagation();
				evt.preventDefault();
			}
		},

		onValueSelected: function(/*Date*/ /*===== date =====*/){
			// summary:
			//		Deprecated.   Notification that a date cell was selected.  It may be the same as the previous value.
			// description:
			//		Formerly used by `dijit/form/_DateTimeTextBox` (and thus `dijit/form/DateTextBox`)
			//		to get notification when the user has clicked a date.  Now onExecute() (above) is used.
			// tags:
			//		protected
		},

		onChange: function(value){
			this.onValueSelected(value);	// remove in 2.0
		},

		getClassForDate: function(/*===== dateObject, locale =====*/){
			// summary:
			//		May be overridden to return CSS classes to associate with the date entry for the given dateObject,
			//		for example to indicate a holiday in specified locale.
			// dateObject: Date
			// locale: String?
			// tags:
			//		extension

			/*=====
			 return ""; // String
			 =====*/
		}
	});

	Calendar._MonthDropDownButton = declare("dijit.Calendar._MonthDropDownButton", DropDownButton, {
		// summary:
		//		DropDownButton for the current month.    Displays name of current month
		//		and a list of month names in the drop down

		onMonthSelect: function(){
		},

		postCreate: function(){
			this.inherited(arguments);
			this.dropDown = new Calendar._MonthDropDown({
				id: this.id + "_mdd", //do not change this id because it is referenced in the template
				onChange: this.onMonthSelect
			});
		},
		_setMonthAttr: function(month){
			// summary:
			//		Set the current month to display as a label
			var monthNames = this.dateLocaleModule.getNames('months', 'wide', 'standAlone', this.lang, month);
			this.dropDown.set("months", monthNames);

			// Set name of current month and also fill in spacer element with all the month names
			// (invisible) so that the maximum width will affect layout.   But not on IE6 because then
			// the center <TH> overlaps the right <TH> (due to a browser bug).
			this.containerNode.innerHTML =
				(has("ie") == 6 ? "" : "<div class='dijitSpacer'>" + this.dropDown.domNode.innerHTML + "</div>") +
					"<div class='dijitCalendarMonthLabel dijitCalendarCurrentMonthLabel'>" + monthNames[month.getMonth()] + "</div>";
		}
	});

	Calendar._MonthDropDown = declare("dijit.Calendar._MonthDropDown", [_Widget, _TemplatedMixin, _CssStateMixin], {
		// summary:
		//		The list-of-months drop down from the MonthDropDownButton

		// months: String[]
		//		List of names of months, possibly w/some undefined entries for Hebrew leap months
		//		(ex: ["January", "February", undefined, "April", ...])
		months: [],

		baseClass: "dijitCalendarMonthMenu dijitMenu",

		templateString: "<div data-dojo-attach-event='ondijitclick:_onClick'></div>",

		_setMonthsAttr: function(/*String[]*/ months){
			this.domNode.innerHTML = "";
			array.forEach(months, function(month, idx){
				var div = domConstruct.create("div", {
					className: "dijitCalendarMonthLabel",
					month: idx,
					innerHTML: month
				}, this.domNode);
				div._cssState = "dijitCalendarMonthLabel";	// trigger _CSSStateMixin magic; property, not attribute.
			}, this);
		},

		_onClick: function(/*Event*/ evt){
			this.onChange(domAttr.get(evt.target, "month"));
		},

		onChange: function(/*Number*/ /*===== month =====*/){
			// summary:
			//		Callback when month is selected from drop down
		}
	});

	return Calendar;
});

},
'dijit/CalendarLite':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/declare", // declare
	"dojo/cldr/supplemental", // cldrSupplemental.getFirstDayOfWeek
	"dojo/date", // date
	"dojo/date/locale",
	"dojo/date/stamp", // stamp.fromISOString
	"dojo/dom", // dom.setSelectable
	"dojo/dom-class", // domClass.contains
	"dojo/_base/lang", // lang.getObject, lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie") has("webkit")
	"dojo/string", // string.substitute
	"./_WidgetBase",
	"./_TemplatedMixin",
	"dojo/text!./templates/Calendar.html",
	"./a11yclick",	// not used directly, but template has ondijitclick in it
	"./hccss"    // not used directly, but sets CSS class on <body>
], function(array, declare, cldrSupplemental, date, locale, stamp, dom, domClass, lang, on, has, string, _WidgetBase, _TemplatedMixin, template){


	// module:
	//		dijit/CalendarLite

	var CalendarLite = declare("dijit.CalendarLite", [_WidgetBase, _TemplatedMixin], {
		// summary:
		//		Lightweight version of Calendar widget aimed towards mobile use
		//
		// description:
		//		A simple GUI for choosing a date in the context of a monthly calendar.
		//		This widget can't be used in a form because it doesn't serialize the date to an
		//		`<input>` field.  For a form element, use dijit/form/DateTextBox instead.
		//
		//		Note that the parser takes all dates attributes passed in the
		//		[RFC 3339 format](http://www.faqs.org/rfcs/rfc3339.html), e.g. `2005-06-30T08:05:00-07:00`
		//		so that they are serializable and locale-independent.
		//
		//		Also note that this widget isn't keyboard accessible; use dijit.Calendar for that
		// example:
		//	|	var calendar = new dijit.CalendarLite({}, dojo.byId("calendarNode"));
		//
		// example:
		//	|	<div data-dojo-type="dijit/CalendarLite"></div>

		// Template for main calendar
		templateString: template,

		// Template for cell for a day of the week (ex: M)
		dowTemplateString: '<th class="dijitReset dijitCalendarDayLabelTemplate" role="columnheader" scope="col"><span class="dijitCalendarDayLabel">${d}</span></th>',

		// Templates for a single date (ex: 13), and for a row for a week (ex: 20 21 22 23 24 25 26)
		dateTemplateString: '<td class="dijitReset" role="gridcell" data-dojo-attach-point="dateCells"><span class="dijitCalendarDateLabel" data-dojo-attach-point="dateLabels"></span></td>',
		weekTemplateString: '<tr class="dijitReset dijitCalendarWeekTemplate" role="row">${d}${d}${d}${d}${d}${d}${d}</tr>',

		// value: Date
		//		The currently selected Date, initially set to invalid date to indicate no selection.
		value: new Date(""),
		// TODO: for 2.0 make this a string (ISO format) rather than a Date

		// datePackage: String
		//		JavaScript namespace to find calendar routines.	 If unspecified, uses Gregorian calendar routines
		//		at dojo/date and dojo/date/locale.
		datePackage: "",
		//		TODO: for 2.0, replace datePackage with dateModule and dateLocalModule attributes specifying MIDs,
		//		or alternately just get rid of this completely and tell user to use module ID remapping
		//		via require

		// dayWidth: String
		//		How to represent the days of the week in the calendar header. See locale
		dayWidth: "narrow",

		// tabIndex: String
		//		Order fields are traversed when user hits the tab key
		tabIndex: "0",

		// currentFocus: Date
		//		Date object containing the currently focused date, or the date which would be focused
		//		if the calendar itself was focused.   Also indicates which year and month to display,
		//		i.e. the current "page" the calendar is on.
		currentFocus: new Date(),

		// Put the summary to the node with role=grid
		_setSummaryAttr: "gridNode",

		baseClass: "dijitCalendar dijitCalendarLite",

		_isValidDate: function(/*Date*/ value){
			// summary:
			//		Runs various tests on the value, checking that it's a valid date, rather
			//		than blank or NaN.
			// tags:
			//		private
			return value && !isNaN(value) && typeof value == "object" &&
				value.toString() != this.constructor.prototype.value.toString();
		},

		_getValueAttr: function(){
			// summary:
			//		Support get('value')

			// this.value is set to 1AM, but return midnight, local time for back-compat
			var storedVal = this._get("value");
			if(storedVal && !isNaN(storedVal)){
				var value = new this.dateClassObj(storedVal);
				value.setHours(0, 0, 0, 0);

				// If daylight savings pushes midnight to the previous date, fix the Date
				// object to point at 1am so it will represent the correct day. See #9366
				if(value.getDate() < storedVal.getDate()){
					value = this.dateModule.add(value, "hour", 1);
				}
				return value;
			}else{
				return null;
			}
		},

		_setValueAttr: function(/*Date|Number*/ value, /*Boolean*/ priorityChange){
			// summary:
			//		Support set("value", ...)
			// description:
			//		Set the current date and update the UI.  If the date is disabled, the value will
			//		not change, but the display will change to the corresponding month.
			// value:
			//		Either a Date or the number of seconds since 1970.
			// tags:
			//		protected
			if(typeof value == "string"){
				value = stamp.fromISOString(value);
			}
			value = this._patchDate(value);

			if(this._isValidDate(value) && !this.isDisabledDate(value, this.lang)){
				this._set("value", value);

				// Set focus cell to the new value.   Arguably this should only happen when there isn't a current
				// focus point.   This will also repopulate the grid to new month/year if necessary.
				this.set("currentFocus", value);

				// Mark the selected date
				this._markSelectedDates([value]);

				if(this._created && (priorityChange || typeof priorityChange == "undefined")){
					this.onChange(this.get('value'));
				}
			}else{
				// clear value, and mark all dates as unselected
				this._set("value", null);
				this._markSelectedDates([]);
			}
		},

		_patchDate: function(/*Date|Number*/ value){
			// summary:
			//		Convert Number into Date, or copy Date object.   Then, round to nearest day,
			//		setting to 1am to avoid issues when DST shift occurs at midnight, see #8521, #9366)
			if(value){
				value = new this.dateClassObj(value);
				value.setHours(1, 0, 0, 0);
			}
			return value;
		},

		_setText: function(node, text){
			// summary:
			//		This just sets the content of node to the specified text.
			//		Can't do "node.innerHTML=text" because of an IE bug w/tables, see #3434.
			// tags:
			//		private
			while(node.firstChild){
				node.removeChild(node.firstChild);
			}
			node.appendChild(node.ownerDocument.createTextNode(text));
		},

		_populateGrid: function(){
			// summary:
			//		Fills in the calendar grid with each day (1-31).
			//		Call this on creation, when moving to a new month.
			// tags:
			//		private

			var month = new this.dateClassObj(this.currentFocus);
			month.setDate(1);
			month = this._patchDate(month);	// needed if currentFocus is start or end of DST, see #17033

			var firstDay = month.getDay(),
				daysInMonth = this.dateModule.getDaysInMonth(month),
				daysInPreviousMonth = this.dateModule.getDaysInMonth(this.dateModule.add(month, "month", -1)),
				today = new this.dateClassObj(),
				dayOffset = cldrSupplemental.getFirstDayOfWeek(this.lang);
			if(dayOffset > firstDay){
				dayOffset -= 7;
			}

			// If they didn't provide a summary, change the default summary to match with the new month
			if(!this.summary){
				var monthNames = this.dateLocaleModule.getNames('months', 'wide', 'standAlone', this.lang, month)
				this.gridNode.setAttribute("summary", monthNames[month.getMonth()]);
			}

			// Mapping from date (as specified by number returned from Date.valueOf()) to corresponding <td>
			this._date2cell = {};

			// Iterate through dates in the calendar and fill in date numbers and style info
			array.forEach(this.dateCells, function(template, idx){
				var i = idx + dayOffset;
				var date = new this.dateClassObj(month),
					number, clazz = "dijitCalendar", adj = 0;

				if(i < firstDay){
					number = daysInPreviousMonth - firstDay + i + 1;
					adj = -1;
					clazz += "Previous";
				}else if(i >= (firstDay + daysInMonth)){
					number = i - firstDay - daysInMonth + 1;
					adj = 1;
					clazz += "Next";
				}else{
					number = i - firstDay + 1;
					clazz += "Current";
				}

				if(adj){
					date = this.dateModule.add(date, "month", adj);
				}
				date.setDate(number);

				if(!this.dateModule.compare(date, today, "date")){
					clazz = "dijitCalendarCurrentDate " + clazz;
				}

				if(this.isDisabledDate(date, this.lang)){
					clazz = "dijitCalendarDisabledDate " + clazz;
					template.setAttribute("aria-disabled", "true");
				}else{
					clazz = "dijitCalendarEnabledDate " + clazz;
					template.removeAttribute("aria-disabled");
					template.setAttribute("aria-selected", "false");
				}

				var clazz2 = this.getClassForDate(date, this.lang);
				if(clazz2){
					clazz = clazz2 + " " + clazz;
				}

				template.className = clazz + "Month dijitCalendarDateTemplate";

				// Each cell has an associated integer value representing it's date
				var dateVal = date.valueOf();
				this._date2cell[dateVal] = template;
				template.dijitDateValue = dateVal;

				// Set Date string (ex: "13").
				this._setText(this.dateLabels[idx], date.getDateLocalized ? date.getDateLocalized(this.lang) : date.getDate());
			}, this);
		},

		_populateControls: function(){
			// summary:
			//		Fill in localized month, and prev/current/next years
			// tags:
			//		protected

			var month = new this.dateClassObj(this.currentFocus);
			month.setDate(1);

			// set name of this month
			this.monthWidget.set("month", month);

			var y = month.getFullYear() - 1;
			var d = new this.dateClassObj();
			array.forEach(["previous", "current", "next"], function(name){
				d.setFullYear(y++);
				this._setText(this[name + "YearLabelNode"],
					this.dateLocaleModule.format(d, {selector: 'year', locale: this.lang}));
			}, this);
		},

		goToToday: function(){
			// summary:
			//		Sets calendar's value to today's date
			this.set('value', new this.dateClassObj());
		},

		constructor: function(params /*===== , srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree

			this.dateModule = params.datePackage ? lang.getObject(params.datePackage, false) : date;
			this.dateClassObj = this.dateModule.Date || Date;
			this.dateLocaleModule = params.datePackage ? lang.getObject(params.datePackage + ".locale", false) : locale;
		},

		_createMonthWidget: function(){
			// summary:
			//		Creates the drop down button that displays the current month and lets user pick a new one

			return CalendarLite._MonthWidget({
				id: this.id + "_mddb",
				lang: this.lang,
				dateLocaleModule: this.dateLocaleModule
			}, this.monthNode);
		},

		buildRendering: function(){
			// Markup for days of the week (referenced from template)
			var d = this.dowTemplateString,
				dayNames = this.dateLocaleModule.getNames('days', this.dayWidth, 'standAlone', this.lang),
				dayOffset = cldrSupplemental.getFirstDayOfWeek(this.lang);
			this.dayCellsHtml = string.substitute([d, d, d, d, d, d, d].join(""), {d: ""}, function(){
				return dayNames[dayOffset++ % 7];
			});

			// Markup for dates of the month (referenced from template), but without numbers filled in
			var r = string.substitute(this.weekTemplateString, {d: this.dateTemplateString});
			this.dateRowsHtml = [r, r, r, r, r, r].join("");

			// Instantiate from template.
			// dateCells and dateLabels arrays filled when _Templated parses my template.
			this.dateCells = [];
			this.dateLabels = [];
			this.inherited(arguments);

			dom.setSelectable(this.domNode, false);

			var dateObj = new this.dateClassObj(this.currentFocus);

			this.monthWidget = this._createMonthWidget();

			this.set('currentFocus', dateObj, false);	// draw the grid to the month specified by currentFocus
		},

		postCreate: function(){
			this.inherited(arguments);
			this._connectControls();
		},

		_connectControls: function(){
			// summary:
			//		Set up connects for increment/decrement of months/years
			// tags:
			//		protected

			var connect = lang.hitch(this, function(nodeProp, part, amount){
				this[nodeProp].dojoClick = true;
				return on(this[nodeProp], "click", lang.hitch(this, function(){
					this._setCurrentFocusAttr(this.dateModule.add(this.currentFocus, part, amount));
				}));
			});

			this.own(
				connect("incrementMonth", "month", 1),
				connect("decrementMonth", "month", -1),
				connect("nextYearLabelNode", "year", 1),
				connect("previousYearLabelNode", "year", -1)
			);
		},

		_setCurrentFocusAttr: function(/*Date*/ date, /*Boolean*/ forceFocus){
			// summary:
			//		If the calendar currently has focus, then focuses specified date,
			//		changing the currently displayed month/year if necessary.
			//		If the calendar doesn't have focus, updates currently
			//		displayed month/year, and sets the cell that will get focus
			//		when Calendar is focused.
			// forceFocus:
			//		If true, will focus() the cell even if calendar itself doesn't have focus

			var oldFocus = this.currentFocus,
				oldCell = this._getNodeByDate(oldFocus);
			date = this._patchDate(date);

			this._set("currentFocus", date);

			// If the focus is on a different month than the current calendar month, switch the displayed month.
			// Also will populate the grid initially, on Calendar creation.
			if(!this._date2cell || this.dateModule.difference(oldFocus, date, "month") != 0){
				this._populateGrid();
				this._populateControls();
				this._markSelectedDates([this.value]);
			}

			// set tabIndex=0 on new cell, and focus it (but only if Calendar itself is focused)
			var newCell = this._getNodeByDate(date);
			newCell.setAttribute("tabIndex", this.tabIndex);
			if(this.focused || forceFocus){
				newCell.focus();
			}

			// set tabIndex=-1 on old focusable cell
			if(oldCell && oldCell != newCell){
				if(has("webkit")){    // see #11064 about webkit bug
					oldCell.setAttribute("tabIndex", "-1");
				}else{
					oldCell.removeAttribute("tabIndex");
				}
			}
		},

		focus: function(){
			// summary:
			//		Focus the calendar by focusing one of the calendar cells
			this._setCurrentFocusAttr(this.currentFocus, true);
		},

		_onDayClick: function(/*Event*/ evt){
			// summary:
			//		Handler for day clicks, selects the date if appropriate
			// tags:
			//		protected
			evt.stopPropagation();
			evt.preventDefault();
			for(var node = evt.target; node && !node.dijitDateValue; node = node.parentNode){
				;
			}
			if(node && !domClass.contains(node, "dijitCalendarDisabledDate")){
				this.set('value', node.dijitDateValue);
			}
		},

		_getNodeByDate: function(/*Date*/ value){
			// summary:
			//		Returns the cell corresponding to the date, or null if the date is not within the currently
			//		displayed month.
			value = this._patchDate(value);
			return value && this._date2cell ? this._date2cell[value.valueOf()] : null;
		},

		_markSelectedDates: function(/*Date[]*/ dates){
			// summary:
			//		Marks the specified cells as selected, and clears cells previously marked as selected.
			//		For CalendarLite at most one cell is selected at any point, but this allows an array
			//		for easy subclassing.

			// Function to mark a cell as selected or unselected
			function mark(/*Boolean*/ selected, /*DomNode*/ cell){
				domClass.toggle(cell, "dijitCalendarSelectedDate", selected);
				cell.setAttribute("aria-selected", selected ? "true" : "false");
			}

			// Clear previously selected cells.
			array.forEach(this._selectedCells || [], lang.partial(mark, false));

			// Mark newly selected cells.  Ignore dates outside the currently displayed month.
			this._selectedCells = array.filter(array.map(dates, this._getNodeByDate, this), function(n){
				return n;
			});
			array.forEach(this._selectedCells, lang.partial(mark, true));
		},

		onChange: function(/*Date*/ /*===== date =====*/){
			// summary:
			//		Called only when the selected date has changed
		},

		isDisabledDate: function(/*===== dateObject, locale =====*/){
			// summary:
			//		May be overridden to disable certain dates in the calendar e.g. `isDisabledDate=dojo.date.locale.isWeekend`
			// dateObject: Date
			// locale: String?
			// tags:
			//		extension
			/*=====
			 return false; // Boolean
			 =====*/
		},

		getClassForDate: function(/*===== dateObject, locale =====*/){
			// summary:
			//		May be overridden to return CSS classes to associate with the date entry for the given dateObject,
			//		for example to indicate a holiday in specified locale.
			// dateObject: Date
			// locale: String?
			// tags:
			//		extension

			/*=====
			 return ""; // String
			 =====*/
		}
	});

	CalendarLite._MonthWidget = declare("dijit.CalendarLite._MonthWidget", _WidgetBase, {
		// summary:
		//		Displays name of current month padded to the width of the month
		//		w/the longest name, so that changing months doesn't change width.
		//
		//		Create as:
		// |	new Calendar._MonthWidget({
		// |			lang: ...,
		// |			dateLocaleModule: ...
		// |		})

		_setMonthAttr: function(month){
			// summary:
			//		Set the current month to display as a label
			var monthNames = this.dateLocaleModule.getNames('months', 'wide', 'standAlone', this.lang, month),
				spacer =
					(has("ie") == 6 ? "" : "<div class='dijitSpacer'>" +
						array.map(monthNames,function(s){
							return "<div>" + s + "</div>";
						}).join("") + "</div>");

			// Set name of current month and also fill in spacer element with all the month names
			// (invisible) so that the maximum width will affect layout.   But not on IE6 because then
			// the center <TH> overlaps the right <TH> (due to a browser bug).
			this.domNode.innerHTML =
				spacer +
					"<div class='dijitCalendarMonthLabel dijitCalendarCurrentMonthLabel'>" +
					monthNames[month.getMonth()] + "</div>";
		}
	});

	return CalendarLite;
});

},
'dijit/form/_DateTimeTextBox':function(){
define([
	"dojo/date", // date date.compare
	"dojo/date/locale", // locale.regexp
	"dojo/date/stamp", // stamp.fromISOString stamp.toISOString
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.getObject
	"./RangeBoundTextBox",
	"../_HasDropDown",
	"dojo/text!./templates/DropDownBox.html"
], function(date, locale, stamp, declare, lang, RangeBoundTextBox, _HasDropDown, template){

	// module:
	//		dijit/form/_DateTimeTextBox

	new Date("X"); // workaround for #11279, new Date("") == NaN

	var _DateTimeTextBox = declare("dijit.form._DateTimeTextBox", [RangeBoundTextBox, _HasDropDown], {
		// summary:
		//		Base class for validating, serializable, range-bound date or time text box.

		templateString: template,

		// hasDownArrow: [const] Boolean
		//		Set this textbox to display a down arrow button, to open the drop down list.
		hasDownArrow: true,

		// Set classes like dijitDownArrowButtonHover depending on mouse action over button node
		cssStateNodes: {
			"_buttonNode": "dijitDownArrowButton"
		},

		/*=====
		// constraints: _DateTimeTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input
		//		(including starting/ending dates/times allowed) as well as
		//		formatting options like whether the date is displayed in long (ex: December 25, 2005)
		//		or short (ex: 12/25/2005) format.  See `dijit/form/_DateTimeTextBox.__Constraints` for details.
		constraints: {},
		======*/

		// The constraints without the min/max properties. Used by the compare() method
		_unboundedConstraints: {},

		// Override ValidationTextBox.pattern.... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale  (plus formatting options too?)
		pattern: locale.regexp,

		// datePackage: String
		//		JavaScript namespace to find calendar routines.	 If unspecified, uses Gregorian calendar routines
		//		at dojo/date and dojo/date/locale.
		datePackage: "",
		//		TODO: for 2.0, replace datePackage with dateModule and dateLocalModule attributes specifying MIDs,
		//		or alternately just get rid of this completely and tell user to use module ID remapping
		//		via require

		postMixInProperties: function(){
			this.inherited(arguments);
			this._set("type", "text"); // in case type="date"|"time" was specified which messes up parse/format
		},

		// Override _FormWidget.compare() to work for dates/times
		compare: function(/*Date*/ val1, /*Date*/ val2){
			var isInvalid1 = this._isInvalidDate(val1);
			var isInvalid2 = this._isInvalidDate(val2);
			if (isInvalid1 || isInvalid2){
				return (isInvalid1 && isInvalid2) ? 0 : (!isInvalid1 ? 1 : -1);
			}
			// Format and parse the values before comparing them to make sure that only the parts of the
			// date that will make the "round trip" get compared.
			var fval1 = this.format(val1, this._unboundedConstraints),
				fval2 = this.format(val2, this._unboundedConstraints),
				pval1 = this.parse(fval1, this._unboundedConstraints),
				pval2 = this.parse(fval2, this._unboundedConstraints);

			return fval1 == fval2 ? 0 : date.compare(pval1, pval2, this._selector);
		},

		// flag to _HasDropDown to make drop down Calendar width == <input> width
		autoWidth: true,

		format: function(/*Date*/ value, /*locale.__FormatOptions*/ constraints){
			// summary:
			//		Formats the value as a Date, according to specified locale (second argument)
			// tags:
			//		protected
			if(!value){ return ''; }
			return this.dateLocaleModule.format(value, constraints);
		},

		"parse": function(/*String*/ value, /*locale.__FormatOptions*/ constraints){
			// summary:
			//		Parses as string as a Date, according to constraints
			// tags:
			//		protected

			return this.dateLocaleModule.parse(value, constraints) || (this._isEmpty(value) ? null : undefined);	 // Date
		},

		// Overrides ValidationTextBox.serialize() to serialize a date in canonical ISO format.
		serialize: function(/*anything*/ val, /*Object?*/ options){
			if(val.toGregorian){
				val = val.toGregorian();
			}
			return stamp.toISOString(val, options);
		},

		// dropDownDefaultValue: Date
		//		The default value to focus in the popupClass widget when the textbox value is empty.
		dropDownDefaultValue : new Date(),

		// value: Date
		//		The value of this widget as a JavaScript Date object.  Use get("value") / set("value", val) to manipulate.
		//		When passed to the parser in markup, must be specified according to `dojo/date/stamp.fromISOString()`
		value: new Date(""),	// value.toString()="NaN"

		_blankValue: null,	// used by filter() when the textbox is blank

		// popupClass: [protected extension] String
		//		Name of the popup widget class used to select a date/time.
		//		Subclasses should specify this.
		popupClass: "", // default is no popup = text only


		// _selector: [protected extension] String
		//		Specifies constraints.selector passed to dojo.date functions, should be either
		//		"date" or "time".
		//		Subclass must specify this.
		_selector: "",

		constructor: function(params /*===== , srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree

			params = params || {};
			this.dateModule = params.datePackage ? lang.getObject(params.datePackage, false) : date;
			this.dateClassObj = this.dateModule.Date || Date;
			if(!(this.dateClassObj instanceof Date)){
				this.value = new this.dateClassObj(this.value);
			}
			this.dateLocaleModule = params.datePackage ? lang.getObject(params.datePackage+".locale", false) : locale;
			this._set('pattern', this.dateLocaleModule.regexp);
			this._invalidDate = this.constructor.prototype.value.toString();
		},

		buildRendering: function(){
			this.inherited(arguments);

			if(!this.hasDownArrow){
				this._buttonNode.style.display = "none";
			}

			// If hasDownArrow is false, we basically just want to treat the whole widget as the
			// button.
			if(!this.hasDownArrow){
				this._buttonNode = this.domNode;
				this.baseClass += " dijitComboBoxOpenOnClick";
			}
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			constraints.selector = this._selector;
			constraints.fullYear = true; // see #5465 - always format with 4-digit years
			var fromISO = stamp.fromISOString;
			if(typeof constraints.min == "string"){
				constraints.min = fromISO(constraints.min);
				if(!(this.dateClassObj instanceof Date)){
					constraints.min = new this.dateClassObj(constraints.min);
				}
			}
			if(typeof constraints.max == "string"){
				constraints.max = fromISO(constraints.max);
				if(!(this.dateClassObj instanceof Date)){
					constraints.max = new this.dateClassObj(constraints.max);
				}
			}
			this.inherited(arguments);
			this._unboundedConstraints = lang.mixin({}, this.constraints, {min: null, max: null});
		},

		_isInvalidDate: function(/*Date*/ value){
			// summary:
			//		Runs various tests on the value, checking for invalid conditions
			// tags:
			//		private
			return !value || isNaN(value) || typeof value != "object" || value.toString() == this._invalidDate;
		},

		_setValueAttr: function(/*Date|String*/ value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Sets the date on this textbox. Note: value can be a JavaScript Date literal or a string to be parsed.
			if(value !== undefined){
				if(typeof value == "string"){
					value = stamp.fromISOString(value);
				}
				if(this._isInvalidDate(value)){
					value = null;
				}
				if(value instanceof Date && !(this.dateClassObj instanceof Date)){
					value = new this.dateClassObj(value);
				}
			}
			this.inherited(arguments, [value, priorityChange, formattedValue]);
			if(this.value instanceof Date){
				this.filterString = "";
			}
			if(this.dropDown){
				this.dropDown.set('value', value, false);
			}
		},

		_set: function(attr, value){
			// Avoid spurious watch() notifications when value is changed to new Date object w/the same value
			if(attr == "value"){
				if(value instanceof Date && !(this.dateClassObj instanceof Date)){
					value = new this.dateClassObj(value);
				}
				var oldValue = this._get("value");
				if(oldValue instanceof this.dateClassObj && this.compare(value, oldValue) == 0){
					return;
				}
			}
			this.inherited(arguments);
		},

		_setDropDownDefaultValueAttr: function(/*Date*/ val){
			if(this._isInvalidDate(val)){
				// convert null setting into today's date, since there needs to be *some* default at all times.
				 val = new this.dateClassObj();
			}
			this._set("dropDownDefaultValue", val);
		},

		openDropDown: function(/*Function*/ callback){
			// rebuild drop down every time, so that constraints get copied (#6002)
			if(this.dropDown){
				this.dropDown.destroy();
			}
			var PopupProto = lang.isString(this.popupClass) ? lang.getObject(this.popupClass, false) : this.popupClass,
				textBox = this,
				value = this.get("value");
			this.dropDown = new PopupProto({
				onChange: function(value){
					// this will cause InlineEditBox and other handlers to do stuff so make sure it's last
					textBox.set('value', value, true);
				},
				id: this.id + "_popup",
				dir: textBox.dir,
				lang: textBox.lang,
				value: value,
				textDir: textBox.textDir,
				currentFocus: !this._isInvalidDate(value) ? value : this.dropDownDefaultValue,
				constraints: textBox.constraints,
				filterString: textBox.filterString, // for TimeTextBox, to filter times shown
				datePackage: textBox.datePackage,
				isDisabledDate: function(/*Date*/ date){
					// summary:
					//		disables dates outside of the min/max of the _DateTimeTextBox
					return !textBox.rangeCheck(date, textBox.constraints);
				}
			});

			this.inherited(arguments);
		},

		_getDisplayedValueAttr: function(){
			return this.textbox.value;
		},

		_setDisplayedValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange){
			this._setValueAttr(this.parse(value, this.constraints), priorityChange, value);
		}
	});


	/*=====
	 _DateTimeTextBox.__Constraints = declare([RangeBoundTextBox.__Constraints, locale.__FormatOptions], {
		 // summary:
		 //		Specifies both the rules on valid/invalid values (first/last date/time allowed),
		 //		and also formatting options for how the date/time is displayed.
		 // example:
		 //		To restrict to dates within 2004, displayed in a long format like "December 25, 2005":
		 //	|		{min:'2004-01-01',max:'2004-12-31', formatLength:'long'}
	 });
	 =====*/

	return _DateTimeTextBox;
});

},
'vodori/ui/_InheritQuarantineMixin':function(){
define([
    'module',
    'vodori/provide',
    'lodash',
    'vodori/ui/_QuarantineMixin',
    'vodori/util/node/getAncestorWidgets'
], function (module, provide, _, _QuarantineMixin, getAncestorWidgets) {

    return provide(module.id, [], {

        applyInheritedQuarantineClassesToNode: function (node) {
            var containingQuarantineWidgets = getAncestorWidgets(this.domNode, _QuarantineMixin);
            if (this.isInstanceOf(_QuarantineMixin)) {
                containingQuarantineWidgets.push(this);
            }

            _.forEach(containingQuarantineWidgets, function (quarantineWidget) {
                quarantineWidget.addQuarantineClassesToNode(node);
            });
        }
    });
});

},
'vodori/input/TimeTextBox':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'dojo/on',
    'dijit/form/TimeTextBox',
    'vodori/ui/_InheritQuarantineMixin'
], function (
    module, provide,
    lang, on,
    TimeTextBox,
    _InheritQuarantineMixin
    ) {

    return provide(module.id, [TimeTextBox, _InheritQuarantineMixin], {

        maxHeight: '250',

        postCreate: function() {
            this.inherited(arguments);

            this.own(on(this.textbox, 'click', lang.hitch(this, 'openDropDown')));
        },

        openDropDown: function () {
            this.inherited(arguments);
            this.applyInheritedQuarantineClassesToNode(this.dropDown.domNode.parentNode);
        }
    });
});

},
'dijit/form/TimeTextBox':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/keys", // keys.DOWN_ARROW keys.ENTER keys.ESCAPE keys.TAB keys.UP_ARROW
	"dojo/_base/lang", // lang.hitch
	"../_TimePicker",
	"./_DateTimeTextBox"
], function(declare, keys, lang, _TimePicker, _DateTimeTextBox){

	// module:
	//		dijit/form/TimeTextBox


	/*=====
	var __Constraints = declare([_DateTimeTextBox.__Constraints, _TimePicker.__Constraints], {
	});
	=====*/

	return declare("dijit.form.TimeTextBox", _DateTimeTextBox, {
		// summary:
		//		A validating, serializable, range-bound time text box with a drop down time picker

		baseClass: "dijitTextBox dijitComboBox dijitTimeTextBox",
		popupClass: _TimePicker,
		_selector: "time",

/*=====
		// constraints: __Constraints
		constraints:{},
=====*/

		// value: Date
		//		The value of this widget as a JavaScript Date object.  Note that the date portion implies time zone and daylight savings rules.
		//
		//		Example:
		// |	new dijit/form/TimeTextBox({value: stamp.fromISOString("T12:59:59", new Date())})
		//
		//		When passed to the parser in markup, must be specified according to locale-independent
		//		`stamp.fromISOString` format.
		//
		//		Example:
		// |	<input data-dojo-type='dijit/form/TimeTextBox' value='T12:34:00'>
		value: new Date(""),		// value.toString()="NaN"
		//FIXME: in markup, you have no control over daylight savings

		// Add scrollbars if necessary so that dropdown doesn't cover the <input>
		maxHeight: -1,

		_onKey: function(evt){
			if(this.disabled || this.readOnly){ return; }
			this.inherited(arguments);

			// If the user has backspaced or typed some numbers, then filter the result list
			// by what they typed.  Maybe there's a better way to detect this, like _handleOnChange()?
			switch(evt.keyCode){
				case keys.ENTER:
				case keys.TAB:
				case keys.ESCAPE:
				case keys.DOWN_ARROW:
				case keys.UP_ARROW:
					// these keys have special meaning
					break;
				default:
					// defer() because the keystroke hasn't yet appeared in the <input>,
					// so the get('displayedValue') call below won't give the result we want.
					this.defer(function(){
						// set this.filterString to the filter to apply to the drop down list;
						// it will be used in openDropDown()
						var val = this.get('displayedValue');
						this.filterString = (val && !this.parse(val, this.constraints)) ? val.toLowerCase() : "";

						// close the drop down and reopen it, in order to filter the items shown in the list
						// and also since the drop down may need to be repositioned if the number of list items has changed
						// and it's being displayed above the <input>
						if(this._opened){
							this.closeDropDown();
						}
						this.openDropDown();
					});
			}
		}
	});
});

},
'dijit/_TimePicker':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/date", // date.compare
	"dojo/date/locale", // locale.format
	"dojo/date/stamp", // stamp.fromISOString stamp.toISOString
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.contains domClass.toggle
	"dojo/dom-construct", // domConstruct.create
	"dojo/_base/kernel", // deprecated
	"dojo/keys", // keys
	"dojo/_base/lang", // lang.mixin
	"dojo/sniff", // has(...)
	"dojo/query", // query
	"dojo/mouse", // mouse.wheel
	"dojo/on",
	"./_WidgetBase",
	"./form/_ListMouseMixin"
], function(array, ddate, locale, stamp, declare, domClass, domConstruct, kernel, keys, lang, has, query, mouse, on,
			_WidgetBase, _ListMouseMixin){

	// module:
	//		dijit/_TimePicker


	var TimePicker = declare("dijit._TimePicker", [_WidgetBase, _ListMouseMixin], {
		// summary:
		//		A time picker dropdown, used by dijit/form/TimeTextBox.
		//		This widget is not available as a standalone widget due to lack of accessibility support.

		// baseClass: [protected] String
		//		The root className to use for the various states of this widget
		baseClass: "dijitTimePicker",

		// pickerMin: String
		//		ISO-8601 string representing the time of the first
		//		visible element in the time picker.
		//		Set in local time, without a time zone.
		pickerMin: "T00:00:00",

		// pickerMax: String
		//		ISO-8601 string representing the last (possible) time
		//		added to the time picker.
		//		Set in local time, without a time zone.
		pickerMax: "T23:59:59",

		// clickableIncrement: String
		//		ISO-8601 string representing the interval between choices in the time picker.
		//		Set in local time, without a time zone.
		//		Example: `T00:15:00` creates 15 minute increments
		//		Must divide dijit/_TimePicker.visibleIncrement evenly
		clickableIncrement: "T00:15:00",

		// visibleIncrement: String
		//		ISO-8601 string representing the interval between "major" choices in the time picker.
		//		Each theme will highlight the major choices with a larger font / different color / etc.
		//		Set in local time, without a time zone.
		//		Example: `T01:00:00` creates text in every 1 hour increment
		visibleIncrement: "T01:00:00",

		// value: String
		//		Time to display.
		//		Defaults to current time.
		//		Can be a Date object or an ISO-8601 string.
		//		If you specify the GMT time zone (`-01:00`),
		//		the time will be converted to the local time in the local time zone.
		//		Otherwise, the time is considered to be in the local time zone.
		//		If you specify the date and isDate is true, the date is used.
		//		Example: if your local time zone is `GMT -05:00`,
		//		`T10:00:00` becomes `T10:00:00-05:00` (considered to be local time),
		//		`T10:00:00-01:00` becomes `T06:00:00-05:00` (4 hour difference),
		//		`T10:00:00Z` becomes `T05:00:00-05:00` (5 hour difference between Zulu and local time)
		//		`yyyy-mm-ddThh:mm:ss` is the format to set the date and time
		//		Example: `2007-06-01T09:00:00`
		value: new Date(),

		_visibleIncrement: 2,
		_clickableIncrement: 1,
		_totalIncrements: 10,

		// constraints: TimePicker.__Constraints
		//		Specifies valid range of times (start time, end time), and also used by TimeTextBox to pass other
		//		options to the TimePicker: pickerMin, pickerMax, clickableIncrement, and visibleIncrement.
		constraints: {},

		/*=====
		 serialize: function(val, options){
			 // summary:
			 //		User overridable function used to convert the attr('value') result to a String
			 // val: Date
			 //		The current value
			 // options: Object?
			 // tags:
			 //		protected
		 },
		 =====*/
		serialize: stamp.toISOString,

		/*=====
		 // filterString: string
		 //		The string to filter by
		 filterString: "",
		 =====*/

		buildRendering: function(){
			this.inherited(arguments);
			this.containerNode = this.domNode;	// expected by _ListBase
			this.timeMenu = this.domNode;	// for back-compat
		},

		setValue: function(/*Date*/ value){
			// summary:
			//		Deprecated.  Used set('value') instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit._TimePicker:setValue() is deprecated.  Use set('value', ...) instead.", "", "2.0");
			this.set('value', value);
		},

		_setValueAttr: function(/*Date*/ date){
			// summary:
			//		Hook so set('value', ...) works.
			// description:
			//		Set the value of the TimePicker.
			//		Redraws the TimePicker around the new date.
			// tags:
			//		protected
			this._set("value", date);
			this._showText();
		},

		_setFilterStringAttr: function(val){
			// summary:
			//		Called by TimeTextBox to filter the values shown in my list
			this._set("filterString", val);
			this._showText();
		},

		isDisabledDate: function(/*===== dateObject, locale =====*/){
			// summary:
			//		May be overridden to disable certain dates in the TimePicker e.g. `isDisabledDate=locale.isWeekend`
			// dateObject: Date
			// locale: String?
			// type:
			//		extension
			return false; // Boolean
		},

		_getFilteredNodes: function(/*number*/ start, /*number*/ maxNum, /*Boolean*/ before, /*DOMNode*/ lastNode){
			// summary:
			//		Returns an array of nodes with the filter applied.  At most maxNum nodes
			//		will be returned - but fewer may be returned as well.  If the
			//		before parameter is set to true, then it will return the elements
			//		before the given index
			// tags:
			//		private

			var nodes = [];

			for(var i = 0 ; i < this._maxIncrement; i++){
				var n = this._createOption(i);
				if(n){
					nodes.push(n);
				}
			}
			return nodes;
		},

		_showText: function(){
			// summary:
			//		Displays the relevant choices in the drop down list
			// tags:
			//		private
			var fromIso = stamp.fromISOString;
			this.domNode.innerHTML = "";
			this._clickableIncrementDate = fromIso(this.clickableIncrement);
			this._visibleIncrementDate = fromIso(this.visibleIncrement);
			// get the value of the increments to find out how many divs to create
			var
				sinceMidnight = function(/*Date*/ date){
					return date.getHours() * 60 * 60 + date.getMinutes() * 60 + date.getSeconds();
				},
				clickableIncrementSeconds = sinceMidnight(this._clickableIncrementDate),
				visibleIncrementSeconds = sinceMidnight(this._visibleIncrementDate),
				// round reference date to previous visible increment
				time = (this.value || this.currentFocus).getTime();

			this._refDate = fromIso(this.pickerMin);
			this._refDate.setFullYear(1970, 0, 1); // match parse defaults

			// assume clickable increment is the smallest unit
			this._clickableIncrement = 1;
			// divide the visible range by the clickable increment to get the number of divs to create
			// example: 10:00:00/00:15:00 -> display 40 divs
			// divide the visible increments by the clickable increments to get how often to display the time inline
			// example: 01:00:00/00:15:00 -> display the time every 4 divs
			this._visibleIncrement = visibleIncrementSeconds / clickableIncrementSeconds;

			// get the number of increments (i.e. number of entries in the picker)
			var endDate = fromIso(this.pickerMax);
			endDate.setFullYear(1970, 0, 1);
			var visibleRange = (endDate.getTime() - this._refDate.getTime()) * 0.001;
			this._maxIncrement = Math.ceil((visibleRange + 1) / clickableIncrementSeconds);

			var nodes  = this._getFilteredNodes();
			array.forEach(nodes, function(n){
				this.domNode.appendChild(n);
			}, this);

			// never show empty due to a bad filter
			if(!nodes.length && this.filterString){
				this.filterString = '';
				this._showText();
			}
		},

		constructor: function(/*===== params, srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree

			this.constraints = {};
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this._setConstraintsAttr(this.constraints); // this needs to happen now (and later) due to codependency on _set*Attr calls
		},

		// For historical reasons TimeTextBox sends all the options for the _TimePicker inside of a constraints{} object
		_setConstraintsAttr: function(/* Object */ constraints){
			// brings in increments, etc.
			for (var key in { clickableIncrement: 1, visibleIncrement: 1, pickerMin: 1, pickerMax: 1 }) {
				if (key in constraints) {
					this[key] = constraints[key];
				}
			}

			// locale needs the lang in the constraints as locale
			if(!constraints.locale){
				constraints.locale = this.lang;
			}
		},

		_createOption: function(/*Number*/ index){
			// summary:
			//		Creates a clickable time option, or returns null if the specified index doesn't match the filter
			// tags:
			//		private
			var date = new Date(this._refDate);
			var incrementDate = this._clickableIncrementDate;
			date.setHours(date.getHours() + incrementDate.getHours() * index,
				date.getMinutes() + incrementDate.getMinutes() * index,
				date.getSeconds() + incrementDate.getSeconds() * index);
			if(this.constraints.selector == "time"){
				date.setFullYear(1970, 0, 1); // make sure each time is for the same date
			}
			var dateString = locale.format(date, this.constraints);
			if(this.filterString && dateString.toLowerCase().indexOf(this.filterString) !== 0){
				// Doesn't match the filter - return null
				return null;
			}

			var div = this.ownerDocument.createElement("div");
			div.className = this.baseClass + "Item";
			div.date = date;
			div.idx = index;
			domConstruct.create('div', {
				"class": this.baseClass + "ItemInner",
				innerHTML: dateString
			}, div);

			if(index % this._visibleIncrement < 1 && index % this._visibleIncrement > -1){
				domClass.add(div, this.baseClass + "Marker");
			}else if(!(index % this._clickableIncrement)){
				domClass.add(div, this.baseClass + "Tick");
			}

			if(this.isDisabledDate(date)){
				// set disabled
				domClass.add(div, this.baseClass + "ItemDisabled");
			}
			if(this.value && !ddate.compare(this.value, date, this.constraints.selector)){
				div.selected = true;
				domClass.add(div, this.baseClass + "ItemSelected");
				this._selectedDiv = div;
				if(domClass.contains(div, this.baseClass + "Marker")){
					domClass.add(div, this.baseClass + "MarkerSelected");
				}else{
					domClass.add(div, this.baseClass + "TickSelected");
				}

				// Initially highlight the current value.   User can change highlight by up/down arrow keys
				// or mouse movement.
				this._highlightOption(div, true);
			}
			return div;
		},

		onOpen: function(){
			this.inherited(arguments);

			// Since _ListBase::_setSelectedAttr() calls scrollIntoView(), shouldn't call it until list is visible.
			this.set("selected", this._selectedDiv);
		},

		_onOptionSelected: function(/*Object*/ tgt){
			// summary:
			//		Called when user clicks an option in the drop down list
			// tags:
			//		private
			var tdate = tgt.target.date || tgt.target.parentNode.date;
			if(!tdate || this.isDisabledDate(tdate)){
				return;
			}
			this._highlighted_option = null;
			this.set('value', tdate);
			this.onChange(tdate);
		},

		onChange: function(/*Date*/ /*===== time =====*/){
			// summary:
			//		Notification that a time was selected.  It may be the same as the previous value.
			// tags:
			//		public
		},

		_highlightOption: function(/*node*/ node, /*Boolean*/ highlight){
			// summary:
			//		Turns on/off highlight effect on a node based on mouse out/over event
			// tags:
			//		private
			if(!node){
				return;
			}
			if(highlight){
				if(this._highlighted_option){
					this._highlightOption(this._highlighted_option, false);
				}
				this._highlighted_option = node;
			}else if(this._highlighted_option !== node){
				return;
			}else{
				this._highlighted_option = null;
			}
			domClass.toggle(node, this.baseClass + "ItemHover", highlight);
			if(domClass.contains(node, this.baseClass + "Marker")){
				domClass.toggle(node, this.baseClass + "MarkerHover", highlight);
			}else{
				domClass.toggle(node, this.baseClass + "TickHover", highlight);
			}
		},

		handleKey: function(/*Event*/ e){
			// summary:
			//		Called from `dijit/form/_DateTimeTextBox` to pass a keypress event
			//		from the `dijit/form/TimeTextBox` to be handled in this widget
			// tags:
			//		protected
			if(e.keyCode == keys.DOWN_ARROW){
				this.selectNextNode();
				e.stopPropagation();
				e.preventDefault();
				return false;
			}else if(e.keyCode == keys.UP_ARROW){
				this.selectPreviousNode();
				e.stopPropagation();
				e.preventDefault();
				return false;
			}else if(e.keyCode == keys.ENTER || e.keyCode === keys.TAB){
				// mouse hover followed by TAB is NO selection
				if(!this._keyboardSelected && e.keyCode === keys.TAB){
					return true;	// true means don't call stopEvent()
				}

				// Accept the currently-highlighted option as the value
				if(this._highlighted_option){
					this._onOptionSelected({target: this._highlighted_option});
				}

				// Call stopEvent() for ENTER key so that form doesn't submit,
				// but not for TAB, so that TAB does switch focus
				return e.keyCode === keys.TAB;
			}
			return undefined;
		},

		// Implement abstract methods for _ListBase
		onHover: function(/*DomNode*/ node){
			this._highlightOption(node, true);
		},

		onUnhover: function(/*DomNode*/ node){
			this._highlightOption(node, false);
		},

		onSelect: function(/*DomNode*/ node){
			this._highlightOption(node, true);
		},

		onDeselect: function(/*DomNode*/ node){
			this._highlightOption(node, false);
		},

		onClick: function(/*DomNode*/ node){
			this._onOptionSelected({target: node});
		}
	});

	/*=====
	 TimePicker.__Constraints = declare(locale.__FormatOptions, {
		 // clickableIncrement: String
		 //		See `dijit/_TimePicker.clickableIncrement`
		 clickableIncrement: "T00:15:00"
	 });
	 =====*/

	return TimePicker;
});

},
'vodori/input/Select':function(){
define([
    'vodori/provide', 'module',
    'dojo/dom-class',
    'dijit/form/Select'
], function(provide, module,
            domClass,
            Select) {

    /**
     * Extending to provide a way to give the dropdown custom classes for custom styling
     */
    return provide(module, [Select], {
        additionalClasses: null, // A string with any additional CSS classes to add

        _fillContent: function () {
            this.inherited(arguments);

            domClass.add(this.dropDown.domNode, this.additionalClasses);
        }
    });
});

},
'vodori/input/WhatsThis':function(){
define([
    'module',
    'vodori/provide',
    'dojo/on',
    'dojo/dom-class',
    'dijit/_Widget', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'dojo/text!./templates/WhatsThis.html', 'dojo/_base/lang'
], function (module, provide, on, domClass, _Widget, _TemplatedMixin, _WidgetsInTemplateMixin, template, lang) {
    return provide(module.id, [_Widget, _TemplatedMixin, _WidgetsInTemplateMixin], {

        templateString: template,

        widgetsInTemplate: true,

        whatsThis: null,
        whatsThisContent: null,
        whatsThisButton: null,

        postCreate: function () {
            this.inherited(arguments);

            on(this.whatsThisButton, 'click', lang.hitch(this, 'toggleContent'));

            this.whatsThisContent.innerHTML = this.whatsThis;
        },

        toggleContent: function () {
            domClass.toggle(this.whatsThisContent, 'hidden');
        }

    });
});

},
'pepper/utilities/DateFormatWrapper':function(){
define([
    'module', 'vodori/provide',
    'pepper/utilities/renderLocalDate',
    'vodori/util/date/DateFormatWrapper'
], function (
    module, provide,
    renderLocalDate, DateFormatWrapper) {

    return provide(module.id, [DateFormatWrapper], {

        renderLocalDate: function(date){
            return renderLocalDate(date, this.settings);
        }

    });


});

},
'pepper/utilities/renderLocalDate':function(){
define([
    'lodash', 'module', 'vodori/provide', 'vodori/util/date/getDateFromIsoString',
    'dojo/date/locale', 'dojo/date'
], function (
    _, module, provide, getDateFromIsoString,
    dateLocale, dojoDate) {

    // default settings for dojo/locale#format
    var defaults = {
        formatLength: 'short',
        fullYear: true
    };

    /**
     * Checks that a provided date is not null, an actual date object, and a valid date.
     *
     * @param {object} date
     * @returns {boolean|*}
     */
    var isValidDate = function(date){
        return (date !== null) && _.isDate(date) && !isNaN(date.getDate());
    };

    /**
     * certain dojo/date/locale settings dictate that only a part of the date should be returned.
     * in order to support this in pepper, we only include timezone if the TIME is being requested
     * either by itself or in addition to the date
     *
     * @param {object} settings - See dojo/date/locale/__FormatOptions
     * @returns {boolean|*}
     */
    var settingsShouldPreventTimezoneBeingAppended = function(settings) {
        return (settings.selector === 'date' || _.isString(settings.datePattern));
    };

    return provide(module.id, function(date, settings) {

        var original = _.clone(date);

        settings = _.defaults(settings || {}, defaults);

        if (_.isString(original)) {

            // if input is a string, assume it is an ISO string first
            date = getDateFromIsoString(original);

            // if that didn't work, try to instantiate a date object from it
            if(!isValidDate(date)){
                date = new Date(original);
            }

        }

        if(isValidDate(date)){
            var formatted = dateLocale.format(date, settings);

            if(!settingsShouldPreventTimezoneBeingAppended(settings)){
                var timezone = dojoDate.getTimezoneName(date);
                return formatted + ' ' + timezone;
            }

            return formatted;

        } else{
            console.warn('Could not resolve object into a valid date.');
            return null;
        }

    });


});

},
'vodori/util/date/getDateFromIsoString':function(){
define(['dojo/date/stamp'], function(dateStamp) {
    /*
     * Takes a string in ISO format from the back end and turns it into a JavaScript Date object. The format from
     * the back end is as described in RFC-2822 (http://tools.ietf.org/html/rfc2822#page-14), where there is no colon
     * separating hours from minutes in the timezone offset:
     *
     *      YYYY-MM-DDTHH:mm:ss.sssZ    where Z is +hhmm or -hhmm
     *
     * In order to normalize for all browsers, such as IE 8, which does not support ISO string parsing by Date
     * (see http://msdn.microsoft.com/en-us/library/ie/ff743760(v=vs.94).aspx)
     * we rely on Dojo date utils. Since Dojo's date/stamp/fromISOString supports a subset of ISO-8601 (namely, one
     * that requires a colon in the offset), we add it to the string manually before parsing.
     * Note that for more modern browsers, this whole utility could be replaced by just passing the string
     * to the Date constructor.
     *
     * @param {string} An ISO date string
     */
    return function(isoDate) {
        // If the offset has no colon, add it in; otherwise don't change a thing
        var normalized = (isoDate.slice(-4).indexOf(':') === -1) ? isoDate.slice(0, -2) + ':' + isoDate.slice(-2) :
                                                                   isoDate;
        return dateStamp.fromISOString(normalized);
    };
});
},
'vodori/util/date/DateFormatWrapper':function(){
/**
 * @module vodori/util/date/DateFormatWrapper
 */
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'dojo/dom-attr',
    'dojo/date/locale', 'dojo/date/stamp',
    'dijit/_WidgetBase'
], function (
    module, provide,
    lang, domAttr,
    dateLocale, dateStamp,
    _WidgetBase) {

    /**
     * Surrounds a server rendered date to enable formatting w/ the dojo locale module. Main purpose
     * is to present the user w/ dates in their own time zone.
     * @lends module:vodori/util/date/DateFormatWrapper#
     */
    var DateFormatWrapper = {
        /**
         * The localized version.
         *
         * @type {string}
         */
        localizedDate: null,

        /**
         * Default to the long format data.
         *
         * See: {dojo.date.locale.__FormatOptions}
         *
         * @type {string}
         */
        formatLength: 'long',

        /**
         * @type {dojo.date.locale.__FormatOptions}
         */
        settings: null,

        /**
         * Set this property to true if this widget is wrapping an `<input>` element rather than just plain text. If it
         * is wrapping an input element, it will pull the date from the value of the input.
         *
         * @type {boolean}
         */
        isWrappingInput: false,

        /**
         * The DateFormatWrapper is used to wrap a date (presented as text).
         * It will then convert the time to the user's local time.
         * This is helpful if a server time coming from the back-end is in a different time-zone
         * than where the user is.
         */
        buildRendering: function () {
            var dateToLocalize = this._retrieveDate();
            this.localizedDate = this.renderLocalDate(dateToLocalize);

            // Only swap out if the text is an actual date that was able to be localized
            if (!!this.localizedDate) {
                this.srcNodeRef.innerHTML = this.localizedDate;
            }

            this.inherited(arguments);
        },

        /**
         * Retrieve the date this widget is wrapping.
         *
         * @returns {Date} The date to be formatted, or null if nothing was found.
         * @private
         */
        _retrieveDate: function () {
            var date;
            if (this.isWrappingInput) {
                var input = this.srcNodeRef.children[0];
                var value = domAttr.get(input, 'value');
                if (value) {
                    date = dateStamp.fromISOString(value);
                }
            } else {
                var dateString = lang.trim(this.srcNodeRef.innerHTML);
                date = new Date(dateString);
            }

            var isItADate = date && !isNaN(date.getDate());
            if (isItADate) {
                return date;
            } else {
                return null;
            }
        },

        /**
         * Convert the date to the user's locale and format accordingly
         * If no date is given return null so we know not to swap the dates.
         *
         * @param {Date} date
         * @return {string} The date localized.
         */
        renderLocalDate: function (date) {

            if (date) {
                // Open the API to any setting, but leave hook for named format lengths, since this
                // is a common use case.
                return dateLocale.format(date, lang.mixin({
                    formatLength: this.formatLength
                }, this.settings));
            } else {
                return null;
            }
        }
    };
    /**
     * @constructor
     * @alias module:vodori/util/date/DateFormatWrapper
     */
    return provide(module.id, [_WidgetBase], DateFormatWrapper);
});

},
'pepper/input/FileInput':function(){
define([
    'module',
    'vodori/provide',
    'dojo/_base/lang',
    'dojo/on',
    'dijit/_Widget', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'dojo/text!./templates/FileInput.html'
], function (module, provide, lang, on, _Widget, _TemplatedMixin, _WidgetsInTemplateMixin, template) {
    /**
     * The FileInput module offers a stylized way to use a file input field
     * It hides the real input behind a prettier, yet fake, button & input field
     *
     * @class pepper/input/FileInput
     * @extends dijit/_Widget
     * @mixes dijit/_TemplatedMixin
     * @mixes dijit/_WidgetsInTemplateMixin
     */
    return provide(module.id, [_Widget, _TemplatedMixin, _WidgetsInTemplateMixin],
        /**
         * @lends pepper/input/FileInput#
         */
        {

            /**
             * @ignore
             */
            templateString: template,

            /**
             * @ignore
             */
            widgetsInTemplate: true,

            fakeFileInput: null,
            realFileInput: null,

            /**
             * @ignore
             */
            postCreate: function () {
                this.inherited(arguments);

                // Connect to the realFileInput changing, that way we can set
                on(this.realFileInput.domNode, 'change', lang.hitch(this, this.updateFakeFileInput));
            },

            /**
             * Set the fakeFileInput value to the realFileInput value
             */
            updateFakeFileInput: function () {
                var filePath = this.realFileInput.get('value');

                // Windows will set the path to 'C:fakepath\..' so we may need to do a little cleaning
                if (filePath.indexOf('fakepath') > -1 && filePath.indexOf('\\') > -1) {
                    filePath = filePath.substr(filePath.lastIndexOf('\\') + 1, filePath.length);
                }

                this.fakeFileInput.value = filePath;
            }
        });
});

},
'pepper/dialogs/info/PropertyViewer':function(){
/**
 * Modular PropertyViewer widget. This is the right hand side of most dialogs built off of the
 * Info widget. Currently displays any tab added to it inside of itself (it is a
 * TabContainer). Tabs must conform to and be configured by the API that this widget enforces.
 */
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/dom-style', 'dojo/on',
    'dijit/registry',
    'dijit/layout/TabContainer',
    'pepper/dialogs/info/PropertiesGrid', 'pepper/dialogs/info/PropertiesProxyPane',
    'pepper/ui/FormProxyPane', 'pepper/ui/handleNotification',
    'pepper/utilities',
    'pepper/dialogs/info/tabs/RelationshipsTab',
    'pepper/dialogs/create/tabs/PropertiesTab',
    'pepper/dialogs/info/tabs/AuditsTab',
    'pepper/dialogs/info/tabs/PermissionsTab',
    'pepper/dialogs/info/tabs/PropertiesTab',
    'pepper/dialogs/info/tabs/RenditionsTab',
    'pepper/dialogs/info/tabs/VersionsTab',
    'pepper/dialogs/info/tabs/WorkflowHistoryTab',
    'pepper/dialogs/review/tabs/PropertiesTab'
], function(
    module, provide,
    _,
    lang,
    domStyle, on,
    registry,
    TabContainer,
    PropertiesGrid, PropertiesProxyPane,
    FormProxyPane, handleNotification,
    utilities,
    RelationshipsTab,
    CreatePropertiesTab,
    AuditsTab,
    PermissionsTab,
    NormalPropertiesTab,
    RenditionsTab,
    VersionsTab,
    WorkflowHistoryTab,
    ReviewPropertiesTab
) {

    var TAB_NAME_TO_CONSTRUCTOR_MAP = {
        'NormalPropertiesTab': NormalPropertiesTab,
        'CreatePropertiesTab': CreatePropertiesTab,
        'ReviewPropertiesTab': ReviewPropertiesTab,
        'AuditsTab': AuditsTab,
        'RelationshipsTab': RelationshipsTab,
        'PermissionsTab': PermissionsTab,
        'RenditionsTab': RenditionsTab,
        'VersionsTab': VersionsTab,
        'WorkflowHistoryTab': WorkflowHistoryTab
    };

    return provide(module, [TabContainer],
        /**
         * Tab Container that contains a set of info tabs that are displayed in the info dialog.
         *
         * @lends pepper/dialogs/info/PropertyViewer#
         */
        {
            propertiesGrids: null,
            proxyPanes: null,
            config: null,
            _dirtyHandle: null,
            relationshipTab: null,

            constructor: function() {
                this.propertiesGrids = [];
                this.proxyPanes = [];
            },

            /**
             * Saves the current tab and returns that deferred, or returns null if the tab isn't saveable
             * @param {Array} params A list of parameters to modify save behavior
             */
            save: function(params) {
                var child = this.selectedChildWidget;
                if (child.save) {
                    return child.save(params);
                }
                return null;
            },

            /**
             * Overridden from dijit/layout/StackContainer to warn the user of unsaved changes in the current tab
             * @param page the page being switched to
             * @param animate
             */
            selectChild: function(page, animate) {
                page = registry.byId(page);

                var previousPage = this.selectedChildWidget;
                if (previousPage !== page) { // check if the page actually changed
                    if (previousPage) {
                        if (previousPage.save && previousPage.isDirty) {
                        // the tab is saveable and enables dirty checking
                            if (previousPage.isDirty()) {
                                var inherited = lang.hitch(this, 'inherited', 'selectChild', arguments);
                                var callback = lang.hitch(this, function() {
                                    inherited();
                                    this._attachDirty();
                                    this.onTabChange(page);
                                });
                                var notification = utilities.dialogs.createUnsavedChangesModal(callback);
                                handleNotification(notification);
                                return;
                            }
                        }
                    }
                    var ret = this.inherited(arguments);
                    this._attachDirty();
                    this.onTabChange(page);
                    return ret;
                }
                return this.inherited(arguments);
            },


            onTabChange: function(page) {
            },

            /**
             * Determine if a tab is potentially saveable by seeing if it is an instance of PropertiesProxyPane
             *
             * @param {pepper.dialogs.info.PropertiesProxyPane} [tab]
             * @return {boolean}
             */
            isCurrentTabSavable: function(tab) {
                if (!tab) {
                    tab = this.selectedChildWidget;
                }

                // Occasionally, this.selectedChildWidget isn't a tab, which leads to buttons being out
                // of sync. see: CAYENNE-1831.
                if (!tab) {
                    tab = this.getChildren()[0];
                }

                return tab.isInstanceOf(PropertiesProxyPane);
            },

            /**
             * Hooks up dirty handling. Disconnects happen for when tabs change
             */
            _attachDirty: function() {
                if (this._dirtyHandle) {
                    this.disconnect(this._dirtyHandle);
                    this._dirtyHandle = null;
                }

                if (this.selectedChildWidget.isDirty && this.selectedChildWidget.onDirty) {
                    this._dirtyHandle = on(this.selectedChildWidget, 'onDirty', this.onDirty);
                }
            },

            /**
             * Is the property viewer (ie the current tab) dirty?
             */
            isDirty: function() {
                var page = this.selectedChildWidget;
                return (page.isDirty && page.isDirty());
            },

            /**
             * Fires when a tab is made dirty or clean
             */
            onDirty: function() {
            },

            /**
             * Populates the configured tabs into the tabcontainer
             */
            populate: function() {
                if (this.config.tabs.length === 1) {
                    domStyle.set(this.tablist.domNode, 'display', 'none');
                    this.resize();
                }

                _.forEach(this.config.tabs, function(tabInfo) {
                    var name = tabInfo;
                    var args = {};

                    if(_.isObject(tabInfo)) {
                        name = tabInfo.name;
                        args = tabInfo.properties;
                    }

                    var TabConstructor = null;
                    if(TAB_NAME_TO_CONSTRUCTOR_MAP.hasOwnProperty(name)){
                        TabConstructor = TAB_NAME_TO_CONSTRUCTOR_MAP[name];
                    } else {
                        throw new Error('No tab found for name: ' + name);
                    }
                    
                    var tab = new TabConstructor(args);
                    this.addChild(tab);

                }, this);
            },

            /**
             * Overriden to push any added children to the propertiesGrids or proxyPanes arrays
             * @param tab the tab being added
             */
            addChild: function(tab) {
                this.inherited(arguments);

                if (tab instanceof PropertiesGrid || (tab.containsGrid && tab.containsGrid())) {
                    this.propertiesGrids.push(tab);
                } else if (tab instanceof FormProxyPane || (tab.containsContentPane && tab.containsContentPane())) {
                    this.proxyPanes.push(tab);
                } else if (tab instanceof RelationshipsTab) {
                    this.relationshipTab = tab;
                }
            },

            /** Updates the widget with new objects
             * @param objects the new objects
             * @param template the new template
             */
            update: function(objects, template) {
                this.updateGrids(objects);
                this.updateProxyPanes(objects, template);

                // relationships tab is broken out into its own case because it is not a properties Grid
                if(this.relationshipTab) {
                    this.relationshipTab.setObjects(objects);
                }
            },

            /**
             * Updates each grid to use new objects
             * @param objects the new objects
             */
            updateGrids: function(objects) {
                _.forEach(this.propertiesGrids, function(grid) {
                    grid.setObjects(objects);
                }, this);
            },

            /**
             * Clears all of the grids' displayed results
             */
            clearGrids: function() {
            },

            /**
             * Updates each of the proxy panes using the new objects
             * @param objects the new objects
             * @param template (optional) the selected template
             */
            updateProxyPanes: function(objects, template) {
                var readOnly = false;
                if (!_.isEmpty(objects)) {
                    readOnly = !objects[0].lockedByCurrentUser;
                }

                _.forEach(this.proxyPanes, function(pane) {
                    var href = null;
                    if (this.config.view === 'create') {
                        href = pane.buildHref(this.config, template, this.channelId);
                    } else {
                        href = pane.buildHref(this.config, objects, template);
                    }
                    if (!!href) {
                        pane.set('readOnly', readOnly);
                        pane.set('href', href);
                    } else {
                        pane.set('content', null);
                    }
                }, this);
            },

            /**
             * Clears each proxy pane so nothing is displayed
             */
            clearProxyPanes: function() {
                _.forEach(this.proxyPanes, function(pane) {
                    pane.set('content', null);
                });
            },

            clear: function() {
                this.clearProxyPanes();
                this.clearGrids();
            },

            destroy: function() {
                this.inherited(arguments);
                if (this.proxyPanes) {
                    _.forEach(this.proxyPanes, function(tab) {
                        tab.destroyRecursive();
                    });
                }
                var children = this.getChildren();
                if (children) {
                    _.forEach(children, function(tab) {
                        if (typeof tab.destroyRecursive === 'function') {
                            tab.destroyRecursive();
                        }
                    });
                }
            }
        });
});

},
'pepper/dialogs/info/PropertiesGrid':function(){
/**
 * Grid that extends vodori.ui.Grid in order to display read-only properties within the info
 * dialog (and similar views). Essentially in use to properly set its query from the
 * current object status (which will be provided, not looked up by itself).
 */
define([
    'module',
    'vodori/provide',
    'vodori/ui/Grid',
    'pepper/utilities'
], function (
    module,
    provide,
    Grid,
    utilities
    ) {

    /**
     * @class pepper/dialogs/info/PropertiesGrid
     * @mixes vodori/ui/Grid
     */
    return provide(module.id, [ Grid ],
        /**
         * @lends pepper/dialogs/info/PropertiesGrid#
         */
        {
            ready: false, // can't be ready until we give it some objects
            noDataMessage: 'No results found',
            defaultSortColumn: null,
            baseClass: 'pepperGrid',
            contextMenu: null, // A reference to an optional context menu
            selectionMode: 'single', // If selections are enabled, whether to make selections 'single' or 'extended'

            postCreate: function () {
                this.inherited(arguments);

                this.set('ready', false);
            },

            /**
             * Uses the object data to set the query used by this grid's service store.
             * @param objects the objects to build a query from
             */
            setObjects: function (objects) {
                if (!this.get('ready')) {
                    this.set('ready', true); // ready when we actually have some objects
                }

                var queryObjects = utilities.createPayload(objects);
                this.set('query', { objects: queryObjects });
            },

            _setReady: function (ready) {
                if (this.store.setReady) {
                    this.store.setReady(ready);
                }
                this.ready = ready;
            },

            /**
             * @ignore
             */
            uninitialize: function () {
                if (this.contextMenu) {
                    this.contextMenu.destroy();
                }

                this.inherited(arguments);
            }
        });
});

},
'vodori/ui/Grid':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'vodori/ui/grid/_BaseGrid',
    './grid/GridFactory!keyboard,selection,columnResizer',
    'dijit/_WidgetBase', 'dijit/layout/_ContentPaneResizeMixin'
], function (provide, module, _, _BaseGrid, GridModules, _WidgetBase, _ContentPaneResizeMixin) {

    /**
     * @class vodori/ui/Grid
     * @extends dijit/_WidgetBase
     * @extends dijit/layout/_ContentPaneResizeMixin
     *
     * @extends dgrid/Keyboard
     * @extends vodori/ui/grid/_Selection
     * @extends dgrid/ColumnResizer
     *
     * @extends vodori/ui/grid/_BaseGrid
     */
    return provide(module, _.flatten([_WidgetBase, _ContentPaneResizeMixin, GridModules, _BaseGrid]), {
    });
});

},
'pepper/dialogs/info/PropertiesProxyPane':function(){
/**
 * A FormProxyPane with a save method so it conforms to the API of "saveable" tabs in the Info/Properties dialog.
 * May seem sort of stupid, but it's primarily here for the sake of convenience and the ability to use generic tabs
 */
define([
    'module', 'vodori/provide',
    'dojo/query', 'dojo/on',
    'vodori/layout/_Composable', 'vodori/util/string/urls',
    'pepper/ui/FormProxyPane'
], function(
    module, provide,
    query, on,
    _Composable, urls,
    FormProxyPane) {
    /**
     * @class pepper/dialogs/info/PropertiesProxyPane
     * @mixes pepper/ui/FormProxyPane
     */
    return provide(module, [FormProxyPane, _Composable],
        /**
         * @lends pepper/dialogs/info/PropertiesProxyPane.prototype
         */
        {
            readOnly: false,
            _onDirtyHandle: null,


            onDownloadEnd: function() {
                this.inherited(arguments);

                if (this.readOnly) {
                    if (this.form) {
                        this.form._getDescendantFormWidgets().forEach(function(widget) {
                            widget.set('disabled', true);
                        });
                    }
                }

                if (!this.form) {
                    console.error('Could not find form inside properties viewer. Did the JSP render properly?');
                }
                else if (this.form.onDirty) {
                    if (this._onDirtyHandle) {
                        this.disconnect(this._onDirtyHandle);
                    }
                    this._onDirtyHandle = on(this.form, 'onDirty', this.onDirty);
                    this.onDirty(); // new form loaded, dirty has to be fired
                }
            },

            /**
             * This function overrides FormProxyPane.parseResponse() to specifically parse for a
             * new title for the dialog that this proxy pane is rendered in.
             */
            parseResponse: function() {
                this.parseNewDialogTitle();
            },

            /**
             * Looks for an element with the data-pepper-dialog-title attribute and emits an event for any containers to
             * adjust themselves accordingly (for instance, updating the dialog container title text)
             */
            parseNewDialogTitle: function() {
                var titles = query('[data-pepper-dialog-title]', this.domNode);
                if (titles.length > 0) {
                    this.fireCompose({
                        props: {
                            heading: titles[0].getAttribute('data-pepper-dialog-title')
                        }
                    });
                }
            },

            /**
             * Saves the tab.
             * @param params List of parameters to modify save behavior.
             */
            save: function(params) {
                return this.mimicFormSubmit(params);
            },

            /**
             * Builds the href that will load in this proxy pane on load
             */
            buildHref: function() {
            },

            /**
             * Determines if the form is dirty. Only works if the form wrapped by this pane implements
             * an isDirty method.
             */
            isDirty: function() {
                if (this.form && this.form.isDirty) {
                    return this.form.isDirty();
                }
                return false;
            },

            onDirty: function() {
                // connect to this
            },

            _getObjectIdsAttr: function() {
                var url = this.form && this.form.get('action');
                var params = urls.getParametersFromUrl(url);
                var objectIdsString = params.objectIds;
                if (!objectIdsString) {
                    return [];
                }
                return objectIdsString.split(/\s*,\s*/);
            }
        });
});

},
'vodori/util/string/urls':function(){
define(['dojo/io-query'], function (ioQuery) {
    /**
     * @exports vodori/util/string/urls
     */
    var _module = {
        /**
         *
         * @param {string} url
         * @param {string} querystringParams
         * @returns {string}
         */
        addQuerystringParamsToUrl: function(url, querystringParams) {
            var newUrl = url;

            if(url.indexOf('?') === -1) {
                newUrl += '?';
            } else {
                newUrl += '&';
            }

            return newUrl + ioQuery.objectToQuery(querystringParams);
        },

        /**
         *
         * @param {string} url
         * @param {string} key
         * @param {string} value
         * @returns {string}
         */
        addSingleQuerystringParamToUrl: function(url, key, value) {
            var object = {};
            object[key] = value;

            // Add on the parameter, respecting the fact that other parameters may be there if a '?' already exists.
            return url + ((url.indexOf('?') >= 0) ? '&' : '?') + ioQuery.objectToQuery(object);
        },

        /**
         * Return an object containing the key-value parameters of the given URL. This uses dojo/io-query to parse the
         * parameters. An empty object is returned if there are no parameters
         *
         * @param {string} url
         * @return {object} never null
         */
        getParametersFromUrl: function(url) {
            if (!url) {
                return {};
            }
            var i = url.indexOf('?');
            if (i === -1) {
                return {};
            }
            return ioQuery.queryToObject(url.substring(i + 1));
        }
    };

    return _module;
});
},
'pepper/ui/FormProxyPane':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/topic', 'dojo/Deferred', 'dojo/_base/lang',
    'dojo/dom-attr',
    'vodori/ui/FormProxyPane',
    'pepper/events',
    'pepper/ui/Form'
], function (provide, module,
             _,
             topic, Deferred, lang,
             domAttr,
             FormProxyPane,
             events,
             Form) {

    /**
     * Overrides a dijit.form.Form in the content so that submitting it
     * loads new content in the FormProxyPane, as if the form were in an <iframe>.
     *
     * This widget also makes vodori.parentFrame in whichever global scope the
     * client lands in. vodori.parentFrame will always be the calling frame.
     *
     * NOTE: You can use widget.on() to handle these events, but you cannot use dojo/on. This uses the _WidgetBase event
     *       system, which varries in subtle but significant ways from dojo/on and dojo/Evented.
     * @emits DownloadStart (no arguments) Triggered for both an initial form load and a form submission.
     * @emits DownloadEnd (no arguments) Triggered for both an initial form load and a form submission.
     * @emits SubmitStart { target: this, isEnterKey: boolean } Triggered only for a form submission.
     * @emits SubmitEnd { target: this, successful: boolean, isEnterKey: boolean } Triggered only for a form
     *        submission.
     */
    return provide(module.id, [FormProxyPane], {

        /**
         * Triggered for both an initial form load and a form submission.
         */
        onDownloadStart: function () {
            topic.publish(events.ui.formProxyPane.formDownloadStart, this);
            return this.inherited(arguments);
        },

        /**
         * Triggered for both an initial form load and a form submission.
         */
        onDownloadEnd: function () {
            topic.publish(events.ui.formProxyPane.formDownloadEnd, this);
            return this.inherited(arguments);
        },

        /**
         * Triggered only for a form submission.
         *
         * @param {{ target: this, isEnterKey: boolean }} event
         */
        onSubmitStart: function(event) {
        },

        /**
         * Triggered only for a form submission.
         *
         * @param {{ target: this, successful: boolean, isEnterKey: boolean }} event
         */
        onSubmitEnd: function(event) {
        },

        /**
         * Update the contentPane with the form's action and method and values.
         * Returns a Deferred you can use to process the response when the pane is ready.
         * @param params A list of parameters to modify form submission behavior, such as
         *                  blocking page redirects.
         */
        mimicFormSubmit: function(params) {
            params = params || {};
            var eventData = {
                isEnterKey: params.isEnterKey ? true : false
            };
            var resultPromise = new Deferred();
            if (!this._validateForm(resultPromise)) {
                return resultPromise;
            }

            this._attachSubmitEndHandlers(resultPromise, eventData);

            var url = this._getFormSubmissionUrl(params);
            var method = this.form.get('method');
            var data = this.form.get('value');

            this.set('ioMethod', method);
            this.ioArgs.content = data;
            var hrefChangeDeferred = this.set('href', url);

            this._emitSubmitStartEvent(eventData);
            this._resolvePromiseWhenFormCompletes(hrefChangeDeferred, resultPromise);

            // reset ioMethod and ioArgs to default
            this.set('ioMethod', 'GET');
            delete this.ioArgs.content;

            return resultPromise;
        },

        _validateForm: function(resultPromise) {
            var valid = this.form.validate();

            if (!valid) {
                if (this.cancelOnInvalid) {
                    resultPromise.cancel('Form validation failed.');
                }
                // NOTE: The resultPromise will never resolve if cancelOnInvalid is false. Is that okay?
            }
            return valid;
        },

        _getFormSubmissionUrl: function(params) {
            var url = this.form.get('action') || this.href;
            url = this._appendUrlParamsToUrl(url, params);
            return url;
        },

        /**
         * @param {string} href
         * @param params
         * @returns {string} the href with params appended
         * @private
         */
        _appendUrlParamsToUrl: function(href, params) {
            // Iterate over the passed-in parameters to mixin them to content, or append them to
            // the href being posted, etc.
            _.forEach(params, function (param) {
                if (param.type) {
                    // If the param type is 'URL', then add the param as a URL parameter
                    if (param.type === 'URL') {
                        // First encode the parameter as 'name=value'
                        var urlParam = encodeURIComponent(param.name) + '=' + encodeURIComponent(param.value);
                        // Then add it on as a parameter, respecting the fact that other parameters may be there
                        // if a '?' already exists.
                        href += ((href.indexOf('?') >= 0) ? '&' : '?') + urlParam;
                    }
                }
            }, this);
            return href;
        },

        _attachSubmitEndHandlers: function(paneReadyDeferred, eventData) {
            paneReadyDeferred.then(
                lang.hitch(this, '_emitSubmitEndEvent', true, eventData),
                lang.hitch(this, '_emitSubmitEndEvent', false, eventData)
            );
        },

        _emitSubmitStartEvent: function(eventData) {
            this._emitEvent('SubmitStart', 'submitInProgress', eventData);
        },

        _emitSubmitEndEvent: function(successful, eventData) {
            this._emitEvent('SubmitEnd', 'submitComplete', _.assign({ successful: successful}, eventData), successful);
        },

        _resolvePromiseWhenFormCompletes: function(hrefChangeDeferred, paneReady) {
            // After we get a response from changing the HREF...
            hrefChangeDeferred.then(
                lang.hitch(this, function (response) {
                    // ... and after the contents are parsed
                    // and the form is overridden in onDownloadEnd...
                    var onDownloadEnd = this.on('DownloadEnd', lang.hitch(this, function () {
                        onDownloadEnd.remove();

                        if (this.form instanceof Form) {
                            var valid = 'true' === domAttr.get(this.form.domNode, 'data-pepper-form-validated');
                            if (valid) {
                                paneReady.resolve(response);
                            } else {
                                paneReady.reject(response);
                            }
                        } else {
                            paneReady.resolve(response);
                        }
                    }));
                }),
                lang.hitch(this, function (response) {
                    var onDownloadError = this.on('DownloadError', lang.hitch(this, function () {
                        onDownloadError.remove();
                        paneReady.reject();
                    }));
                })
            );
        },

        /**
         * Overriding to notify Info/FolderInfo that the form came back read-only
         */
        onReadOnly: function () {
            topic.publish(events.ui.formProxyPane.onReadOnly, this);
        },

        /**
         * @param {string} eventType
         * @param {string} topicName
         * @param {object} [eventData] optional properties to mix into event
         * @param {*} [topicParam] optional additional param for topic.publish
         * @private
         */
        _emitEvent: function(eventType, topicName, eventData, topicParam) {
            this.emit(eventType, _.assign({ target: this }, eventData));
            topic.publish(events.ui.formProxyPane[topicName], this, topicParam);
        }
    });
});

},
'pepper/ui/Form':function(){
/**
 * Custom form extending dijit/form/Form that provides dirty checking.
 */
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/on',
    'dojo/json',
    'dijit/registry',
    'dijit/form/Form'
], function (module, provide, _, lang, on, JSON, registry, Form) {
    return provide(module.id, [Form], {
        _inputOnChangeHandles: null,

        _originalValue: null,

        constructor: function () {
            this._inputOnChangeHandles = [];
        },

        /**
         * Connects to all of the form's input widget onChange methods to mark the
         * form as dirty
         */
        startup: function () {
            this.inherited(arguments);

            this._originalValue = JSON.stringify(this.get('value'));

            _.forEach(this._getDescendantFormWidgets(), function (input) {
                var handle = on(input, 'change', lang.hitch(this, function () {
                    if (this._originalValue === JSON.stringify(this.get('value'))) {
                        this.set('dirty', false);
                    } else {
                        this.set('dirty', true);
                    }
                }));
                this._inputOnChangeHandles.push(handle);
            }, this);

            this.set('dirty', false);
        },

        /**
         * Dijit/Form does not return native inputs by default.  So extends the original value to include hiddens
         */
        _getValueAttr: function () {

            var value = this.inherited(arguments);

            // Loop through every form element (unless this widget is in the process of being destroyed)
            // NOTE: This is put in here to block the situation where this.containerNode === null.
            // There is a situation where this._beingDestroyed === true and this.containerNode!=null, but we
            // figured we don't care about getting our hidden inputs if the Form widget is being destroyed.
            if (!this._beingDestroyed) {
                _.forEach(this.containerNode.elements, function (element) {

                    // To keep it simple, we'll only deal with hidden inputs (and only if it's not already a dijit)
                    // We also need to have a name, otherwise we'll be passing nameless form values around.
                    if ( !registry.byNode(element) && element.type === 'hidden' &&
                        (typeof element.name !== 'undefined') &&
                        element.name !== '') {

                        value[element.name] = element.value;
                    }

                });
            }

            return value;

        },

        /**
         * Overridden to disconnect the input handles
         */
        uninitialize: function () {
            _.forEach(this._inputOnChangeHandles, function (handle) {
                handle.remove();
            }, this);
        },

        /**
         * Whether or not something has changed in this form since it was loaded
         */
        isDirty: function () {
            return this.get('dirty');
        },

        _setDirtyAttr: function (dirty) {
            this.dirty = dirty;
            this.onDirty();
        },

        onDirty: function () {
            // connect to this
        }
    });
});

},
'pepper/dialogs/info/tabs/RelationshipsTab':function(){
/**
 * Defines the relationships tab for the Info dialog
 */
define(['dojo/_base/declare',
    'lodash',
    'dojo/_base/lang',
    'dojo/date/locale', 'dojo/dom-style',
    'dijit/_WidgetBase',
    'dijit/_TemplatedMixin',
    'pepper/utilities/renderLocalDate',
    'pepper/ui/TreeSection',
    'pepper/services', 'pepper/utilities',
    'dojo/text!./templates/RelationshipsTab.html'
], function(declare,
            _,
            lang,
            locale, domStyle,
            _WidgetBase,
            _TemplatedMixin,
            renderLocalDate,
            TreeSection,
            services, utilities,
            template) {


    /**
     * Used by the uniqueIdGenerator. Contained within the closure to remain non-modifiable.
     *
     * @type {number}
     */
    var UNIQUE_ID_INDEX = 0;

    /**
     * Used to insert an icon class as a column entry.
     *
     * @enum {{icon:string}}
     */
    var ICONS = {
        DELETED: {icon: 'deleted-entry'},
        SYNC_AVAILABLE: {icon: 'sync-available'},
        EXPIRED: {icon: 'expired-source'},
        NEW_DISTRIBUTION: {icon: 'new-distribution'}
    };

    /**
     * Represents an empty cell (column entry).
     *
     * @type {{content: null}}
     */
    var EMPTY_CELL = {content: null};


    /**
     * A map that links backend indicator types with which icon cell should be used.
     *
     */
    var INDICATOR_TO_ICON_MAP = {
        'DeletedIndicator': ICONS.DELETED,
        'NewDistributionIndicator': ICONS.NEW_DISTRIBUTION,
        'DistributionUpdateAvailableIndicator':ICONS.SYNC_AVAILABLE,
        'DistributionExpiredIndicator':ICONS.EXPIRED
    };


    /**
     * A helper function for determining what the entry for the indicator column
     * for a indicator result object should be.
     *
     * @param indicator
     * @returns {{}}
     */
    var getIndicatorCellForIndicatorResult = function(indicator){
        if(indicator){
            var type = indicator.type;
            if(INDICATOR_TO_ICON_MAP.hasOwnProperty(type)){
                return {
                    icon: INDICATOR_TO_ICON_MAP[type].icon,
                    title: indicator.message
                };
            }
        }
        return EMPTY_CELL;
    };


    /**
     * Defines the widget used to represent the asset relationships
     * on the relationships tab of the info dialog.
     *
     * @class RelationshipsTab
     */
    return declare([ _WidgetBase, _TemplatedMixin], {

        /**
         * The template string for the widget
         * @type {string}
         */
        templateString:template,

        /**
         * The title for the tab
         * @type {string}
         */
        title: 'Relationships',

        /**
         * The node that acts as a placeholder for the inner channel node.
         *
         * @type {HTMLSpanElement}
         */
        channelNameNode: null,

        /**
         * The domNode at which the distribution section is positioned.
         *
         * @type {HTMLDivElement}
         */
        distributionNode: null,

        /**
         * The domNode at which the link section is positioned.
         *
         * @type {HTMLDivElement}
         */
        linkNode: null,

        /**
         * The dom node at which the copy section is positioned.
         * @type {HTMLDivElement}
         */
        copyNode: null,

        /**
         * The headers for the distribution section tree rows
         *
         * @type {object[]}
         */
        distributionHeaders: [
            {content: 'Target Channel'},
            {content: 'Source Channel'},
            {content: 'Date Available'},
            EMPTY_CELL,
            {content: 'Last Sync Date'}
        ],

        /**
         * The headers for the link section tree rows
         *
         * @type {object[]}
         */
        linkHeaders: [
            {content: 'File name'},
            {content: 'Channel'},
            {content: 'Date linked'},
            {content: 'Direction'},
            {content: 'Current Version'}
        ],

        /**
         * The headers for the copy section tree rows
         *
         * @type {object[]}
         */
        copyHeaders: [
            {content: 'File name'},
            {content: 'Path'},
            {content: 'Language'},
            EMPTY_CELL,
            {content: 'Date copied'}
        ],

        /**
         * The date pattern to use when rendering dates on this widget.
         *
         * @type {string}
         */
        datePattern: 'd MMM yyyy',

        /**
         * What to display if a date column has null data provided.
         */
        nullDateDefault: '--',

        /**
         * This is called by PropertyViewer in order to indicate to the tab which objects
         * it should render its data for.
         *
         * @param objects
         */
        setObjects: function (objects) {
            var query = this._buildServiceQuery(objects);
            services.getRelationships(query).then(lang.hitch(this, function(response){
                this._handleRelationshipData(response);
                this.set('ready', true);
            }));
        },

        /**
         * This method builds the request payload for the service call according
         * to the object being viewed.
         *
         * @param {string[]} objects A list of object ids to display for the relationships tab
         *                           (in reality only one object can be viewed).
         *
         * @returns {{params: {objects: *}}} Returns the request data object.
         * @private
         */
        _buildServiceQuery: function(objects){
            return {
                params: {
                    objects: utilities.createPayload(objects)
                }
            };
        },

        /**
         * Builds the data for the distribution TreeSection using the raw data from the backend.
         *
         * @param {object[]} distributionResults
         * @returns {Array}
         * @private
         */
        _buildDistributionData: function(distributionResults){
            var relationshipsTab = this;
            var results = [];

            _.forEach(distributionResults, function(distribution){

                var columns = [
                    {content: distribution.targetChannel.name},
                    {content: distribution.sourceChannel.name},
                    {content: relationshipsTab._formatDateFromIso(distribution.dateAvailable)},
                    getIndicatorCellForIndicatorResult(distribution.syncIndicator),
                    {content: relationshipsTab._formatDateFromIso(distribution.lastSyncDate)}
                ];

                // providing a unique id for this row
                var id = relationshipsTab._generateUniqueId();

                // make a recursive call to gather children if children are expected.
                var children = distribution.hasChildren ?
                                relationshipsTab._buildDistributionData(distribution.children) : [];

                var result = {
                    id: id,
                    current: distribution.current,
                    columns: columns,
                    children: children
                };

                results.push(result);
            });

            return results;
        },

        /**
         * Builds the data for the copy TreeSection using the raw data from the backend.
         *
         * @param {object[]} copyResults
         * @returns {Array}
         * @private
         */
        _buildCopyData: function(copyResults){
            var relationshipsTab = this;
            var results = [];

            _.forEach(copyResults, function(copy){

                var columns = [
                    {content: copy.filename},
                    {content: copy.path},
                    {content: copy.language},
                    getIndicatorCellForIndicatorResult(copy.indicator),
                    {content: relationshipsTab._formatDateFromIso(copy.dateCopied)}
                ];

                // providing a unique id for this row
                var id = relationshipsTab._generateUniqueId();

                // make a recursive call to gather children if children are expected.
                var children = copy.hasChildren ? relationshipsTab._buildCopyData(copy.children) : [];

                var result = {
                    id: id,
                    current: copy.current,
                    columns: columns,
                    children: children
                };

                results.push(result);
            });

            return results;
        },

        /**
         * Builds the data for the links TreeSection based on the raw data from the backend.
         *
         * @param {object[]} linkResults
         * @returns {Array} The array of children to use for the link section.
         * @private
         */
        _buildLinkData: function(linkResults){
            var relationshipsTab = this;
            var results = [];

            _.forEach(linkResults, function(link){

                var columns = [
                    {content: link.filename},
                    {content: link.channel.name},
                    {content: relationshipsTab._formatDateFromIso(link.dateLinked)},
                    {content: link.direction},
                    {content: relationshipsTab._buildVersionStateString(link.currentVersion)}
                ];

                // generates a unique id for the row
                var id = relationshipsTab._generateUniqueId();

                // make a recursive call to gather children if children are expected.
                var children = link.hasChildren ? relationshipsTab._buildLinkData(link.children) : [];

                var result = {
                    id: id,
                    current: false, // no such thing as a 'current' linked asset
                    columns: columns,
                    children: children
                };

                results.push(result);
            });

            return results;
        },

        /**
         * Each element in a tree needs a unique ID to link the expando buttons to the expando sections.
         *
         * @returns {number}
         * @private
         */
        _generateUniqueId: function(){
            return UNIQUE_ID_INDEX++;
        },

        /**
         * Builds the version / state cell contents based on the provided version/state object.
         *
         * @param versionState The versionState object returned from the backend.
         * @returns {string}
         * @private
         */
        _buildVersionStateString: function(versionState){
            if(versionState && versionState.version && versionState.state){
                return versionState.version + ', ' + versionState.state;
            } else {
                return null;
            }
        },

        /**
         * A method for formatting dates that appear on the page.
         *
         * @param {string} dateAsIsoString
         * @returns {string|null} Returns the formatted string, or null.
         * @private
         */
        _formatDateFromIso: function(dateAsIsoString){
            if(dateAsIsoString){
                var formatted = renderLocalDate(dateAsIsoString);
                return formatted ? formatted : this.nullDateDefault;
            } else {
                return this.nullDateDefault;
            }
        },

        /**
         * This method is responsible for parsing and modifying the data received from the backend to an
         * appropriate state for rendering the tree section widgets.
         *
         * @param rawData The data received from the backend service call. see GetRelationshipsStrategy.java
         * @private
         */
        _handleRelationshipData: function(rawData) {

            var distributionData = {
                sectionHeader: 'Distribution Breakdown',
                noContentMessage: 'This asset has no related distributions.',
                headers: this.distributionHeaders,
                children: this._buildDistributionData(rawData.distributions || [])
            };

            var linkData = {
                sectionHeader: 'Related Links',
                noContentMessage: 'This asset has no related links.',
                headers: this.linkHeaders,
                children: this._buildLinkData(rawData.links || [])
            };

            var copyData = {
                sectionHeader: 'Related Copies',
                noContentMessage: 'This asset has no related copies.',
                headers: this.copyHeaders,
                children: this._buildCopyData(rawData.copies || [])
            };

            var dataForRendering = {
                distributions: distributionData,
                links: linkData,
                copies: copyData,
                channelName: rawData.currentAssetChannel
            };

            this._renderSections(dataForRendering);
        },

        /**
         * This method is responsible for actually rendering the contents of the relationships tab based
         * off of the data for each of the tree sections.
         *
         * @param data
         * @private
         */
        _renderSections: function(data) {

            this.channelNameNode.innerText = data.channelName + ' Channel';

            this.distributionWidget = new TreeSection({data: data.distributions}, this.distributionNode);
            this.distributionWidget.startup();

            this.linkWidget = new TreeSection({data: data.links}, this.linkNode);
            this.linkWidget.startup();

            this.copyWidget = new TreeSection({data: data.copies}, this.copyNode);
            this.copyWidget.startup();
        },

        resize: function(dimensions) {
            if(dimensions) {
                domStyle.set(this.domNode, 'width', dimensions.w + 'px');
                domStyle.set(this.domNode, 'height', dimensions.h + 'px');
            } else {
                // if we don't have sizing, it should just be the wild, wild west
                domStyle.set(this.domNode, 'width', '');
                domStyle.set(this.domNode, 'height', '');
            }
        }

    });
});

},
'pepper/ui/TreeSection':function(){
define([
    'dijit/_TemplatedMixin',
    'dijit/_WidgetBase',
    'dojo/on',
    'dojo/query',
    'dojo/dom-attr',
    'dojo/_base/lang',
    'dojo/_base/declare',
    'vodori/renderTemplate',
    'dojo/dom-class',
    'dojo/text!./templates/TableTreeSection.mustache',
    'dojo/text!./templates/TableTreePartial.mustache'
], function (TemplatedMixin, WidgetBase, on, query, domAttr, lang, declare,
              renderTemplate, domClass, sectionTemplate, treePartial) {


    /**
     * Defining a click handler for the expando sections.
     */
    var clickHandler = function(){
        domClass.toggle(this.button, 'expando-open');
        domClass.toggle(this.button, 'expando-closed');
        domClass.toggle(this.section, 'hidden');
    };

    /**
     * Defines an area with a header and a tree of children if they exist or a noContentMessage.
     * Nested children are supported and will be collapsible.
     *
     *
     * @class TreeSection
     */
    return declare([WidgetBase, TemplatedMixin], {

        startup: function () {
            // keeping the widget safe from multiple startup calls
            if(!this._started){
                this._connectToggleButtonsAndSections();
            }
            this.inherited(arguments);
        },

        buildRendering: function () {
            // the template string gets used for the first time in the buildRendering, so it's okay to define
            // it dynamically after rendering via mustache
            this.templateString = this._getDynamicTemplate();
            this.inherited(arguments);
        },

        /**
         * Parses the existing tree and links up click events on the expando icons according to the
         * ids that were set on the data-expando-button-id and data-expando-section-id attributes.
         *
         */
        _connectToggleButtonsAndSections: function () {
            // tree will be undefined if there were no children in which case the query
            // would actually query the whole page and therefore register some expando-icons multiple times.
            if(this.tree){
                var toggleButtons = query('.expando-icon', this.tree);
                for(var index = 0; index < toggleButtons.length; index++){
                    var toggleButton = toggleButtons[index];
                    var childId = domAttr.get(toggleButton, 'data-expando-button-id');
                    var toggleSection = query('[data-expando-section-id="' + childId + '"]', this.tree)[0];
                    if(toggleSection){
                        this.own(
                            on(toggleButton, 'click',
                                lang.hitch({button: toggleButton, section: toggleSection}, clickHandler)));
                    }
                }
            }
        },

        /**
         * Renders the mustache template with the data and a mustache partial that handles all
         * the nested tabular logic.
         *
         * @returns {string} The built out template string
         */
        _getDynamicTemplate: function(){

            // NOTE: do not change the key in the third argument as it must be kept in sync with the {{>tableTree}}
            // partial usage inside of TreeSection.mustache
            return renderTemplate(sectionTemplate, this.data, {tableTree: treePartial});
        }

    });
});

},
'pepper/dialogs/create/tabs/PropertiesTab':function(){
/**
 * Properties tab in the info dialog
 */
define([
    'module', 'vodori/provide',
    'vodori/util/string/urls',
    'pepper/dialogs/info/PropertiesProxyPane'
], function(
    module, provide,
    urls,
    PropertiesProxyPane) {
    /**
     * @class pepper/dialogs/info/tabs/PropertiesTab
     * @mixes pepper/dialogs/info/PropertiesProxyPane
     */
    return provide(module, [PropertiesProxyPane],
        /**
         * @lends pepper/dialogs/info/tabs/PropertiesTab.prototype
         */
        {
            region: 'center',
            title: 'Properties',
            refreshOnShow: true,

            /**
             * Builds the href property for a FormProxyPane based on the objects and template provided
             * @param config the configuration of the info dialog
             * @param template the selected template
             */
            buildHref: function (config, template, channelId) {
                var href = (template) ? template.formHref : null;

                if(href && channelId) {
                    href = urls.addSingleQuerystringParamToUrl(href, 'channelId', channelId);
                }

                return href;
            }
        });
});

},
'pepper/dialogs/info/tabs/AuditsTab':function(){
/**
 * Audit tab for the info dialog
 */
define([
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'pepper/utilities/renderLocalDate',
    'pepper/dialogs/info/PropertiesGrid',
    'pepper/data/PepperServiceObjectStore',
    'pepper/services'
], function (module, provide,
             lang,
             renderLocalDate,
             PropertiesGrid,
             PepperServiceObjectStore,
             services) {
    return provide(module, [ PropertiesGrid ], {

        startup:function () {
            this.inherited(arguments);
            this.set('sort', 'performedOnMillis', true);
        },

        constructor:function () {
            this.store = new PepperServiceObjectStore({
                service:services.getAuditHistory,
                identifier:'id',
                sortable:true,
                paginated:true
            });

            this.columns = [
                { label:'Version', field:'version', sortable:true },
                { label:'State', field:'state', sortable:true },
                { label:'ID', field:'objectId', sortable:true },
                { label:'Action', field:'action', sortable:true },
                { label:'Performed On', field:'performedOnMillis', sortable:true,
                    renderCell:lang.hitch(this, 'renderLocalDate')
                },
                { label:'Performed By', field:'user', sortable:true }
            ];
            this.region = 'center';
            this.title = 'Audits';
        },

        renderLocalDate:function (object, dateAsInt, td) {
            td.innerHTML = renderLocalDate(object.auditDate);
        }
    });
});

},
'pepper/data/PepperServiceObjectStore':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/_base/declare',
    'dojo/Deferred', 'dojo/store/util/QueryResults'
], function (module, provide, _, lang, declare, Deferred, QueryResults) {
    /**
     * This store is primarily used for our fancy-shmancy dgrid. It wraps any SMD into
     * a read-only dojo Store.
     *
     * Check http://dojotoolkit.org/reference-guide/dojo/store.html for more info on the API
     *
     * @class pepper/data/PepperServiceObjectStore
     */
    return provide(module, null,
        /**
         * @lends pepper/data/PepperServiceObjectStore.prototype
         */
        {
            _ready: true, // If set to false, any fetch requests will be ignored

            idProperty: 'id', // Name of the property to use as the identifier for results (part of store API)

            identifier: null, // Name of the property in request results data that contains the identifier data
            service: null, // The SMD to use

            sortable: false,    // Whether the service call supports sorting
            paginated: false,   // Whether the service call supports pagination

            QueryResults: QueryResults,

            /**
             * @param options {object}
             * @param options.service {string} the SMD method to use for fetch requests
             * @param options.identifier {string} the name of the ID attribute in the server results
             */
            constructor: function (/* Object */ options) {
                declare.safeMixin(this, options);

                if (this.service === null) {
                    console.warn(module.id + ' was created without a service!');
                }
            },

            /**
             * This is the entry point of a query. See API link at top for more info on parameters
             *
             * @param query             the query object specific to the SMD
             * @param options           this is usually generated by the dgrid
             * @param options.sort {object} Sort options
             * @param options.start {number} Start index of results
             * @param options.count {number} Number of results to return
             *
             * @return QueryResults     a QueryResults object containing the results
             */
            query: function (/* Object */ query, /* Object */ options) {
                if (!this._ready) {
                    return this.QueryResults({}); // Return empty results if not ready
                }

                // Do any necessary formatting of the query and then execute it!
                query = this.formatQuery(query, options);

                var deferred = this._executeQuery(query, options);

                // Return the results data wrapped in a QueryResults object that lets the dgrid
                // easily iterate over the results data
                return this.QueryResults(deferred);
            },

            /**
             * Return the object's ID value
             *
             * @param object    the object... lol
             *
             * @return String   the object's ID value
             */
            getIdentity: function (/* Object */ object) {
                return object[this.idProperty];
            },

            /**
             * Moves attributes in the options object into the query object. See
             * query() for more info on parameters
             *
             * @param query     the query object specific to the SMD
             * @param options   this is usually generated by the dgrid
             * @param options.sort {object} Sort options
             * @param options.start {number} Start index of results
             * @param options.count {number} Number of results to return
             *
             * @return Object   the newly formatted query object
             */
            formatQuery: function (/* Object */ query, /* Object */ options) {
                options = options || {};

                // If this store is sortable, generate the sort params
                if (this.sortable && options.sort !== undefined) {
                    var s = options.sort[0];
                    if (s) {
                        query.sortOrder = {
                            field: s.attribute,
                            order: (!s.descending) ? 'ASC' : 'DESC'
                        };
                    }
                }

                // If this store is paginated, generate the pagination params
                if (this.paginated) {
                    if (options.start !== undefined) {
                        query.start = options.start;
                    }

                    if (options.count !== undefined) {
                        query.count = options.count;
                    }
                }

                return query;
            },

            /**
             * Needed a public version of _formatResults, but I don't want to break a heavily used API.
             *
             * @param results
             * @return {Array}
             */
            formatResults: function (results) {
                return this._formatResults(results);
            },

            /**
             * Formats the result data to be used with a grid
             *
             * @param results   an array of results
             * @return Array    the newly formatted results
             */
            _formatResults: function (/* Array */ results) {
                var idProperty = this.idProperty;
                var identifier = this.identifier;
                return _.map(results, function (result) {
                    // Set custom id attribute
                    if (identifier !== null && !(idProperty in result)) {
                        result[idProperty] = result[identifier];
                    }

                    return result;
                });
            },

            /**
             * Run a query using the given SMD and query object
             *
             * @param query         the query to execute
             * @param options       includes sort, count etc.
             * @return Deferred     a promise with the query results
             */
            _executeQuery: function (/* Object */ query, /* Object */ options) {
                var serviceResultDeferred = this.service({ params: query });

                return this._buildQueryResultsDeferred(serviceResultDeferred);
            },

            _buildQueryResultsDeferred: function (serviceResultDeferred) {
                var resultDeferred = new Deferred(function (reasonForCancel) {
                    // pass on cancel to the service result deferred as well.
                    serviceResultDeferred.cancel(reasonForCancel);
                });
                resultDeferred.total = new Deferred(); // Required by QueryResults.js

                serviceResultDeferred.then(
                    lang.hitch(this, function (data) {
                        var results = this._formatResults(data.results);
                        var totalResults = data.totalResults || results.length;

                        resultDeferred.total.resolve(totalResults);
                        resultDeferred.resolve(results);
                    }),
                    function (error) {
                        if (serviceResultDeferred.isCanceled()) {
                            resultDeferred.total.cancel(error);
                            resultDeferred.cancel(error);
                        } else {
                            resultDeferred.total.reject(error);
                            resultDeferred.reject(error);
                        }
                    }
                );

                return resultDeferred;
            },

            /**
             * Herp derp simple setter for this._ready
             */
            setReady: function (/* Boolean */ ready) {
                this._ready = ready;
            },

            // Stubbed out. Pretty sure these don't need to be implemented unless if we want to
            // make this a read/write store.

            get: function (id, options) {
            },

            put: function (object, options) {
            },

            add: function (object, options) {
            },

            remove: function (id) {
            }
        });

});

},
'pepper/dialogs/info/tabs/PermissionsTab':function(){
define([
    'module', 'vodori/provide',
    'dijit/_Widget', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'dijit/layout/_ContentPaneResizeMixin',
    'dojo/text!pepper/dialogs/info/tabs/templates/PermissionsTab.html'
], function (module, provide, _Widget, _TemplatedMixin, _WidgetsInTemplateMixin, _ContentPaneResizeMixin, template) {
    /**
     * Tab for displaying permissions information in the info dialog
     */
    return provide(module.id, [ _Widget, _TemplatedMixin, _WidgetsInTemplateMixin, _ContentPaneResizeMixin ], {
        templateString: template,
        title: 'Permissions',
        region: 'center',
        refreshOnShow: true,

        buildRendering: function () {
            this.inherited(arguments);
            this.containerNode = this.domNode; // For the _ResizeMixin
        },

        containsContentPane: function () {
            return true;
        },

        buildHref: function (config, objects) {
            if (objects.length > 0) {
                var href = '/author/pepper/getPermissionsForm.html?objectIds=' + objects[0].objectId;
                for (var i = 1; i < objects.length; i++) {
                    href += '&objectIds=' + objects[i].objectId;
                }
                return href;
            }
            return null;
        },

        _setHrefAttr: function (href) {
            this.pane.set('href', href);
        }
    });
});

},
'pepper/dialogs/info/tabs/PropertiesTab':function(){
/**
 * Properties tab in the info dialog
 */
define([
    'module', 'vodori/provide',
    'pepper/dialogs/info/PropertiesProxyPane'
], function(
    module, provide,
    PropertiesProxyPane) {
    /**
     * @class pepper/dialogs/info/tabs/PropertiesTab
     * @mixes pepper/dialogs/info/PropertiesProxyPane
     */
    return provide(module, [PropertiesProxyPane],
        /**
         * @lends pepper/dialogs/info/tabs/PropertiesTab#
         */
        {
            region: 'center',
            loadingHref: '/author/pepper/getPropertiesForm.html',
            title: 'Properties',
            refreshOnShow: true,

            /**
             * Builds the href property for a FormProxyPane based on the objects and template provided
             * @param {Object} config The configuration of the info dialog
             * @param {Array.<Object>} objects The objects
             * @param {Object} template The template of the object(s)
             */
            buildHref: function(config, objects, template) {
                if (!template || template.id === 'UI_multipleTemplate') {
                    if (objects && objects.length > 0) {
                        var href = this.loadingHref + '?objectIds=' + objects[0].objectId;
                        for (var i = 1; i < objects.length; i++) {
                            href = href + '&objectIds=' + objects[i].objectId;
                        }
                        return href;
                    }

                    return null;
                }

                return (template) ? template.formHref : null;
            }
        });
});

},
'pepper/dialogs/info/tabs/RenditionsTab':function(){
/**
 * Defines the Renditions tab for the Info/Properties dialog
 */
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'pepper/utilities/renderLocalDate',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'dijit/layout/_ContentPaneResizeMixin',
    'vodori/ui/Button',
    'pepper/dialogs/info/PropertiesGrid', 'pepper/dialogs/info/UploadRenditionDialog',
    'pepper/data/PepperServiceObjectStore',
    'pepper/services', 'pepper/utilities',
    'dojo/text!pepper/dialogs/info/tabs/templates/RenditionsTab.html'
], function (module, provide,
             lang, renderLocalDate,
             _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
             _ContentPaneResizeMixin,
             Button,
             PropertiesGrid, UploadRenditionDialog,
             PepperServiceObjectStore,
             services, utilities,
             template) {

    return provide(module.id, [ _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, _ContentPaneResizeMixin ],
        /**
         * @lends pepper/dialogs/info/tabs/RenditionsTab#
         * @mixes dijit/_WidgetBase
         * @mixes dijit/_TemplatedMixin
         * @mixes dijit/_WidgetsInTemplateMixin
         * @mixes dijit/layout/_ContentPaneResizeMixin
         */
        {
            templateString: template,
            renditionDialogClassName: 'renditionDialog',

            /**
             * @constructs
             * @mixes dijit/_WidgetBase
             * @mixes dijit/_TemplatedMixin
             * @mixes dijit/_WidgetsInTemplateMixin
             * @mixes dijit/layout/_ContentPaneResizeMixin',
             */
            constructor: function () {
                this.region = 'center';
                this.title = 'Renditions';
            },

            buildRendering: function () {
                this.inherited(arguments);
                this.containerNode = this.domNode; // For the _ResizeMixin
            },

            postCreate: function () {
                this.inherited(arguments);

                this.uploadButton.on('click', this.launchUploadDialog);

                var store = new PepperServiceObjectStore({
                    service: services.getRenditions,
                    identifier: 'fileName'
                });
                var columns = [
                    // Display the filename, and link if it's a thumbnail.
                    { label: 'File Name', field: 'fileName',
                        renderCell: function (object, fileName, td) {
                            var url = object.url;
                            if(url !== '') {
                                td.innerHTML = '<a href="' + url + '" target="_blank">' + fileName + '</a>';
                            }
                            else {
                                td.innerHTML = fileName;
                            }
                        }
                    },
                    // Display the format.  If the format is 'Upload' don't display.
                    { label: 'Format', field: 'format' },
                    // Display the date added.
                    { label:'Date Added', field:'dateAddedMillis', sortable:true,
                        renderCell: lang.hitch(this, 'renderLocalDate')
                    },
                    // Display 'Remove' button if canRemove, display 'Add rendition' if format is Upload
                    { label: 'Remove', field: 'canRemove',
                        renderCell: lang.hitch(this, function (object, canRemove, td) {
                            if (canRemove) {
                                var button = new Button({
                                    label: 'Remove',
                                    onClick: lang.hitch(this, function () {
                                        this._removeRendition(object);
                                    })
                                });
                                td.appendChild(button.domNode);
                            }
                        })
                    }
                ];

                this.grid = new PropertiesGrid({
                    store: store,
                    columns: columns

                }, this.grid);

                this.set('ready', false);
            },

            /**
             * Renders the date in the viewers local time.
             * @param object
             * @param dateAsInt
             * @param td
             */
            renderLocalDate:function (object, dateAsInt, td) {
                var lastModified = object.dateAdded;
                td.innerHTML = renderLocalDate(lastModified);
            },

            /**
             * Opens the dialog to upload a new rendition
             */
            launchUploadDialog: function () {
                var dialog = new UploadRenditionDialog({
                    objects: this.objects,
                    'class': this.renditionDialogClassName
                });
                dialog.on('cancel', this._uploadCompleteHandler);
                dialog.show();
            },

            _uploadCompleteHandler: function () {
                this.grid.refresh();
            },

            containsGrid: function () {
                return true;
            },

            /**
             * onClick handler for the remove button for a row in the grid.
             * @param rendition
             */
            _removeRendition: function (rendition) {
                var def = services.deleteRendition({
                    params: {
                        renditionVersionSeriesId: rendition.versionSeriesId,
                        objects: utilities.createPayload(this.objects)
                    }
                });
                def.then(lang.hitch(this, function () {
                    var queryObjects = utilities.createPayload(this.objects);
                    this.grid.set('query', { objects: queryObjects });
                }));
            },

            setObjects: function (objects) {
                if (!this.get('ready')) {
                    this.set('ready', true); // ready when we actually have some objects
                }

                this.objects = objects;

                if (objects[0] !== null && !objects[0].lockedByCurrentUser) {
                    this.uploadButton.set('disabled', true);
                }

                var queryObjects = utilities.createPayload(objects);
                this.grid.set('query', { objects: queryObjects });
            },

            _setReadyAttr: function (ready) {
                if (this.grid.store.setReady) {
                    this.grid.store.setReady(ready);
                }
                this.ready = ready;
            }
        });
});

},
'pepper/dialogs/info/UploadRenditionDialog':function(){
define([
    'require',
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'dojo/request/iframe',
    'pepper/ui/LazyDialog',
    'pepper/ui/handleNotification'
], function (require, module, provide, lang, iframe, LazyDialog, handleNotification) {
    /**
     * Dialog for uploading a rendition. Launched from the RenditionsTab in the info dialog.
     * Uses dojo/request/iframe to POST the file to the server.
     *
     * @class pepper/dialogs/info/UploadRenditionDialog
     * @mixes pepper/ui/LazyDialog
     */
    return provide(module.id, [ LazyDialog ],
        /**
         * @lends pepper/dialogs/info/UploadRenditionDialog#
         */
        {
            destroyOnHide: true,
            title: 'Add New Rendition',

            contentHref: require.toUrl('./templates/UploadRenditionDialog-content.html'),

            _buttonMapping: {
                'cancelButton': 'onCancel',
                'uploadButton': 'onUpload'
            },

            postCreate: function () {
                this.inherited(arguments);

                this.lazy(function () {
                    this.cancelButton.attr('style', 'display:inline');
                });

                // Load the form to upload
                var href = '/uploadRenditionForm.html?objectId=' + this.objects[0].objectId;
                this.pane.set('href', href);
            },

            /**
             * Submits the form to upload the rendition via a hidden iframe
             *
             * This is attached using lazyOn, we don't need to wrap its contents in a lazy block.
             */
            onUpload: function () {

                var file = this.realFileInput.domNode.files[0];

                //This traps the case when someone tries to click upload before a file is selected,
                // and throws up a notification.
                if (!file || file === '') {
                    handleNotification({
                        title: 'No File Selected',
                        message: 'Please select a file before attempting to upload a new rendition.',
                        type: 'modal',
                        buttons: [
                            {
                                label: 'Okay',
                                command: null
                            }
                        ]
                    })();
                } else {

                    // The upload function needs to know the expectedSize to ensure the whole things makes it
                    var size = file.size;

                    iframe.post(this.form.action, {
                        form: this.form.id,
                        handleAs: 'json',
                        // Neither dojo/io/iframe or dojo/request/iframe uses this, needed?
                        contentType: 'multipart/form-data',
                        data: {
                            objectId: this.objects[0].objectId,
                            PepperFilesize: size
                        }
                    }).then(lang.hitch(this, function () {
                            this.onCancel();
                        }));
                }
            }
        });
});

},
'pepper/ui/LazyDialog':function(){
define([
    'dojo/_base/declare',
    'vodori/ui/LazyDialog',
    './_QuarantineMixin'
], function (declare, LazyDialog, _QuarantineMixin) {

    return declare([LazyDialog, _QuarantineMixin], {
        /**
         * Appending a specific className to the container, so we know which
         * quarantine nodes contain popups.
         */
        constructor: function () {
            this.quarantineAreaClassNames += ' dialogContainer';
        }
    });
});

},
'vodori/ui/LazyDialog':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/promise/all',
    'dojo/dom-construct', 'dojo/query',
    'dijit/registry',
    'dojox/layout/ResizeHandle',
    'vodori/layout/_LazyAttachPoints',
    'vodori/ui/Dialog',
    'dojo/text!./templates/LazyDialog.html'
], function (module, provide,
             _,
             lang, all,
             domConstruct, query,
             registry,
             ResizeHandle,
             _LazyAttachPoints,
             Dialog,
             template) {

    return provide(module.id, [Dialog, _LazyAttachPoints], {
        templateString: template,

        /**
         *
         * @type {string}
         */
        contentHref: '',

        /**
         * List of methods to attach to the click event of a button
         *
         * Create a map of 'buttonAttachPoint' to 'methodName'
         *
         * @type {Object}
         */
        _buttonMappings: {},

        constructor: function () {
            if (this.lazyPanes) {
                this.lazyPanes.push('lazyContainerNode');
            } else {
                this.lazyPanes = ['lazyContainerNode'];
            }
        },

        postCreate: function () {
            this.inherited(arguments);
            this._attachButtonMappings();

            // Reset the value of containerNode so that resize handles get added properly;
            // lazyContainerNode is where we actually want _addResizeHandle() in vodori/ui/Dialog to
            // tack on a resizable div. Since this.containerNode is a hardcoded value in
            // _addResizeHandle and in the dijit/layout/_ContentPaneResizeMixin
            // _checkIfSingleChild() method on which it depends, we just override the
            // current containerNode value here.
            this.containerNode = this.lazyContainerNode.domNode;
        },

        /*
         * This is factored out into its own function so that on *RARE* occassions, it might get overwritten.
         */
        _attachButtonMappings: function () {
            _.forEach(this._buttonMappings, function (handler, attachPoint) {
                this.lazyOn(attachPoint, 'click', lang.hitch(this, handler));
                if (this._buttonMapHandler) {
                    this._buttonMapHandler(handler, attachPoint);
                }
            }, this);
        },

        /*
         * Because of the lazy nature of this dialog, the positioning and sizing of contents can get screwed up.
         * Thus, we reset the size and position once the dialog is being shown and the lazy points are ready!
         *
         * Similarly, call _addResizeHandle() again because it can only add the resize HTML fragment to
         * a node that is already in the DOM
         */
        show: function () {
            var fadeInDeferred = this.inherited(arguments);
            all([this.pointsReadyPromise, fadeInDeferred]).then(lang.hitch(this, function () {
                this.lazyContainerNode.resize();
                this._position();
                this._addResizeHandle();
            }));

            return fadeInDeferred;
        },

        _setHrefAttr: function (href) {
            this.lazyContainerNode.set('href', href);
        },

        _getHrefAttr: function (content) {
            return this.lazyContainerNode.get('href');
        },

        _setContentAttr: function (content) {
            this.lazyContainerNode.set('content', content);
        },

        _getContentAttr: function (content) {
            return this.lazyContainerNode.get('content');
        }
    });
});

},
'vodori/layout/_LazyAttachPoints':function(){
define([
    'lodash',
    'dojo/_base/declare', 'dojo/_base/lang', 'dojo/Stateful',
    'dojo/when', 'dojo/Deferred', 'dojo/DeferredList',
    'dojo/parser', 'dojo/query', 'dojo/dom-attr', 'dojo/on', 'dojo/aspect',
    '../util/_BehavioralAttachPointsBase',
    'vodori/layout/LazyPaneWrapper', 'vodori/layout/lazyPaneWrapper/ListenerRemoverKeys'
], function (
    _,
    declare, lang, Stateful,
    when, Deferred, DeferredList,
    parser, query, domAttr, on, aspect,
    _BehavioralAttachPointsBase,
    LazyPaneWrapper, ListenerRemoverKeys
    ) {
    /**
     * Provides a reasonably straightforward way to interact w/ attach points that are inside of
     * intermittently available content panes.
     *
     * To attach handlers use lazy*(attachPointName, usual args).
     *
     * To interact w/ widgets directly wrap your method's logic in when(T::pointsReadyPromise) and
     * be sure to wrap any out of thread interactions as well, in case the pane refreshes.
     *
     * Alternatively, you can simply watch T::pointsReady, which will be true when they're ready and
     * false when they're not.
     */
    return declare([Stateful, _BehavioralAttachPointsBase], {
        /**
         * Whether the points are ready. Feel free to watch this.
         *
         * @type {boolean}
         */
        pointsReady: false,

        /**
         * Resolves when all attach points are available. Resets whenever a pane unloads.
         *
         * @type {dojo.Deferred.promise}
         */
        pointsReadyPromise: null,

        /**
         * The data-dojo-attach-point value for the panes that we'll track lazily.
         *
         * @type {Array.<string>}
         */
        lazyPanes: null,

        /**
         * Constructor for the ContentPane wrapper that'll be injected. Override at will, but must
         * extend LazyPaneWrapper.
         *
         * @type {vodori.layout.LazyPaneWrapper}
         */
        PaneWrapperConstructor: LazyPaneWrapper,

        /**
         * The attr that denotes a dojo class.
         *
         * @type {string}
         * @const
         */
        DOJO_TYPE_ATTR: 'data-dojo-type',

        /**
         * The attr that denotes where to attach a widget or node.
         *
         * @type {string}
         * @const
         */
        DOJO_ATTACH_ATTR: 'data-dojo-attach-point',

        /**
         * A marker that prevents _BAPB from attaching our sub components.
         *
         * @type {string}
         * @const
         */
        LAZY_DATA_MARKER: 'data-vodori-laziness',

        /**
         * Prevent the dojo.parser from parsing our contents. Needed to control the lifecycle
         * properly.
         *
         * @type {boolean}
         */
        stopParser: true,

        /**
         * A hash of all the panes available to this widget.
         *
         * @type {Array.<vodori.layout.LazyPaneWrapper>}
         * @private
         */
        _lazyPanes: null,

        /**
         * Where we'll store the key for the pane that we'll be wrapping.
         *
         * @type {string}
         */
        _origConstructorKey: '',

        /**
         * A collection of all the points available in this module.
         */
        _lazyPoints: null,

        /**
         * Used to generate the promise notifying that all points are ready.
         *
         * @type {dojo.Deferred}
         */
        _pointsReady: null,

        /**
         * @type {(dojo.DeferredList|dojo.Deferred)}
         */
        _unloadedDefList: null,

        /**
         * Initialize all our objects.
         */
        constructor: function () {
            this.lazyPanes = this.lazyPanes || [];

            this._lazyPanes = this._lazyPanes || [];
            this._panes = [];
            this._lazyPoints = [];

            // Must be a quiet call, since _WidgetBase isn't ready for statefulness during
            // construction.
            this._resetPointsReadyDef(true);
        },

        /**
         * Save the constructor key that was set in our pane wrapper.
         */
        postMixInProperties: function () {
            this.inherited(arguments);

            this._origConstructorKey = this.PaneWrapperConstructor.prototype.ORIGINAL_CONSTRUCTOR_KEY;
        },

        /**
         * Let dijit define this.domNode, then begin w/ the fiddling.
         */
        buildRendering: function () {
            this.inherited(arguments);

            // Proxy points inside our template.
            this._proxyPoints(this.domNode);

            // Broken into a separate method to allow subclasses a way to intercept.
            this._parseTemplate();
        },

        /**
         * Executes the callback once the points are ready. Context is fixed to the optional context
         * setting.
         *
         * @param {(Function|string)} fn Either a function or a string that's a method on context.
         * @param {T} [context=this] Context to call the function in.
         * @return {dojo.promise.Promise}
         */
        lazy: function (fn, context) {
            context = context || this;

            return when(this.pointsReadyPromise, lang.hitch(context, fn));
        },

        /**
         * Listen to an attachpoint whenever it's ready.
         *
         * @param {string} name The name of the attach point that you wish to listen to.
         * @param {string} event An on compatible event description.
         * @param {Function} handler What to do when the event happens.
         * @return {{remove: Function}} A remover for the handler. The remove is also lazy.
         */
        lazyOn: function (name, event, handler) {
            return this._lazyListen('on', arguments);
        },

        /**
         * Register w/ an attachpoint once it's ready.
         *
         * @param {string} name The attachpoint to register w/
         * @param {...*} args The remaining args needed by the register method.
         * @return {{remove: Function}} A handle that will lazily remove the the register.
         */
        lazyRegister: function (name, args) {
            return this._lazyListen('register', arguments);
        },

        /**
         * Watch a property once it's widget is ready.
         *
         * @param {string} name The attachpoint that has the prop
         * @param {string} prop The prop to watch.
         * @param {Function} notify The function to call when the prop changes.
         */
        lazyWatch: function (name, prop, notify) {
            return this._lazyListen('watch', arguments);
        },

        /**
         * Register a lazy pane.
         *
         * @param {string} wrappedId A *unique* identifier for the ContentPane that was wrapped.
         * @param {vodori.layout.LazyPaneWrapper} pane The lazy pane.
         * @return {{remove: Function}}
         */
        registerPane: function (wrappedId, pane) {
            this._lazyPanes.push(pane);

            // I tried to use a watch for this, but it wasn't firing the change the way I expected.
            // Watch for changes to points
            var handle = on(pane, 'pointsChange', lang.hitch(this, '_pointsChange', wrappedId, pane));
            // Simulate the first change.
            when(pane.pointsReady, lang.hitch(this, '_pointsChange', wrappedId, pane));

            // If any pane unloads, then we need to refresh the deferred.
            this.own(
                handle,
                on(pane, 'unload', lang.hitch(this, '_handleUnload'))
            );

            var remove = lang.hitch(this.lazyPanes, function (key) {
                handle.remove();
                delete this[key];
            }, wrappedId);

            return {
                'unregister': remove,
                'remove': remove
            };
        },

        /**
         * Create listener of any type.
         *
         * @param {string} type The sort of listener we're dealing with
         * @param {Arguments} args The arguments object from the listener.
         * @return {Object.<Function>} An object w/ the appropriate remover.
         * @private
         */
        _lazyListen: function (type, args) {
            // Convert it to an Array.
            args = _.toArray(args);

            // The point we'll be listening to.
            var targetName = args.shift(),
                handleDef = new Deferred(),
                handle = {},
                removerKey = ListenerRemoverKeys[type],
                found = null;

            // Wait for the listener to be attached before trying to remove it.
            handle[removerKey] = function () {
                when(handleDef, function (realHandle) {
                    realHandle[removerKey]();
                });
            };

            // Wait for all the panes to load up before attaching to any of them.
            when(this._pointsReady, lang.hitch(this, function () {
                found = _.find(this._lazyPoints, function (point) {
                    return point.name === targetName;
                });

                if (!found) {
                    throw new Error('Couldn\'t find attach point for ' + targetName);
                }

                handleDef.resolve(found.wrapper[type].apply(found.wrapper, args));
            }));

            return handle;
        },

        /**
         * Called whenever a pane's points are changed. Makes sure our list stays up to date.
         *
         * @param {string} paneId
         * @param {vodori.layout.LazyPane} pane
         * @private
         */
        _pointsChange: function (paneId, pane) {
            var current = pane.get('points');

            // Remove the old points from the pane and add the new ones..
            this._lazyPoints = _.filter(this._lazyPoints,function (point) {
                if (point.src === paneId) {
                    delete this[point.name];
                    return false;
                }

                return true;
            }, this).concat(
                    _.map(current, function (point) {
                        this[point.name] = point.widget || point.node;
                        return point;
                    }, this)
                );
        },

        /**
         * Switch the constructor's path to our pane constructor's.
         *
         * @param {Element} node
         * @return {Element}
         * @private
         */
        _swapType: function (node) {
            var get = lang.hitch(domAttr, 'get', node),
                set = lang.hitch(domAttr, 'set', node);

            set(this._origConstructorKey, get(this.DOJO_TYPE_ATTR));
            set(this.DOJO_TYPE_ATTR, this.PaneWrapperConstructor.prototype.declaredClass);
            query('[' + this.DOJO_ATTACH_ATTR + ']', node).forEach(this._markLazy, this);

            return node;
        },

        /**
         * Let _BAPB do the heavy lifting, then register any lazy panes we encounter.
         *
         * @param {Element} node
         * @param {T} target
         * @return {Array.<Object>}
         * @private
         */
        _addAttachPoint: function (node, target) {
            var attachments = this.inherited(arguments);

            // They're all the same attachment, but at different positions.
            var attachment = attachments[0],
                widget = attachment.widget;

            if (!!widget && widget.isInstanceOf(this.PaneWrapperConstructor)) {
                this.registerPane(widget.getWrappedId(), widget);
            }

            return attachments;
        },

        /**
         * Finds and annotates components that we'll be attaching.
         *
         * @param {Element} rootNode The node that we'll search in.
         * @private
         */
        _proxyPoints: function (rootNode) {
            // We list out all the lazy panes as a query selector. This is slightly faster than
            // traversing a list of all possible matches since query often runs in C++.
            var paneSearch = [
                '[', this.DOJO_ATTACH_ATTR, '="',
                this.lazyPanes.join('"],[' + this.DOJO_ATTACH_ATTR + '="'),
                '"]'
            ].join('');

            // Switch out the type for our wrapper.
            query(paneSearch, rootNode).forEach(this._swapType, this);

            // Mark off our attach points, but ignore lazy panes, so they can handle attaching for
            // us.
            query(
                '[' + this.DOJO_ATTACH_ATTR + ']:not([' + this.LAZY_DATA_MARKER + '="true"])',
                rootNode
            ).forEach(this._markPoint, this);
        },

        /**
         * Resets the client programmer notifications.
         *
         * @param {boolean} [quiet=false]
         * @return {dojo.Deferred}
         * @private
         */
        _resetPointsReadyDef: function (quiet) {
            var ready = this._pointsReady = new Deferred();

            this.pointsReadyPromise = ready.promise;

            if (!quiet) {
                this.set('pointsReady', false);
            }

            when(ready, lang.hitch(this, function () {
                this.set('pointsReady', true);
            }));

            return ready;
        },


        _handleUnload: function () {
            if (!!this._unloadedDefList) {
                this._unloadedDefList.cancel();
            }

            var ready = this._pointsReady;

            if (ready.isResolved()) {
                ready = this._resetPointsReadyDef();
            }

            // It doesn't actually matter which pane unloaded, wince we're waiting for all of them.
            this._unloadedDefList = new DeferredList(this._collectPointsPromises());

            this._unloadedDefList.then(lang.hitch(ready, 'resolve', this));

            return ready;
        },

        /**
         * Hooks up the load time attach points.
         *
         * @protected
         */
        _parseTemplate: function () {
            var rootNode = this.domNode;
            // Once the parser does its thing.
            when(parser.parse(rootNode, {template:false}), lang.hitch(this, function () {
                // Connect our points.
                this._makeAttachPoints(rootNode);

                (new DeferredList(this._collectPointsPromises())).then(
                    lang.hitch(this._pointsReady, 'resolve')
                );
            }));
        },

        /**
         * Adds a data attr that notifies us not to attach these directly.
         *
         * @param {Element} node
         * @return {Element}
         * @private
         */
        _markLazy: function (node) {
            domAttr.set(node, this.LAZY_DATA_MARKER, 'true');
            return node;
        },

        /**
         * Broken out to allow child classes to extend the list.
         *
         * @return {Array.<dojo.promise.Promise>}
         * @protected
         */
        _collectPointsPromises: function () {
            return _.pluck(this._lazyPanes, 'pointsReady');
        }

    });
});

},
'dojo/DeferredList':function(){
define(["./_base/kernel", "./_base/Deferred", "./_base/array"], function(dojo, Deferred, darray){
	// module:
	//		dojo/DeferredList


dojo.DeferredList = function(/*Array*/ list, /*Boolean?*/ fireOnOneCallback, /*Boolean?*/ fireOnOneErrback, /*Boolean?*/ consumeErrors, /*Function?*/ canceller){
	// summary:
	//		Deprecated, use dojo/promise/all instead.
	//		Provides event handling for a group of Deferred objects.
	// description:
	//		DeferredList takes an array of existing deferreds and returns a new deferred of its own
	//		this new deferred will typically have its callback fired when all of the deferreds in
	//		the given list have fired their own deferreds.  The parameters `fireOnOneCallback` and
	//		fireOnOneErrback, will fire before all the deferreds as appropriate
	// list:
	//		The list of deferreds to be synchronizied with this DeferredList
	// fireOnOneCallback:
	//		Will cause the DeferredLists callback to be fired as soon as any
	//		of the deferreds in its list have been fired instead of waiting until
	//		the entire list has finished
	// fireonOneErrback:
	//		Will cause the errback to fire upon any of the deferreds errback
	// canceller:
	//		A deferred canceller function, see dojo.Deferred
	var resultList = [];
	Deferred.call(this);
	var self = this;
	if(list.length === 0 && !fireOnOneCallback){
		this.resolve([0, []]);
	}
	var finished = 0;
	darray.forEach(list, function(item, i){
		item.then(function(result){
			if(fireOnOneCallback){
				self.resolve([i, result]);
			}else{
				addResult(true, result);
			}
		},function(error){
			if(fireOnOneErrback){
				self.reject(error);
			}else{
				addResult(false, error);
			}
			if(consumeErrors){
				return null;
			}
			throw error;
		});
		function addResult(succeeded, result){
			resultList[i] = [succeeded, result];
			finished++;
			if(finished === list.length){
				self.resolve(resultList);
			}

		}
	});
};
dojo.DeferredList.prototype = new Deferred();

dojo.DeferredList.prototype.gatherResults = function(deferredList){
	// summary:
	//		Gathers the results of the deferreds for packaging
	//		as the parameters to the Deferred Lists' callback
	// deferredList: dojo/DeferredList
	//		The deferred list from which this function gathers results.
	// returns: dojo/DeferredList
	//		The newly created deferred list which packs results as
	//		parameters to its callback.

	var d = new dojo.DeferredList(deferredList, false, true, false);
	d.addCallback(function(results){
		var ret = [];
		darray.forEach(results, function(result){
			ret.push(result[1]);
		});
		return ret;
	});
	return d;
};

return dojo.DeferredList;
});

},
'vodori/util/_BehavioralAttachPointsBase':function(){
/**
 * Provides the same functionality as `_TemplatedMixin`, but for widgets that do
 * not have a template.
 * Use `_BehavioralNestedWidgets` if you want attach points that are widgets.
 *
 * @module vodori/util/_BehavioralAttachPointsBase
 */
define([
    'require',
    'lodash',
    'dojo/_base/declare', 'dojo/_base/lang', 'dojo/query',
    'dojo/dom-attr', 'dojo/dom-class',
    'dijit/registry'
], function (require, _, declare, lang, query, domAttr, domClass, registry) {

    /**
     * @lends module:vodori/util/_BehavioralAttachPointsBase#
     */
    var _BehavioralAttachPointsBase = {
        /**
         * @type {string}
         * @const
         */
        ATTACH_POINT_ATTR: 'data-dojo-attach-point',

        /**
         * String that replaces commas in ATTACH_POINT_ATTR's value.
         *
         * @type {string}
         * @const
         */
        COMMA_REPLACER: '__44__',

        /**
         * This separates ATTACH_POINT_ATTR and the attachpoint name in the
         * className prop of the node we'll be attaching.
         *
         * @type {string}
         * @const
         */
        SEPARATOR: '__BEHAVIORAL_ATTACH_POINT_SEPARATOR__',

        /**
         * Will match one of our generated CSS classes.
         *
         * @type {RegExp}
         */
        _classNamePattern: null,

        constructor: function () {
            // This happens twice, since we might not have a postMixInProperties call, but must
            // always have the pattern compiled.
            this._classNamePattern = new RegExp(this.ATTACH_POINT_ATTR + this.SEPARATOR);
        },

        postMixInProperties: function () {
            this.inherited(arguments);
            this._classNamePattern = new RegExp(this.ATTACH_POINT_ATTR + this.SEPARATOR);
        },

        /**
         * NOTE: _LazyAttachPoints uses the return value, so refactor both if either needs it.
         *
         * @param {Element} rootNode
         * @return {Array.<string>}
         * @protected
         */
        _markAttachPoints: function (rootNode) {
            return query('[' + this.ATTACH_POINT_ATTR + ']', rootNode).map(this._markPoint, this);
        },

        _markPoint: function (node) {
            var attachName = domAttr.get(node, this.ATTACH_POINT_ATTR);
            domClass.add(node, this._attachNameToCssClass(attachName));

            domAttr.remove(node, this.ATTACH_POINT_ATTR);

            return attachName;
        },

        /**
         *
         * @param {Element} rootNode
         * @return {dojo._base.NodeList}
         * @protected
         */
        _findPointNodesAfterParse: function (rootNode) {
            return query(
                '[class*="' + this.ATTACH_POINT_ATTR + '"]',
                rootNode
            );
        },

        /**
         * @param {Element} rootNode
         * @param {T} [target=this]
         * @protected
         */
        _makeAttachPoints: function (rootNode, target) {
            // We've prepended all our injected class names w/ the attr key.
            return this._findPointNodesAfterParse(rootNode).map(function (node) {
                return this._addAttachPoint(node, target || this);
            }, this);
        },

        /**
         * Do the actual attachment.
         *
         * @param {Element} node
         * @param {T} [target=this]
         * @private
         */
        _addAttachPoint: function (node, target) {
            var attachNames = this._extractAttachNames(node);

            var widget = registry.byNode(node);

            return _.map(attachNames, function (name) {
                (target || this)[name] = widget || node;
                return {name: name, node: node, widget: widget, src: this.id};
            }, this);
        },

        _attachNameToCssClass: function (name) {

            return this.ATTACH_POINT_ATTR +
                this.SEPARATOR +
                name.split(/\s{0,},\s{0,}/).join(this.COMMA_REPLACER);
        },

        _extractAttachNames: function (node) {
            var className = domAttr.get(node, 'class');
            var classes = lang.trim(className).split(' ');

            var hashed = _.find(classes, function (className) {
                return this._classNamePattern.test(className);
            }, this);

            // Clean up the weird class name.
            domClass.remove(node, hashed);

            return hashed.split(this.SEPARATOR)[1].split(this.COMMA_REPLACER);
        }

    };
    return declare(null, _BehavioralAttachPointsBase);
});

},
'vodori/layout/LazyPaneWrapper':function(){
define([
    'require', 'module', 'vodori/provide',
    'lodash',
    'dojo/_base/declare', 'dojo/_base/lang', 'dojo/when', 'dojo/Deferred',
    'dojo/parser', 'dojo/on', 'dojo/dom-attr', 'dojo/Evented', 'dojo/Stateful',
    'dijit/_WidgetBase', 'dijit/registry',
    'put-selector/put',
    'vodori/util/_BehavioralAttachPointsBase',
    './lazyPaneWrapper/Point'
], function (
    require, module, provide,
    _,
    declare, lang, when, Deferred,
    parser, on, domAttr, Evented, Stateful,
    _WidgetBase, registry,
    put,
    _BehavioralAttachPointsBase,
    Point
) {

    /**
     * Keeps track of its internal attach points, so that it can register them w/ a containing
     * widget.
     */
    return provide(module.id, [
        _WidgetBase,
        Stateful,
        Evented,
        _BehavioralAttachPointsBase
    ], {
        /**
         * Resolves when all attach points inside this pane are ready for interaction.
         *
         * @type {dojo.Deferred.promise}
         */
        pointsReady: null,

        /**
         * The constructor that we'll inject inside our self.
         *
         * @type {string}
         * @const
         */
        ORIGINAL_CONSTRUCTOR_KEY: 'data-original-dojo-type',

        /**
         * Marker for our own attach points.
         *
         * @type {string}
         * @const
         */
        LAZY_DATA_MARKER: 'data-vodori-laziness',

        /**
         * The attach point for this will have this string appended to it.
         *
         * @type {string}
         * @const
         */
        POST_FIX: 'LazyPane',

        /**
         * Prevent dojo/parser from parsing our contents too soon.
         *
         * @type {boolean}
         */
        stopParser: true,

        /**
         * Used to remove the attach point marker from transported CSS class. Compiling once, since
         * we don't want ot tie ourselves to a hardcoded separator.
         *
         * @type {RegExp}
         * @const
         */
        MARKED_CLASS_REGEX: new RegExp(
            // The space is optional since the marker could be the only CSS class. The separator
            // *must* be preceded by the attach point prefix, but the exact string is not really
            // relevant.
            '\\s*([^\\s]+' +
                // We'll use the separator from _BAPB.
                _BehavioralAttachPointsBase.prototype.SEPARATOR +
                // The attachpoint marker must have name associated, but we don't care what that name is.
                '[^\\s]+)\\s*'
        ),

        /**
         * Collection of the "points" we found.
         *
         * @type {Array.<{name: string, node: Element, widget: dijit._WidgetBase}>}
         */
        _points: null,

        /**
         * Interact w/ the promise not this.
         *
         * @private
         * @type {dojo.Deferred}
         */
        _pointsReadyDef: null,

        /**
         * Properties that LazyPane needs to set on the swallowed pane. Very important this is not
         * a shared reference amongst the panes, so lang.mixin({}, T::_props) whenever used.
         *
         * @private
         * @type {Object.<*>}
         */
        _props: {
            parseOnLoad: false
        },

        /**
         * The pane that we're proxying interaction with.
         *
         * @type {dijit.layout.ContentPane}
         */
        _wrapped: null,

        constructor: function () {
            this.points = [];
            this._points = [];
            this._initDef();
        },

        /**
         * Wrap our contents in an instance of ORIGINAL_CONSTRUCTOR_KEY and make sure events fire
         * as needed.
         */
        buildRendering: function () {
            this.inherited(arguments);

            var innerHtml = this.domNode.innerHTML;
            this.srcNodeRef.innerHTML = '';

            var props = lang.mixin({}, this._props, this.params);
            delete props[this.ORIGINAL_CONSTRUCTOR_KEY];

            // We need the setter to be called or our events won't fire, so to not waste an
            // additional set('content'), hide it, then call the setter.
            var content = lang.isString(props.content) ? props.content : innerHtml;
            delete props.content;

            var mid = this._toMid(this[this.ORIGINAL_CONSTRUCTOR_KEY]);
            var Ctor = require(mid);
            //noinspection JSValidateTypes
            var wrapped = this._wrapped = new Ctor(props, put(this.domNode, 'div'));

            wrapped.set('_lazyPointsReady', this._pointsReady);

            this.own(on(wrapped, 'load', lang.hitch(this, '_loadHandler')));
            this.own(on(wrapped, 'unload', lang.hitch(this, '_unloadHandler')));

            wrapped.startup();

            this._addExtraMarkings();

            // If the pane has an href, that wins. Otherwise, we set the content, since I *need* the
            // load event.
            if (!lang.isString(props.href)) {
                wrapped.set('content', content);
            }
        },

        /**
         * Get's the id of the ContentPane we wrap.
         *
         * @return {string}
         */
        getWrappedId: function () {
            return this._wrapped.get('id');
        },

        /**
         * Called whenever the pane is finished loading.
         *
         * @private
         */
        _loadHandler: function () {
            var paneNode = this._wrapped.domNode;

            this.emit('beforeLoad', {
                pane: paneNode,
                ready: this.pointsReady
            });

            // Annotate the attach points.
            //noinspection JSUnresolvedFunction
            this._markAttachPoints(paneNode);

            when(parser.parse(paneNode, {template:false}), lang.hitch(this, '_afterParse'));
        },

        /**
         * Whenever the pane unloads we need to reset the deferred.
         *
         * @private
         */
        _unloadHandler: function () {
            this._initDef();
            this.emit('unload', {
                pane: this._wrapped,
                ready: this.pointsReady
            });
        },

        /**
         * Whenever the pane's been parsed again...
         *
         * @private
         */
        _afterParse: function () {
            //noinspection JSUnresolvedFunction
            this._updatePoints(this._findPointNodesAfterParse(this._wrapped.domNode));
            this.emit('load', {
                pane: this._wrapped
            });
        },

        /**
         * Make sure we have all our points broken out.
         *
         * @param {dojo.NodeList} points
         * @private
         */
        _updatePoints: function (points) {
            // We must iterate over all points to support multi-attach.
            var namedPoints = [];
            _.forEach(points, function (point) {
                var names = this._extractAttachNames(point);
                var widget = registry.byNode(point);
                namedPoints.push.apply(namedPoints, _.map(names, function (name) {
                    // Added the src field, so _LAP knows which points it can ignore.
                    return {name: name, node: point, widget: widget, src: this._wrapped.id};
                }, this));
            }, this);

            this._setPoints(namedPoints);

            this._pointsReadyDef.resolve(namedPoints);

            return this;
        },

        /**
         * Converts a dojo type to an MID. This can go away when 2.0 comes out.
         *
         * @param {string} name
         * @return {string}
         * @private
         */
        _toMid: function (name) {
            return name.split('.').join('/');
        },

        /**
         * Reinitialize the deferred and promise.
         *
         * @private
         */
        _initDef: function () {
            this._pointsReadyDef = new Deferred();
            this.pointsReady = this._pointsReadyDef.promise;
        },
        /**
         * Make sure that we're name the same thing as the wrapped pane, except w/ the POST_FIX.
         *
         * @return {T}
         * @private
         */
        _addExtraMarkings: function () {
            var classNames = domAttr.get(this.domNode, 'class');

            classNames = classNames.replace(this.MARKED_CLASS_REGEX, '$1' + this.POST_FIX);

            domAttr.set(this.domNode, 'class', classNames);

            this['class'] = classNames;
            return this;
        },

        /**
         * Getter for the wrapped pane.
         *
         * @return {dijit.layout.ContentPane}
         * @private
         */
        _getPaneAttr: function () {
            return this._wrapped;
        },

        /**
         * There's a getter, so defining a setter.
         *
         * @private
         */
        _setPaneAttr: function () {
            console.error('Setting pane is not supported.');
        },

        /**
         * Gets the points associated w/ this.
         *
         * @return {Array.<Object>}
         * @private
         */
        _getPointsAttr: function () {
            return this._points;
        },

        _setPoints: function (points) {
            var old = this._points;

            // WARNING: I'm using the closured old for some in-place manipulation.
            var current = _.map(points, function (point) {
                var limit = old.length,
                    found = false,
                    comp = null;

                // We're walking through the queue, but it might change size.
                while (--limit >= 0) {
                    comp = old.pop();

                    if (point.name === comp.name) {
                        found = true;
                        point.wrapper = comp.wrapper;
                        point.wrapper.attach(point.node, point.widget);
                        break;
                    }

                    // If we don't find it then put it back.
                    old.unshift(comp);
                }

                if (!found) {
                    point.wrapper = new Point(point.name, point.node, point.widget);
                }

                return point;
            });

            // Clean up any no longer relevant points.
            _.forEach(old, function (point) {
                point.wrapper.destroy();
            });

            this._points = current;

            this.emit('pointsChange', {
                old: old,
                current: current
            });

            this.set('points', current);

            return this;
        },

        /**
         * Probably a bad idea to expose this as a setter, but I want this to be a watch. This
         * probably should not be called by others, but I want points to be watchable.
         *
         * @param {Array.<Object>} points
         * @return {T}
         * @private
         */
        _setPointsAttr: function (points) {
            this.points = points;
        }
    });
});

},
'vodori/layout/lazyPaneWrapper/Point':function(){
/**
 * Models an attach point. Handles GC and abstracting attachments. Designed
 * specifically for _LazyAttachPoints.
 *
 * @module vodori/layout/lazyPaneWrapper/Point
 */
define([
    'lodash',
    'dojo/_base/declare', 'dojo/_base/lang',
    'dijit/registry',
    './Listener'
], function (_, declare, lang, registry, Listener) {
    // Used to convert arguments to an Array.
    var aSlice = Array.prototype.slice;

    /**
     * @lends module:vodori/layout/lazyPaneWrapper/Point#
     */
    var _class = {
        /**
         * The name of the attach point.
         *
         * @type {string}
         */
        name: '',

        /**
         * The element where the attachment will be made.
         *
         * @type {Element}
         * @protected
         */
        _domNode: null,

        /**
         * A collection of listeners attached to this point.
         *
         * @type {Array.<vodori/layout/_lazyAttachPoints/Listener>}
         */
        _listeners: null,

        /**
         * If we're associated w/ a widget, then we'll figure out the right way
         * to add an on handler.
         *
         * @type {dijit/_WidgetBase}
         * @protected
         */
        _widget: null,

        /*
         * @see: T::attach
         */
        constructor: function (name, domNode, widget) {
            // We store everything we need to listen here.
            this._listeners = [];
            this.attach(domNode, widget);
        },

        // Proxied listeners that reattach automatically.

        /**
         * @param {string} name
         * @param {Function} fn
         * @return {{remove: Function}}
         */
        on: function (name, fn) {
            return this._makeListener(this._widget || this._domNode, 'on', arguments);
        },

        /**
         * @param {string} name
         * @param {Function} fn
         * @return {{remove: Function}}
         */
        watch: function (name, fn) {
            if (!this._widget) {
                throw new Error(
                    'Tried to watch a domNode; might be a bad attach-point'
                );
            }
            return this._makeListener(this._widget, 'watch', arguments);
        },

        /**
         * @param {...*} args This could be anything.
         * @return {{remove: Function}}
         */
        register: function (args) {
            if (!this._widget) {
                throw new Error(
                    'Tried to register w/ a domNode; may be a bad attach-point'
                );
            }

            var listener = new Listener(this._widget, 'register', arguments);
            this._listeners.push(listener);
            return listener.remover;
        },

        /**
         * Attaches the point to a place and refreshes any listeners associated.
         *
         * @param {Element} domNode
         * @param {dijit._WidgetBase} [widget=null] If unset will attempt to get the widget from
         * domNode.
         */
        attach: function (domNode, widget) {
            this._domNode = domNode;
            // Try to get any associated widgets.
            widget = this._widget = widget || registry.byNode(domNode) || null;

            _.forEach(this._listeners, function (listener) {
                listener.reattach(widget || domNode);
            }, this);
        },

        /**
         * Cleanup stale references.
         */
        detach: function () {
            // Release bad references.
            this._widget = this._domNode = null;

            _.forEach(this._listeners, function (listener) {
                listener.detach();
            }, this);
        },

        /**
         * Prevent the listeners from leaking memory.
         */
        destroy: function () {
            this.detach();
            this._listeners = null;
        },

        /**
         * Creates a listener of any type.
         *
         * @param {Element|dijit._WidgetBase} target
         * @param {string} type The type of listener to apply.
         * @param {Arguments} args All other arguments.
         * @return {Object.<Function>} An appropriately named remover function.
         * @private
         */
        _makeListener: function (target, type, args) {
            args = aSlice.call(args, 0);

            var listener = new Listener(target, type, args);
            this._listeners.push(listener);
            return listener.remover;
        }
    };

    return declare(null, _class);
});

},
'vodori/layout/lazyPaneWrapper/Listener':function(){
define([
    'dojo/_base/declare', 'dojo/_base/lang', 'dojo/aspect', 'dojo/on',
    './ListenerRemoverKeys'
], function (declare, lang, aspect, on, ListenerRemoverKeys) {

    // If the listener is an on, then we do special things.
    var ON = 'on';

    //noinspection JSCommentMatchesSignature
    return declare(null, {
        /**
         * The object that has an appropriately named remover function.
         *
         * @type {Object.<Function>}
         */
        remover: null,

        /**
         * The method to listen with on the attach point.
         *
         * @type {string}
         */
        _methodName: '',

        /**
         * Keep track of arguments across refreshes.
         *
         * @type {*}
         */
        _args: null,

        /**
         * We aspect the original remover, so that we can destroy ourself in a simple way.
         *
         * @type {{remove: Function}}
         */
        _afterHandle: null,

        /**
         * Create a new event listener.
         *
         * @param {Element|dijit._WidgetBase} target
         * @param {string} method
         * @param {*} args
         * @return {T}
         */
        constructor: function (target, methodName, args) {
            this.remover = {};

            this._attach(target, methodName, args);

            this._methodName = methodName;
            this._args = args;

            return this;
        },

        /**
         * Reattach w/ the same specs as the previous handler.
         *
         * @param {Element|dijit._WidgetBase} target
         * @return {Object.<Function>} An object w/ the method needed to remove
         *         the handler.
         */
        reattach: function (target) {
            this._attach(target, this._methodName, this._args);
            return this.remover;
        },

        /**
         * Detach an exisiting handler.
         */
        detach: function () {
            this.remover[ListenerRemoverKeys[this._methodName]]();
            this._afterHandle.remove();
        },

        /**
         * Attach an event.
         *
         * @param {Element|dijit._WidgetBase} target
         * @param {string} methodName
         * @param {*} args
         * @private
         */
        _attach: function (target, methodName, args) {
            // Set `on` to use dojo/on if it's not a prop of the target.
            var method = methodName === ON && !(ON in target) ?
                lang.partial(on, target) :
                lang.hitch(target, methodName);

            var removerKey = ListenerRemoverKeys[methodName];

            var remover = method.apply(null, args);

            this._afterHandle = aspect.after(
                remover,
                removerKey,
                lang.hitch(this, 'destroy')
            );

            // Cache the remover in an object of the same signature.
            this.remover[removerKey] = remover[removerKey];
        },

        /**
         * Cleanup up any dangling handlers.
         *
         * @return {T}
         */
        destroy: function () {
            this.detach();

            return this;
        }
    });
});

},
'vodori/layout/lazyPaneWrapper/ListenerRemoverKeys':function(){
define(['../../util/Enum'], function (Enum) {
    /**
     * Defines the keys needed to remove a handler of a given type.
     */
    return new Enum(
        {'on': 'handle'},
        {'watch': 'remove'},
        {'register': 'remove'}
    );
});
},
'pepper/dialogs/info/tabs/VersionsTab':function(){
/**
 * Versions tab for the info dialog.
 */
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/aspect',
    'pepper/utilities/renderLocalDate',
    'pepper/commands/actions/open', 'pepper/data/PepperServiceObjectStore', 'pepper/services',
    'pepper/dialogs/info/PropertiesGrid',
    'pepper/dialogs/info/tabs/VersionsContextMenu', 'pepper/ui/Wayfinder'
], function (module, provide,
             _,
             lang,
             aspect,
             renderLocalDate,
             open, PepperServiceObjectStore, services,
             PropertiesGrid,
             VersionsContextMenu, Wayfinder
    ) {
    return provide(module, [ PropertiesGrid ], {

        _wayfinders: null,

        constructor: function () {
            this._wayfinders = [];
            this.columns = [
                { label:'File Name', field:'filename' },
                { label:'Version Label', field:'versionLabel',
                    renderCell:function (object, lifecycle, td, options) {
                        td.innerHTML = object.lifecycle.currentVersion;
                    }
                },
                { label:'Versions/State', field:'lifecycle',
                    renderCell: lang.hitch(this, function (object, lifecycle, td, options) {
                        /*jshint -W031 */
                        var wayfinder = new Wayfinder({
                            objectId: object.objectId,
                            mini:true
                        }, td);
                        this._wayfinders.push(wayfinder);
                    })
                },
                { label:'Current State', field: 'currentState'},
                { label:'Latest State', field:'latestState' },
                { label:'Reached On', field:'dateStateWasReached',
                    renderCell:lang.hitch(this, 'renderLocalDate')
                },
                { label:'Version Created', field:'dateVersionWasCreated',
                    renderCell:lang.hitch(this, 'renderLocalDate')
                }
            ];

            this.store = new PepperServiceObjectStore({
                service:services.getVersionHistory,
                identifier:'objectId',
                sortable:true,
                paginated:true
            });

            this.region = 'center';
            this.title = 'Versions';
        },

        postCreate:function () {
            this.inherited(arguments);

            // Create a custom context menu for the grid to open past versions
            this.contextMenu = new VersionsContextMenu({
                targetNodeIds:[this.domNode],
                grid:this      // Keep a reference to the grid
            });
            this.contextMenu.startup();

            // Add the selected items from the versions grid to the arguments passed to the context menu open method
            this.own(aspect.before(this.contextMenu, '_openMyself', lang.hitch(this, function(args) {
                return [lang.mixin(args, {
                    selectedItems: this.get('selectedItems')
                })];
            })));

        },

        renderLocalDate:function (object, date, td) {
            td.innerHTML = renderLocalDate(date);
        },

        destroy: function() {
            if(this._wayfinders) {
                _.forEach(this._wayfinders, function(wayfinder) {
                    wayfinder.destroyRecursive();
                });
            }
            this.inherited(arguments);
        }
    });
});

},
'pepper/dialogs/info/tabs/VersionsContextMenu':function(){
define([
    'module', 'vodori/provide',
    'pepper/commands/actions/open',
    'pepper/ui/Menu'
], function (module, provide, open, Menu) {

    /**
     * A custom context menu for the versions tab that will let users open past versions of documents
     */
    return provide(module.id, [ Menu ], {
        currentURL: null,   // The URL of the grid row the context menu is opened from
        grid: null,         // A reference to the grid this menu is tied to

        constructor: function () {
            this.items = [
                {label: 'Open', command: open},
                {label: 'Open in a new window', command: open, concatDefaultArgs: true, args: [true]}
            ];
            this.defaultArgsFunction = function () {
                return {
                    authorUrl: this.currentURL
                };
            };
        },

        /**
         * Overridden to grab the URL of the row the context menu was opened on
         *
         * @param args object containing information about what was clicked
         * @private
         */
        _openMyself: function (/* Object */ args) {
            var selectedItems = args.selectedItems;

            // If there's one selected item, open the context menu
            if (selectedItems && selectedItems.length === 1) {
                var row = this.grid.row(selectedItems[0]);
                if (row) {
                    this.currentURL = row.data.url;
                } else {
                    return;
                }
            } else {
                // If right clicking not on a grid row, don't open the menu
                return;
            }

            this.inherited(arguments);
        }
    });
});

},
'pepper/ui/Wayfinder':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang', 'dojo/when', 'dojo/Deferred',
    'dojo/dom-attr', 'dojo/dom-class', 'dojo/dom-construct', 'dojo/dom-style',
    'dojo/query',
    'dijit/_WidgetBase',
    'vodori/util/string/capitalize',
    'pepper/enums/wayfinderEnum',
    'pepper/data/PostDescriptorStore'
], function (provide, module,
             _,
             lang, when, Deferred,
             domAttr, domClass, domConstruct, domStyle,
             query,
             _WidgetBase,
             capitalize,
             wayfinderEnum,
             postDescriptorStore) {

    /**
     * This is the little Wayfinder widget that is displayed all over Pepper. It gives
     * an at-a-glance indication of the state of the document; whether the document is in a
     * workflow or not, if there are multiple versions of the document being pushed through
     * the lifecycle, and which state is currently being viewed.
     */
    return provide(module, [_WidgetBase], {

        _initializer: null, // A series of callbacks to init the widget

        objectId: null, // the objectId to display lifecycle information

        // Note: if both object and objectId are both set, only objectId will be used to display lifecycle information
        object: null, // the data used to display lifecycle information

        baseClass: 'pepperWayfinder',

        _proxies: null, // References to the little arrow thingies
        _workflowIcon: null, // Reference to the workflow spinny arrow
        _workflowUserIcon: null, // Reference to the user-specific claimable/assigned task badge

        // Subscriptions to the object
        _updatingSub: null,
        _updatedSub: null,

        mini: false, // Whether to display mini icons or not
        deadState: null, // If showing a dead state, we need its last reached lifecycle state

        constructor: function (args) {
            this._proxies = [];
            this._initializer = new Deferred();
        },

        postCreate: function () {

            this.inherited(arguments);
            this._initializer.resolve();
        },


        /**
         * Dim when updating status
         */
        expectNewStatus: function () {
            domStyle.set(this.domNode, 'opacity', 0.5);
        },

        /**
         * Update the rendering based on new life cycle information
         */
        gotNewStatus: function (newStatus) {

            // If newStatus is null it means it was removed from the post descriptor store. Don't do anything.
            if (!newStatus) {
                return;
            }

            var lifecycle = newStatus.lifecycle;

            // Clear wayfinder for the new status
            // Need to clear before possibly creating a dummy lifecycle, otherwise
            // multiple dummy lifecycles in a row will just keep chaining together.
            this.clear();

            // If no lifecycle exists in the new status,
            // then create a dummy lifecycle and exit this function
            if (!lifecycle) {
                if (_.isEmpty(newStatus)) {
                    this._createDummyLifecycle();
                    return;
                } else {
                    lifecycle = newStatus;
                }
            }

            // Create the lifecycle icons
            _.forEach(lifecycle.states, this._createLifecycleIcon, this);

            // If in workflow, create the workflow icon after the first icon
            if (lifecycle.workflow) {
                this._createWorkflowIcon(lifecycle.workflow);
            }

            // Colorize the lifecycle icons!
            this._applyStateClasses(lifecycle.currentVersion);

            domStyle.set(this.domNode, 'opacity', '');
        },

        /**
         * Creates a dummy lifecycle with empty icons and pretending like it is in reception
         * @private
         */
        _createDummyLifecycle: function () {
            // Use a dummy state object in reception with no version
            var dummyStateObject = { id: 'reception' };
            for (var i = 0; i < wayfinderEnum.STANDARD_NUMBER_OF_STATES; i++) {
                this._createLifecycleIcon(dummyStateObject);
            }
        },

        _setObjectAttr: function (object) {
            if(_.isNull(this.objectId)) {
                this.object = object;
                this.gotNewStatus(object);
            }
        },

        _setObjectIdAttr: function (objectId) {

            if (objectId) {
                this.objectId = objectId;

                this.expectNewStatus();

                when(this._initializer, lang.hitch(this, function () {

                    // Fetch the content by objectId and set the value
                    var result = postDescriptorStore.get(this.objectId);

                    if (result) {
                        when(result, lang.hitch(this, 'gotNewStatus'));

                        // Ensure that any future updates to this object also update the display
                        this.own(result.observe(lang.hitch(this, 'gotNewStatus')));
                    } else {
                        console.log('Wayfinder: objectId set, but no results found for id in store');
                    }

                }));
            } else {
                console.log('Wayfinder: no value given when trying to set objectId');
            }

            return this;

        },

        /**
         * Create a single Lifecycle icon with the given state
         */
        _createLifecycleIcon: function (/* Object */ state) {
            // Create a node for each version
            var proxy = domConstruct.create('span', {
                'class': ([state.id, this.mini ? wayfinderEnum.MINI_CLASS : wayfinderEnum.STATE_CLASS]).join(' ')
            }, this.domNode);

            // Store the state's data on the node
            domAttr.set(proxy, wayfinderEnum.LIFECYCLE_VERSION_ATTR, state.version);
            domAttr.set(proxy, wayfinderEnum.LIFECYCLE_ID_ATTR, state.id);

            // Append a version number
            domConstruct.create('span', {
                'class': wayfinderEnum.VERSION_CLASS,
                innerHTML: state.version || '&mdash;'
            }, proxy);

            // Keep track of it
            this._proxies.push(proxy);

            // If this is a dead state node, keep track of the state's last reached state
            if (state.id === wayfinderEnum.DEAD_CLASS && state.latestState) {
                this.deadState = state.latestState;
            }
        },

        /**
         * Create a workflow icon between the first two lifecycle icons
         */
        _createWorkflowIcon: function (workflowData) {
            // Find the Review icon
            var queryString = 'span[' + wayfinderEnum.LIFECYCLE_ID_ATTR + '=' + wayfinderEnum.REVIEW_CLASS + ']';
            var reviewState = query(queryString, this.domNode)[0];

            // Assign icon span's class based on whether workflow for this page is assigned to the current user,
            // or if the workflow has any tasks claimable by the current user.
            var iconClass;
            if (workflowData.hasClaimableTasks) {
                iconClass = wayfinderEnum.WORKFLOW_USER_CLAIMABLE_CLASS;
            }

            this._workflowIcon = domConstruct.create('span', {
                'class': wayfinderEnum.WORKFLOW_ICON_CLASS + ' ' + iconClass
            }, reviewState, 'before');
        },

        /**
         * Iterate through Lifecycle states and apply classes relating to their
         * current state
         */
        _applyStateClasses: function (/* Float */ currentDocumentVersion) {
            var currentVersion = null;
            var currentState = null;

            // If there are 5 states being displayed, shrink the non-selected states
            var shrinkIcons = this._proxies.length > wayfinderEnum.STANDARD_NUMBER_OF_STATES;
            if (shrinkIcons && this._workflowIcon) {
                domClass.add(this._workflowIcon, wayfinderEnum.SHRINK_CLASS);
            }

            // Loop that starts at the last node and works its way back.
            // Matching states goes from right to left, each lifecycle icon will try to
            // match the icon to its right if they have the same version
            _.forEachRight(this._proxies, function(proxy) {
                var version = domAttr.get(proxy, wayfinderEnum.LIFECYCLE_VERSION_ATTR);

                // Reset icon state if changing states and not loading new states
                domClass.remove(proxy, [wayfinderEnum.CURRENT_VERSION_CLASS, wayfinderEnum.SHRINK_CLASS]);

                // Add a "currentVersion" class on the version currently being viewed
                if (version === currentDocumentVersion) {
                    domClass.add(proxy, wayfinderEnum.CURRENT_VERSION_CLASS);
                } else {
                    if (shrinkIcons) {
                        domClass.add(proxy, wayfinderEnum.SHRINK_CLASS);
                    }
                }

                // lifecycle states with no version are considered unborn
                if (!version || version === 'null') {
                    domClass.add(proxy, wayfinderEnum.UNBORN_CLASS);
                } else {
                    // Add an "at<State>" class
                    // If this lifecycle version is the same as the last one,
                    // color this the same color as the last one
                    if (version === currentVersion) {
                        domClass.add(proxy, 'at' + capitalize(currentState));
                    } else {
                        var state = domAttr.get(proxy, wayfinderEnum.LIFECYCLE_ID_ATTR);
                        domClass.add(proxy, 'at' + capitalize(state));

                        // Otherwise, this is the new current version
                        currentVersion = version;
                        currentState = state;
                    }

                    // Apply special dead state class if the state is 'dead'
                    if (currentState === wayfinderEnum.DEAD_CLASS && this.deadState) {
                        domClass.add(proxy, 'at' + capitalize(this.deadState));
                    }
                }
            }, this);
        },

        /**
         * Clear all the elements in this Wayfinder
         */
        clear: function () {
            // Clear out the existing proxies
            _.forEach(this._proxies, domConstruct.destroy);
            this._proxies.length = 0;

            // Clear out the existing workflow icon
            if (this._workflowIcon) {
                domConstruct.destroy(this._workflowIcon);
            }
            this._workflowIcon = null;

            // Clear out the existing claimable/assigned task badge
            if (this._workflowUserIcon) {
                domConstruct.destroy(this._workflowUserIcon);
            }
            this._workflowUserIcon = null;
        }
    });
});

},
'pepper/enums/wayfinderEnum':function(){
define(['vodori/util/Enum'], function (Enum) {
    return new Enum(
        {'STATE_CLASS': 'state'},   // Default container class for the Wayfinder
        {'MINI_CLASS': 'mini'},     // used to shrink icons for a mini display in results lists. Replaces STATE_CLASS
        {'VERSION_CLASS': 'label'},
        {'UNBORN_CLASS': 'unborn'},
        {'REVIEW_CLASS': 'review'},
        {'LIVE_CLASS': 'live'},
        {'DEAD_CLASS': 'dead'},
        {'SHRINK_CLASS': 'shrink'}, // used to shrink icons when there are 5 states visible
        {'WORKFLOW_ICON_CLASS': 'workflowIcon'},
        {'WORKFLOW_USER_ICON_CLASS': 'workflowUserIcon'},
        {'WORKFLOW_USER_CLAIMABLE_CLASS': 'workflowUserClaimable'},
        {'WORKFLOW_USER_ASSIGNED_CLASS': 'workflowUserAssigned'},
        {'CURRENT_VERSION_CLASS': 'currentVersion'},
        // data attribute to store the state's lifecycle version (1.0, 1.1, etc)
        {'LIFECYCLE_VERSION_ATTR': 'data-lifecycle-version'},
        // data attribute to store the state's lifecycle state (draft, review, live, etc)
        {'LIFECYCLE_ID_ATTR': 'data-lifecycle-id'},
        // The standard number of lifecycle states
        {'STANDARD_NUMBER_OF_STATES': 4}
    );
});

},
'pepper/dialogs/info/tabs/WorkflowHistoryTab':function(){
/**
 * The workflow history tab will show the workflows associated with the asset in a PropertiesList grid.
 */
define([
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'pepper/utilities/renderLocalDate',
    'pepper/dialogs/info/PropertiesGrid', 'pepper/data/PepperServiceObjectStore',
    'pepper/services'

], function (module, provide,
             lang,
             renderLocalDate,
             PropertiesGrid, PepperServiceObjectStore,
             services) {

    var INBOX_PROCESS_STEM = '/pepper/inbox#/process/';

    var WorkflowHistoryTab = provide(module.id, [PropertiesGrid], {

        region: 'center',

        title: 'Workflow History',

        constructor: function () {
            this.store = new PepperServiceObjectStore({
                service: services.getWorkflowHistory,
                identifier: 'processId',
                sortable: false,
                paginated: true
            });

            this.renderFriendlyDate = lang.hitch(this, 'renderPossiblyNullDate');

            this.columns = [
                { label: 'Initiated', field: 'initiated',
                    renderCell: this.renderFriendlyDate},
                { label: 'Completed', field: 'completed',
                    renderCell: this.renderFriendlyDate},
                { label: 'Flow Type', field: 'flowType' },
                { label: 'Name [ID]', field: 'flowName',
                    renderCell: lang.hitch(this, 'renderFlowNameAnchor') },
                { label: 'Doc Ver #', field: 'version',
                    renderCell: lang.hitch(this, 'renderVersionAnchor')},
                { label: 'Last Activity', field: 'lastActivity' },
                { label: 'Last Activity Date', field: 'activityDate',
                    renderCell: this.renderFriendlyDate}
            ];
        },

        renderFlowNameAnchor: function(object, flowName, td) {
            var url = INBOX_PROCESS_STEM + object.processId;
            td.innerHTML = WorkflowHistoryTab.getAnchorTag(url, flowName);
        },

        renderVersionAnchor: function(object, version, td) {
            var url = object.url;
            td.innerHTML = WorkflowHistoryTab.getAnchorTag(url, version);
        },

        /**
         * The back end is responsible for deciding whether a date should be provided for various columns
         * because it might not make sense in some contexts. In that case, null will be returned as the date.
         * @param object
         * @param date {string|null}
         * @param td {domNode}
         *
         */
        renderPossiblyNullDate: function(object, date, td) {
            td.innerHTML = date ? this.renderDate(object, date, td) : '';
        },

        renderDate: function(object, date, td) {
            return renderLocalDate(date);
        }
    }, {
        getAnchorTag: function(url, anchorText) {
            return '<a class="grid-anchor" target="_blank" href="' + url + '">' + anchorText + '</a>';
        }
    } );
    return WorkflowHistoryTab;
});
},
'pepper/dialogs/review/tabs/PropertiesTab':function(){
/**
 * Properties tab in the info dialog
 */
define([
    'module', 'vodori/provide',
    'pepper/dialogs/info/PropertiesProxyPane'
], function(
    module, provide,
    PropertiesProxyPane) {
    /**
     * @class pepper/dialogs/info/tabs/PropertiesTab
     * @mixes pepper/dialogs/info/PropertiesProxyPane
     */
    return provide(module, [PropertiesProxyPane],
        /**
         * @lends pepper/dialogs/info/tabs/PropertiesTab#
         */
        {
            region: 'center',
            loadingHref: '/author/pepper/getPropertiesForm.html',
            title: 'Properties',
            refreshOnShow: true,

            /**
             * Builds the href property for a FormProxyPane based on the objects and template provided
             * @param {Object} config the configuration of the info dialog
             * @param {Array.<Object>} objects the objects
             * @param {Object} template The template of the object(s)
             */
            buildHref: function (config, objects, template) {
                if (!template) {
                    if (objects && objects.length > 0) {
                        var href = this.loadingHref + '?objectIds=' + objects[0].objectId;
                        for (var i = 1; i < objects.length; i++) {
                            href = href + '&objectIds=' + objects[i].objectId;
                        }
                        return href;
                    }

                    return null;
                }
                return template.formHref;
            }
        });
});

},
'pepper/dialogs/info/Footer':function(){
/**
 * Modular footer widget for the Info/Properties dialog.
 */
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/dom-style',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'vodori/util/string/capitalize',
    'dojo/text!./../templates/Footer-content.html',
    /* Unreferenced MIDs */
    'dijit/layout/ContentPane'
], function(
    module, provide,
    _,
    lang,
    domStyle,
    _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
    capitalize,
    content) {

    /**
     * @class pepper/dialogs/info/Footer
     * @extends dijit/_WidgetBase
     * @extends dijit/_TemplatedMixin
     * @extends dijit/_WidgetsInTemplateMixin
     */
    return provide(module.id, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin],
        /**
         * @lends pepper/dialogs/info/Footer#
         */
        {

        /**
         * this footer will watch this stateful object and update button availability accordingly
         * @type InfoState
         */
        infoState: null,

        templateString: content,
        
        _buttonActions: {
            'cancel':   'onCancel',
            'save':     'onSave',
            'next':     'onNext',
            'skip':     'onSkip',
            'previous': 'onPrevious',
            'done':     'onDone',
            'exit':     'onExit'
        },

        postCreate: function() {
            this.inherited(arguments);
            this.buttons = {
                cancel:     this.cancel,
                save:       this.save,
                next:       this.next,
                skip:       this.skip,
                previous:   this.previous,
                done:       this.done,
                exit:       this.exit
            };

            _.forEach(this._buttonActions, function(handler, buttonName) {
                this.own(this[buttonName].on('click', lang.hitch(this, handler)));
            }, this);
        },

        _setInfoStateAttr: function(value) {
            this.infoState = value;
            if (this.infoState) {
                this.own(this.infoState.watch(lang.hitch(this, 'refreshButtonStates')));
                this.refreshButtonStates();
            }
        },

        // jshint -W071
        refreshButtonStates: function() {
            var state = this.infoState;
            var visibleButtons = {};
            var enabledButtons = {}; // note if something is enabled but not visible, it will not show

            enabledButtons.cancel = true;
            enabledButtons.exit = true;
            enabledButtons.previous = true;
            enabledButtons.skip = true;

            // Note: 'cancel' is the Cancel button on the left and 'exit' is the Cancel button on the right. The read
            // only state determines which should be shown.
            if (state.readOnly) {
                visibleButtons.exit = true;
            } else {
                visibleButtons.cancel = true;
            }

            if (state.currentTabSavable) {
                if (!state.readOnly) {
                    visibleButtons.save = true;
                    visibleButtons.done = true;
                }
                if (state.flipThrough) {
                    visibleButtons.next = true;
                    visibleButtons.previous = true;
                    visibleButtons.skip = true;
                }

                if (state.valid && !state.loading) {
                    enabledButtons.save = true;
                    enabledButtons.done = true;
                    enabledButtons.next = true;
                }

                if (state.readOnly) {
                    // In readOnly state, "Next" is actually alias for "Skip"
                    enabledButtons.next = true;
                }

                if (!state.hasNext) {
                    delete enabledButtons.next;
                    delete enabledButtons.skip;
                }
                if (!state.hasPrevious) {
                    delete enabledButtons.previous;
                }
            }

            this._applyButtonStates(visibleButtons, enabledButtons);
        },
        // jshint +W071

        _applyButtonStates: function(visibleButtons, enabledButtons) {
            _.forEach(this.buttons, function(button, name) {
                var invisible = !visibleButtons[name];
                var disabled = invisible || !enabledButtons[name];
                domStyle.set(button.domNode, 'display', invisible ? 'none' : '');
                button.set('disabled', disabled);
            });
        },

        //--------------------------------------------------------------------------------
        // Subscribe to these events, they occur when their respective buttons are clicked
        //--------------------------------------------------------------------------------
        onSave: function() {
        },

        onCancel: function() {
        },

        onNext: function() {
        },

        onSkip: function() {
        },

        onPrevious: function() {
        },

        onDone: function() {
        },

        onExit: function() {
        },

        destroy: function() {
            this._destroyButtons(this.buttons);
            this.inherited(arguments);
        },

        _destroyButtons: function(buttons) {
            _.forEach(buttons, function(button) {
                if (button instanceof _WidgetBase) {
                    button.destroy();
                } else {
                    this._destroyButtons(button);
                }
            }, this);
        }
    });
});

},
'pepper/dialogs/info/configs/views':function(){
/**
 * Defines the various view configurations for the Info/Review dialog's config property.
 */
define([
    'module', 'vodori/provide',
    'dojo/_base/lang'
], function (module, provide, lang) {
    var views = {
        info: {},
        review: {}
    };
    var standard = {
        tabs: [
            'NormalPropertiesTab', 'VersionsTab',
            'RelationshipsTab', 'AuditsTab',
            'PermissionsTab', 'RenditionsTab',
            'WorkflowHistoryTab'
        ],
        templateSelector: {
            enabled: true
        }
    };

    views.info.single = lang.mixin({}, standard, {
        view: 'info',
        mode: 'single'
    });
    views.info.queue = lang.mixin({}, standard, {
        view: 'info',
        mode: 'queue'
    });
    views.info.bulk = lang.mixin({}, standard, {
        view: 'info',
        mode: 'bulk',
        tabs: [
            'NormalPropertiesTab'
        ]
    });

    views.review.single = lang.mixin({}, standard, {
        view: 'review',
        mode: 'single'
    });
    views.review.queue = lang.mixin({}, standard, {
        view: 'review',
        mode: 'queue'
    });
    views.review.bulk = lang.mixin({}, standard, {
        view: 'review',
        mode: 'bulk',
        tabs: [
            'ReviewPropertiesTab'
        ]
    });

    views.create = lang.mixin({}, standard, {
        view: 'create',
        mode: 'single',
        tabs: [
            'CreatePropertiesTab'
        ]
    });

    return provide(module.id, views);
});

},
'pepper/commands/dialogs/showFlipThrough':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
/**
 * Launches the Get Info dialog in queue mode for the Flip Through command
 */
define([
    'vodori/provide', 'module',
    'lodash',
    'pepper/dialogs/Info', 'pepper/dialogs/info/configs/views',
    'pepper/ui/ComposingDialog', 'pepper/utilities/checkOutAll', 'pepper/utilities/isInReception'
], function (
    provide, module,
    _,
    Info, views,
    ComposingDialog, checkOutAll, isInReception) {
    return provide(module.id,
        /**
         * Opens the Info dialog in flip through mode with the given objects. This function will also attempt to check
         * out all reception items passed in, assuming the user will want to perform a review action on any reception
         * items while flipping through the list.
         *
         * @memberOf pepper/commands/dialogs
         * @param {Array.<Object>} objects
         */
        function showFlipThrough(objects) {

            var receptionObjects = _.remove(objects, isInReception);

            checkOutAll(receptionObjects).then(function(results) {

                var allObjects = [].concat(results.checkedOut, results.alreadyCheckedOut, objects);

                // Sets list of selected items to flip
                // Sets index to start at first item
                // Sets config view type to queue
                var infoWidget = new Info({
                    objects: allObjects,
                    index: 0,
                    config: views.info.queue
                });

                var modal = new ComposingDialog({
                    destroyOnHide: true,
                    parseOnFirstShow: false,
                    widget: infoWidget
                });

                modal.startup();
                modal.show();
            });
        });
});

},
'pepper/utilities/checkOutAll':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'lodash',
    'dojo/topic', 'dojo/Deferred', 'dojo/promise/all',
    'pepper/events',
    'pepper/data/PostDescriptorStore'
], function (
    _,
    topic, Deferred, all,
    events,
    PostDescriptorStore) {

    /**
     * This module will attempt to check out all objects in the list that aren't locked by the current user, doing
     * nothing to the objects that are already checked out.
     *
     * The promise will be resolved with an object containing two array properties labeled checkedOut and
     * alreadyCheckedOut. These contain the objects that were checked out, and the objects that were not
     * Example:
     * {
     *     checkedOut: [ objects... ],
     *     alreadyCheckedOut: [ objects... ]
     * }
     *
     * @param objects The objects to be checked out.
     * @returns {dojo/promise/Promise} a deferred that will be resolved when all checkouts are complete.
     */
    return function checkOutAll(objects) {

        var deferred = new Deferred();
        var deferredResult = {
            alreadyCheckedOut: [],
            checkedOut: []
        };

        var checkOutDeferreds = [];

        _.forEach(objects, function(obj) {
            if(!obj.lockedByCurrentUser) {
                checkOutDeferreds.push(PostDescriptorStore.checkOut([ obj ], { state: 'CONFIRMED' }));
            } else {
                deferredResult.alreadyCheckedOut.push(obj);
            }
        });

        all(checkOutDeferreds).then(function(results) {

            if (results && results.length > 0) {

                _.forEach(results, function (serviceResult) {
                    var result = serviceResult.results[0];
                    deferredResult.checkedOut.push(result);
                });

                // ensure the library reflects the fact that we just changed checkout state of at least one item
                topic.publish(events.library.refresh);
            }

            deferred.resolve(deferredResult);

        });
        return deferred.promise;
    };
});

},
'pepper/commands/dialogs/showReview':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'vodori/provide', 'module',
    'lodash',
    'pepper/dialogs/Info', 'pepper/dialogs/info/configs/views',
    'pepper/ui/ComposingDialog', 'pepper/utilities/checkOutAll'
], function (
    provide, module,
    _,
    Info, views,
    ComposingDialog, checkOutAll) {
    return provide(module.id,
        /**
         * @memberOf pepper/commands/dialogs
         *
         * @param {Array.<Object>} objects
         */
        function showReview(objects) {

            checkOutAll(objects).then(function(results) {
                var allObjects = [].concat(results.checkedOut, results.alreadyCheckedOut);

                // Sets list of items for review
                // Sets config mode depending on how many objects were passed in
                var infoWidget = new Info({
                    objects: allObjects,
                    config: (allObjects.length > 1) ? views.review.bulk : views.review.single
                });

                var modal = new ComposingDialog({
                    destroyOnHide: true,
                    parseOnFirstShow: false,
                    widget: infoWidget
                });

                modal.startup();
                modal.show();
            });
        });
});

},
'pepper/commands/dialogs/showCheckInAssets':function(){
define([
    'module', 'vodori/provide',
    'dojo/topic',
    'pepper/import/CheckIn', 'pepper/ui/ComposingDialog',
    'pepper/utilities/createPayload', 'pepper/events'
], function (
    module, provide,
    topic,
    CheckIn, ComposingDialog,
    createPayload, events) {

    return provide(module.id,

        /**
         * Display the static asset check in dialog
         *
         * @memberOf pepper/commands/dialogs
         *
         * @param {Object} payload      A pepper ajax payload containing the objects to check in.
         * @param {*} lastPepperResult
         */
        function showCheckInAssets(payload, lastPepperResult) {
            var checkInWidget = new CheckIn({
                objects: createPayload(payload.objects)
            });

            var checkInDialog = new ComposingDialog({
                destroyOnHide: true,
                parseOnFirstShow: false,
                widget: checkInWidget
            });

            checkInDialog.startup();
            checkInDialog.show();

            // We need to clear the last service request, as we're venturing down a different branch of functionality
            // Find a cleaner way of doing this
            // https://jira.vodori.com/browse/CAYENNE-2903
            topic.publish(events.services.canceledRequest, lastPepperResult);
        });
});

},
'pepper/import/CheckIn':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/query', 'dojo/dom-construct',
    'vodori/util/number/humanizeBytes',
    'pepper/import/ImportPepperDoc',
    'pepper/services', 'pepper/ui/handleNotification', 'pepper/utilities/createPayload'
], function (
    module, provide,
    _,
    lang, query, domConstruct,
    humanizeBytes,
    ImportPepperDoc,
    services, handleNotification, createPayload) {

    /**
     * Similar to the Import dialog except with special functionality for checking in assets
     *
     * @class pepper/dialogs/CheckIn
     * @mixes pepper/dialogs/ImportPepperDoc
     */
    return provide(module.id, [ ImportPepperDoc ],
        /**
         * @lends pepper/dialogs/CheckIn.prototype
         */
        {
            title: 'Check In Wizard',

            objects: null, // An array of objectIds of the assets we are checking in
            assets: null,  // A map of asset filenames -> objectIds

            addedFiles: null, // An array of files that were most recently added
            filesPane: null,

            _UPLOAD_URL: '/checkInFiles.html',
            _OBJECT_ID_REQUEST_HEADER: 'Pepper-ObjectId', // Name of the request header to include with each upload

            constructor: function() {
                this.objects = [];
                this.assets = {};
                this.addedFiles = {};
            },

            /**
             * Before uploading each file, insert the target file's objectId into the request header
             *
             * @param {*} up    reference to plupload
             * @param {Object} file  the file the user chose through the file browser
             */
            beforeUpload: function (up, file) {
                this.inherited(arguments);

                // Grab and insert the corresponding file's objectId into the request header
                up.settings.headers[this._OBJECT_ID_REQUEST_HEADER] = this.assets[file.name];
            },

            /**
             * Added files are stored and won't be acted upon until filesChanged is called
             *
             * @param up    reference to plupload
             * @param files an array of files the user has selected
             */
            filesAdded: function (/* Plupload */ up, /* Array */ files) {
                this.addedFiles = files;
            },

            /**
             * When files have been chosen using the file browser, make sure the filenames match the
             * files being checked in
             *
             * @param {*} up    reference to plupload
             */
            filesChanged: function (up) {
                this.inherited(arguments);

                // Only enable "start upload" if all files have been selected
                this.startButton.set('disabled', up.files.length !== this.objects.length);
                this.addButton.set('disabled', up.files.length === this.objects.length);

                // Only continue if the user added files to the queue
                if (this.addedFiles.length === 0) {
                    return;
                }

                var mismatches = []; // Array to hold potential file name mismatches
                var duplicates = []; // Array to hold duplicate file upload selections

                // Validate the filenames
                _.forEach(this.addedFiles, function (file) {

                    // getting the names of current files.
                    var filenames = _.keys(this.assets);

                    // we need to use normalize to accommodate mismatched special character encodings.
                    var match = _.find(filenames, function(name){
                        return (file.name.localeCompare(name) === 0);
                        // preferred but not fully supported until ECMA6:
                        // return file.name.normalize() === name.normalize();
                    });

                    // if we found a match then let that version become the new filename so that
                    // it can be used to access elements in the assets dict.
                    if(match){
                        file.name = match;
                    } else {
                        mismatches.push(file);
                        return;
                    }

                    var objectId = this.assets[file.name];

                    // If the user has already selected this file, remove the duplicate from plupload's queue
                    if (!(objectId in this.fileRows)) {
                        duplicates.push(file);
                        return;
                    }

                    // Finally, if the file passed validation...

                    // Change the row reference key from objectId to plupload's file id
                    this.fileRows[file.id] = this.fileRows[objectId];
                    delete this.fileRows[objectId];

                    // Update the data displayed in the grid
                    var fileRowElement = this.fileRows[file.id];
                    query('.status', fileRowElement)[0].innerHTML = 'File matched';
                    query('.size', fileRowElement)[0].innerHTML = humanizeBytes(file.size);
                }, this);

                // Reset the addedFiles array to ignore potential removeFile calls
                this.addedFiles.length = 0;

                if (mismatches.length > 0) {
                    // If there are filename mismatches, display an error dialog
                    handleNotification({
                        title: 'Unable to match files',
                        message: _.map(mismatches,function (mismatch) {
                            return mismatch.name;
                        }).join(', ') + ' has no matches with any assets you are trying to check in. ' +
                                        'Please double-check the filenames and try again.',
                        type: 'modal'
                    });

                    // Remove the mismatched files from the plupload queue
                    _.forEach(mismatches, function (mismatch) {
                        up.removeFile(mismatch);
                    });
                }

                if (duplicates.length > 0) {
                    // Remove duplicate file selections from the queue
                    _.forEach(duplicates, function (duplicate) {
                        up.removeFile(duplicate);
                    });
                }
            },

            /**
             * Overriding to only display the "close" button
             *
             * @param up    reference to plupload
             */
            uploadComplete: function (/* Plupload */ up) {
                this.inherited(arguments);

                this.closeButton.set('style', {display: 'block'});
                this.cancelButton.set('style', {display: 'none'});
                this.addButton.set('style', {display: 'none'});
                this.startButton.set('style', {display: 'none'});
                this.reviewLaterButton.set('style', {display: 'none'});
                this.reviewNowButton.set('style', {display: 'none'});
            },

            /**
             * Overriding to add a new event hook to BeforeUpload to pass in custom parameters right
             * before uploading a file
             */
            initUploader: function () {
                this.inherited(arguments);

                this.uploader.settings.url = this._UPLOAD_URL;

                this.uploader.unbind('FilesRemoved', this.filesRemoved);
            },

            postCreate: function () {
                this.inherited(arguments);

                this.addButton.set('label', 'Select Files');

                // Grab data about the assets to be checked in and populate the grid with the returned data
                services.getImportReviewFileInfo({
                    params: {
                        objects: createPayload(this.objects)
                    }
                }).then(lang.hitch(this, 'prepareCheckInObjects'));
            },

            /**
             * Called after retrieving more data about the files to be checked in.
             * Will fill the grid with the file data and create a mapping of file name to objectId
             *
             * @param objects   a Pepper Object containing an array with data of the assets to be checked in
             */
            prepareCheckInObjects: function (/* Object */ objects) {
                var assetData = objects.results;

                // Iterate through the object data and create a new row in the grid for each object
                _.forEach(assetData, function (file) {
                    // Each file gets a row with a name and status.
                    var row = domConstruct.create('div', {
                        'class': 'file'
                    }, this.filesPane.domNode);

                    domConstruct.create('span', {
                        'class': 'name',
                        innerHTML: file.fileName
                    }, row);

                    domConstruct.create('span', {
                        'class': 'size',
                        innerHTML: ''
                    }, row);

                    domConstruct.create('span', {
                        'class': 'status',
                        innerHTML: 'Please select your corresponding file'
                    }, row);

                    // Save references to the row by its objectId
                    this.fileRows[file.objectId] = row;

                    // Push the filename to objectId mapping
                    this.assets[file.fileName] = file.objectId;
                }, this);
            }
        });
});

},
'vodori/util/number/humanizeBytes':function(){
define([
    'vodori/provide',
    'module'
], function (provide, module) {
    return provide(module.id, function (bytes, decimalPlaces, bin) {
        bytes = parseFloat(bytes);

        var units = [
            bin ? 'KiB' : 'KB',
            bin ? 'MiB' : 'MB',
            bin ? 'GiB' : 'GB'
        ];

        var unitMultipliers = [
            bin ? Math.pow(2, 10) : 1e3,
            bin ? Math.pow(2, 20) : 1e6,
            bin ? Math.pow(2, 30) : 1e9
        ];

        var size = (+bytes).toFixed(decimalPlaces) + ' bytes';

        for (var i = 0; i < unitMultipliers.length; i++) {
            if (bytes >= unitMultipliers[i]) {
                size = (bytes / unitMultipliers[i]).toFixed(decimalPlaces) + ' ' + units[i];
            }
        }

        return size;
    });
});

},
'pepper/import/ImportPepperDoc':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'dojo/topic', 'dojo/json',
    'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'pepper/events',
    'pepper/import/_Import', 'pepper/import/Review',
    'pepper/ui/ComposingDialog',
    'dojo/text!./templates/ImportPepperDoc.html'
], function (
    module, provide,
    lang, topic, JSON,
    _TemplatedMixin, _WidgetsInTemplateMixin,
    events,
    _Import, Review,
    ComposingDialog,
    template) {


    /**
     * This is the import files dialog. It uses Plupload to upload files and then the user can
     * launch the review dialog from here.
     */

    return provide(module, [_Import, _TemplatedMixin, _WidgetsInTemplateMixin],
        /**
         * @lends pepper/import/ImportPepperDoc.prototype
         */
        {
            title: 'Pepper Document Import (Step 1 of 2)',
            uploadedFiles: [],

            templateString: template,

            /**
             * @constructs
             * @mixes pepper/import/_Import
             */
            constructor: function () {
                this.uploadedFiles = [];
                this._buttonMappings = lang.mixin({}, this._buttonMappings, {
                    'reviewLaterButton': 'reviewLater',
                    'reviewNowButton': 'startReview'
                });
            },

            /**
             * Adds to upload rejection handling by adding successfully uploaded files to a file
             * list that will be passed to the Review dialog that comes after this particular
             * Import dialog.
             *
             * @param {Uploader} up
             * @param {Object} file
             * @param {{response: string}} response
             */
            fileUploaded: function (up, file, response) {
                var parsedResponse = JSON.parse(response.response).results[0];

                if (parsedResponse.success) {
                    // Keep a record of the return Pepper object of each successful upload.
                    // This will be passed to the Review dialog.
                    this.uploadedFiles.push({
                        objectId: parsedResponse.objectId,
                        versionSeriesId: parsedResponse.versionSeriesId
                    });
                }
                else {
                    this.inherited(arguments);
                }
            },

            /**
             * Overrides upload complete callback to add in disabling of review buttons
             * if all files failed to upload.
             *
             * @param up  A reference to the uploader
             */
            uploadComplete: function (up) {
                this.inherited(arguments);

                // If this is true, then all of the files failed and we don't want to be able to review them
                if (this.failedFiles.length === up.files.length) {
                    this.reviewLaterButton.set('disabled', true);
                    this.reviewNowButton.set('disabled', true);
                }
            },

            /**
             * Review the content later, and update the library for any successfully imported content
             */
            reviewLater: function () {
                // Refresh the library if we've successfully imported some files
                topic.publish(events.library.refresh);
                this.onCancel();
            },

            /**
             * Kick off the review workflow and close this dialog
             */
            startReview: function () {
                var params = {
                    objects: this.uploadedFiles
                };

                if (this.parentFolder) {
                    params.pathId = this.parentFolder.objectId;
                }

                var reviewWidget = new Review(params);

                var reviewDialog = new ComposingDialog({
                    destroyOnHide: true,
                    parseOnFirstShow: false,
                    widget: reviewWidget
                });

                reviewDialog.startup();
                reviewDialog.show();

                this.onCancel(); // Close and destroy the Import dialog.
            }
        });
});

},
'pepper/import/_Import':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/aspect', 'dojo/on', 'dojo/io-query',
    'dojo/dom-construct', 'dojo/dom-class', 'dojo/dom-style',
    'dojo/query', 'dojo/topic', 'dojo/has', 'dojo/json',
    'dijit/_WidgetBase',
    'dijit/registry',
    'vodori/layout/_Composable',
    'vodori/util/number/humanizeBytes', 'vodori/util/csrf',
    'vodori/amd/plupload', 'vodori/ui/Button', 'vodori/ui/util/pane',
    'vodori/ui/_ButtonMappingMixin',
    'pepper/ui/_QuarantineMixin',
    'pepper/events',
    /* Unreference MIDs */
    'dijit/layout/BorderContainer',
    'dijit/layout/ContentPane',
    'dijit/ProgressBar'
],
function (
    module, provide,
    _,
    lang, aspect, on, ioQuery,
    domConstruct, domClass, domStyle,
    query, topic, has, JSON,
    _WidgetBase,
    registry,
    _Composable,
    humanizeBytes, csrf,
    plupload, Button, paneUtils,
    _ButtonMappingMixin,
    _QuarantineMixin,
    events) {

    /**
     * @mixin pepper/import/_Import
     * @mixes pepper/ui/_QuarantineMixin
     */
    return provide(module, [_WidgetBase, _Composable, _QuarantineMixin, _ButtonMappingMixin],
        /**
         * @lends pepper/dialogs/ImportPepperDoc.prototype
         */
    {
        title: '',

        baseClass: 'pepperImportDialog',

        hiddenClass: 'hidden',

        uploader: null, // Reference to the magical Plupload

        _failures: 0,
        _expandedFailuresHeight: 'auto',

        fileRows: null,

        failedFiles: null,
        failuresPane: null,

        UPLOAD_COMPLETE_HTML_CLASS: 'upload-complete',

        _UPLOAD_URL: '/uploadFiles.html',
        _FILE_SIZE_REQUEST_HEADER: 'Pepper-Filesize',

        _buttonMappings: {
            'cancelButton': 'onCancel',
            'startButton': 'startUploader',
            'closeButton': 'onClose'
        },

        /**
         * The id of the channel to import the document into.
         */
        channelId: null,

        constructor: function() {
            this.fileRows = {};
            this.failedFiles = [];
            this.quarantineAreaClassNames += ' dialogContainer';
        },

        postCreate: function() {
            this.inherited(arguments);

            this.hideFailures();
        },

        startup: function() {
            if (!this.uploader) {
                this.initUploader();
            }

            this.fireCompose({
                props: {
                    title: this.title
                }
            });
        },

        initUploader: function() {
            var queryString = ioQuery.objectToQuery({
                channelId: this.channelId
            });
            var target = this._UPLOAD_URL + '?' + queryString;
            if (has('config-mock-data')) {
                target = '/static/js/pepper/mockData/import.json';
            }

            // Create the Plupload instance.
            this.uploader = new plupload.Uploader({
                runtimes: 'html5',
                container: this.importerPane.id,
                'drop_element': this.importerPane.id,
                url: target,
                'browse_button': this.addButton.id,
                'flash_swf_url': '/static/js/plupload/plupload.flash.swf',
                'multipart_params': csrf.getParameterKeyValuePair()
            });

            // Attach our methods to its events.
            this.uploader.bind('FilesAdded', this.filesAdded, this);
            this.uploader.bind('FilesRemoved', this.filesRemoved, this);
            this.uploader.bind('QueueChanged', this.filesChanged, this);
            this.uploader.bind('BeforeUpload', this.beforeUpload, this);
            this.uploader.bind('UploadProgress', this.uploadProgress, this);
            this.uploader.bind('Error', this.uploadError, this);
            this.uploader.bind('FileUploaded', this.fileUploaded, this);
            this.uploader.bind('UploadComplete', this.uploadComplete, this);

            this.uploader.init();

            // Emulate browse button hover state (Plupload places the file input above the browse button)
            var fileInput = document.getElementById(this.uploader.id + '_html5');
            domStyle.set(fileInput, 'cursor', 'pointer');
            var browseButton = this.addButton.domNode;
            plupload.addEvent(fileInput, 'mouseover', function() {
                plupload.addClass(browseButton, 'vodoriButtonHover');
            }, this.uploader.id);
            plupload.addEvent(fileInput, 'mouseout', function() {
                plupload.removeClass(browseButton, 'vodoriButtonHover');
            }, this.uploader.id);

            // Keep file input position from Plupload up to date
            aspect.after(this.importerPane, 'resize', lang.hitch(this.uploader, 'refresh'));
        },

        // This is the uploader's response to picking a new set up files.
        filesAdded: function(up, files) {
            _.forEach(files, function(file) {
                // Each file gets a row with a name, size, and status.
                var row = domConstruct.create('div', {
                    'class': 'file'
                }, this.filesPane.domNode);

                domConstruct.create('span', {
                    'class': 'name',
                    innerHTML: file.name
                }, row);

                domConstruct.create('span', {
                    'class': 'size',
                    innerHTML: humanizeBytes(file.size)
                }, row);

                domConstruct.create('span', {
                    'class': 'status'
                }, row);

                // Add a button to remove the file.
                var button = new Button({
                    'class': 'remover',
                    label: '&times;',
                    onClick: lang.hitch(this, 'removeFile', file.id)
                });

                domConstruct.place(button.domNode,domConstruct.create('span', {}, row));

                // Keep a reference to each row.
                this.fileRows[file.id] = row;
            }, this);
        },

        // Tell the uploader we want to remove a file.
        removeFile: function(id) {
            this.uploader.removeFile(this.uploader.getFile(id));
        },

        _destroyWidgetByNode: function(widgetNode) {
            registry.byNode(widgetNode).destroyRecursive();
        },

        // This is the uploader's response to removing a file.
        filesRemoved: function(up, files) {
            for (var i = 0; i < files.length; i++) {
                // Destroy the "remove" button.
                query('.remover', this.fileRows[files[i].id]).forEach(this._destroyWidgetByNode);

                // Destroy the row node and delete the reference.
                domConstruct.destroy(this.fileRows[files[i].id]);
                delete this.fileRows[files[i].id];
            }
        },

        // When files are added to or removed from the queue...
        filesChanged: function(up) {
            // Update the footer information.
            this.progressImportedNode.innerHTML = up.total.uploaded - this._failures;
            this.progressTotalNode.innerHTML = up.files.length;
            this.progressStatusNode.innerHTML = up.total.percent + '%';
            this.progressBarNode.set('value', up.total.percent + '%');

            // Calculate the total size of the files in the queue.
            var totalSize = 0;
            _.forEach(up.files, function(file) {totalSize += file.size;});
            this.totalSizeNode.innerHTML = humanizeBytes(totalSize);

            this.toggleDragFilesHereText(totalSize);

            this.startButton.set('disabled', up.files.length === 0);
        },

        /**
         * Hide or show the "Drag Files Here" text based on whether files are in the queue.
         *
         * @param totalSize    number of files in the queue
         */
        toggleDragFilesHereText: function(totalSize) {
            if (totalSize > 0) {
                domClass.add(this.dragFilesHere, this.hiddenClass);
            } else {
                domClass.remove(this.dragFilesHere, this.hiddenClass);
            }
        },

        /**
         * Before uploading each file, insert the target file's file size into the request header
         *
         * @param {vodori.amd.plupload} up  A reference to the uploader
         * @param file                      The file the user chose through the file browser
         */
        beforeUpload: function(/* Plupload */ up, /* Object */ file) {
            // Grab and insert the corresponding file's filesize into the request header
            up.settings.headers = {};
            up.settings.headers[this._FILE_SIZE_REQUEST_HEADER] = file.size;
        },

        // Start uploading.
        startUploader: function() {
            // Remove the "remove" buttons so the queue can't change.
            for (var id in this.fileRows) {
                query('.remover', this.fileRows[id]).forEach(this._destroyWidgetByNode);
            }

            // We don't want to be able to click upload twice.
            this.startButton.set('disabled', true);
            // Don't want to keep adding files while the current ones are uploading.
            this.addButton.set('disabled', true);
            plupload.removeEvent(this.addButton.titleNode, 'click', this.uploader.id);

            this._failures = 0;
            this.uploader.start();
        },

        /**
         * Called whenever progress is made during a file upload. Will update the
         * percent complete display.
         *
         * @param {vodori.amd.plupload} up  A reference to the uploader
         * @param file
         */
        uploadProgress: function(up, file) {
            if (file.status === plupload.DONE) {
                return;
            }

            query('.status', this.fileRows[file.id])[0].innerHTML = file.percent + '%';
            this.progressImportedNode.innerHTML = up.total.uploaded - this._failures;
            this.progressStatusNode.innerHTML = up.total.percent + '%';
            this.progressBarNode.set('value', up.total.percent + '%');
        },

        /**
         * Called when a file has been uploaded. Shuttles file info to error handler
         * if the upload failed.
         *
         * @param {vodori.amd.plupload} up  A reference to the uploader
         * @param file                      Details about the file uploaded
         * @param response                  Response from the server
         */
        fileUploaded: function(/* Uploader */ up, /* Object */ file, /* Object */ response) {
            var parsedResponse = JSON.parse(response.response).results[0];

            // If the upload was rejected, handle the error
            if (!parsedResponse.success) {
                this.uploadError(up, {
                    file: file,
                    message: parsedResponse.message
                });
            }
        },

        /**
         * Error handling. Display error message and update error count
         *
         * @param {vodori.amd.plupload} up  A reference to the uploader
         * @param err                       Error details
         */
        uploadError: function(/* Uploader */ up, /* Object */ err) {
            // Log error message if it's a non-file related error
            if (!err.file) {
                console.error('Plupload error: ' + err.message);
                return;
            }

            // Print out the error message
            var row = this.fileRows[err.file.id];
            query('.status', row)[0].innerHTML = err.message;

            // Add file to array of failed files
            this.failedFiles.push(err);

            // Update the failed files count
            var count = this._failures = this.failedFiles.length;
            this.failuresCount.innerHTML = count + ' ' + (count === 1 ? 'file' : 'files');

            this.showFailures();
        },

        /**
         * Callback for upload completion, which changes the uploader window buttons depending on
         * whether all the files failed to upload or not. Also destroys the uploader object.
         *
         * @param {vodori.amd.plupload} up A reference to the uploader
         */
        uploadComplete: function(up) {
            this.progressImportedNode.innerHTML = up.total.uploaded - this._failures;

            if (this.failedFiles.length === up.files.length) {
                domClass.add(this.footerTrailNode, 'importFail');
            }
            else {
                domClass.add(this.footerTrailNode, 'importSuccess');
            }

            // We won't need the uploader anymore.
            this.uploader.destroy();
            this.uploader = null;

            domClass.add(this.domNode, this.UPLOAD_COMPLETE_HTML_CLASS);
        },

        showFailures: function() {
            domStyle.set(this.failuresPane.domNode, 'display', '');
            domStyle.set(this.failuresPane._splitterWidget.domNode, 'display', '');
            this.resize();

            paneUtils.resize(this.failuresPane, {h: this._expandedFailuresHeight});
        },

        hideFailures: function() {
            var hidePane = paneUtils.hide(this.failuresPane);
            var onEnd = on(hidePane, 'end', function() {
                onEnd.remove();
                domStyle.set(this.failuresPane.domNode, 'display', 'none');
                domStyle.set(this.failuresPane._splitterWidget.domNode, 'display', 'none');
                this.resize();
            });
        },

        onCancel: function() {
            this._destroyUploader();
            this.fireCompose({
                methods : {
                    'hide' : {}
                }
            });
        },

        onClose: function() {
            topic.publish(events.library.refresh);

            this.onCancel();
        },

        _destroyUploader: function () {
            if (this.uploader) {
                this.uploader.destroy();
            }
        }
    });
});

},
'vodori/amd/plupload':function(){
/* global plupload: false */
define([
    'plupload/plupload/plupload.full'
], function () {
    // PSP-1884: Triggering the file dialog doesn't always work when triggered programmatically,
    //           fallback to case of clicking the file input directly
    var features = plupload.runtimes.Html5.getFeatures();
    features.triggerDialog = false;
    plupload.runtimes.Html5.getFeatures = function() {
      return features;
    };

    return plupload;
});

},
'plupload/plupload/plupload.full':function(){
// wrapped by build app
define(["dojo","dijit","dojox"], function(dojo,dijit,dojox){
/*1.5.4*/
(function(){var f=0,l=[],n={},j={},a={"<":"lt",">":"gt","&":"amp",'"':"quot","'":"#39"},m=/[<>&\"\']/g,b,c=window.setTimeout,d={},e;function h(){this.returnValue=false}function k(){this.cancelBubble=true}(function(o){var p=o.split(/,/),q,s,r;for(q=0;q<p.length;q+=2){r=p[q+1].split(/ /);for(s=0;s<r.length;s++){j[r[s]]=p[q]}}})("application/msword,doc dot,application/pdf,pdf,application/pgp-signature,pgp,application/postscript,ps ai eps,application/rtf,rtf,application/vnd.ms-excel,xls xlb,application/vnd.ms-powerpoint,ppt pps pot,application/zip,zip,application/x-shockwave-flash,swf swfl,application/vnd.openxmlformats-officedocument.wordprocessingml.document,docx,application/vnd.openxmlformats-officedocument.wordprocessingml.template,dotx,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,xlsx,application/vnd.openxmlformats-officedocument.presentationml.presentation,pptx,application/vnd.openxmlformats-officedocument.presentationml.template,potx,application/vnd.openxmlformats-officedocument.presentationml.slideshow,ppsx,application/x-javascript,js,application/json,json,audio/mpeg,mpga mpega mp2 mp3,audio/x-wav,wav,audio/mp4,m4a,image/bmp,bmp,image/gif,gif,image/jpeg,jpeg jpg jpe,image/photoshop,psd,image/png,png,image/svg+xml,svg svgz,image/tiff,tiff tif,text/plain,asc txt text diff log,text/html,htm html xhtml,text/css,css,text/csv,csv,text/rtf,rtf,video/mpeg,mpeg mpg mpe,video/quicktime,qt mov,video/mp4,mp4,video/x-m4v,m4v,video/x-flv,flv,video/x-ms-wmv,wmv,video/avi,avi,video/webm,webm,video/vnd.rn-realvideo,rv,application/vnd.oasis.opendocument.formula-template,otf,application/octet-stream,exe");var g={VERSION:"1.5.4",STOPPED:1,STARTED:2,QUEUED:1,UPLOADING:2,FAILED:4,DONE:5,GENERIC_ERROR:-100,HTTP_ERROR:-200,IO_ERROR:-300,SECURITY_ERROR:-400,INIT_ERROR:-500,FILE_SIZE_ERROR:-600,FILE_EXTENSION_ERROR:-601,IMAGE_FORMAT_ERROR:-700,IMAGE_MEMORY_ERROR:-701,IMAGE_DIMENSIONS_ERROR:-702,mimeTypes:j,ua:(function(){var s=navigator,r=s.userAgent,t=s.vendor,p,o,q;p=/WebKit/.test(r);q=p&&t.indexOf("Apple")!==-1;o=window.opera&&window.opera.buildNumber;return{windows:navigator.platform.indexOf("Win")!==-1,ie:!p&&!o&&(/MSIE/gi).test(r)&&(/Explorer/gi).test(s.appName),webkit:p,gecko:!p&&/Gecko/.test(r),safari:q,opera:!!o}}()),typeOf:function(p){return({}).toString.call(p).match(/\s([a-z|A-Z]+)/)[1].toLowerCase()},extend:function(o){g.each(arguments,function(p,q){if(q>0){g.each(p,function(s,r){o[r]=s})}});return o},cleanName:function(o){var p,q;q=[/[\300-\306]/g,"A",/[\340-\346]/g,"a",/\307/g,"C",/\347/g,"c",/[\310-\313]/g,"E",/[\350-\353]/g,"e",/[\314-\317]/g,"I",/[\354-\357]/g,"i",/\321/g,"N",/\361/g,"n",/[\322-\330]/g,"O",/[\362-\370]/g,"o",/[\331-\334]/g,"U",/[\371-\374]/g,"u"];for(p=0;p<q.length;p+=2){o=o.replace(q[p],q[p+1])}o=o.replace(/\s+/g,"_");o=o.replace(/[^a-z0-9_\-\.]+/gi,"");return o},addRuntime:function(o,p){p.name=o;l[o]=p;l.push(p);return p},guid:function(){var o=new Date().getTime().toString(32),p;for(p=0;p<5;p++){o+=Math.floor(Math.random()*65535).toString(32)}return(g.guidPrefix||"p")+o+(f++).toString(32)},buildUrl:function(p,o){var q="";g.each(o,function(s,r){q+=(q?"&":"")+encodeURIComponent(r)+"="+encodeURIComponent(s)});if(q){p+=(p.indexOf("?")>0?"&":"?")+q}return p},each:function(r,s){var q,p,o;if(r){q=r.length;if(q===b){for(p in r){if(r.hasOwnProperty(p)){if(s(r[p],p)===false){return}}}}else{for(o=0;o<q;o++){if(s(r[o],o)===false){return}}}}},formatSize:function(o){if(o===b||/\D/.test(o)){return g.translate("N/A")}if(o>1073741824){return Math.round(o/1073741824,1)+" GB"}if(o>1048576){return Math.round(o/1048576,1)+" MB"}if(o>1024){return Math.round(o/1024,1)+" KB"}return o+" b"},getPos:function(p,t){var u=0,s=0,w,v=document,q,r;p=p;t=t||v.body;function o(C){var A,B,z=0,D=0;if(C){B=C.getBoundingClientRect();A=v.compatMode==="CSS1Compat"?v.documentElement:v.body;z=B.left+A.scrollLeft;D=B.top+A.scrollTop}return{x:z,y:D}}if(p&&p.getBoundingClientRect&&((navigator.userAgent.indexOf("MSIE")>0)&&(v.documentMode<8))){q=o(p);r=o(t);return{x:q.x-r.x,y:q.y-r.y}}w=p;while(w&&w!=t&&w.nodeType){u+=w.offsetLeft||0;s+=w.offsetTop||0;w=w.offsetParent}w=p.parentNode;while(w&&w!=t&&w.nodeType){u-=w.scrollLeft||0;s-=w.scrollTop||0;w=w.parentNode}return{x:u,y:s}},getSize:function(o){return{w:o.offsetWidth||o.clientWidth,h:o.offsetHeight||o.clientHeight}},parseSize:function(o){var p;if(typeof(o)=="string"){o=/^([0-9]+)([mgk]?)$/.exec(o.toLowerCase().replace(/[^0-9mkg]/g,""));p=o[2];o=+o[1];if(p=="g"){o*=1073741824}if(p=="m"){o*=1048576}if(p=="k"){o*=1024}}return o},xmlEncode:function(o){return o?(""+o).replace(m,function(p){return a[p]?"&"+a[p]+";":p}):o},toArray:function(q){var p,o=[];for(p=0;p<q.length;p++){o[p]=q[p]}return o},inArray:function(q,r){if(r){if(Array.prototype.indexOf){return Array.prototype.indexOf.call(r,q)}for(var o=0,p=r.length;o<p;o++){if(r[o]===q){return o}}}return -1},addI18n:function(o){return g.extend(n,o)},translate:function(o){return n[o]||o},isEmptyObj:function(o){if(o===b){return true}for(var p in o){return false}return true},hasClass:function(q,p){var o;if(q.className==""){return false}o=new RegExp("(^|\\s+)"+p+"(\\s+|$)");return o.test(q.className)},addClass:function(p,o){if(!g.hasClass(p,o)){p.className=p.className==""?o:p.className.replace(/\s+$/,"")+" "+o}},removeClass:function(q,p){var o=new RegExp("(^|\\s+)"+p+"(\\s+|$)");q.className=q.className.replace(o,function(s,r,t){return r===" "&&t===" "?" ":""})},getStyle:function(p,o){if(p.currentStyle){return p.currentStyle[o]}else{if(window.getComputedStyle){return window.getComputedStyle(p,null)[o]}}},addEvent:function(t,o,u){var s,r,q,p;p=arguments[3];o=o.toLowerCase();if(e===b){e="Plupload_"+g.guid()}if(t.addEventListener){s=u;t.addEventListener(o,s,false)}else{if(t.attachEvent){s=function(){var v=window.event;if(!v.target){v.target=v.srcElement}v.preventDefault=h;v.stopPropagation=k;u(v)};t.attachEvent("on"+o,s)}}if(t[e]===b){t[e]=g.guid()}if(!d.hasOwnProperty(t[e])){d[t[e]]={}}r=d[t[e]];if(!r.hasOwnProperty(o)){r[o]=[]}r[o].push({func:s,orig:u,key:p})},removeEvent:function(t,o){var r,u,q;if(typeof(arguments[2])=="function"){u=arguments[2]}else{q=arguments[2]}o=o.toLowerCase();if(t[e]&&d[t[e]]&&d[t[e]][o]){r=d[t[e]][o]}else{return}for(var p=r.length-1;p>=0;p--){if(r[p].key===q||r[p].orig===u){if(t.removeEventListener){t.removeEventListener(o,r[p].func,false)}else{if(t.detachEvent){t.detachEvent("on"+o,r[p].func)}}r[p].orig=null;r[p].func=null;r.splice(p,1);if(u!==b){break}}}if(!r.length){delete d[t[e]][o]}if(g.isEmptyObj(d[t[e]])){delete d[t[e]];try{delete t[e]}catch(s){t[e]=b}}},removeAllEvents:function(p){var o=arguments[1];if(p[e]===b||!p[e]){return}g.each(d[p[e]],function(r,q){g.removeEvent(p,q,o)})}};g.Uploader=function(s){var p={},v,u=[],r,q=false;v=new g.QueueProgress();s=g.extend({chunk_size:0,multipart:true,multi_selection:true,file_data_name:"file",filters:[]},s);function t(){var x,y=0,w;if(this.state==g.STARTED){for(w=0;w<u.length;w++){if(!x&&u[w].status==g.QUEUED){x=u[w];x.status=g.UPLOADING;if(this.trigger("BeforeUpload",x)){this.trigger("UploadFile",x)}}else{y++}}if(y==u.length){this.stop();this.trigger("UploadComplete",u)}}}function o(){var x,w;v.reset();for(x=0;x<u.length;x++){w=u[x];if(w.size!==b){v.size+=w.size;v.loaded+=w.loaded}else{v.size=b}if(w.status==g.DONE){v.uploaded++}else{if(w.status==g.FAILED){v.failed++}else{v.queued++}}}if(v.size===b){v.percent=u.length>0?Math.ceil(v.uploaded/u.length*100):0}else{v.bytesPerSec=Math.ceil(v.loaded/((+new Date()-r||1)/1000));v.percent=v.size>0?Math.ceil(v.loaded/v.size*100):0}}g.extend(this,{state:g.STOPPED,runtime:"",features:{},files:u,settings:s,total:v,id:g.guid(),init:function(){var B=this,C,y,x,A=0,z;if(typeof(s.preinit)=="function"){s.preinit(B)}else{g.each(s.preinit,function(E,D){B.bind(D,E)})}s.page_url=s.page_url||document.location.pathname.replace(/\/[^\/]+$/g,"/");if(!/^(\w+:\/\/|\/)/.test(s.url)){s.url=s.page_url+s.url}s.chunk_size=g.parseSize(s.chunk_size);s.max_file_size=g.parseSize(s.max_file_size);B.bind("FilesAdded",function(D,G){var F,E,I=0,J,H=s.filters;if(H&&H.length){J=[];g.each(H,function(K){g.each(K.extensions.split(/,/),function(L){if(/^\s*\*\s*$/.test(L)){J.push("\\.*")}else{J.push("\\."+L.replace(new RegExp("["+("/^$.*+?|()[]{}\\".replace(/./g,"\\$&"))+"]","g"),"\\$&"))}})});J=new RegExp(J.join("|")+"$","i")}for(F=0;F<G.length;F++){E=G[F];E.loaded=0;E.percent=0;E.status=g.QUEUED;if(J&&!J.test(E.name)){D.trigger("Error",{code:g.FILE_EXTENSION_ERROR,message:g.translate("File extension error."),file:E});continue}if(E.size!==b&&E.size>s.max_file_size){D.trigger("Error",{code:g.FILE_SIZE_ERROR,message:g.translate("File size error."),file:E});continue}u.push(E);I++}if(I){c(function(){B.trigger("QueueChanged");B.refresh()},1)}else{return false}});if(s.unique_names){B.bind("UploadFile",function(D,E){var G=E.name.match(/\.([^.]+)$/),F="tmp";if(G){F=G[1]}E.target_name=E.id+"."+F})}B.bind("UploadProgress",function(D,E){E.percent=E.size>0?Math.ceil(E.loaded/E.size*100):100;o()});B.bind("StateChanged",function(D){if(D.state==g.STARTED){r=(+new Date())}else{if(D.state==g.STOPPED){for(C=D.files.length-1;C>=0;C--){if(D.files[C].status==g.UPLOADING){D.files[C].status=g.QUEUED;o()}}}}});B.bind("QueueChanged",o);B.bind("Error",function(D,E){if(E.file){E.file.status=g.FAILED;o();if(D.state==g.STARTED){c(function(){t.call(B)},1)}}});B.bind("FileUploaded",function(D,E){E.status=g.DONE;E.loaded=E.size;D.trigger("UploadProgress",E);c(function(){t.call(B)},1)});if(s.runtimes){y=[];z=s.runtimes.split(/\s?,\s?/);for(C=0;C<z.length;C++){if(l[z[C]]){y.push(l[z[C]])}}}else{y=l}function w(){var G=y[A++],F,D,E;if(G){F=G.getFeatures();D=B.settings.required_features;if(D){D=D.split(",");for(E=0;E<D.length;E++){if(!F[D[E]]){w();return}}}G.init(B,function(H){if(H&&H.success){B.features=F;B.runtime=G.name;B.trigger("Init",{runtime:G.name});B.trigger("PostInit");B.refresh()}else{w()}})}else{B.trigger("Error",{code:g.INIT_ERROR,message:g.translate("Init error.")})}}w();if(typeof(s.init)=="function"){s.init(B)}else{g.each(s.init,function(E,D){B.bind(D,E)})}},refresh:function(){this.trigger("Refresh")},start:function(){if(u.length&&this.state!=g.STARTED){this.state=g.STARTED;this.trigger("StateChanged");t.call(this)}},stop:function(){if(this.state!=g.STOPPED){this.state=g.STOPPED;this.trigger("CancelUpload");this.trigger("StateChanged")}},disableBrowse:function(){q=arguments[0]!==b?arguments[0]:true;this.trigger("DisableBrowse",q)},getFile:function(x){var w;for(w=u.length-1;w>=0;w--){if(u[w].id===x){return u[w]}}},removeFile:function(x){var w;for(w=u.length-1;w>=0;w--){if(u[w].id===x.id){return this.splice(w,1)[0]}}},splice:function(y,w){var x;x=u.splice(y===b?0:y,w===b?u.length:w);this.trigger("FilesRemoved",x);this.trigger("QueueChanged");return x},trigger:function(x){var z=p[x.toLowerCase()],y,w;if(z){w=Array.prototype.slice.call(arguments);w[0]=this;for(y=0;y<z.length;y++){if(z[y].func.apply(z[y].scope,w)===false){return false}}}return true},hasEventListener:function(w){return !!p[w.toLowerCase()]},bind:function(w,y,x){var z;w=w.toLowerCase();z=p[w]||[];z.push({func:y,scope:x||this});p[w]=z},unbind:function(w){w=w.toLowerCase();var z=p[w],x,y=arguments[1];if(z){if(y!==b){for(x=z.length-1;x>=0;x--){if(z[x].func===y){z.splice(x,1);break}}}else{z=[]}if(!z.length){delete p[w]}}},unbindAll:function(){var w=this;g.each(p,function(y,x){w.unbind(x)})},destroy:function(){this.stop();this.trigger("Destroy");this.unbindAll()}})};g.File=function(r,p,q){var o=this;o.id=r;o.name=p;o.size=q;o.loaded=0;o.percent=0;o.status=0};g.Runtime=function(){this.getFeatures=function(){};this.init=function(o,p){}};g.QueueProgress=function(){var o=this;o.size=0;o.loaded=0;o.uploaded=0;o.failed=0;o.queued=0;o.percent=0;o.bytesPerSec=0;o.reset=function(){o.size=o.loaded=o.uploaded=o.failed=o.queued=o.percent=o.bytesPerSec=0}};g.runtimes={};window.plupload=g})();(function(){if(window.google&&google.gears){return}var a=null;if(typeof GearsFactory!="undefined"){a=new GearsFactory()}else{try{a=new ActiveXObject("Gears.Factory");if(a.getBuildInfo().indexOf("ie_mobile")!=-1){a.privateSetGlobalObject(this)}}catch(b){if((typeof navigator.mimeTypes!="undefined")&&navigator.mimeTypes["application/x-googlegears"]){a=document.createElement("object");a.style.display="none";a.width=0;a.height=0;a.type="application/x-googlegears";document.documentElement.appendChild(a)}}}if(!a){return}if(!window.google){window.google={}}if(!google.gears){google.gears={factory:a}}})();(function(e,b,c,d){var f={};function a(h,k,m){var g,j,l,o;j=google.gears.factory.create("beta.canvas");try{j.decode(h);if(!k.width){k.width=j.width}if(!k.height){k.height=j.height}o=Math.min(width/j.width,height/j.height);if(o<1||(o===1&&m==="image/jpeg")){j.resize(Math.round(j.width*o),Math.round(j.height*o));if(k.quality){return j.encode(m,{quality:k.quality/100})}return j.encode(m)}}catch(n){}return h}c.runtimes.Gears=c.addRuntime("gears",{getFeatures:function(){return{dragdrop:true,jpgresize:true,pngresize:true,chunks:true,progress:true,multipart:true,multi_selection:true}},init:function(l,n){var m,h,g=false;if(!e.google||!google.gears){return n({success:false})}try{m=google.gears.factory.create("beta.desktop")}catch(k){return n({success:false})}function j(q){var p,o,r=[],s;for(o=0;o<q.length;o++){p=q[o];s=c.guid();f[s]=p.blob;r.push(new c.File(s,p.name,p.blob.length))}l.trigger("FilesAdded",r)}l.bind("PostInit",function(){var p=l.settings,o=b.getElementById(p.drop_element);if(o){c.addEvent(o,"dragover",function(q){m.setDropEffect(q,"copy");q.preventDefault()},l.id);c.addEvent(o,"drop",function(r){var q=m.getDragData(r,"application/x-gears-files");if(q){j(q.files)}r.preventDefault()},l.id);o=0}c.addEvent(b.getElementById(p.browse_button),"click",function(u){var t=[],r,q,s;u.preventDefault();if(g){return}no_type_restriction:for(r=0;r<p.filters.length;r++){s=p.filters[r].extensions.split(",");for(q=0;q<s.length;q++){if(s[q]==="*"){t=[];break no_type_restriction}t.push("."+s[q])}}m.openFiles(j,{singleFile:!p.multi_selection,filter:t})},l.id)});l.bind("CancelUpload",function(){if(h.abort){h.abort()}});l.bind("UploadFile",function(u,r){var w=0,v,s,t=0,q=u.settings.resize,o;if(q&&/\.(png|jpg|jpeg)$/i.test(r.name)){f[r.id]=a(f[r.id],q,/\.png$/i.test(r.name)?"image/png":"image/jpeg")}r.size=f[r.id].length;s=u.settings.chunk_size;o=s>0;v=Math.ceil(r.size/s);if(!o){s=r.size;v=1}function p(){var C,y=u.settings.multipart,x=0,B={name:r.target_name||r.name},z=u.settings.url;function A(E){var D,J="----pluploadboundary"+c.guid(),G="--",I="\r\n",F,H;if(y){h.setRequestHeader("Content-Type","multipart/form-data; boundary="+J);D=google.gears.factory.create("beta.blobbuilder");c.each(c.extend(B,u.settings.multipart_params),function(L,K){D.append(G+J+I+'Content-Disposition: form-data; name="'+K+'"'+I+I);D.append(L+I)});H=c.mimeTypes[r.name.replace(/^.+\.([^.]+)/,"$1").toLowerCase()]||"application/octet-stream";D.append(G+J+I+'Content-Disposition: form-data; name="'+u.settings.file_data_name+'"; filename="'+r.name+'"'+I+"Content-Type: "+H+I+I);D.append(E);D.append(I+G+J+G+I);F=D.getAsBlob();x=F.length-E.length;E=F}h.send(E)}if(r.status==c.DONE||r.status==c.FAILED||u.state==c.STOPPED){return}if(o){B.chunk=w;B.chunks=v}C=Math.min(s,r.size-(w*s));if(!y){z=c.buildUrl(u.settings.url,B)}h=google.gears.factory.create("beta.httprequest");h.open("POST",z);if(!y){h.setRequestHeader("Content-Disposition",'attachment; filename="'+r.name+'"');h.setRequestHeader("Content-Type","application/octet-stream")}c.each(u.settings.headers,function(E,D){h.setRequestHeader(D,E)});h.upload.onprogress=function(D){r.loaded=t+D.loaded-x;u.trigger("UploadProgress",r)};h.onreadystatechange=function(){var D;if(h.readyState==4&&u.state!==c.STOPPED){if(h.status==200){D={chunk:w,chunks:v,response:h.responseText,status:h.status};u.trigger("ChunkUploaded",r,D);if(D.cancelled){r.status=c.FAILED;return}t+=C;if(++w>=v){r.status=c.DONE;u.trigger("FileUploaded",r,{response:h.responseText,status:h.status})}else{p()}}else{u.trigger("Error",{code:c.HTTP_ERROR,message:c.translate("HTTP Error."),file:r,chunk:w,chunks:v,status:h.status})}}};if(w<v){A(f[r.id].slice(w*s,C))}}p()});l.bind("DisableBrowse",function(o,p){g=p});l.bind("Destroy",function(o){var p,q,r={browseButton:o.settings.browse_button,dropElm:o.settings.drop_element};for(p in r){q=b.getElementById(r[p]);if(q){c.removeAllEvents(q,o.id)}}});n({success:true})}})})(window,document,plupload);(function(g,b,d,e){var a={},h={};function c(o){var n,m=typeof o,j,l,k;if(o===e||o===null){return"null"}if(m==="string"){n="\bb\tt\nn\ff\rr\"\"''\\\\";return'"'+o.replace(/([\u0080-\uFFFF\x00-\x1f\"])/g,function(r,q){var p=n.indexOf(q);if(p+1){return"\\"+n.charAt(p+1)}r=q.charCodeAt().toString(16);return"\\u"+"0000".substring(r.length)+r})+'"'}if(m=="object"){j=o.length!==e;n="";if(j){for(l=0;l<o.length;l++){if(n){n+=","}n+=c(o[l])}n="["+n+"]"}else{for(k in o){if(o.hasOwnProperty(k)){if(n){n+=","}n+=c(k)+":"+c(o[k])}}n="{"+n+"}"}return n}return""+o}function f(s){var v=false,j=null,o=null,k,l,m,u,n,q=0;try{try{o=new ActiveXObject("AgControl.AgControl");if(o.IsVersionSupported(s)){v=true}o=null}catch(r){var p=navigator.plugins["Silverlight Plug-In"];if(p){k=p.description;if(k==="1.0.30226.2"){k="2.0.30226.2"}l=k.split(".");while(l.length>3){l.pop()}while(l.length<4){l.push(0)}m=s.split(".");while(m.length>4){m.pop()}do{u=parseInt(m[q],10);n=parseInt(l[q],10);q++}while(q<m.length&&u===n);if(u<=n&&!isNaN(u)){v=true}}}}catch(t){v=false}return v}d.silverlight={trigger:function(n,k){var m=a[n],l,j;if(m){j=d.toArray(arguments).slice(1);j[0]="Silverlight:"+k;setTimeout(function(){m.trigger.apply(m,j)},0)}}};d.runtimes.Silverlight=d.addRuntime("silverlight",{getFeatures:function(){return{jpgresize:true,pngresize:true,chunks:true,progress:true,multipart:true,multi_selection:true}},init:function(p,q){var o,m="",n=p.settings.filters,l,k=b.body;if(!f("2.0.31005.0")||(g.opera&&g.opera.buildNumber)){q({success:false});return}h[p.id]=false;a[p.id]=p;o=b.createElement("div");o.id=p.id+"_silverlight_container";d.extend(o.style,{position:"absolute",top:"0px",background:p.settings.shim_bgcolor||"transparent",zIndex:99999,width:"100px",height:"100px",overflow:"hidden",opacity:p.settings.shim_bgcolor||b.documentMode>8?"":0.01});o.className="plupload silverlight";if(p.settings.container){k=b.getElementById(p.settings.container);if(d.getStyle(k,"position")==="static"){k.style.position="relative"}}k.appendChild(o);for(l=0;l<n.length;l++){m+=(m!=""?"|":"")+n[l].title+" | *."+n[l].extensions.replace(/,/g,";*.")}o.innerHTML='<object id="'+p.id+'_silverlight" data="data:application/x-silverlight," type="application/x-silverlight-2" style="outline:none;" width="1024" height="1024"><param name="source" value="'+p.settings.silverlight_xap_url+'"/><param name="background" value="Transparent"/><param name="windowless" value="true"/><param name="enablehtmlaccess" value="true"/><param name="initParams" value="id='+p.id+",filter="+m+",multiselect="+p.settings.multi_selection+'"/></object>';function j(){return b.getElementById(p.id+"_silverlight").content.Upload}p.bind("Silverlight:Init",function(){var r,s={};if(h[p.id]){return}h[p.id]=true;p.bind("Silverlight:StartSelectFiles",function(t){r=[]});p.bind("Silverlight:SelectFile",function(t,w,u,v){var x;x=d.guid();s[x]=w;s[w]=x;r.push(new d.File(x,u,v))});p.bind("Silverlight:SelectSuccessful",function(){if(r.length){p.trigger("FilesAdded",r)}});p.bind("Silverlight:UploadChunkError",function(t,w,u,x,v){p.trigger("Error",{code:d.IO_ERROR,message:"IO Error.",details:v,file:t.getFile(s[w])})});p.bind("Silverlight:UploadFileProgress",function(t,x,u,w){var v=t.getFile(s[x]);if(v.status!=d.FAILED){v.size=w;v.loaded=u;t.trigger("UploadProgress",v)}});p.bind("Refresh",function(t){var u,v,w;u=b.getElementById(t.settings.browse_button);if(u){v=d.getPos(u,b.getElementById(t.settings.container));w=d.getSize(u);d.extend(b.getElementById(t.id+"_silverlight_container").style,{top:v.y+"px",left:v.x+"px",width:w.w+"px",height:w.h+"px"})}});p.bind("Silverlight:UploadChunkSuccessful",function(t,w,u,z,y){var x,v=t.getFile(s[w]);x={chunk:u,chunks:z,response:y};t.trigger("ChunkUploaded",v,x);if(v.status!=d.FAILED&&t.state!==d.STOPPED){j().UploadNextChunk()}if(u==z-1){v.status=d.DONE;t.trigger("FileUploaded",v,{response:y})}});p.bind("Silverlight:UploadSuccessful",function(t,w,u){var v=t.getFile(s[w]);v.status=d.DONE;t.trigger("FileUploaded",v,{response:u})});p.bind("FilesRemoved",function(t,v){var u;for(u=0;u<v.length;u++){j().RemoveFile(s[v[u].id])}});p.bind("UploadFile",function(t,v){var w=t.settings,u=w.resize||{};j().UploadFile(s[v.id],t.settings.url,c({name:v.target_name||v.name,mime:d.mimeTypes[v.name.replace(/^.+\.([^.]+)/,"$1").toLowerCase()]||"application/octet-stream",chunk_size:w.chunk_size,image_width:u.width,image_height:u.height,image_quality:u.quality||90,multipart:!!w.multipart,multipart_params:w.multipart_params||{},file_data_name:w.file_data_name,headers:w.headers}))});p.bind("CancelUpload",function(){j().CancelUpload()});p.bind("Silverlight:MouseEnter",function(t){var u,v;u=b.getElementById(p.settings.browse_button);v=t.settings.browse_button_hover;if(u&&v){d.addClass(u,v)}});p.bind("Silverlight:MouseLeave",function(t){var u,v;u=b.getElementById(p.settings.browse_button);v=t.settings.browse_button_hover;if(u&&v){d.removeClass(u,v)}});p.bind("Silverlight:MouseLeftButtonDown",function(t){var u,v;u=b.getElementById(p.settings.browse_button);v=t.settings.browse_button_active;if(u&&v){d.addClass(u,v);d.addEvent(b.body,"mouseup",function(){d.removeClass(u,v)})}});p.bind("Sliverlight:StartSelectFiles",function(t){var u,v;u=b.getElementById(p.settings.browse_button);v=t.settings.browse_button_active;if(u&&v){d.removeClass(u,v)}});p.bind("DisableBrowse",function(t,u){j().DisableBrowse(u)});p.bind("Destroy",function(t){var u;d.removeAllEvents(b.body,t.id);delete h[t.id];delete a[t.id];u=b.getElementById(t.id+"_silverlight_container");if(u){k.removeChild(u)}});q({success:true})})}})})(window,document,plupload);(function(f,b,d,e){var a={},g={};function c(){var h;try{h=navigator.plugins["Shockwave Flash"];h=h.description}catch(k){try{h=new ActiveXObject("ShockwaveFlash.ShockwaveFlash").GetVariable("$version")}catch(j){h="0.0"}}h=h.match(/\d+/g);return parseFloat(h[0]+"."+h[1])}d.flash={trigger:function(k,h,j){setTimeout(function(){var n=a[k],m,l;if(n){n.trigger("Flash:"+h,j)}},0)}};d.runtimes.Flash=d.addRuntime("flash",{getFeatures:function(){return{jpgresize:true,pngresize:true,maxWidth:8091,maxHeight:8091,chunks:true,progress:true,multipart:true,multi_selection:true}},init:function(n,p){var l,m,h=0,j=b.body;if(c()<10){p({success:false});return}g[n.id]=false;a[n.id]=n;l=b.getElementById(n.settings.browse_button);m=b.createElement("div");m.id=n.id+"_flash_container";d.extend(m.style,{position:"absolute",top:"0px",background:n.settings.shim_bgcolor||"transparent",zIndex:99999,width:"100%",height:"100%"});m.className="plupload flash";if(n.settings.container){j=b.getElementById(n.settings.container);if(d.getStyle(j,"position")==="static"){j.style.position="relative"}}j.appendChild(m);(function(){var q,r;q='<object id="'+n.id+'_flash" type="application/x-shockwave-flash" data="'+n.settings.flash_swf_url+'" ';if(d.ua.ie){q+='classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" '}q+='width="100%" height="100%" style="outline:0"><param name="movie" value="'+n.settings.flash_swf_url+'" /><param name="flashvars" value="id='+escape(n.id)+'" /><param name="wmode" value="transparent" /><param name="allowscriptaccess" value="always" /></object>';if(d.ua.ie){r=b.createElement("div");m.appendChild(r);r.outerHTML=q;r=null}else{m.innerHTML=q}}());function o(){return b.getElementById(n.id+"_flash")}function k(){if(h++>5000){p({success:false});return}if(g[n.id]===false){setTimeout(k,1)}}k();l=m=null;n.bind("Destroy",function(q){var r;d.removeAllEvents(b.body,q.id);delete g[q.id];delete a[q.id];r=b.getElementById(q.id+"_flash_container");if(r){j.removeChild(r)}});n.bind("Flash:Init",function(){var s={},r;try{o().setFileFilters(n.settings.filters,n.settings.multi_selection)}catch(q){p({success:false});return}if(g[n.id]){return}g[n.id]=true;n.bind("UploadFile",function(t,v){var w=t.settings,u=n.settings.resize||{};o().uploadFile(s[v.id],w.url,{name:v.target_name||v.name,mime:d.mimeTypes[v.name.replace(/^.+\.([^.]+)/,"$1").toLowerCase()]||"application/octet-stream",chunk_size:w.chunk_size,width:u.width,height:u.height,quality:u.quality,multipart:w.multipart,multipart_params:w.multipart_params||{},file_data_name:w.file_data_name,format:/\.(jpg|jpeg)$/i.test(v.name)?"jpg":"png",headers:w.headers,urlstream_upload:w.urlstream_upload})});n.bind("CancelUpload",function(){o().cancelUpload()});n.bind("Flash:UploadProcess",function(u,t){var v=u.getFile(s[t.id]);if(v.status!=d.FAILED){v.loaded=t.loaded;v.size=t.size;u.trigger("UploadProgress",v)}});n.bind("Flash:UploadChunkComplete",function(t,v){var w,u=t.getFile(s[v.id]);w={chunk:v.chunk,chunks:v.chunks,response:v.text};t.trigger("ChunkUploaded",u,w);if(u.status!==d.FAILED&&t.state!==d.STOPPED){o().uploadNextChunk()}if(v.chunk==v.chunks-1){u.status=d.DONE;t.trigger("FileUploaded",u,{response:v.text})}});n.bind("Flash:SelectFiles",function(t,w){var v,u,x=[],y;for(u=0;u<w.length;u++){v=w[u];y=d.guid();s[y]=v.id;s[v.id]=y;x.push(new d.File(y,v.name,v.size))}if(x.length){n.trigger("FilesAdded",x)}});n.bind("Flash:SecurityError",function(t,u){n.trigger("Error",{code:d.SECURITY_ERROR,message:d.translate("Security error."),details:u.message,file:n.getFile(s[u.id])})});n.bind("Flash:GenericError",function(t,u){n.trigger("Error",{code:d.GENERIC_ERROR,message:d.translate("Generic error."),details:u.message,file:n.getFile(s[u.id])})});n.bind("Flash:IOError",function(t,u){n.trigger("Error",{code:d.IO_ERROR,message:d.translate("IO error."),details:u.message,file:n.getFile(s[u.id])})});n.bind("Flash:ImageError",function(t,u){n.trigger("Error",{code:parseInt(u.code,10),message:d.translate("Image error."),file:n.getFile(s[u.id])})});n.bind("Flash:StageEvent:rollOver",function(t){var u,v;u=b.getElementById(n.settings.browse_button);v=t.settings.browse_button_hover;if(u&&v){d.addClass(u,v)}});n.bind("Flash:StageEvent:rollOut",function(t){var u,v;u=b.getElementById(n.settings.browse_button);v=t.settings.browse_button_hover;if(u&&v){d.removeClass(u,v)}});n.bind("Flash:StageEvent:mouseDown",function(t){var u,v;u=b.getElementById(n.settings.browse_button);v=t.settings.browse_button_active;if(u&&v){d.addClass(u,v);d.addEvent(b.body,"mouseup",function(){d.removeClass(u,v)},t.id)}});n.bind("Flash:StageEvent:mouseUp",function(t){var u,v;u=b.getElementById(n.settings.browse_button);v=t.settings.browse_button_active;if(u&&v){d.removeClass(u,v)}});n.bind("Flash:ExifData",function(t,u){n.trigger("ExifData",n.getFile(s[u.id]),u.data)});n.bind("Flash:GpsData",function(t,u){n.trigger("GpsData",n.getFile(s[u.id]),u.data)});n.bind("QueueChanged",function(t){n.refresh()});n.bind("FilesRemoved",function(t,v){var u;for(u=0;u<v.length;u++){o().removeFile(s[v[u].id])}});n.bind("StateChanged",function(t){n.refresh()});n.bind("Refresh",function(t){var u,v,w;o().setFileFilters(n.settings.filters,n.settings.multi_selection);u=b.getElementById(t.settings.browse_button);if(u){v=d.getPos(u,b.getElementById(t.settings.container));w=d.getSize(u);d.extend(b.getElementById(t.id+"_flash_container").style,{top:v.y+"px",left:v.x+"px",width:w.w+"px",height:w.h+"px"})}});n.bind("DisableBrowse",function(t,u){o().disableBrowse(u)});p({success:true})})}})})(window,document,plupload);(function(a){a.runtimes.BrowserPlus=a.addRuntime("browserplus",{getFeatures:function(){return{dragdrop:true,jpgresize:true,pngresize:true,chunks:true,progress:true,multipart:true,multi_selection:true}},init:function(g,j){var e=window.BrowserPlus,h={},d=g.settings,c=d.resize;function f(o){var n,m,k=[],l,p;for(m=0;m<o.length;m++){l=o[m];p=a.guid();h[p]=l;k.push(new a.File(p,l.name,l.size))}if(m){g.trigger("FilesAdded",k)}}function b(){var k=false;g.bind("PostInit",function(){var o,m=d.drop_element,q=g.id+"_droptarget",l=document.getElementById(m),n;function r(t,s){e.DragAndDrop.AddDropTarget({id:t},function(u){e.DragAndDrop.AttachCallbacks({id:t,hover:function(v){if(!v&&s){s()}},drop:function(v){if(s){s()}f(v)}},function(){})})}function p(){document.getElementById(q).style.top="-1000px"}if(l){if(document.attachEvent&&(/MSIE/gi).test(navigator.userAgent)){o=document.createElement("div");o.setAttribute("id",q);a.extend(o.style,{position:"absolute",top:"-1000px",background:"red",filter:"alpha(opacity=0)",opacity:0});document.body.appendChild(o);a.addEvent(l,"dragenter",function(t){var s,u;s=document.getElementById(m);u=a.getPos(s);a.extend(document.getElementById(q).style,{top:u.y+"px",left:u.x+"px",width:s.offsetWidth+"px",height:s.offsetHeight+"px"})});r(q,p)}else{r(m)}}a.addEvent(document.getElementById(d.browse_button),"click",function(y){var s=[],u,t,x=d.filters,w,v;y.preventDefault();if(k){return}no_type_restriction:for(u=0;u<x.length;u++){w=x[u].extensions.split(",");for(t=0;t<w.length;t++){if(w[t]==="*"){s=[];break no_type_restriction}v=a.mimeTypes[w[t]];if(v&&a.inArray(v,s)===-1){s.push(a.mimeTypes[w[t]])}}}e.FileBrowse.OpenBrowseDialog({mimeTypes:s},function(z){if(z.success){f(z.value)}})});l=o=null});g.bind("CancelUpload",function(){e.Uploader.cancel({},function(){})});g.bind("DisableBrowse",function(l,m){k=m});g.bind("UploadFile",function(o,l){var n=h[l.id],t={},m=o.settings.chunk_size,p,q=[];function s(u,w){var v;if(l.status==a.FAILED){return}t.name=l.target_name||l.name;if(m){t.chunk=""+u;t.chunks=""+w}v=q.shift();e.Uploader.upload({url:o.settings.url,files:{file:v},cookies:document.cookies,postvars:a.extend(t,o.settings.multipart_params),progressCallback:function(z){var y,x=0;p[u]=parseInt(z.filePercent*v.size/100,10);for(y=0;y<p.length;y++){x+=p[y]}l.loaded=x;o.trigger("UploadProgress",l)}},function(y){var x,z;if(y.success){x=y.value.statusCode;if(m){o.trigger("ChunkUploaded",l,{chunk:u,chunks:w,response:y.value.body,status:x})}if(q.length>0){s(++u,w)}else{l.status=a.DONE;o.trigger("FileUploaded",l,{response:y.value.body,status:x});if(x>=400){o.trigger("Error",{code:a.HTTP_ERROR,message:a.translate("HTTP Error."),file:l,status:x})}}}else{o.trigger("Error",{code:a.GENERIC_ERROR,message:a.translate("Generic Error."),file:l,details:y.error})}})}function r(u){l.size=u.size;if(m){e.FileAccess.chunk({file:u,chunkSize:m},function(x){if(x.success){var y=x.value,v=y.length;p=Array(v);for(var w=0;w<v;w++){p[w]=0;q.push(y[w])}s(0,v)}})}else{p=Array(1);q.push(u);s(0,1)}}if(c&&/\.(png|jpg|jpeg)$/i.test(l.name)){BrowserPlus.ImageAlter.transform({file:n,quality:c.quality||90,actions:[{scale:{maxwidth:c.width,maxheight:c.height}}]},function(u){if(u.success){r(u.value.file)}})}else{r(n)}});j({success:true})}if(e){e.init(function(l){var k=[{service:"Uploader",version:"3"},{service:"DragAndDrop",version:"1"},{service:"FileBrowse",version:"1"},{service:"FileAccess",version:"2"}];if(c){k.push({service:"ImageAlter",version:"4"})}if(l.success){e.require({services:k},function(m){if(m.success){b()}else{j()}})}else{j()}})}else{j()}}})})(plupload);(function(h,k,j,e){var c={},g;function m(o,p){var n;if("FileReader" in h){n=new FileReader();n.readAsDataURL(o);n.onload=function(){p(n.result)}}else{return p(o.getAsDataURL())}}function l(o,p){var n;if("FileReader" in h){n=new FileReader();n.readAsBinaryString(o);n.onload=function(){p(n.result)}}else{return p(o.getAsBinary())}}function d(r,p,n,v){var q,o,u,s,t=this;m(c[r.id],function(w){q=k.createElement("canvas");q.style.display="none";k.body.appendChild(q);o=q.getContext("2d");u=new Image();u.onerror=u.onabort=function(){v({success:false})};u.onload=function(){var B,x,z,y,A;if(!p.width){p.width=u.width}if(!p.height){p.height=u.height}s=Math.min(p.width/u.width,p.height/u.height);if(s<1||(s===1&&n==="image/jpeg")){B=Math.round(u.width*s);x=Math.round(u.height*s);q.width=B;q.height=x;o.drawImage(u,0,0,B,x);if(n==="image/jpeg"){y=new f(atob(w.substring(w.indexOf("base64,")+7)));if(y.headers&&y.headers.length){A=new a();if(A.init(y.get("exif")[0])){A.setExif("PixelXDimension",B);A.setExif("PixelYDimension",x);y.set("exif",A.getBinary());if(t.hasEventListener("ExifData")){t.trigger("ExifData",r,A.EXIF())}if(t.hasEventListener("GpsData")){t.trigger("GpsData",r,A.GPS())}}}if(p.quality){try{w=q.toDataURL(n,p.quality/100)}catch(C){w=q.toDataURL(n)}}}else{w=q.toDataURL(n)}w=w.substring(w.indexOf("base64,")+7);w=atob(w);if(y&&y.headers&&y.headers.length){w=y.restore(w);y.purge()}q.parentNode.removeChild(q);v({success:true,data:w})}else{v({success:false})}};u.src=w})}j.runtimes.Html5=j.addRuntime("html5",{getFeatures:function(){var s,o,r,q,p,n;o=r=p=n=false;if(h.XMLHttpRequest){s=new XMLHttpRequest();r=!!s.upload;o=!!(s.sendAsBinary||s.upload)}if(o){q=!!(s.sendAsBinary||(h.Uint8Array&&h.ArrayBuffer));p=!!(File&&(File.prototype.getAsDataURL||h.FileReader)&&q);n=!!(File&&(File.prototype.mozSlice||File.prototype.webkitSlice||File.prototype.slice))}g=j.ua.safari&&j.ua.windows;return{html5:o,dragdrop:(function(){var t=k.createElement("div");return("draggable" in t)||("ondragstart" in t&&"ondrop" in t)}()),jpgresize:p,pngresize:p,multipart:p||!!h.FileReader||!!h.FormData,canSendBinary:q,cantSendBlobInFormData:!!(j.ua.gecko&&h.FormData&&h.FileReader&&!FileReader.prototype.readAsArrayBuffer),progress:r,chunks:n,multi_selection:!(j.ua.safari&&j.ua.windows),triggerDialog:(j.ua.gecko&&h.FormData||j.ua.webkit)}},init:function(p,r){var n,q;function o(w){var u,t,v=[],x,s={};for(t=0;t<w.length;t++){u=w[t];if(s[u.name]){continue}s[u.name]=true;x=j.guid();c[x]=u;v.push(new j.File(x,u.fileName||u.name,u.fileSize||u.size))}if(v.length){p.trigger("FilesAdded",v)}}n=this.getFeatures();if(!n.html5){r({success:false});return}p.bind("Init",function(w){var G,F,C=[],v,D,t=w.settings.filters,u,B,s=k.body,E;G=k.createElement("div");G.id=w.id+"_html5_container";j.extend(G.style,{position:"absolute",background:p.settings.shim_bgcolor||"transparent",width:"100px",height:"100px",overflow:"hidden",zIndex:99999,opacity:p.settings.shim_bgcolor?"":0});G.className="plupload html5";if(p.settings.container){s=k.getElementById(p.settings.container);if(j.getStyle(s,"position")==="static"){s.style.position="relative"}}s.appendChild(G);no_type_restriction:for(v=0;v<t.length;v++){u=t[v].extensions.split(/,/);for(D=0;D<u.length;D++){if(u[D]==="*"){C=[];break no_type_restriction}B=j.mimeTypes[u[D]];if(B&&j.inArray(B,C)===-1){C.push(B)}}}G.innerHTML='<input id="'+p.id+'_html5"  style="font-size:999px" type="file" accept="'+C.join(",")+'" '+(p.settings.multi_selection&&p.features.multi_selection?'multiple="multiple"':"")+" />";G.scrollTop=100;E=k.getElementById(p.id+"_html5");if(w.features.triggerDialog){j.extend(E.style,{position:"absolute",width:"100%",height:"100%"})}else{j.extend(E.style,{cssFloat:"right",styleFloat:"right"})}E.onchange=function(){o(this.files);this.value=""};F=k.getElementById(w.settings.browse_button);if(F){var z=w.settings.browse_button_hover,A=w.settings.browse_button_active,x=w.features.triggerDialog?F:G;if(z){j.addEvent(x,"mouseover",function(){j.addClass(F,z)},w.id);j.addEvent(x,"mouseout",function(){j.removeClass(F,z)},w.id)}if(A){j.addEvent(x,"mousedown",function(){j.addClass(F,A)},w.id);j.addEvent(k.body,"mouseup",function(){j.removeClass(F,A)},w.id)}if(w.features.triggerDialog){j.addEvent(F,"click",function(H){var y=k.getElementById(w.id+"_html5");if(y&&!y.disabled){y.click()}H.preventDefault()},w.id)}}});p.bind("PostInit",function(){var s=k.getElementById(p.settings.drop_element);if(s){if(g){j.addEvent(s,"dragenter",function(w){var v,t,u;v=k.getElementById(p.id+"_drop");if(!v){v=k.createElement("input");v.setAttribute("type","file");v.setAttribute("id",p.id+"_drop");v.setAttribute("multiple","multiple");j.addEvent(v,"change",function(){o(this.files);j.removeEvent(v,"change",p.id);v.parentNode.removeChild(v)},p.id);s.appendChild(v)}t=j.getPos(s,k.getElementById(p.settings.container));u=j.getSize(s);if(j.getStyle(s,"position")==="static"){j.extend(s.style,{position:"relative"})}j.extend(v.style,{position:"absolute",display:"block",top:0,left:0,width:u.w+"px",height:u.h+"px",opacity:0})},p.id);return}j.addEvent(s,"dragover",function(t){t.preventDefault()},p.id);j.addEvent(s,"drop",function(u){var t=u.dataTransfer;if(t&&t.files){o(t.files)}u.preventDefault()},p.id)}});p.bind("Refresh",function(s){var t,u,v,x,w;t=k.getElementById(p.settings.browse_button);if(t){u=j.getPos(t,k.getElementById(s.settings.container));v=j.getSize(t);x=k.getElementById(p.id+"_html5_container");j.extend(x.style,{top:u.y+"px",left:u.x+"px",width:v.w+"px",height:v.h+"px"});if(p.features.triggerDialog){if(j.getStyle(t,"position")==="static"){j.extend(t.style,{position:"relative"})}w=parseInt(j.getStyle(t,"z-index"),10);if(isNaN(w)){w=0}j.extend(t.style,{zIndex:w});j.extend(x.style,{zIndex:w-1})}}});p.bind("DisableBrowse",function(s,u){var t=k.getElementById(s.id+"_html5");if(t){t.disabled=u}});p.bind("CancelUpload",function(){if(q&&q.abort){q.abort()}});p.bind("UploadFile",function(s,u){var v=s.settings,y,t;function x(A,D,z){var B;if(File.prototype.slice){try{A.slice();return A.slice(D,z)}catch(C){return A.slice(D,z-D)}}else{if(B=File.prototype.webkitSlice||File.prototype.mozSlice){return B.call(A,D,z)}else{return null}}}function w(A){var D=0,C=0,z=("FileReader" in h)?new FileReader:null;function B(){var I,M,K,L,H,J,F,E=s.settings.url;function G(V){var T=0,N="----pluploadboundary"+j.guid(),O,P="--",U="\r\n",R="";q=new XMLHttpRequest;if(q.upload){q.upload.onprogress=function(W){u.loaded=Math.min(u.size,C+W.loaded-T);s.trigger("UploadProgress",u)}}q.onreadystatechange=function(){var W,Y;if(q.readyState==4&&s.state!==j.STOPPED){try{W=q.status}catch(X){W=0}if(W>=400){s.trigger("Error",{code:j.HTTP_ERROR,message:j.translate("HTTP Error."),file:u,status:W})}else{if(K){Y={chunk:D,chunks:K,response:q.responseText,status:W};s.trigger("ChunkUploaded",u,Y);C+=J;if(Y.cancelled){u.status=j.FAILED;return}u.loaded=Math.min(u.size,(D+1)*H)}else{u.loaded=u.size}s.trigger("UploadProgress",u);V=I=O=R=null;if(!K||++D>=K){u.status=j.DONE;s.trigger("FileUploaded",u,{response:q.responseText,status:W})}else{B()}}}};if(s.settings.multipart&&n.multipart){L.name=u.target_name||u.name;q.open("post",E,true);j.each(s.settings.headers,function(X,W){q.setRequestHeader(W,X)});if(typeof(V)!=="string"&&!!h.FormData){O=new FormData();j.each(j.extend(L,s.settings.multipart_params),function(X,W){O.append(W,X)});O.append(s.settings.file_data_name,V);q.send(O);return}if(typeof(V)==="string"){q.setRequestHeader("Content-Type","multipart/form-data; boundary="+N);j.each(j.extend(L,s.settings.multipart_params),function(X,W){R+=P+N+U+'Content-Disposition: form-data; name="'+W+'"'+U+U;R+=unescape(encodeURIComponent(X))+U});F=j.mimeTypes[u.name.replace(/^.+\.([^.]+)/,"$1").toLowerCase()]||"application/octet-stream";R+=P+N+U+'Content-Disposition: form-data; name="'+s.settings.file_data_name+'"; filename="'+unescape(encodeURIComponent(u.name))+'"'+U+"Content-Type: "+F+U+U+V+U+P+N+P+U;T=R.length-V.length;V=R;if(q.sendAsBinary){q.sendAsBinary(V)}else{if(n.canSendBinary){var S=new Uint8Array(V.length);for(var Q=0;Q<V.length;Q++){S[Q]=(V.charCodeAt(Q)&255)}q.send(S.buffer)}}return}}E=j.buildUrl(s.settings.url,j.extend(L,s.settings.multipart_params));q.open("post",E,true);q.setRequestHeader("Content-Type","application/octet-stream");j.each(s.settings.headers,function(X,W){q.setRequestHeader(W,X)});q.send(V)}if(u.status==j.DONE||u.status==j.FAILED||s.state==j.STOPPED){return}L={name:u.target_name||u.name};if(v.chunk_size&&u.size>v.chunk_size&&(n.chunks||typeof(A)=="string")){H=v.chunk_size;K=Math.ceil(u.size/H);J=Math.min(H,u.size-(D*H));if(typeof(A)=="string"){I=A.substring(D*H,D*H+J)}else{I=x(A,D*H,D*H+J)}L.chunk=D;L.chunks=K}else{J=u.size;I=A}if(s.settings.multipart&&n.multipart&&typeof(I)!=="string"&&z&&n.cantSendBlobInFormData&&n.chunks&&s.settings.chunk_size){z.onload=function(){G(z.result)};z.readAsBinaryString(I)}else{G(I)}}B()}y=c[u.id];if(n.jpgresize&&s.settings.resize&&/\.(png|jpg|jpeg)$/i.test(u.name)){d.call(s,u,s.settings.resize,/\.png$/i.test(u.name)?"image/png":"image/jpeg",function(z){if(z.success){u.size=z.data.length;w(z.data)}else{if(n.chunks){w(y)}else{l(y,w)}}})}else{if(!n.chunks&&n.jpgresize){l(y,w)}else{w(y)}}});p.bind("Destroy",function(s){var u,v,t=k.body,w={inputContainer:s.id+"_html5_container",inputFile:s.id+"_html5",browseButton:s.settings.browse_button,dropElm:s.settings.drop_element};for(u in w){v=k.getElementById(w[u]);if(v){j.removeAllEvents(v,s.id)}}j.removeAllEvents(k.body,s.id);if(s.settings.container){t=k.getElementById(s.settings.container)}t.removeChild(k.getElementById(w.inputContainer))});r({success:true})}});function b(){var q=false,o;function r(t,v){var s=q?0:-8*(v-1),w=0,u;for(u=0;u<v;u++){w|=(o.charCodeAt(t+u)<<Math.abs(s+u*8))}return w}function n(u,s,t){var t=arguments.length===3?t:o.length-s-1;o=o.substr(0,s)+u+o.substr(t+s)}function p(t,u,w){var x="",s=q?0:-8*(w-1),v;for(v=0;v<w;v++){x+=String.fromCharCode((u>>Math.abs(s+v*8))&255)}n(x,t,w)}return{II:function(s){if(s===e){return q}else{q=s}},init:function(s){q=false;o=s},SEGMENT:function(s,u,t){switch(arguments.length){case 1:return o.substr(s,o.length-s-1);case 2:return o.substr(s,u);case 3:n(t,s,u);break;default:return o}},BYTE:function(s){return r(s,1)},SHORT:function(s){return r(s,2)},LONG:function(s,t){if(t===e){return r(s,4)}else{p(s,t,4)}},SLONG:function(s){var t=r(s,4);return(t>2147483647?t-4294967296:t)},STRING:function(s,t){var u="";for(t+=s;s<t;s++){u+=String.fromCharCode(r(s,1))}return u}}}function f(s){var u={65505:{app:"EXIF",name:"APP1",signature:"Exif\0"},65506:{app:"ICC",name:"APP2",signature:"ICC_PROFILE\0"},65517:{app:"IPTC",name:"APP13",signature:"Photoshop 3.0\0"}},t=[],r,n,p=e,q=0,o;r=new b();r.init(s);if(r.SHORT(0)!==65496){return}n=2;o=Math.min(1048576,s.length);while(n<=o){p=r.SHORT(n);if(p>=65488&&p<=65495){n+=2;continue}if(p===65498||p===65497){break}q=r.SHORT(n+2)+2;if(u[p]&&r.STRING(n+4,u[p].signature.length)===u[p].signature){t.push({hex:p,app:u[p].app.toUpperCase(),name:u[p].name.toUpperCase(),start:n,length:q,segment:r.SEGMENT(n,q)})}n+=q}r.init(null);return{headers:t,restore:function(y){r.init(y);var w=new f(y);if(!w.headers){return false}for(var x=w.headers.length;x>0;x--){var z=w.headers[x-1];r.SEGMENT(z.start,z.length,"")}w.purge();n=r.SHORT(2)==65504?4+r.SHORT(4):2;for(var x=0,v=t.length;x<v;x++){r.SEGMENT(n,0,t[x].segment);n+=t[x].length}return r.SEGMENT()},get:function(x){var y=[];for(var w=0,v=t.length;w<v;w++){if(t[w].app===x.toUpperCase()){y.push(t[w].segment)}}return y},set:function(y,x){var z=[];if(typeof(x)==="string"){z.push(x)}else{z=x}for(var w=ii=0,v=t.length;w<v;w++){if(t[w].app===y.toUpperCase()){t[w].segment=z[ii];t[w].length=z[ii].length;ii++}if(ii>=z.length){break}}},purge:function(){t=[];r.init(null)}}}function a(){var q,n,o={},t;q=new b();n={tiff:{274:"Orientation",34665:"ExifIFDPointer",34853:"GPSInfoIFDPointer"},exif:{36864:"ExifVersion",40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelYDimension",36867:"DateTimeOriginal",33434:"ExposureTime",33437:"FNumber",34855:"ISOSpeedRatings",37377:"ShutterSpeedValue",37378:"ApertureValue",37383:"MeteringMode",37384:"LightSource",37385:"Flash",41986:"ExposureMode",41987:"WhiteBalance",41990:"SceneCaptureType",41988:"DigitalZoomRatio",41992:"Contrast",41993:"Saturation",41994:"Sharpness"},gps:{0:"GPSVersionID",1:"GPSLatitudeRef",2:"GPSLatitude",3:"GPSLongitudeRef",4:"GPSLongitude"}};t={ColorSpace:{1:"sRGB",0:"Uncalibrated"},MeteringMode:{0:"Unknown",1:"Average",2:"CenterWeightedAverage",3:"Spot",4:"MultiSpot",5:"Pattern",6:"Partial",255:"Other"},LightSource:{1:"Daylight",2:"Fliorescent",3:"Tungsten",4:"Flash",9:"Fine weather",10:"Cloudy weather",11:"Shade",12:"Daylight fluorescent (D 5700 - 7100K)",13:"Day white fluorescent (N 4600 -5400K)",14:"Cool white fluorescent (W 3900 - 4500K)",15:"White fluorescent (WW 3200 - 3700K)",17:"Standard light A",18:"Standard light B",19:"Standard light C",20:"D55",21:"D65",22:"D75",23:"D50",24:"ISO studio tungsten",255:"Other"},Flash:{0:"Flash did not fire.",1:"Flash fired.",5:"Strobe return light not detected.",7:"Strobe return light detected.",9:"Flash fired, compulsory flash mode",13:"Flash fired, compulsory flash mode, return light not detected",15:"Flash fired, compulsory flash mode, return light detected",16:"Flash did not fire, compulsory flash mode",24:"Flash did not fire, auto mode",25:"Flash fired, auto mode",29:"Flash fired, auto mode, return light not detected",31:"Flash fired, auto mode, return light detected",32:"No flash function",65:"Flash fired, red-eye reduction mode",69:"Flash fired, red-eye reduction mode, return light not detected",71:"Flash fired, red-eye reduction mode, return light detected",73:"Flash fired, compulsory flash mode, red-eye reduction mode",77:"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",79:"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",89:"Flash fired, auto mode, red-eye reduction mode",93:"Flash fired, auto mode, return light not detected, red-eye reduction mode",95:"Flash fired, auto mode, return light detected, red-eye reduction mode"},ExposureMode:{0:"Auto exposure",1:"Manual exposure",2:"Auto bracket"},WhiteBalance:{0:"Auto white balance",1:"Manual white balance"},SceneCaptureType:{0:"Standard",1:"Landscape",2:"Portrait",3:"Night scene"},Contrast:{0:"Normal",1:"Soft",2:"Hard"},Saturation:{0:"Normal",1:"Low saturation",2:"High saturation"},Sharpness:{0:"Normal",1:"Soft",2:"Hard"},GPSLatitudeRef:{N:"North latitude",S:"South latitude"},GPSLongitudeRef:{E:"East longitude",W:"West longitude"}};function p(u,C){var w=q.SHORT(u),z,F,G,B,A,v,x,D,E=[],y={};for(z=0;z<w;z++){x=v=u+12*z+2;G=C[q.SHORT(x)];if(G===e){continue}B=q.SHORT(x+=2);A=q.LONG(x+=2);x+=4;E=[];switch(B){case 1:case 7:if(A>4){x=q.LONG(x)+o.tiffHeader}for(F=0;F<A;F++){E[F]=q.BYTE(x+F)}break;case 2:if(A>4){x=q.LONG(x)+o.tiffHeader}y[G]=q.STRING(x,A-1);continue;case 3:if(A>2){x=q.LONG(x)+o.tiffHeader}for(F=0;F<A;F++){E[F]=q.SHORT(x+F*2)}break;case 4:if(A>1){x=q.LONG(x)+o.tiffHeader}for(F=0;F<A;F++){E[F]=q.LONG(x+F*4)}break;case 5:x=q.LONG(x)+o.tiffHeader;for(F=0;F<A;F++){E[F]=q.LONG(x+F*4)/q.LONG(x+F*4+4)}break;case 9:x=q.LONG(x)+o.tiffHeader;for(F=0;F<A;F++){E[F]=q.SLONG(x+F*4)}break;case 10:x=q.LONG(x)+o.tiffHeader;for(F=0;F<A;F++){E[F]=q.SLONG(x+F*4)/q.SLONG(x+F*4+4)}break;default:continue}D=(A==1?E[0]:E);if(t.hasOwnProperty(G)&&typeof D!="object"){y[G]=t[G][D]}else{y[G]=D}}return y}function s(){var v=e,u=o.tiffHeader;q.II(q.SHORT(u)==18761);if(q.SHORT(u+=2)!==42){return false}o.IFD0=o.tiffHeader+q.LONG(u+=2);v=p(o.IFD0,n.tiff);o.exifIFD=("ExifIFDPointer" in v?o.tiffHeader+v.ExifIFDPointer:e);o.gpsIFD=("GPSInfoIFDPointer" in v?o.tiffHeader+v.GPSInfoIFDPointer:e);return true}function r(w,u,z){var B,y,x,A=0;if(typeof(u)==="string"){var v=n[w.toLowerCase()];for(hex in v){if(v[hex]===u){u=hex;break}}}B=o[w.toLowerCase()+"IFD"];y=q.SHORT(B);for(i=0;i<y;i++){x=B+12*i+2;if(q.SHORT(x)==u){A=x+8;break}}if(!A){return false}q.LONG(A,z);return true}return{init:function(u){o={tiffHeader:10};if(u===e||!u.length){return false}q.init(u);if(q.SHORT(0)===65505&&q.STRING(4,5).toUpperCase()==="EXIF\0"){return s()}return false},EXIF:function(){var v;v=p(o.exifIFD,n.exif);if(v.ExifVersion&&j.typeOf(v.ExifVersion)==="array"){for(var w=0,u="";w<v.ExifVersion.length;w++){u+=String.fromCharCode(v.ExifVersion[w])}v.ExifVersion=u}return v},GPS:function(){var u;u=p(o.gpsIFD,n.gps);if(u.GPSVersionID){u.GPSVersionID=u.GPSVersionID.join(".")}return u},setExif:function(u,v){if(u!=="PixelXDimension"&&u!=="PixelYDimension"){return false}return r("exif",u,v)},getBinary:function(){return q.SEGMENT()}}}})(window,document,plupload);(function(d,a,b,c){function e(f){return a.getElementById(f)}b.runtimes.Html4=b.addRuntime("html4",{getFeatures:function(){return{multipart:true,triggerDialog:(b.ua.gecko&&d.FormData||b.ua.webkit)}},init:function(f,g){f.bind("Init",function(p){var j=a.body,n,h="javascript",k,x,q,z=[],r=/MSIE/.test(navigator.userAgent),t=[],m=p.settings.filters,o,l,s,w;no_type_restriction:for(o=0;o<m.length;o++){l=m[o].extensions.split(/,/);for(w=0;w<l.length;w++){if(l[w]==="*"){t=[];break no_type_restriction}s=b.mimeTypes[l[w]];if(s&&b.inArray(s,t)===-1){t.push(s)}}}t=t.join(",");function v(){var C,A,y,B;q=b.guid();z.push(q);C=a.createElement("form");C.setAttribute("id","form_"+q);C.setAttribute("method","post");C.setAttribute("enctype","multipart/form-data");C.setAttribute("encoding","multipart/form-data");C.setAttribute("target",p.id+"_iframe");C.style.position="absolute";A=a.createElement("input");A.setAttribute("id","input_"+q);A.setAttribute("type","file");A.setAttribute("accept",t);A.setAttribute("size",1);B=e(p.settings.browse_button);if(p.features.triggerDialog&&B){b.addEvent(e(p.settings.browse_button),"click",function(D){if(!A.disabled){A.click()}D.preventDefault()},p.id)}b.extend(A.style,{width:"100%",height:"100%",opacity:0,fontSize:"99px",cursor:"pointer"});b.extend(C.style,{overflow:"hidden"});y=p.settings.shim_bgcolor;if(y){C.style.background=y}if(r){b.extend(A.style,{filter:"alpha(opacity=0)"})}b.addEvent(A,"change",function(G){var E=G.target,D,F=[],H;if(E.value){e("form_"+q).style.top=-1048575+"px";D=E.value.replace(/\\/g,"/");D=D.substring(D.length,D.lastIndexOf("/")+1);F.push(new b.File(q,D));if(!p.features.triggerDialog){b.removeAllEvents(C,p.id)}else{b.removeEvent(B,"click",p.id)}b.removeEvent(A,"change",p.id);v();if(F.length){f.trigger("FilesAdded",F)}}},p.id);C.appendChild(A);j.appendChild(C);p.refresh()}function u(){var y=a.createElement("div");y.innerHTML='<iframe id="'+p.id+'_iframe" name="'+p.id+'_iframe" src="'+h+':&quot;&quot;" style="display:none"></iframe>';n=y.firstChild;j.appendChild(n);b.addEvent(n,"load",function(D){var E=D.target,C,A;if(!k){return}try{C=E.contentWindow.document||E.contentDocument||d.frames[E.id].document}catch(B){p.trigger("Error",{code:b.SECURITY_ERROR,message:b.translate("Security error."),file:k});return}A=C.body.innerHTML;if(A){k.status=b.DONE;k.loaded=1025;k.percent=100;p.trigger("UploadProgress",k);p.trigger("FileUploaded",k,{response:A})}},p.id)}if(p.settings.container){j=e(p.settings.container);if(b.getStyle(j,"position")==="static"){j.style.position="relative"}}p.bind("UploadFile",function(y,B){var C,A;if(B.status==b.DONE||B.status==b.FAILED||y.state==b.STOPPED){return}C=e("form_"+B.id);A=e("input_"+B.id);A.setAttribute("name",y.settings.file_data_name);C.setAttribute("action",y.settings.url);b.each(b.extend({name:B.target_name||B.name},y.settings.multipart_params),function(F,D){var E=a.createElement("input");b.extend(E,{type:"hidden",name:D,value:F});C.insertBefore(E,C.firstChild)});k=B;e("form_"+q).style.top=-1048575+"px";C.submit()});p.bind("FileUploaded",function(y){y.refresh()});p.bind("StateChanged",function(y){if(y.state==b.STARTED){u()}else{if(y.state==b.STOPPED){d.setTimeout(function(){b.removeEvent(n,"load",y.id);if(n.parentNode){n.parentNode.removeChild(n)}},0)}}b.each(y.files,function(B,A){if(B.status===b.DONE||B.status===b.FAILED){var C=e("form_"+B.id);if(C){C.parentNode.removeChild(C)}}})});p.bind("Refresh",function(A){var G,B,C,D,y,H,I,F,E;G=e(A.settings.browse_button);if(G){y=b.getPos(G,e(A.settings.container));H=b.getSize(G);I=e("form_"+q);F=e("input_"+q);b.extend(I.style,{top:y.y+"px",left:y.x+"px",width:H.w+"px",height:H.h+"px"});if(A.features.triggerDialog){if(b.getStyle(G,"position")==="static"){b.extend(G.style,{position:"relative"})}E=parseInt(G.style.zIndex,10);if(isNaN(E)){E=0}b.extend(G.style,{zIndex:E});b.extend(I.style,{zIndex:E-1})}C=A.settings.browse_button_hover;D=A.settings.browse_button_active;B=A.features.triggerDialog?G:I;if(C){b.addEvent(B,"mouseover",function(){b.addClass(G,C)},A.id);b.addEvent(B,"mouseout",function(){b.removeClass(G,C)},A.id)}if(D){b.addEvent(B,"mousedown",function(){b.addClass(G,D)},A.id);b.addEvent(a.body,"mouseup",function(){b.removeClass(G,D)},A.id)}}});f.bind("FilesRemoved",function(y,B){var A,C;for(A=0;A<B.length;A++){C=e("form_"+B[A].id);if(C){C.parentNode.removeChild(C)}}});f.bind("DisableBrowse",function(y,B){var A=a.getElementById("input_"+q);if(A){A.disabled=B}});f.bind("Destroy",function(y){var A,B,C,D={inputContainer:"form_"+q,inputFile:"input_"+q,browseButton:y.settings.browse_button};for(A in D){B=e(D[A]);if(B){b.removeAllEvents(B,y.id)}}b.removeAllEvents(a.body,y.id);b.each(z,function(F,E){C=e("form_"+F);if(C){j.removeChild(C)}})});v()});g({success:true})}})})(window,document,plupload);
});

},
'vodori/ui/util/pane':function(){
define([
    'vodori/provide', 'module',
    'dojo/_base/lang', 'dojo/_base/fx',
    'dojo/dom-class', 'dojo/dom-construct', 'dojo/dom-style',
    'dijit/registry', 'dijit/_base/manager', 'dijit/form/Button'
], function (provide, module, lang, fx, domClass, domConstruct, domStyle, dijitRegistry, dijitManager, Button) {
    var paneUtils = provide(module.id, {
        // This function will resize a layout widget within a layout container.
        resize: function (pane, sizes) {
            if (sizes.h === 'auto') {
                domStyle.set(pane.domNode, 'height', '');
                sizes.h = pane.domNode.scrollHeight;
            }

            var from = {
                w: pane.w,
                h: pane.h
            };

            var to = lang.mixin({}, from, sizes);

            var parentWidget = dijitRegistry.byNode(pane.domNode.parentNode);
            var parentWidgetResize = function () {
                if (parentWidget && 'resize' in parentWidget) {
                    parentWidget.resize();
                }
            };

            var anim = new fx.Animation({
                duration: dijitManager.defaultDuration / 2,

                onAnimate: function (at) {
                    if (!pane.domNode) {
                        return;
                    }

                    var args = {};
                    if (from.w && to.w) {
                        args.w = from.w + ((to.w - from.w) * at);
                    }
                    if (from.h && to.h) {
                        args.h = from.h + ((to.h - from.h) * at);
                    }

                    pane.resize(args);

                    parentWidgetResize();
                },

                onEnd: function () {
                    if (!pane.domNode) {
                        return;
                    }

                    pane.resize(to);

                    parentWidgetResize();
                },

                curve: [0, 1]
            });

            anim.play();

            return anim;
        },

        show: function (pane) {
            if (pane.w > 20 && pane.h > 20) {
                return;
            }

            domClass.replace(pane.domNode, 'expanded', 'collapsed');

            return paneUtils.resize(pane, pane.fullSize);
        },

        hide: function (pane) {
            if (pane.w < 20 || pane.h < 20) {
                return;
            }

            pane.fullSize = {
                w: domStyle.get(pane.domNode, 'width'),
                h: domStyle.get(pane.domNode, 'height')
            };

            domClass.replace(pane.domNode, 'collapsed', 'expanded');

            return paneUtils.resize(pane, {w: 0.01, h: 0.01});
        },

        toggle: function (pane) {
            // 20 seems to be the smallest panes will claim to be.
            var expanded = pane.w > 20 && pane.h > 20;

            if (expanded) {
                paneUtils.hide(pane);
            } else {
                paneUtils.show(pane);
            }

            return !expanded;
        },

        makeExpando: function (pane) {
            pane.fullSize = {
                w: domStyle.get(pane.domNode, 'width'),
                h: domStyle.get(pane.domNode, 'height')
            };

            if (!pane.splitter) {
                return;
            }

            var splitter = pane._splitterWidget;

            // Don't re-expando something.
            if (splitter.toggler) {
                return;
            }

            splitter.toggler = new Button({
                'class': 'toggle',
                onClick: function () {
                    var expanded = paneUtils.toggle(pane);
                    domClass.toggle(this.domNode, 'expanded', expanded);
                }
            });

            splitter.toggler.placeAt(splitter.domNode);

            domClass.replace(pane.domNode, 'expanded', 'collapsed');
        }
    });

    return paneUtils;
});

},
'vodori/ui/_ButtonMappingMixin':function(){

define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/on'
], function (
    module, provide,
    _,
    lang, on) {

    return provide(module.id, [],

    /**
     * This mixin will automatically bind click handlers for you. Simply fill up the _buttonMappings property with key
     * value pairs where the key is the property name of the button to bind to, and the value is the method name to bind
     * to.
     *
     * example:
     *
     * _buttonMappings: {
     *     'saveButton': '_saveHandler',
     *     'cancelButton': '_cancelHandler'
     * }
     */
    {
        _buttonMappings: {},

        postCreate: function() {
            this._bindButtonHandlers();

            this.inherited(arguments);
        },

        _bindButtonHandlers: function() {
            _.forIn(this._buttonMappings, function(value, key) {
                this.own(on(this[key], 'click', lang.hitch(this, value)));
            }, this);
        }
    });
});



},
'dijit/ProgressBar':function(){
define([
	"require", // require.toUrl
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/lang", // lang.mixin
	"dojo/number", // number.format
	"./_Widget",
	"./_TemplatedMixin",
	"dojo/text!./templates/ProgressBar.html"
], function(require, declare, domClass, lang, number, _Widget, _TemplatedMixin, template){

	// module:
	//		dijit/ProgressBar

	return declare("dijit.ProgressBar", [_Widget, _TemplatedMixin], {
		// summary:
		//		A progress indication widget, showing the amount completed
		//		(often the percentage completed) of a task.

		// progress: [const] String (Percentage or Number)
		//		Number or percentage indicating amount of task completed.
		//		Deprecated.   Use "value" instead.
		progress: "0",

		// value: String (Percentage or Number)
		//		Number or percentage indicating amount of task completed.
		//		With "%": percentage value, 0% <= progress <= 100%, or
		//		without "%": absolute value, 0 <= progress <= maximum.
		//		Infinity means that the progress bar is indeterminate.
		value: "",

		// maximum: [const] Float
		//		Max sample number
		maximum: 100,

		// places: [const] Number
		//		Number of places to show in values; 0 by default
		places: 0,

		// indeterminate: [const] Boolean
		//		If false: show progress value (number or percentage).
		//		If true: show that a process is underway but that the amount completed is unknown.
		//		Deprecated.   Use "value" instead.
		indeterminate: false,

		// label: String?
		//		HTML label on progress bar.   Defaults to percentage for determinate progress bar and
		//		blank for indeterminate progress bar.
		label: "",

		// name: String
		//		this is the field name (for a form) if set. This needs to be set if you want to use
		//		this widget in a dijit/form/Form widget (such as dijit/Dialog)
		name: '',

		templateString: template,

		// _indeterminateHighContrastImagePath: [private] URL
		//		URL to image to use for indeterminate progress bar when display is in high contrast mode
		_indeterminateHighContrastImagePath: require.toUrl("./themes/a11y/indeterminate_progress.gif"),

		postMixInProperties: function(){
			this.inherited(arguments);

			// Back-compat for when constructor specifies indeterminate or progress, rather than value.   Remove for 2.0.
			if(!(this.params && "value" in this.params)){
				this.value = this.indeterminate ? Infinity : this.progress;
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			this.indeterminateHighContrastImage.setAttribute("src",
				this._indeterminateHighContrastImagePath.toString());
			this.update();
		},

		_setDirAttr: function(val){
			// Normally _CssStateMixin takes care of this, but we aren't extending it
			var rtl = val.toLowerCase() == "rtl";
			domClass.toggle(this.domNode, "dijitProgressBarRtl", rtl);
			domClass.toggle(this.domNode, "dijitProgressBarIndeterminateRtl", this.indeterminate && rtl);
			this.inherited(arguments);
		},

		update: function(/*Object?*/attributes){
			// summary:
			//		Internal method to change attributes of ProgressBar, similar to set(hash).  Users should call
			//		set("value", ...) rather than calling this method directly.
			// attributes:
			//		May provide progress and/or maximum properties on this parameter;
			//		see attribute specs for details.
			// example:
			//	|	myProgressBar.update({'indeterminate': true});
			//	|	myProgressBar.update({'progress': 80});
			//	|	myProgressBar.update({'indeterminate': true, label:"Loading ..." })
			// tags:
			//		private

			// TODO: deprecate this method and use set() instead

			lang.mixin(this, attributes || {});
			var tip = this.internalProgress, ap = this.domNode;
			var percent = 1;
			if(this.indeterminate){
				ap.removeAttribute("aria-valuenow");
			}else{
				if(String(this.progress).indexOf("%") != -1){
					percent = Math.min(parseFloat(this.progress) / 100, 1);
					this.progress = percent * this.maximum;
				}else{
					this.progress = Math.min(this.progress, this.maximum);
					percent = this.maximum ? this.progress / this.maximum : 0;
				}
				ap.setAttribute("aria-valuenow", this.progress);
			}

			// Even indeterminate ProgressBars should have these attributes
			ap.setAttribute("aria-labelledby", this.labelNode.id);
			ap.setAttribute("aria-valuemin", 0);
			ap.setAttribute("aria-valuemax", this.maximum);

			this.labelNode.innerHTML = this.report(percent);

			domClass.toggle(this.domNode, "dijitProgressBarIndeterminate", this.indeterminate);
			domClass.toggle(this.domNode, "dijitProgressBarIndeterminateRtl", this.indeterminate && !this.isLeftToRight());

			tip.style.width = (percent * 100) + "%";
			this.onChange();
		},

		_setValueAttr: function(v){
			this._set("value", v);
			if(v == Infinity){
				this.update({indeterminate: true});
			}else{
				this.update({indeterminate: false, progress: v});
			}
		},

		_setLabelAttr: function(label){
			this._set("label", label);
			this.update();
		},

		_setIndeterminateAttr: function(indeterminate){
			// Deprecated, use set("value", ...) instead
			this._set("indeterminate", indeterminate);
			this.update();
		},

		report: function(/*float*/percent){
			// summary:
			//		Generates HTML message to show inside progress bar (normally indicating amount of task completed).
			//		May be overridden.
			// tags:
			//		extension

			return this.label ? this.label :
				(this.indeterminate ? "&#160;" : number.format(percent, { type: "percent", places: this.places, locale: this.lang }));
		},

		onChange: function(){
			// summary:
			//		Callback fired when progress updates.
			// tags:
			//		extension
		}
	});
});

},
'pepper/import/Review':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/on', 'dojo/aspect', 'dojo/_base/lang', 'dojo/topic', 'dojo/dom-style', 'dojo/when',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'vodori/layout/_Composable',
    'vodori/ui/_ButtonMappingMixin',
    'pepper/events', 'pepper/ui/ComposingDialog',
    'pepper/dialogs/Info', 'pepper/dialogs/info/configs/views',
    'pepper/data/PostDescriptorStore',
    'dojo/text!./templates/Review.html',
    /* Unreference MIDs */
    'dojo/store/Memory',
    'dojo/store/Observable',
    'dijit/layout/BorderContainer',
    'dijit/layout/ContentPane',
    'vodori/ui/Grid',
    'vodori/ui/Button',
    'pepper/dialogs/import/configs/review'
], function (
    module, provide,
    _,
    on, aspect, lang, topic, domStyle, when,
    _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
    _Composable,
    _ButtonMappingMixin,
    events, ComposingDialog,
    Info, views,
    postDescriptorStore,
    template) {

    return provide(module, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, _Composable, _ButtonMappingMixin],
        /**
         * @lends pepper/import/Review.prototype
         */
        {
            title: 'Pepper Document Import (Step 2 of 2)',

            templateString: template,

            _buttonMappings: {
                'selectAllBtn': 'selectAll',
                'selectNoneBtn':'selectNone',
                'laterBtn':     'onCancel',
                'reviewBtn':    'reviewSelected',
                'doneBtn':      'onCancel'
            },

            resizable: true,

            destroyOnHide: true,

            baseClass: 'pepperReviewDialog',

            objects: [], // An array of all the items displayed in this dialog

            /* Attach Points */
            container: null,
            selectAllBtn: null,
            selectNoneBtn: null,
            selectedItemsText: null,
            laterBtn: null,
            reviewBtn: null,
            doneBtn: null,

            /**
             * @constructs
             */
            constructor: function() {
                this.objects = [];
            },

            startup: function() {
                this.fireCompose({
                    props: {
                        title: this.title
                    }
                });

                // Give the Grid the documents to query for
                var query = {
                    objects: this.objects
                };
                this.grid.set('query', query);

                this.updateTotals(0);

                this.own(
                    aspect.after(this.grid, 'renderBegin', lang.hitch(this, function (args) {
                        this._checkReviewStatus.apply(this, args);
                    }), true),
                    on(this.grid, 'selectionChange', lang.hitch(this, 'gridChanged')),
                    aspect.after(this.grid, 'renderComplete', lang.hitch(this, function() {
                        this.container.resize();
                        if (this.objects.length === 1) {
                            this.selectAll();
                        }
                    }))
                );

                this.inherited(arguments);
            },

            /**
             * Updates the "total files selected" text field and enable/disable
             * the "review" button depending on if files are selected or not
             *
             * @param amount    the amount of selected files
             */
            updateTotals: function(/* int */ amount) {
                var rendered = amount + '/' + this.objects.length + '' + (amount === 1 ? 'file' : 'files');
                this.selectedItemsText.innerHTML = rendered;

                this.reviewBtn.set('disabled', amount === 0);
            },

            /**
             * Called when the user makes selections on the grid. Updates the
             * selection totals
             *
             * @param {{grid: Object}} event
             */
            gridChanged: function(event) {
                this.updateTotals(_.size(event.grid.get('selectedItems')));
            },

            /**
             * Select all items in the dialog
             */
            selectAll: function() {
                // Tell the grid that we're selecting all objects
                this.grid.selectAll();

                this.updateTotals(this.objects.length);
            },

            /**
             * Deselect all items in the dialog
             */
            selectNone: function() {
                // Tell the grid that we're clearing all selections
                this.grid.selectNone();

                this.updateTotals(0);
            },

            /**
             * Switch between the Reviewing and Done buttons depending on if everything has been reviewed
             *
             * @param {boolean} complete Whether all items have been reviewed or not
             */
            _switchButtons: function (complete) {
                // coerce undefined to a boolean.
                complete = !!complete;

                // Set the Review Now/Later and Done buttons to display or not depending on review completion
                domStyle.set(this.laterBtn.domNode,  'display', complete ? 'none' : 'inline-block');
                domStyle.set(this.reviewBtn.domNode, 'display', complete ? 'none' : 'inline-block');
                domStyle.set(this.doneBtn.domNode,   'display', complete ? 'inline-block' : 'none');
            },

            /**
             * Iterate over the review items and see if all items have been
             * reviewed. Switch buttons between Reviewing Now/Later and Done
             * depending on whether all files are reviewed or not.
             */
            _checkReviewStatus: function(results) {
                var complete = true; // Assume complete, makes the check in the loop a lot simpler
                var promise = results.forEach(function(result) {
                    // If any of them are still awaiting review, then reviewing is not complete
                    if (result.status === 'Awaiting Review') {
                        complete = false;
                    }
                });

                // Hitch the button switching function to the promise from the forEach call.
                promise.then(lang.hitch(this, function() {
                    this._switchButtons(complete);
                }));
            },

            /**
             * Refresh the grid and select items with matching objectIds
             *
             * @param selections    an array of objectIds. (optional)
             */
            updateGrid: function(/* Array */ selections) {
                this.grid.refreshAndSelect(selections);
            },

            /**
             * Called when the "review" button is pressed. Begins the review
             * workflow
             */
            reviewSelected: function() {
                this.startReview(this.grid.get('selectedItems'));
            },

            /**
             * Creates a new Info dialog to review the selected items.
             * Different parameters are used depending on whether one or multiple
             * items are selected for review (one = queue, multiple = bulk).
             *
             * @param selectedItems     The selected items in the review dialog
             */
            startReview: function(selectedItems) {
                // If the user has only one selected item, then we want to review all items in queue mode.
                // If there are multiple selections, then we'll want bulk mode.
                var queueMode = selectedItems.length === 1;

                var objectsToQuery = queueMode ? this.objects : selectedItems;
                var objectIds = _.pluck(objectsToQuery, 'objectId');

                // We need to force refresh to ensure that the info dialog is always created with the latest
                // asset information, especially if the user keeps closing and re-opening the Info dialog by clicking
                // 'Review'
                when(postDescriptorStore.queryByIds(objectIds, { forceRefresh: true }),
                    lang.hitch(this, function(objects) {

                    // Sets list of items to be reviewed (all objects in queue mode, or specifically
                    //      selected items if in bulk mode)
                    // Sets index if we only have one selected item and are therefore in queue mode
                    //      (meaning we will scroll through all objects and the index is which one we're
                    //      currently on)
                    // Sets config mode for either bulk or queue (will use index if in queue)
                    var infoWidget = new Info({
                        pathId: this.pathId,
                        objects: objects,
                        index: queueMode ? this._determineSelectedIndex(selectedItems) : null,
                        config: queueMode ? views.review.queue : views.review.bulk
                    });

                    var modal = new ComposingDialog({
                        destroyOnHide: true,
                        parseOnFirstShow: false,
                        widget: infoWidget
                    });

                    modal.startup();
                    modal.show();

                    this._connectToInfoDialog();
                }));
            },

            _connectToInfoDialog: function() {

                // When an item is reviewed, its objectId changes, so we have to update the
                // Review dialog's grid query to use the new objectId
                this._infoDialogUpdatedObjectId = this.subscribe(events.library.review.itemReviewed,
                    function(reviewedItems) {
                        var objects = this.grid.query.objects; // The objects in the grid's query to update

                        // Iterate through the reviewed items and replace the old objectIds of them
                        // from the grid's query
                        _.forEach(reviewedItems, function(newObject) {
                            // Search for the corresponding object in the grid query object array
                            for (var i = 0; i < objects.length; i++) {
                                var currentObject = objects[i];
                                if (currentObject.objectId === newObject.objectId) {
                                    // Replace the old data!
                                    currentObject.objectId = newObject.newObjectId;
                                    currentObject.versionSeriesId = newObject.versionSeriesId;
                                    break;
                                }
                            }
                        }, this);
                    }
                );

                this._infoDialogFlipConnect = this.subscribe(events.properties.actions.flip, function(selectedObject) {
                    this.grid.reset();
                    this.grid.set('selectedItems', selectedObject.objectId);
                });

                this._infoDialogHideConnect = this.subscribe(events.properties.actions.close, function () {
                    this.grid.refresh();
                    this.unsubscribe(this._infoDialogUpdatedObjectId);
                    this.unsubscribe(this._infoDialogHideConnect);
                    this.unsubscribe(this._infoDialogFlipConnect);
                });
            },

            /**
             * Determines the index to use when launching the info dialog.
             * Only used when items will be reviewed one at a time in a queue.
             * @param selectedItems The selected items
             */
            _determineSelectedIndex: function(selectedItems) {
                // Only valid if a single item is selected
                if (selectedItems.length === 1) {
                    for (var i = 0; i < this.objects.length; i++) {
                        if (this.objects[i].objectId === selectedItems[0].objectId) {
                            return i;
                        }
                    }
                }

                // If there is more than 1 selection, it's bulk mode and the index doesn't matter
                return 0;
            },

            onCancel: function() {
                this.fireCompose({
                    methods : {
                        'hide' : {}
                    }
                });

                // By the time we reached the review dialog, the asset has already been imported into reception, so a
                // cancel of this step still needs a library refresh to show the new asset in reception.
                topic.publish(events.library.refresh);
            }
        });
});

},
'pepper/dialogs/import/configs/review':function(){
define([
    'module',
    'vodori/provide',
    'vodori/util/number/humanizeBytes',
    'pepper/services',
    'pepper/data/PepperServiceObjectStore'
], function (module, provide, humanizeBytes, services, PepperServiceObjectStore) {
    var store = new PepperServiceObjectStore({
        service: services.getImportReviewFileInfo,
        identifier: 'objectId'
    });
    var config = {

        columns: [
            { label: 'Filename', field: 'fileName' },
            {
                label: 'Size',
                field: 'fileSize',
                formatter: function (data) {
                    return humanizeBytes(data);
                }
            },
            { label: 'Review Status', field: 'status' }
        ],

        store: store
    };

    return provide(module.id, config);
});

},
'pepper/commands/dialogs/showCreateURI':function(){
/**
 * This command launches the Create Segment dialog. Typical use is from a _PepperServiceMenu
 */
define([
    'module',
    'vodori/provide',
    'pepper/ui/ComposingDialog', 'pepper/dialogs/FolderInfo'
], function (
    module,
    provide,
    ComposingDialog, FolderInfo) {

    return provide(module.id,
        /**
         * Command to show the create segment dialog
         * @memberOf pepper/commands/dialogs
         *
         * @param {Object} parentFolder the parent folder from where this dialog was launched
         */
        function showCreateURI(parentFolder) {
            if (!parentFolder) {
                throw Error('parentFolder required for creating a URI path');
            }
            var widget = new FolderInfo({
                parentFolderId: parentFolder.objectId,
                type: 'URI'
            });

            var dialog = new ComposingDialog({
                destroyOnHide: true,
                parseOnFirstShow: false,
                widget: widget
            });

            dialog.startup();
            dialog.show();
        });
});

},
'pepper/dialogs/FolderInfo':function(){
define([
    'dojo/_base/declare', 'dojo/_base/lang', 'dojo/topic',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'vodori/layout/_Composable', 'vodori/ui/_ButtonMappingMixin',
    'pepper/events',
    'dojo/text!./templates/FolderInfo.html',
    /* unreferenced MIDs */
    'vodori/ui/Button',
    'pepper/dialogs/info/FolderPropertiesPane'
], function (
    declare, lang, topic,
    _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
    _Composable, _ButtonMappingMixin,
    events,
    template) {

    return declare([_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, _Composable, _ButtonMappingMixin], {

        templateString: template,

        title: 'Create Folder', // Override for different folder creation titles.
        event: null,
        type: null,
        folderId: null,
        parentFolderId: null,

        _buttonMappings: {
            cancelButton: '_onCancel',
            saveButton: '_onSave',
            doneButton: '_onDone'
        },

        /* attach points */
        form: null,

        cancelButton: null,
        saveButton: null,
        doneButton: null,

        postMixInProperties: function() {
            this.inherited(arguments);
            var folderEvents = this._getEventTypesForFolderType(this.type);
            if (this._isCreateForm()) {
                this.event = folderEvents.created;
            } else {
                this.event = folderEvents.changed;
            }
        },

        postCreate: function() {
            this.inherited(arguments);
            this.own(this.form.on('DownloadEnd', lang.hitch(this, function() {
                this.form.resize();
            })));
            this.own(this.form.on('SubmitEnd', lang.hitch(this, '_submitEndHandler')));
        },

        _submitEndHandler: function (e) {
            if (e.successful) {
                topic.publish(this.event, [this.parentFolderId, this.folderId]);

                if (e.isEnterKey) {
                    this.hide();
                }
            }
        },

        startup: function() {
            if (this._started) {
                return;
            }

            this.inherited(arguments);

            this.fireCompose({
                props: {
                    title: this.title
                }
            });
        },

        hide: function() {
            this.fireCompose({
                methods : {
                    'hide' : {}
                }
            });
        },

        destroy: function() {
            if (this.form) {
                this.form.destroy();
            }
            this.inherited(arguments);
        },

        /**
         * @returns {Deferred}
         */
        save: function () {
            var def = this.form.save(arguments);
            return def;
        },

        _getEventTypesForFolderType: function (folderType) {

            if (!folderType) {
                throw new Error('No folder type was defined when trying to open the FolderInfo dialog.');
            }

            var eventName;
            switch (folderType) {
                case 'PERSONAL_TAG':
                    eventName = 'personalTag';
                    break;
                default:
                    eventName = folderType.toLowerCase();
            }

            var folderEvent = events.folders[eventName];

            if (!folderEvent) {
                throw new Error('No matching events were found for the given folder type: ' + folderType);
            }
            return folderEvent;
        },

        _onCancel: function() {
            this.hide();
        },

        _onSave: function() {
            this.save();
        },

        _onDone: function() {
            this.save().then(lang.hitch(this, 'hide'));
        },

        /**
         * Determines whether or not the form will be creating a new folder, or editing an existing one.
         * @returns {boolean} true if we are creating a new folder, false otherwise.
         * @private
         */
        _isCreateForm: function() {
            return !this.folderId;
        }
    });
});

},
'pepper/dialogs/info/FolderPropertiesPane':function(){
/**
 * Properties tab for viewing info on a folder (segment, term, tag)
 */
define([
    'module',
    'vodori/provide',
    'pepper/dialogs/info/PropertiesProxyPane'
], function (module, provide, PropertiesProxyPane) {

    var SHOW_FOLDER_URI = '/author/pepper/showFolderInfo.html';
    var CREATE_FOLDER_URI = '/author/pepper/createFolderForm.html';

    return provide(module.id, [ PropertiesProxyPane ], {
        href: null,

        type: null,
        parentFolderId: null,
        folderId: null,

        postMixInProperties: function() {
            this.inherited(arguments);
            if (!this.type) {
                throw Error('folder type required to load the folder info form.');
            }
            this.href = this.buildHref();
        },

        startup: function() {
            this.inherited(arguments);
            this.resize();
        },

        buildHref: function () {
            var href;
            if (this.folderId) {
                href = SHOW_FOLDER_URI + '?folderId=' + this.folderId + '&folderType=' + this.type;
            } else if (this.parentFolderId) {
                href = CREATE_FOLDER_URI + '?folderType=' + this.type + '&parentFolderId=' + this.parentFolderId;
            } else {
                throw Error('folderId or parentFolderId should be set to load the folder info form');
            }
            return href;
        }
    });
});
},
'pepper/commands/dialogs/showCreateTag':function(){
/**
 * This command launches the Create Tag (shared or personal) dialog. Typical use is from a _PepperServiceMenu
 */
define([
    'module',
    'vodori/provide',
    'pepper/ui/ComposingDialog', 'pepper/dialogs/FolderInfo'
], function (
    module,
    provide,
    ComposingDialog, FolderInfo) {

    return provide(module.id,
        /**
         * Command to show the create tag dialog
         * @memberOf pepper/commands/dialogs
         *
         * @param {Object} parentFolder the parent folder from where this dialog was launched
         * @param {string} type the type of tag to create (SHARED_TAG, PERSONAL_TAG)
         */
        function showCreateTag(parentFolder, type) {
            if (!parentFolder) {
                throw Error('parentFolder required for creating a tag');
            }
            var widget = new FolderInfo({
                title: 'Create Tag',
                parentFolderId: parentFolder.objectId,
                type: type || 'PERSONAL_TAG'
            });

            var dialog = new ComposingDialog({
                destroyOnHide: true,
                parseOnFirstShow: false,
                widget: widget
            });

            dialog.startup();
            dialog.show();
        });
});

},
'pepper/commands/dialogs/showCreateCategory':function(){
/**
 * This command launches the Create Term dialog. Typical use is from a _PepperServiceMenu
 */
define([
    'module',
    'vodori/provide',
    'pepper/ui/ComposingDialog', 'pepper/dialogs/FolderInfo'
], function (
    module,
    provide,
    ComposingDialog, FolderInfo) {

    return provide(module.id,
        /**
         * Command to show the create term dialog
         * @memberOf pepper/commands/dialogs
         *
         * @param {Object} parentFolder the parent folder from where this dialog was launched
         */
        function showCreateCategory(parentFolder) {
            if (!parentFolder) {
                throw Error('parentFolder required for creating a category');
            }
            var widget = new FolderInfo({
                title: 'Create Category',
                parentFolderId: parentFolder.objectId,
                type: 'CATEGORY'
            });

            var dialog = new ComposingDialog({
                destroyOnHide: true,
                parseOnFirstShow: false,
                widget: widget
            });

            dialog.startup();
            dialog.show();
        });
});

},
'pepper/commands/dialogs/showFolderInfo':function(){
define([
    'vodori/provide',
    'module',
    'pepper/ui/ComposingDialog', 'pepper/dialogs/FolderInfo'
], function (
    provide,
    module,
    ComposingDialog, FolderInfo) {

    return provide(module.id,
        /**
         *
         * @memberOf pepper/commands/dialogs
         *
         * @param {Object} folder
         * @param {string} folderType
         */
            function showFolderInfo(/* Object */ folder, /* String */ folderType) {
            var widget = new FolderInfo({
                folderId: folder.objectId,
                type: folderType
            });

            var dialog = new ComposingDialog({
                destroyOnHide: true,
                parseOnFirstShow: false,
                widget: widget
            });

            dialog.startup();
            dialog.show();
        });
});

},
'pepper/commands/dialogs/showCreate':function(){
/**
 * This command launches the Create dialog. Typical use is from the DirectoryMenu.
 */

define([
    'module',
    'vodori/provide',
    'pepper/dialogs/Create'
], function (module, provide, Create) {

    return provide(module.id,
        /**
         * Command to show the create dialog
         * @memberOf pepper/commands/dialogs
         *
         * @param {Object} parentFolder The parent folder from where this dialog was launched
         */
            function showCreate(parentFolder, channelId) {
            var createDlg = new Create({
                parentFolder: parentFolder,
                channelId: channelId
            });

            createDlg.startup();
            return createDlg.show();
        });
});

},
'pepper/dialogs/Create':function(){
define([
    'module',
    'lodash',
    'vodori/provide',
    'vodori/ui/wizard/WizardDialog',
    'pepper/dialogs/wizards/CreatePostWizard', 'pepper/ui/_QuarantineMixin'
], function (module, _, provide, WizardDialog, CreatePostWizard, _QuarantineMixin) {
    return provide(module, [WizardDialog, _QuarantineMixin], {

        title: 'Create New Content',

        useTrailingActionBar: true,

        constructor: function (args) {
            // since this isn't a widget, apply all constructor args to the object
            _.extend(this, args);

            this.quarantineAreaClassNames += ' createDialog';

            this._wizard = new CreatePostWizard({
                parentFolder: this.parentFolder,
                channelId: this.channelId
            });
        }
    });
});

},
'pepper/dialogs/wizards/CreatePostWizard':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dijit/Destroyable',
    'vodori/util/string/capitalize',
    'vodori/ui/wizard/_Wizard',
    'pepper/dialogs/info/TemplateSelector',
    'pepper/dialogs/info/PostTemplateViewer', 'pepper/dialogs/info/PropertyViewer',
    'pepper/dialogs/info/configs/views'
], function (module, provide,
             _,
             lang,
             Destroyable,
             capitalize,
             _Wizard,
             TemplateSelector,
             PostTemplateViewer, PropertyViewer,
             views) {
    return provide(module, [_Wizard, Destroyable], {

        stateMachine: [
            {
                awaitingTemplate: {
                    _templateSelected: 'readyToSave',
                    Cancel: 'CANCELED'
                },
                readyToSave: {
                    _templateDeselected: 'awaitingTemplate',
                    Create: 'saving',
                    Cancel: 'CANCELED'
                },
                saving: {
                    _saveFailed: 'saveFailure',
                    Create: null,
                    Cancel: null
                },
                saveFailure: {
                    _templateDeselected: 'awaitingTemplate',
                    Create: 'saving',
                    Cancel: 'CANCELED'
                }
            }
        ],

        actionClasses: {
            Cancel: 'standard cancel',
            Create: 'standard action default'
        },

        constructor: function (args) {
            // since this isn't a widget, apply all constructor args to the object
            _.extend(this, args);

            this.initialState = ['awaitingTemplate'];

            this.own(this.watch('state', lang.hitch(this, function (__, ___, newState) {
                if (this.get('contentPane')) {
                    var targetState = newState[0],
                        stateHandlerFunction = this['_display' + capitalize(targetState)];

                    if (_.isFunction(stateHandlerFunction)) {
                        stateHandlerFunction.call(this);
                    }
                }
            })));
        },

        performAction: function (action) {
            var newState = this.inherited(arguments);

            if (action === 'Create' && this.get('contentPane')) {
                this.propertyViewer.save(null, null, 0, [
                    {
                        name: 'button',
                        value: 'create_done',
                        type: 'URL'
                    }
                ]).then(lang.hitch(this, '_complete'), lang.hitch(this, 'performAction', '_saveFailed'));
            }

            return newState;
        },

        _displayAwaitingTemplate: function () {
            var templateSelector = this.templateSelector,
                contentPane = this.get('contentPane');

            if (!templateSelector) {
                this.templateSelector = templateSelector = new TemplateSelector({
                    'class': 'templateSelector'
                });

                this.own(templateSelector.on(TemplateSelector.SELECTION_CHANGED_EVENT, lang.hitch(this, function () {
                    this.performAction('_templateSelected');
                })));
            }

            var pathId = this.parentFolder && this.parentFolder.objectId;

            templateSelector.populate({
                pathId: pathId,
                channelId: this.channelId
            });

            contentPane.removeChild(this.templateViewer);
            contentPane.removeChild(this.propertyViewer);
            contentPane.addChild(templateSelector);
        },

        _displayReadyToSave: function () {
            var propertyViewer = this.propertyViewer,
                templateViewer = this.templateViewer,
                contentPane = this.get('contentPane'),
                template = this.templateSelector.get('selectedTemplate');

            if (!templateViewer) {
                this.templateViewer = templateViewer = new PostTemplateViewer();

                this.own(templateViewer.on(PostTemplateViewer.DESELECT, lang.hitch(this, function () {
                    this.performAction('_templateDeselected');
                })));
            }

            if (!propertyViewer) {
                this.propertyViewer = propertyViewer = new PropertyViewer({
                    'class': 'standard tabs propertyViewer',
                    channelId: this.channelId
                });
            }

            contentPane.removeChild(this.templateSelector);

            templateViewer.set('template', template);

            contentPane.addChild(templateViewer);
            contentPane.addChild(propertyViewer);

            propertyViewer.set('config', views.create);
            propertyViewer.populate();
            propertyViewer.update(null, template);

            contentPane.resize();
        }
    });
});

},
'pepper/dialogs/info/PostTemplateViewer':function(){
define([
    'module',
    'vodori/provide',
    'dojo/Evented',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'dojo/text!./templates/PostTemplateViewer-content.html'
], function (module, provide, Evented, _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, widgetTemplate) {
    var Constructor = provide(module, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, Evented], {

        templateString: widgetTemplate,

        widgetsInTemplate: true,

        /* The Vodori template, nothing to do with Templated Widgets */
        template: null,

        _setTemplateAttr: function (value) {
            this.templateThumbnail.src = value.thumbnail;
            this.templateLabel.innerHTML = value.label;
        },

        deselectTemplate: function (evt) {
            this.emit(Constructor.DESELECT);
        }
    });

    Constructor.DESELECT = 'templateDeselected';

    return Constructor;
});

},
'pepper/commands/dialogs/showImportPepperDoc':function(){
/**
 * This command launches the Import dialog for Pepper Documents. Typical use is from the DirectoryMenu.
 */

define([
    'lodash',
    'module', 'vodori/provide',
    'pepper/import/ImportPepperDoc', 'pepper/ui/ComposingDialog'
], function (
    _,
    module, provide,
    ImportPepperDoc, ComposingDialog) {

    return provide(module.id,

        /**
         * Command to show the create dialog
         * @memberOf pepper/commands/dialogs
         *
         * @param {Object} parentFolder The parent folder from where this dialog was launched
         * @param {String} channelId The id of the channel to import into. This will be determined from the folder if
         *                 not specified.
         */
        function showImportPepperDoc(parentFolder, channelId) {

            if (_.isObject(parentFolder ) && _.isUndefined(channelId)) {
                channelId = parentFolder.channelId;
            }

            var importWidget = new ImportPepperDoc({
                parentFolder: parentFolder,
                channelId: channelId
            });

            var importDialog = new ComposingDialog({
                destroyOnHide: true,
                parseOnFirstShow: false,
                widget: importWidget
            });

            importDialog.startup();
            importDialog.show();
        });
});

},
'pepper/commands/dialogs/showImportRefDoc':function(){
/**
 * This command launches the Import dialog. Typical use is from the DirectoryMenu.
 */

define([
    'module', 'vodori/provide',
    'pepper/import/ImportRefDoc', 'pepper/ui/ComposingDialog'
], function (
    module, provide,
    ImportRefDoc, ComposingDialog) {

    return provide(module.id,
        /*
         * Command to show the create dialog
         * @memberOf pepper/commands/dialogs
         *
         * @param {Object} parentFolder The parent folder from where this dialog was launched
         */
        function showImportRefDoc(/* Object */ parentFolder) {
            var importRefWidget = new ImportRefDoc({
                parentFolder: parentFolder
            });

            var importRefDialog = new ComposingDialog({
                destroyOnHide: true,
                parseOnFirstShow: false,
                widget: importRefWidget
            });

            importRefDialog.startup();
            importRefDialog.show();
        });
});

},
'pepper/import/ImportRefDoc':function(){
define([
    'module', 'vodori/provide',
    'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'pepper/import/_Import',
    'dojo/text!./templates/ImportRefDoc.html'
], function (
    module, provide,
    _TemplatedMixin, _WidgetsInTemplateMixin,
    _Import,
    template) {
        /**
         * @class pepper/import/ImportRefDoc
         * @mixes pepper/import/_Import
         */
        return provide(module.id, [_Import, _TemplatedMixin, _WidgetsInTemplateMixin],
            /**
             * @lends pepper/dialogs/ImportRefDoc.prototype
             */
            {

                title: 'Reference Document Import',

                templateString: template,
                _REF_DOC_REQUEST_HEADER: 'Pepper-IsRefDoc',

                /**
                 * Before uploading each file, indicate that it is a reference document
                 *
                 * @param {vodori.amd.plupload} up  A reference to the uploader
                 * @param file                      The file the user chose through the file browser
                 */
                beforeUpload: function (/* Plupload */ up, /* Object */ file) {
                    this.inherited(arguments);
                    up.settings.headers[this._REF_DOC_REQUEST_HEADER] = true;
                }
            });
    });

},
'pepper/commands/dialogs/showWorkflowWizard':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'pepper/dialogs/InitiateWorkflow'
], function (
    module, provide,
    _,
    InitiateWorkflow) {
    'use strict';

    return provide(module.id,
        /**
         * @memberOf pepper/commands/dialogs
         *
         * @param {Object} object {objectId: string}
         * @return {dojo/promise/promise}
         */
            function showWorkflowWizard(object) {
            if (!_.isArray(object)) {
                object = [object];
            }

            var dialog = new InitiateWorkflow({
                flowedObjects : object
            });

            dialog.startup();

            return dialog.show();
        });
});

},
'pepper/dialogs/InitiateWorkflow':function(){
/*global define:true */
define([
    'module',
    'vodori/provide',
    'vodori/ui/wizard/WizardDialog',
    'pepper/form/WorkflowWizard', 'pepper/ui/_QuarantineMixin'
], function(
    module,
    provide,
    WizardDialog,
    WorkflowWizard, _QuarantineMixin
) {
    return provide(module, [WizardDialog, _QuarantineMixin], {

        useTrailingActionBar : true,

        flowedObjects : null,

        postMixInProperties: function () {
            this.inherited(arguments);

            this.quarantineAreaClassNames += ' pepperWorkflowWizardDialog';

            this._wizard = new WorkflowWizard({
                flowedObjects: this.flowedObjects
            });
        }
    });
});

},
'pepper/form/WorkflowWizard':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/on', 'dojo/topic', 'dojo/query', 'dojo/dom-attr',
    'dijit/Destroyable',
    'vodori/ui/wizard/_Wizard',
    'pepper/events', 'pepper/commands/dialogs/showLibrary',
    'pepper/data/PostDescriptorStore',
    './workflowWizard/WorkflowWizardFormProxyPane'
], function(
    module, provide,
    _,
    lang,
    on, topic, query, domAttr,
    Destroyable,
    _Wizard,
    events, showLibrary,
    postDescriptorStore,
    WorkflowWizardFormProxyPane) {

    /**
     * Creates a workflow instance. Mainly, this seeks to provide a container for serving arbitrary
     * JSPs inside a dialogable form.
     *
     * @class pepper/form/WorkflowWizard
     * @mixes vodori/ui/wizard/_Wizard
     * @mixes dijit/Destroyable
     */
    return provide(module, [_Wizard, Destroyable], {

        title: 'Workflow Wizard',

        /**
         * The objects that'll be sent through the workflow.
         *
         * @type {Array.<{objectId: string}>}
         */
        flowedObjects: null,

        formProxyPane: null,

        initialState: ['screen-1'],

        stateMachine: [
            {
                'screen-1': {
                    Cancel: 'CANCELED',
                    Previous: null,
                    Next: 'submit-1',
                    Initiate: null
                },
                'submit-1': {
                    Cancel: 'CANCELED',
                    Previous: null,
                    Next: null,
                    Initiate: null,
                    _fail: 'screen-1',
                    _succeed: 'screen-2'
                },
                'screen-2': {
                    Cancel: 'CANCELED',
                    Previous: 'screen-1',
                    Next: 'submit-2',
                    Initiate: null
                },
                'submit-2': {
                    Cancel: 'CANCELED',
                    Previous: null,
                    Next: null,
                    Initiate: null,
                    _fail: 'screen-2',
                    _succeed: 'screen-3'
                },
                'screen-3': {
                    Cancel: 'CANCELED',
                    Previous: 'submit-1',
                    Next: null,
                    Initiate: 'submit-3'
                },
                'submit-3': {
                    Cancel: null,
                    Previous: null,
                    Next: null,
                    Initiate: null,
                    _fail: 'screen-3',
                    _succeed: 'review'
                },
                'review': {
                    Done: 'COMPLETED'
                }
            }
        ],

        actionClasses: {
            Cancel: 'standard cancel',
            Previous: 'standard default previous',
            Next: 'standard default next',
            Initiate: 'standard initiate default action',
            Done: 'standard done default action'
        },

        actionOrder: [ 'Cancel', 'Previous', 'Next', 'Initiate', 'Done' ],

        constructor: function() {
            if (!this.flowedObjects) {
                this.flowedObjects = [];
            }
            this.own(
                this.on('wizardComplete', lang.hitch(this, '_refreshLibrary')),
                this.on('wizardCancel', lang.hitch(this, '_refreshLibrary'))
            );
        },

        _refreshLibrary: function() {
            topic.publish(events.library.refresh);
        },

        start: function(state) {
            this.fireCompose({
                props: {
                    title: this.title
                }
            });

            this._createFinalButtonHandler('start-new-flow-button', function(event) {
                // Do this async to prevent circular dependency.
                require(['pepper/commands/dialogs/showWorkflowWizard'], function(showWorkflowWizard) {
                    // The null is important, as the BE relies on at least one value, even null.
                    showWorkflowWizard([null]);
                });
            });

            this._createFinalButtonHandler('open-library-button', function(event) {
                showLibrary({refresh: true});
            });

            this._createFinalButtonHandler('go-to-inbox-button', function(event) {
                window.open('/pepper/inbox#', 'pepperInboxWindow');
            });

            var formProxyPane = (this.formProxyPane = new WorkflowWizardFormProxyPane({
                    'class': 'containerPane'
                })),
                contentPane = this.get('contentPane');

            if (contentPane) {
                contentPane.addChild(formProxyPane);
            }

            formProxyPane.set('flowedObjects', _.map(this.flowedObjects, function(object) {
                return _.isString(object) ? object : (object === null ? null : object.objectId);
            }));

            this.inherited(arguments);
        },

        /**
         * Note: The wizard states are numbered 1-3 corresponding to the number the user sees for that panel. The
         * formProxyPane expects steps 0-3, where 0 renders the initial panel and 3 submits the final panel. So the
         * step # set on the formProxyPane is essentially the number of the step that is being submitted.
         */
        renderState: function(state) {
            state = state[0];

            if (state === 'screen-1') {
                this.formProxyPane.set('step', '0');
            } else  if (state.indexOf('submit-') === 0) {
                // the 'step' is the number at the end of the state.
                var step = state.substring(state.length - 1);
                this._submitStep(step);
            } else if (state === 'review') {
                postDescriptorStore.get(postDescriptorStore.getCurrentPageObjectId(), {
                    forceRefresh: true
                });
            }
        },

        _submitStep: function(step) {
            this.formProxyPane.set('step', step).then(
                lang.hitch(this, function() {
                    var succeed = true;
                    var nodes = query('input[name=currentStep]', this.formProxyPane.domNode);

                    if(nodes.length === 1) {
                        var currentStepFromBackend = domAttr.get(nodes[0], 'value');

                        if(currentStepFromBackend !== this.formProxyPane.step) {
                            succeed = false;
                        }
                    }

                    if(succeed) {
                        this.performAction('_succeed');
                    } else {
                        this.performAction('_fail');
                    }
                }),
                lang.hitch(this, function() {
                    this.performAction('_fail');
                })
            );
        },

        /**
         * Create a handler for the buttons that are shown on the final page of the Workflow Wizard
         * @param {string} buttonClass The HTML class of the button
         * @param {function(Object)} handler The function to call (will be called in the same context as 'this'
         * @private
         */
        _createFinalButtonHandler: function(buttonClass, handler) {
            var contentPane = this.get('contentPane');

            if (contentPane) {
                this.own(on(contentPane.domNode, '.' + buttonClass + ':click', lang.hitch(this, function(event) {
                    this.complete();

                    handler.call(this, event);
                })));
            }
        }
    });
});

},
'pepper/form/workflowWizard/WorkflowWizardFormProxyPane':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/xhr', 'dojo/io-query', 'dojo/Deferred', 'dojo/_base/lang',
    'pepper/ui/FormProxyPane',
    './WorkflowWizardFormValidator', './OptionsGrid', './ObjectList', './objectList/ValueArrayInputWrapper',
    'pepper/workflow/NextPerformerSelector',
    'pepper/ui/DropDownButton',
    'dijit/Menu',
    'pepper/ui/LibraryBrowserButton'
], function (module, provide, xhr, ioQuery, Deferred, lang, FormProxyPane) {
    /**
     * A custom FormProxyPane for the workflow wizard.
     */
    /**
     * @class pepper/form/workflowWizard/WorkflowWizardFormProxyPane
     * @extends pepper/ui/FormProxyPane
     */
    return provide(module.id, [FormProxyPane],
        /**
         * @lends pepper/form/workflowWizard/WorkflowWizardFormProxyPane#
         */
        {
            /**
             * @type {boolean}
             */
            extractContent: true,

            /**
             * Which step in the wizard to render. Use the setter to change.
             *
             * @type {number}
             * @private
             */
            step: 0,

            /**
             * @type {Array.<{objectId: string}>}
             */
            flowedObjects: null,

            /**
             * The url that'll be hit when the pane's ready to refresh. Using a private version, so I
             * can hang extra data off the pane before submission.
             *
             * @type {string}
             * @private
             */
            _href: '/author/pepper/getWorkflowStep.html',

            /**
             * We only use GET once to get the a form w/o sending any significant data.
             *
             * @type {boolean}
             */
            _initialGet: true,

            /**
             * Indicates to the FormProxyPane superclass that we want to receive a cancelled deferred
             * on invalid form submission.
             *
             * See pepper.ui.FormProxyPane or vodori.ui.FormProxyPane for a caveat in how this works.
             *
             * @type {boolean}
             */
            cancelOnInvalid: true,

            /**
             * Initialize collections.
             */
            constructor: function () {
                this.flowedObjects = [];
            },

            mimicFormSubmit: function () {
                var currentValue = this.form.get('value');
                currentValue.nextStep = this.step;

                // Try to advance the form.
                this.form.set('value', currentValue);

                // Piggyback our data on the GET params, that FormProxyPane will convert to POST later.
                this.href = this._buildHref();

                // Need a bit more data to come back from a submission, so adding to the
                // callback args.
                var submissionDef = new Deferred();
                var originalSubmissionDef = this.inherited(arguments);
                originalSubmissionDef.then(
                    lang.hitch(this, function () {
                        submissionDef.resolve(this.form.get('value'));
                    }),
                    lang.hitch(this, function () {
                        submissionDef.cancel(this.form.get('value'));
                    })
                );

                return submissionDef;
            },

            /**
             * Append data to the href.
             *
             * @return {string}
             * @private
             */
            _buildHref: function () {
                // Note that this is nextStep, since we're asking for it. The server will know what the
                // current step is, since it tells us when the form loads.
                return this._href + '?' + ioQuery.objectToQuery({
                    nextStep: this.step,
                    flowedObjects: this.flowedObjects
                });
            },

            /**
             * Move the wizard to a different step.
             *
             * @param {number} step
             * @return {dojo.Deferred.promise}
             * @private
             */
            _setStepAttr: function (step) {
                this.step = step;

                if (!this._initialGet) {
                    return this.mimicFormSubmit().promise;
                }
                // Bypass the POST for initial form load.
                else {
                    this._initialGet = false;
                    return this.set('href', this._buildHref());
                }
            }
        });
});

},
'pepper/form/workflowWizard/WorkflowWizardFormValidator':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'pepper/ui/_FormValidator'
], function (provide, module,
             _,
             _FormValidator) {
    /**
     * Form validator for the Workflow Wizard. Contains validating and error functions for
     * fields that require validation in the wizard (see pepper.ui._FormValidator).
     *
     * @class pepper/form/workflowWizard/WorkflowWizardFormValidator
     * @mixes pepper/ui/_FormValidator
     */
    return provide(module.id, [ _FormValidator ],
        /**
         * @lends pepper/form/workflowWizard/WorkflowWizardFormValidator#
         */
        {

            startup: function () {
                _.forEach(this.clientParameterValidators, function (fn, fnName) {
                    var suffix = '';
                    if (fnName.indexOf('Error') >= 0) {
                        fnName = fnName.substring(0, fnName.indexOf('Error'));
                        suffix = 'Error';
                    }
                    this['clientParameters[\'' + fnName + '\']' + suffix] = fn;
                }, this);

                this.inherited(arguments);
            },

            /**
             * Validates the workflow wizard's flowName field (workflow's name).
             * Checks to make sure we're on the correct step for validation, since
             * the workflow wizard form is unique in having it's fields on different steps.
             * @param {string} value The field value
             * @param {string} key The field name
             * @param {Object} formValues A map of all form inputs
             * @return {boolean} Whether the flowName input is valid or not at the given step
             */
            flowName: function (value, key, formValues) {
                var tryingToMoveForward = (formValues.nextStep > formValues.currentStep);
                var onCorrectPage = (formValues.currentStep > 1);
                var nameIsSet = this.hasText(value);

                return !tryingToMoveForward || !onCorrectPage || nameIsSet;
            },

            /**
             * Error function for invalid entry for the flowName field. Calls superclass'
             * error message creation function (see pepper.ui._FormValidator).
             * @param value The field's value
             * @param key The field's name (here, 'flowName')
             */
            flowNameError: function (value, key) {
                // Doesn't pass in an HTML tag type, as the default of span is fine here
                this.createErrorMessage(key, 'Please enter a name for this activity.');
            },

            /**
             * Validates the workflow wizard contains flowed objects
             * Checks to make sure we're on the correct step for validation, since
             * the workflow wizard form has its fields in different steps
             * @param {string} value The field value
             * @param {string} key The field name
             * @param {Object} formValues A map of all form inputs
             * @return {boolean} Whether the flowedObjects input is valid or not at the given step
             */
            flowedObjects: function (value, key, formValues) {
                return  !(formValues.currentStep > 0 && !this.hasText(value));
            },

            /**
             * Error function for invalid entry for the flowedObjects field. Calls superclass's
             * error message creation function (see pepper.ui._FormValidator).
             * @param value The field's value
             * @param key The field's name
             */
            flowedObjectsError: function (value, key) {
                // Doesn't pass in an HTML tag type, as the default of span is fine here
                this.createErrorMessage(key, 'Workflow must have at least one document associated with it.');
            },

            /**
             * Validates the workflow wizard's next performer
             * Checks to make sure we're on the correct step for validation, since
             * the workflow wizard form is unique in having it's fields on different steps.
             * @param {string} value The field value
             * @param {string} key The field name
             * @param {Object} formValues A map of all form inputs
             * @return {boolean} Whether the next performer input is valid or not at the given step
             */
            nextPerformer: function (value, key, formValues) {
                var tryingToMoveForward = (formValues.nextStep > formValues.currentStep);
                var onCorrectPage = (formValues.currentStep > 1);
                var validPerformer = (formValues.performerType === 'GROUP') || this.hasText(value);

                return !tryingToMoveForward || !onCorrectPage || validPerformer;
            },

            /**
             * Error function for invalid entry for the nextPerformer field. Calls superclass's
             * error message creation function (see pepper.ui._FormValidator).
             * @param value The field's value
             * @param key The field's name
             */
            nextPerformerError: function (value, key) {
            // Doesn't pass in an HTML tag type, as the default of span is fine here
                this.createErrorMessage(key, 'Must select a performer from the list, or select the reviewer group');
            },

            workflowDefinition: function(value, key, formValues) {
                return !!value;
            },

            workflowDefinitionError: function(value, key) {
                this.createErrorMessage(key, 'Please select a workflow.');
            }

        });
});


},
'pepper/ui/_FormValidator':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'dojo/query', 'dojo/on',
    'dojo/dom-class', 'dojo/dom-construct',
    'dijit/_WidgetBase', 'dijit/form/Form',
    'dijit/registry',
    'vodori/util/getDijitAncestorByClass', 'vodori/util/node/removeClassByPattern',
    'vodori/util/collections/mapAndFilter'
], function (provide, module,
             _,
             lang,
             query, on,
             domClass, domConstruct,
             _WidgetBase, DijitForm,
             registry,
             getDijitAncestorByClass, removeClassByPattern,
             mapAndFilter
    ) {
    /**
     * A form validation widget that dynamically discoveres which form it is a part of
     * and then dynamically calls validation functions that have the same name as the
     * form's input names. If invalid, a similarly named error function (key + 'Error')
     * will be called to deal with error handling.
     *
     * To use this class, simply create a subclass of this, and create a function/error
     * function pair for each key that needs validation (so for an input named 'someInput',
     * make a function named 'someInput' for validation of that field, and 'someInputError'
     * for error handling). The validation/error functions are passed the input value,
     * the input name, and a list of the other form values as arguments. You will also
     * need to add this widget to your form tag, for instance as a div inside your form's
     * tag in markup with data-dojo-type='path.to.your._FormValidator.subclass'.
     *
     * On error, classes will be added to the form to reflect that the form has errors
     * (with the VALIDATOR_ERROR_CLASS class) and which fields have errors (with classes
     * of the form 'VALIDATOR_ERROR_CLASS-<key>'). Additionally the error functions in the
     * subclass can add their own error classes to their particular input field.
     */
    return provide(module.id, [_WidgetBase], {

        /**
         * The form that this validator is attached to
         * @type {dijit.form.Form}
         */
        form: null,

        /**
         * Array of strings of input names on which to perform live validation on the change event
         * @type {Array.<string>}
         */
        liveValidators: null,

        /**
         * Whether the form should be found dynamically or not.
         * Allows for the form to be set programmatically if desired by the subclass.
         * @type {boolean}
         */
        shouldFindForm: true,

        /**
         * Regular expression object allowing the identification of error classes that this validator puts onto
         * DOM elements.
         * @type {RegExp}
         */
        validatorErrorRegex: null,

        /**
         * General CSS error class that will be added to the form to indicate that the validator found invalid input
         * @type {string}
         */
        VALIDATOR_ERROR_CLASS: 'formValidatorError',
        /**
         * CSS error class that is concatenated to the name of each specific input found to have errors, and added to
         * this validator's form.
         * @type {string}
         */
        INPUT_ERROR_CLASS: 'formValidatorInputError',

        constructor: function () {
            // We want to find all classes with our validator's error class at the end of the class
            this.validatorErrorRegex = new RegExp(this.VALIDATOR_ERROR_CLASS + '$');
        },

        postCreate: function () {
            this.inherited(arguments);
            // Find the form for which validation is going to be performed and override its validator
            if (this.shouldFindForm) {
                this.form = getDijitAncestorByClass(this.domNode, DijitForm);
            }
            // Override the form's validation function with this class' form validator
            this.form.validate = lang.hitch(this, 'isValid');
        },

        startup: function () {
            // Go over the list of live validators and attach a listener to them so that when each of these inputs is
            // changed, validation will be called on that input immediately.
            // This isn't the best spot for this, but it is necessary so that the form input widgets will be parsed
            // at this point in the widget lifecycle. As such, we will guard against multiple startup calls using the
            // _started property inherited from _WidgetBase.
            if (!this._started) {
                this._started = true;
                this.own.apply(this, mapAndFilter(this.liveValidators,
                    lang.hitch(this, function (inputName) {
                        var input = this.form.domNode[inputName];
                        if (!!input) {
                            return on(registry.byNode(input) || input, 'change',
                                lang.hitch(this, 'validateSingle', inputName));
                        } else {
                            return undefined;
                        }
                    }),
                    function (item) {
                        return typeof item !== 'undefined';
                    }
                ));
            }

            // this._started will be set in _WidgetBase.startup()
            this.inherited(arguments);
        },

        /**
         * Loops over all the form's inputs and sees if a matching function name exists in
         * this validator object. If it does, that means there is a validation function
         * for that input which needs to be called. If that validation function fails, an
         * error function will be called (which can also be customly made).
         *
         * This is what ends up being called whenever form.validate() is called elsewhere
         * on the form's dijit.form.Form submission.
         *
         * @return {boolean} True if the form was submitted with all valid input, false otherwise.
         */
        isValid: function () {
            // Remove all errors that are marked on the form, so we don't carry over errors across submits
            removeClassByPattern(this.form.domNode, this.validatorErrorRegex);

            var formValues = this.form.get('value');
            var isValid = true;

            // Go over each form value and call any potential validators
            for (var key in formValues) {

                // Get the validation on this input
                var thisInputIsValid = this.validateSingle(key);

                // If it is not valid, then the entire form is invalid, which must be kept track of
                if (!thisInputIsValid) {
                    isValid = false;
                }
            }

            // If any errors occurred, mark this form as having validation errors
            if (!isValid) {
                domClass.add(this.form.domNode, this.VALIDATOR_ERROR_CLASS);
            }

            return isValid;
        },

        /**
         * Calls the validation function of a single input in the form, specified via argument, and returns the
         * result. Also calls error-handling functions and adds error classes.
         * @param {string} inputName The form input on which to call validation
         * @return {boolean} Whether the form input has valid user input or not
         */
        validateSingle: function (inputName) {
            // Check if the input has a validator function in the subclass
            if ((inputName in this) && lang.isFunction(this[inputName])) {
                // Fetch all of the form values for passing to the validator/error functions
                var formValues = this.form.get('value');

                // Call the validator function and cache the value
                var validInput = this[inputName](formValues[inputName], inputName, formValues);

                // Do error handling if input is not valid
                if (!validInput) {
                    // Mark the form with an error class for this input
                    domClass.add(this.form.domNode, this.VALIDATOR_ERROR_CLASS + '-' + inputName);

                    // Call the corresponding error function if it exists
                    var errorHandler = inputName + 'Error';
                    if (lang.isFunction(this[errorHandler])) {
                        this[errorHandler](formValues[inputName], inputName, formValues);
                    }
                } else {
                    // Otherwise we need to destroy any error message that may be there (necessary for live validation)
                    this.destroyErrorMessage(inputName);
                }

                return validInput;

            } else {
                // If there is no validator, return that this input "is valid"
                return true;
            }
        },

        /**
         * Creates an error message with a specified HTML tag type and a specified message
         * as a sibling to the input that has the class '<key>-pepperInput'. Includes standardized
         * classes on it for standard styling and functional use. Also destroys the previous error
         * message, if there is one (see comments within this function for why this should happen here).
         * @param {string} key The form input's key
         * @param {string} message The error message to use
         * @param {string?} tagType The HTML tag type to use for containing the error message (defaults to span)
         */
        createErrorMessage: function (key, message, tagType) {
            tagType = tagType || 'span'; // Defaults to a span

            // We can't guarantee that this particular error message node was created unless this create function
            // was called, so if the subclass uses this function for its error messages, we should also
            // clean up our own error messages at this point. Otherwise the subclass is responsible for that
            // all on its own, and we shouldn't interfere with that in this class.
            this.destroyErrorMessage(key);

            var classKey = key.replace('[', '\\[').replace(']', '\\]');

            domConstruct.create(tagType, {
                'class': this.INPUT_ERROR_CLASS + '-' + key + ' ' + this.INPUT_ERROR_CLASS,
                innerHTML: message
            }, query('.' + classKey + '-pepperInput', this.form.domNode)[0]);
        },

        /**
         * Destroys an error message that was created by this.createErrorMessage(). Can be harmlessly called if the
         * error message doesn't actually exist, since the query for the error message will return nothing, and
         * domConstruct.destroy() will simply do nothing.
         * @param {string} key The input for which the error message needs destruction.
         */
        destroyErrorMessage: function (key) {
            var classKey = key.replace('[', '\\[').replace(']', '\\]');
            domConstruct.destroy(query('.' + this.INPUT_ERROR_CLASS + '-' + classKey)[0]);
        },

        /**
         * Determines if the passed in input string is empty/null/undefined
         * @param {string} value The input string on which to test emptiness
         * @return {boolean} Whether the input string is empty or not
         */
        isEmpty: function (value) {
            return !value;
        },

        /**
         * Determines if the passed in input string has text (i.e. is not empty)
         * @param {string} value The input string for which to check for text
         * @return {boolean} Whether the input string has text or not
         */
        hasText: function (value) {
            return !this.isEmpty(value);
        }
    });
});

},
'vodori/util/getDijitAncestorByClass':function(){
define([
    'dijit/registry'
], function (registry) {
    'use strict';
    return function (node, targetClass) {
        var widget;
        if (!node || !targetClass) {
            console.error('Incorrect call to getDijitAncestorByClass(%o,%o)', node, targetClass);
        }
        while (node && node.parentNode) {
            node = node.parentNode;
            if (node === document) {
                // Calling dijit.byNode on the document will result in an error
                return;
            }
            widget = registry.byNode(node);
            if (widget && widget.isInstanceOf(targetClass)) {
                return widget;
            }
        }
    };
});

},
'vodori/util/node/removeClassByPattern':function(){
define([
    'lodash',
    'dojo/_base/lang',
    'dojo/dom-attr'
], function (_, lang, domAttr) {
    'use strict';

    var className = 'className';

    var defaultExcept = function (name) {
        return false;
    };

    return function (node, regex, except) {
        var cls = lang.trim(domAttr.get(node, className));

        except = _.isFunction(except) ? except : defaultExcept;

        var classes = _.filter(cls.split(/\s+/), function (name) {
            return !regex.test(regex) || except(name);
        });

        domAttr.set(node, className, classes.join(' '));

        return node;
    };
});
},
'pepper/form/workflowWizard/OptionsGrid':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'vodori/input/GroupedSelect',
    'dojo/text!./templates/OptionsGrid-option.html'
], function (module, provide, _, GroupedSelect, optionsTemplate) {

    /**
     * @class pepper/form/workflowWizard/OptionsGrid
     * @extends vodori/input/GroupedSelect
     */
    return provide(module, [GroupedSelect],
        /**
         * @lends pepper/form/workflowWizard/OptionsGrid#
         */ {
            /**
             * Generates a checked select option form a mustache template.
             *
             * @type {string}
             */
            labelTemplate: optionsTemplate,

            /**
             * We're loading extra data with our options, which we'll get from the data-dojo-props attr
             * in the domNode.
             *
             * @type {Array.<{
         *            label: string,
         *            value: (string|number),
         *            thumbnail: string,
         *            description: string
         *       }>}
             */
            options: null,

            /* START group comment */
            // These are constants, but can be changed in cas ethe BE modifies the data format.
            // Let's us decouple the OptionGrid's templates from the data.
            /**
             * @type {string}
             * @const
             */
            DESCRIPTION_KEY: 'description',

            /**
             * @type {string}
             * @const
             */
            THUMBNAIL_KEY: 'thumbnail',

            /**
             * @type {string}
             * @const
             */
            LABEL_KEY: 'label',

            /* END group comment */

            buildRendering: function () {
                this._decorateOptions();
                this.inherited(arguments);
            },

            /**
             * Associate the data w/ its option, so it'll be available when the inputs render.
             * @private
             */
            _decorateOptions: function () {
                _.forEach(this.options, function (option) {
                    option.label = option.label || 'No label';
                    option.thumbnail = option.thumbnail || '';
                    option.description = option.description || 'No description';
                });
            }
        });
});

},
'pepper/form/workflowWizard/ObjectList':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/string',
    'dojo/on', 'dojo/query', 'dojo/dom-construct', 'dojo/dom-attr', 'dojo/when',
    'dijit/_WidgetBase', 'dijit/registry',
    'dijit/form/TextBox', 'dijit/InlineEditBox', 'dijit/form/Textarea', 'dijit/form/Form',
    'vodori/util/node/getParents', 'vodori/util/node/htmlToElement',
    'vodori/util/getDijitAncestorByClass',
    'pepper/data/PostDescriptorStore',
    './objectList/ValueArrayInputWrapper',
    'dojo/text!./templates/ObjectListItem.html',

    'dojo/NodeList-dom'
], function (
    module, provide,
    _,
    lang, string, on, query, domConstruct, domAttr, when,
    _WidgetBase, registry,
    TextBox, InlineEditBox, Textarea, Form,
    getParents, htmlToElement,
    getDijitAncestorByClass,
    postDescriptorStore,
    ValueArrayInputWrapper,
    objectlistitemTemplate
    ) {
    var LIST_ITEM_ID_ATTR = 'data-pepper-object-list-item-id';
    var LIST_ITEM_REMOVER_ATTR = 'data-pepper-object-list-item-remover';
    var COMMENTS_FIELD = 'documentComments';

    /**
     * Lists arbitrary items w/ objectIds. Main purpose is to allow JSP rendered lists of objects to
     * be modified w/o heavy interaction on startup.
     *
     * @class pepper/form/workflowWizard/ObjectList
     * @extends dijit/_WidgetBase
     */
    return provide(module.id, [_WidgetBase],
        /**
         * @lends pepper/form/workflowWizard/ObjectList#
         */
        {
            /**
             * Something that performs basic add and remove w/ Array.<string>s. Must also have a dojo/on 'add' event.
             *
             * @type {{add: Function, remove: Function}}
             */
            readWriter: null,

            /**
             * Node to be wrapped w/ our readWriter. If set to a string will assume it's the form
             * element's name.
             *
             * @type {(dijit.form.TextBox|string)}
             */
            valueSrc: null,

            /**
             * Id of node to hold the hidden inputs that hold document comments
             */
            comments: null,

            /**
             * A query that will return all the listed objects.
             *
             * @type {string}
             */
            listItemDomQuery: 'li[' + LIST_ITEM_ID_ATTR + ']',

            /**
             * An attribute name for the element that will trigger an item's removal.
             *
             * @type {string}
             * @const
             */
            REMOVER_ATTR: LIST_ITEM_REMOVER_ATTR,

            /**
             * Where the id of each listed object is stored on its DOMNode.
             *
             * @type {string}
             * @const
             */
            ID_ATTR: LIST_ITEM_ID_ATTR,

            /**
             * Used to render all the items.
             *
             * @type {string}
             */
            itemTemplate: objectlistitemTemplate,

            /**
             * {Class.<{add: Function, remove: Function}>}
             *
             * @typedef ReadWriteConstructor
             * @type function
             */
            /**
             * Used to construct our add/remove utility.
             *
             * @type {ReadWriteConstructor}
             */
            ReadWriteConstructor: ValueArrayInputWrapper,

            editable: false,

            _storedComments: null,

            /**
             * Init collections.
             */
            constructor: function () {
                this._storedComments = {};
                this.commentField = COMMENTS_FIELD;
            },

            /**
             * Create our readwriter and attach to relevant events.
             */
            postCreate: function () {
                this.inherited(arguments);

                if (_.isString(this.comments)) {
                    this.comments = query('div[id=' + this.comments + ']', this._getContainingForm())[0];
                }

                this.readWriter = this._createReadWriter();
                this.readWriter.all().then(lang.hitch(this, function(objectIds) {
                    console.log(objectIds);
                    _.forEach(objectIds, this._setupCommentsForObjectId, this);
                }));

                this.parentForm = getDijitAncestorByClass(this.domNode, Form);

                this.own(on(this.domNode, 'click', lang.hitch(this, 'handleClick')));

                this.own(on(this.readWriter, 'add', lang.hitch(this, 'addItem')));
            },

            _setupCommentsForObjectId: function(objectId) {
                var objectItem = query('li[data-pepper-object-list-item-id="'+objectId+'"]', this.domNode)[0];
                var commentDiv = query('.item-comment', objectItem)[0];
                this._storeComment(objectId, commentDiv.innerHTML);
                this._createCommentEditor(objectItem, objectId);
            },

            /**
             * To use the same template for BE and FE, we'll shim the data.
             *
             * @param {*} data
             * @return {Object}
             */
            shimData: function (data) {
                var thumbnailUrl = data.thumbnailUrl + '?v=' + data.lastModified;
                return {
                    listedItem: {
                        item: {
                            id: (data.objectId || data.id),
                            logicalName: (data.name || 'No name set'),
                            primaryUri: data.path,
                            url: data.authorUrl
                        },
                        dateAdded: {
                            time: 'Now'
                        },
                        comment: this.editable ? '' : 'No comment provided',

                        // appending a query string for potential cache busting
                        thumbnailUrl: (thumbnailUrl || '/static/js/pepper/images/placeholder.png')
                    }
                };
            },

            /**
             * Create an Inline editor for document comments
             *
             * @param listItemNode The Node that holds the ObjectLsit Item
             * @param objectId The object ID of that item
             * @return {*} the InlineEditBox
             * @private
             */
            _createCommentEditor: function(listItemNode, objectId) {
                if(this.editable) {
                    var commentDiv = query('.item-comment',listItemNode)[0];
                    var editBox =  new InlineEditBox(
                        {
                            editor: Textarea,
                            autoSave: false,
                            noValueIndicator: '<em>Click here to add a comment or directions</em>',
                            onChange: lang.hitch(this, '_storeComment', objectId)
                        }, commentDiv
                    );
                    return editBox;
                } else {
                    return null;
                }
            },

            /**
             * Render the datum as an html string.
             *
             * @param {*} objectId
             */
            addItem: function (objectId) {

                when(postDescriptorStore.get(objectId), lang.hitch(this, function(addedObject) {

                    addedObject = this.shimData(addedObject);
                    addedObject.mutability = 'delible';
                    var pepperItemId = addedObject.listedItem.item.id;
                    var listItemNode = domConstruct.place(
                        htmlToElement(
                            string.substitute(this.itemTemplate, addedObject), true
                        ),
                        this.domNode,
                        'last'
                    );
                    this._storeComment(pepperItemId, addedObject.listedItem.comment);
                    this._createCommentEditor(listItemNode, pepperItemId);

                }));


            },

            /**
             * Remove an object from the list.
             *
             * @param {(string|Element|HTMLElement)} item
             */
            removeItem: function (item) {
                this.readWriter.remove(this.getItemId(item));
                domConstruct.destroy(this.getItem(item));
                this._removeComment(this.getItemId(item));
            },

            /**
             * @param {Element|string} item The element that represents the object, or it's id.
             * @return {Element}
             */
            getItem: function (item) {
                if (lang.isString(item)) {
                    return query('[' + this.ID_ATTR + '=' + item + ']', this.domNode)[0];
                } else {
                    return item;
                }
            },

            /**
             * @param {Element} child An element inside of the sought item.
             * @return {Element} The sought item.
             */
            getItemByChildElement: function (child) {
                return getParents(child, '[' + LIST_ITEM_ID_ATTR + ']')[0];
            },

            /**
             * Figure out which element to remove, if any.
             *
             * @param {Event} event
             */
            handleClick: function (event) {
                var targetElement = /** @type {Element} */ event.target;
                var isRemove = !!getParents(targetElement, '[' + this.REMOVER_ATTR + ']').length;

                if (isRemove) {
                    this.removeItem(this.getItemByChildElement(targetElement));
                }
            },

            /**
             * @param {(Element|string)} item The item or its id.
             * @return {string} The item's id.
             */
            getItemId: function (item) {
                if (lang.isString(item)) {
                    return item;
                } else {
                    return domAttr.get(item, this.ID_ATTR);
                }
            },

            /**
             * Finds the inner most form that contains this widget.
             *
             * @return {HTMLFormElement}
             * @private
             */
            _getContainingForm: function () {
                return getParents(this.domNode, 'form')[0];
            },

            /**
             * Look up the proxied input if it's not a node reference and create the read writer.
             *
             * @return {ReadWriteConstructor} See: this.readWriter
             * @private
             */
            _createReadWriter: function () {
                if (lang.isString(this.valueSrc)) {
                    this.valueSrc = query('[name="' + this.valueSrc + '"]', this._getContainingForm())[0];
                }

                return new this.ReadWriteConstructor({
                    wrappedInput: registry.byNode(this.valueSrc)
                });
            },

            _storeComment: function(itemId, comment) {
                if(typeof this._storedComments[itemId] === 'undefined') {
                    this._storedComments[itemId] = new TextBox({
                        name:   this.commentField+'[\''+itemId+'\']',
                        type:   'hidden'
                    });
                    domConstruct.place(this._storedComments[itemId].domNode, this.comments, 'last');
                    if(this.parentForm) {
                        /*
                         * Since we programatically added this TextBox, if there is a form, we need to tell it
                         * to connect to it  so that our watch works correctly
                         */
                        this.parentForm.connectChildren();
                    }
                }

                this._storedComments[itemId].set('value', comment);
            },

            _removeComment: function(itemId) {
                if(typeof this._storedComments[itemId] !== 'undefined') {
                    domConstruct.destroy(this._storedComments[itemId].domNode);
                    this._storedComments[itemId] = undefined;
                }
            }
        });
});


},
'dijit/InlineEditBox':function(){
define([
	"require",
	"dojo/_base/array", // array.forEach
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set domAttr.get
	"dojo/dom-class", // domClass.add domClass.remove domClass.toggle
	"dojo/dom-construct", // domConstruct.create domConstruct.destroy
	"dojo/dom-style", // domStyle.getComputedStyle domStyle.set domStyle.get
	"dojo/i18n", // i18n.getLocalization
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/keys", // keys.ENTER keys.ESCAPE
	"dojo/_base/lang", // lang.getObject
	"dojo/on",
	"dojo/sniff", // has("ie")
	"dojo/when",
	"./a11yclick",
	"./focus",
	"./_Widget",
	"./_TemplatedMixin",
	"./_WidgetsInTemplateMixin",
	"./_Container",
	"./form/Button",
	"./form/_TextBoxMixin",
	"./form/TextBox",
	"dojo/text!./templates/InlineEditBox.html",
	"dojo/i18n!./nls/common"
], function(require, array, aspect, declare, domAttr, domClass, domConstruct, domStyle, i18n, kernel, keys, lang, on, has, when, a11yclick, fm, _Widget, _TemplatedMixin, _WidgetsInTemplateMixin, _Container, Button, _TextBoxMixin, TextBox, template){

	// module:
	//		dijit/InlineEditBox

	var InlineEditor = declare("dijit._InlineEditor", [_Widget, _TemplatedMixin, _WidgetsInTemplateMixin], {
		// summary:
		//		Internal widget used by InlineEditBox, displayed when in editing mode
		//		to display the editor and maybe save/cancel buttons.  Calling code should
		//		connect to save/cancel methods to detect when editing is finished
		//
		//		Has mainly the same parameters as InlineEditBox, plus these values:
		//
		// style: Object
		//		Set of CSS attributes of display node, to replicate in editor
		//
		// value: String
		//		Value as an HTML string or plain text string, depending on renderAsHTML flag

		templateString: template,

		contextRequire: require,

		postMixInProperties: function(){
			this.inherited(arguments);
			this.messages = i18n.getLocalization("dijit", "common", this.lang);
			array.forEach(["buttonSave", "buttonCancel"], function(prop){
				if(!this[prop]){
					this[prop] = this.messages[prop];
				}
			}, this);
		},

		buildRendering: function(){
			this.inherited(arguments);

			// Create edit widget in place in the template
			// TODO: remove getObject() for 2.0
			var Cls = typeof this.editor == "string" ? (lang.getObject(this.editor) || require(this.editor)) : this.editor;

			// Copy the style from the source
			// Don't copy ALL properties though, just the necessary/applicable ones.
			// wrapperStyle/destStyle code is to workaround IE bug where getComputedStyle().fontSize
			// is a relative value like 200%, rather than an absolute value like 24px, and
			// the 200% can refer *either* to a setting on the node or it's ancestor (see #11175)
			var srcStyle = this.sourceStyle,
				editStyle = "line-height:" + srcStyle.lineHeight + ";",
				destStyle = domStyle.getComputedStyle(this.domNode);
			array.forEach(["Weight", "Family", "Size", "Style"], function(prop){
				var textStyle = srcStyle["font" + prop],
					wrapperStyle = destStyle["font" + prop];
				if(wrapperStyle != textStyle){
					editStyle += "font-" + prop + ":" + srcStyle["font" + prop] + ";";
				}
			}, this);
			array.forEach(["marginTop", "marginBottom", "marginLeft", "marginRight", "position", "left", "top", "right", "bottom", "float", "clear", "display"], function(prop){
				this.domNode.style[prop] = srcStyle[prop];
			}, this);
			var width = this.inlineEditBox.width;
			if(width == "100%"){
				// block mode
				editStyle += "width:100%;";
				this.domNode.style.display = "block";
			}else{
				// inline-block mode
				editStyle += "width:" + (width + (Number(width) == width ? "px" : "")) + ";";
			}
			var editorParams = lang.delegate(this.inlineEditBox.editorParams, {
				style: editStyle,
				dir: this.dir,
				lang: this.lang,
				textDir: this.textDir
			});
			// set the value in onLoadDeferred instead so the widget has time to finish initializing
			//editorParams[("displayedValue" in Cls.prototype || "_setDisplayedValueAttr" in Cls.prototype) ? "displayedValue" : "value"] = this.value;
			this.editWidget = new Cls(editorParams, this.editorPlaceholder);

			if(this.inlineEditBox.autoSave){
				// Remove the save/cancel buttons since saving is done by simply tabbing away or
				// selecting a value from the drop down list
				this.saveButton.destroy();
				this.cancelButton.destroy();
				this.saveButton = this.cancelButton = null;
				domConstruct.destroy(this.buttonContainer);
			}
		},

		postCreate: function(){
			this.inherited(arguments);

			var ew = this.editWidget;

			if(this.inlineEditBox.autoSave){
				this.own(
					// Selecting a value from a drop down list causes an onChange event and then we save
					aspect.after(ew, "onChange", lang.hitch(this, "_onChange"), true),

					// ESC and TAB should cancel and save.
					on(ew, "keydown", lang.hitch(this, "_onKeyDown"))
				);
			}else{
				// If possible, enable/disable save button based on whether the user has changed the value
				if("intermediateChanges" in ew){
					ew.set("intermediateChanges", true);
					this.own(aspect.after(ew, "onChange", lang.hitch(this, "_onIntermediateChange"), true));
					this.saveButton.set("disabled", true);
				}
			}
		},

		startup: function(){
			this.editWidget.startup();
			this.inherited(arguments);
		},

		_onIntermediateChange: function(/*===== val =====*/){
			// summary:
			//		Called for editor widgets that support the intermediateChanges=true flag as a way
			//		to detect when to enable/disabled the save button
			this.saveButton.set("disabled", (this.getValue() == this._resetValue) || !this.enableSave());
		},

		destroy: function(){
			this.editWidget.destroy(true); // let the parent wrapper widget clean up the DOM
			this.inherited(arguments);
		},

		getValue: function(){
			// summary:
			//		Return the [display] value of the edit widget
			var ew = this.editWidget;
			return String(ew.get(("displayedValue" in ew || "_getDisplayedValueAttr" in ew) ? "displayedValue" : "value"));
		},

		_onKeyDown: function(e){
			// summary:
			//		Handler for keydown in the edit box in autoSave mode.
			// description:
			//		For autoSave widgets, if Esc/Enter, call cancel/save.
			// tags:
			//		private

			if(this.inlineEditBox.autoSave && this.inlineEditBox.editing){
				if(e.altKey || e.ctrlKey){
					return;
				}
				// If Enter/Esc pressed, treat as save/cancel.
				if(e.keyCode == keys.ESCAPE){
					e.stopPropagation();
					e.preventDefault();
					this.cancel(true); // sets editing=false which short-circuits _onBlur processing
				}else if(e.keyCode == keys.ENTER && e.target.tagName == "INPUT"){
					e.stopPropagation();
					e.preventDefault();
					this._onChange(); // fire _onBlur and then save
				}

				// _onBlur will handle TAB automatically by allowing
				// the TAB to change focus before we mess with the DOM: #6227
				// Expounding by request:
				//	The current focus is on the edit widget input field.
				//	save() will hide and destroy this widget.
				//	We want the focus to jump from the currently hidden
				//	displayNode, but since it's hidden, it's impossible to
				//	unhide it, focus it, and then have the browser focus
				//	away from it to the next focusable element since each
				//	of these events is asynchronous and the focus-to-next-element
				//	is already queued.
				//	So we allow the browser time to unqueue the move-focus event
				//	before we do all the hide/show stuff.
			}
		},

		_onBlur: function(){
			// summary:
			//		Called when focus moves outside the editor
			// tags:
			//		private

			this.inherited(arguments);
			if(this.inlineEditBox.autoSave && this.inlineEditBox.editing){
				if(this.getValue() == this._resetValue){
					this.cancel(false);
				}else if(this.enableSave()){
					this.save(false);
				}
			}
		},

		_onChange: function(){
			// summary:
			//		Called when the underlying widget fires an onChange event,
			//		such as when the user selects a value from the drop down list of a ComboBox,
			//		which means that the user has finished entering the value and we should save.
			// tags:
			//		private

			if(this.inlineEditBox.autoSave && this.inlineEditBox.editing && this.enableSave()){
				fm.focus(this.inlineEditBox.displayNode); // fires _onBlur which will save the formatted value
			}
		},

		enableSave: function(){
			// summary:
			//		User overridable function returning a Boolean to indicate
			//		if the Save button should be enabled or not - usually due to invalid conditions
			// tags:
			//		extension
			return this.editWidget.isValid ? this.editWidget.isValid() : true;
		},

		focus: function(){
			// summary:
			//		Focus the edit widget.
			// tags:
			//		protected

			this.editWidget.focus();

			if(this.editWidget.focusNode){
				// IE can take 30ms to report the focus event, but focus manager needs to know before a 0ms timeout.
				fm._onFocusNode(this.editWidget.focusNode);

				if(this.editWidget.focusNode.tagName == "INPUT"){
					this.defer(function(){
						_TextBoxMixin.selectInputText(this.editWidget.focusNode);
					});
				}
			}
		}
	});


	var InlineEditBox = declare("dijit.InlineEditBox" + (has("dojo-bidi") ? "_NoBidi" : ""), _Widget, {
		// summary:
		//		An element with in-line edit capabilities
		//
		// description:
		//		Behavior for an existing node (`<p>`, `<div>`, `<span>`, etc.) so that
		//		when you click it, an editor shows up in place of the original
		//		text.  Optionally, Save and Cancel button are displayed below the edit widget.
		//		When Save is clicked, the text is pulled from the edit
		//		widget and redisplayed and the edit widget is again hidden.
		//		By default a plain Textarea widget is used as the editor (or for
		//		inline values a TextBox), but you can specify an editor such as
		//		dijit.Editor (for editing HTML) or a Slider (for adjusting a number).
		//		An edit widget must support the following API to be used:
		//
		//		- displayedValue or value as initialization parameter,
		//			and available through set('displayedValue') / set('value')
		//		- void focus()
		//		- DOM-node focusNode = node containing editable text

		// editing: [readonly] Boolean
		//		Is the node currently in edit mode?
		editing: false,

		// autoSave: [const] Boolean
		//		Changing the value automatically saves it; don't have to push save button
		//		(and save button isn't even displayed)
		autoSave: true,

		// buttonSave: String
		//		Save button label
		buttonSave: "",

		// buttonCancel: String
		//		Cancel button label
		buttonCancel: "",

		// renderAsHtml: Boolean
		//		Set this to true if the specified Editor's value should be interpreted as HTML
		//		rather than plain text (ex: `dijit.Editor`)
		renderAsHtml: false,

		// editor: String|Function
		//		MID (ex: "dijit/form/TextBox") or constructor for editor widget
		editor: TextBox,

		// editorWrapper: String|Function
		//		Class name (or reference to the Class) for widget that wraps the editor widget, displaying save/cancel
		//		buttons.
		editorWrapper: InlineEditor,

		// editorParams: Object
		//		Set of parameters for editor, like {required: true}
		editorParams: {},

		// disabled: Boolean
		//		If true, clicking the InlineEditBox to edit it will have no effect.
		disabled: false,

		onChange: function(/*===== value =====*/){
			// summary:
			//		Set this handler to be notified of changes to value.
			// tags:
			//		callback
		},

		onCancel: function(){
			// summary:
			//		Set this handler to be notified when editing is cancelled.
			// tags:
			//		callback
		},

		// width: String
		//		Width of editor.  By default it's width=100% (ie, block mode).
		width: "100%",

		// value: String
		//		The display value of the widget in read-only mode
		value: "",

		// noValueIndicator: [const] String
		//		The text that gets displayed when there is no value (so that the user has a place to click to edit)
		noValueIndicator: has("ie") <= 6 ? // font-family needed on IE6 but it messes up IE8
			"<span style='font-family: wingdings; text-decoration: underline;'>&#160;&#160;&#160;&#160;&#x270d;&#160;&#160;&#160;&#160;</span>" :
			"<span style='text-decoration: underline;'>&#160;&#160;&#160;&#160;&#x270d;&#160;&#160;&#160;&#160;</span>", // &#160; == &nbsp;

		constructor: function(/*===== params, srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my value
			//		- replace srcNodeRef with my generated DOM tree

			this.editorParams = {};
		},

		postMixInProperties: function(){
			this.inherited(arguments);

			// save pointer to original source node, since Widget nulls-out srcNodeRef
			this.displayNode = this.srcNodeRef;

			// connect handlers to the display node
			this.own(
				on(this.displayNode, a11yclick, lang.hitch(this, "_onClick")),
				on(this.displayNode, "mouseover, focus", lang.hitch(this, "_onMouseOver")),
				on(this.displayNode, "mouseout, blur", lang.hitch(this, "_onMouseOut"))
			);

			this.displayNode.setAttribute("role", "button");
			if(!this.displayNode.getAttribute("tabIndex")){
				this.displayNode.setAttribute("tabIndex", 0);
			}

			if(!this.value && !("value" in this.params)){ // "" is a good value if specified directly so check params){
				this.value = lang.trim(this.renderAsHtml ? this.displayNode.innerHTML :
					(this.displayNode.innerText || this.displayNode.textContent || ""));
			}
			if(!this.value){
				this.displayNode.innerHTML = this.noValueIndicator;
			}

			domClass.add(this.displayNode, 'dijitInlineEditBoxDisplayMode');
		},

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.   Use set('disabled', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.InlineEditBox.setDisabled() is deprecated.  Use set('disabled', bool) instead.", "", "2.0");
			this.set('disabled', disabled);
		},

		_setDisabledAttr: function(/*Boolean*/ disabled){
			// summary:
			//		Hook to make set("disabled", ...) work.
			//		Set disabled state of widget.
			this.domNode.setAttribute("aria-disabled", disabled ? "true" : "false");
			if(disabled){
				this.displayNode.removeAttribute("tabIndex");
			}else{
				this.displayNode.setAttribute("tabIndex", 0);
			}
			domClass.toggle(this.displayNode, "dijitInlineEditBoxDisplayModeDisabled", disabled);
			this._set("disabled", disabled);
		},

		_onMouseOver: function(){
			// summary:
			//		Handler for onmouseover and onfocus event.
			// tags:
			//		private
			if(!this.disabled){
				domClass.add(this.displayNode, "dijitInlineEditBoxDisplayModeHover");
			}
		},

		_onMouseOut: function(){
			// summary:
			//		Handler for onmouseout and onblur event.
			// tags:
			//		private
			domClass.remove(this.displayNode, "dijitInlineEditBoxDisplayModeHover");
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Handler for onclick event.
			// tags:
			//		private
			if(this.disabled){
				return;
			}
			if(e){
				e.stopPropagation();
				e.preventDefault();
			}
			this._onMouseOut();

			// Since FF gets upset if you move a node while in an event handler for that node...
			this.defer("edit");
		},

		edit: function(){
			// summary:
			//		Display the editor widget in place of the original (read only) markup.
			// tags:
			//		private

			if(this.disabled || this.editing){
				return;
			}
			this._set('editing', true);

			// save some display node values that can be restored later
			this._savedTabIndex = domAttr.get(this.displayNode, "tabIndex") || "0";

			if(!this.wrapperWidget){
				// Placeholder for edit widget
				// Put place holder (and eventually editWidget) before the display node so that it's positioned correctly
				// when Calendar dropdown appears, which happens automatically on focus.
				var placeholder = domConstruct.create("span", null, this.domNode, "before");

				// Create the editor wrapper (the thing that holds the editor widget and the save/cancel buttons)
				var Ewc = typeof this.editorWrapper == "string" ? lang.getObject(this.editorWrapper) : this.editorWrapper;
				this.wrapperWidget = new Ewc({
					value: this.value,
					buttonSave: this.buttonSave,
					buttonCancel: this.buttonCancel,
					dir: this.dir,
					lang: this.lang,
					tabIndex: this._savedTabIndex,
					editor: this.editor,
					inlineEditBox: this,
					sourceStyle: domStyle.getComputedStyle(this.displayNode),
					save: lang.hitch(this, "save"),
					cancel: lang.hitch(this, "cancel"),
					textDir: this.textDir
				}, placeholder);
				if(!this.wrapperWidget._started){
					this.wrapperWidget.startup();
				}
				if(!this._started){
					this.startup();
				}
			}
			var ww = this.wrapperWidget;

			// to avoid screen jitter, we first create the editor with position: absolute, visibility: hidden,
			// and then when it's finished rendering, we switch from display mode to editor
			// position: absolute releases screen space allocated to the display node
			// opacity:0 is the same as visibility: hidden but is still focusable
			// visibility: hidden removes focus outline

			domClass.add(this.displayNode, "dijitOffScreen");
			domClass.remove(ww.domNode, "dijitOffScreen");
			domStyle.set(ww.domNode, { visibility: "visible" });
			domAttr.set(this.displayNode, "tabIndex", "-1"); // needed by WebKit for TAB from editor to skip displayNode

			// After edit widget has finished initializing (in particular need to wait for dijit.Editor),
			// or immediately if there is no onLoadDeferred Deferred,
			// replace the display widget with edit widget, leaving them both displayed for a brief time so that
			// focus can be shifted without incident.
			var ew = ww.editWidget;
			var self = this;
			when(ew.onLoadDeferred, lang.hitch(ww, function(){
				// set value again in case the edit widget's value is just now valid
				ew.set(("displayedValue" in ew || "_setDisplayedValueAttr" in ew) ? "displayedValue" : "value", self.value);
				this.defer(function(){ // defer needed so that the change of focus doesn't happen on mousedown which also sets focus
					// the saveButton should start out disabled in most cases but the above set could have fired onChange
					if(ww.saveButton){
						ww.saveButton.set("disabled", "intermediateChanges" in ew);
					}
					this.focus(); // both nodes are showing, so we can switch focus safely
					this._resetValue = this.getValue();
				});
			}));
		},

		_onBlur: function(){
			// summary:
			//		Called when focus moves outside the InlineEditBox.
			//		Performs garbage collection.
			// tags:
			//		private

			this.inherited(arguments);
			if(!this.editing){
				/* causes IE focus problems, see TooltipDialog_a11y.html...
				 this.defer(function(){
				 if(this.wrapperWidget){
				 this.wrapperWidget.destroy();
				 delete this.wrapperWidget;
				 }
				 });
				 */
			}
		},

		destroy: function(){
			if(this.wrapperWidget && !this.wrapperWidget._destroyed){
				this.wrapperWidget.destroy();
				delete this.wrapperWidget;
			}
			this.inherited(arguments);
		},

		_showText: function(/*Boolean*/ focus){
			// summary:
			//		Revert to display mode, and optionally focus on display node
			// tags:
			//		private

			var ww = this.wrapperWidget;
			domStyle.set(ww.domNode, { visibility: "hidden" }); // hide the editor from mouse/keyboard events
			domClass.add(ww.domNode, "dijitOffScreen");
			domClass.remove(this.displayNode, "dijitOffScreen");
			domAttr.set(this.displayNode, "tabIndex", this._savedTabIndex);
			if(focus){
				fm.focus(this.displayNode);
			}
		},

		save: function(/*Boolean*/ focus){
			// summary:
			//		Save the contents of the editor and revert to display mode.
			// focus: Boolean
			//		Focus on the display mode text
			// tags:
			//		private

			if(this.disabled || !this.editing){
				return;
			}
			this._set('editing', false);

			var ww = this.wrapperWidget;
			var value = ww.getValue();
			this.set('value', value); // display changed, formatted value

			this._showText(focus); // set focus as needed
		},

		setValue: function(/*String*/ val){
			// summary:
			//		Deprecated.   Use set('value', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.InlineEditBox.setValue() is deprecated.  Use set('value', ...) instead.", "", "2.0");
			return this.set("value", val);
		},

		_setValueAttr: function(/*String*/ val){
			// summary:
			//		Hook to make set("value", ...) work.
			//		Inserts specified HTML value into this node, or an "input needed" character if node is blank.

			val = lang.trim(val);
			var renderVal = this.renderAsHtml ? val : val.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;").replace(/\n/g, "<br>");
			this.displayNode.innerHTML = renderVal || this.noValueIndicator;
			this._set("value", val);

			if(this._started){
				// tell the world that we have changed
				this.defer(function(){
					this.onChange(val);
				}); // defer prevents browser freeze for long-running event handlers
			}
		},

		getValue: function(){
			// summary:
			//		Deprecated.   Use get('value') instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.InlineEditBox.getValue() is deprecated.  Use get('value') instead.", "", "2.0");
			return this.get("value");
		},

		cancel: function(/*Boolean*/ focus){
			// summary:
			//		Revert to display mode, discarding any changes made in the editor
			// tags:
			//		private

			if(this.disabled || !this.editing){
				return;
			}
			this._set('editing', false);

			// tell the world that we have no changes
			this.defer("onCancel"); // defer prevents browser freeze for long-running event handlers

			this._showText(focus);
		}
	});

	if(has("dojo-bidi")){
		InlineEditBox = declare("dijit.InlineEditBox", InlineEditBox, {
			_setValueAttr: function(){
				this.inherited(arguments);
				this.applyTextDir(this.displayNode);
			}
		});
	}

	InlineEditBox._InlineEditor = InlineEditor;	// for monkey patching

	return InlineEditBox;
});

},
'vodori/util/node/htmlToElement':function(){
define([
    'dojo/_base/window',
    'dojo/parser'
], function (window, parser) {
    /**
     * Takes in an HTML string and converts it to a DOM node tree.
     * Assumes that there is only one root node of the tree.
     * @param {string} html The HTML string to convert
     * @param {boolean} [parse] Whether to run the Dojo parser on the converted DOM tree
     * @param {function} [callback] Function called with the instantiated widgets from parser.parse (needs parse = true)
     * @return {DomNode} The converted string as a DOM node tree
     */
    return function (html, parse, callback) {
        // We'll render via a doc frag.
        var fragment = window.doc.createDocumentFragment();

        // This'll hold the innerHTML
        var container = window.doc.createElement('div');
        fragment.appendChild(container);
        container.innerHTML = html;

        if (parse) {
            var result = parser.parse(container, {template:false});

            if(callback) {
                result.then(callback);
            }
        }

        fragment.removeChild(container);

        var rendered = container.firstChild;

        while (rendered.nodeType !== 1) {
            rendered = rendered.nextSibling;
        }

        return rendered;
    };
});

},
'pepper/form/workflowWizard/objectList/ValueArrayInputWrapper':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/on',
    'dojo/_base/lang', 'dojo/Deferred',
    'dijit/_WidgetBase', 'dojo/Evented'
], function (module, provide, _, on, lang, Deferred, _WidgetBase, Evented) {
    /**
     * Facade around managing an InputElement as a data source. Essentially, it'll proxy add and
     * remove to and from the InputElement, which is handy, if you need to connect many items to the
     * same input. Attempts to treat the inputs value as a database.
     * @class pepper/form/workflowWizard/objectList/ValueArrayInputWrapper
     * @extends dijit/_WidgetBase
     * @mixes dojo/Evented
     */
    return provide(module.id, [_WidgetBase, Evented],
        /**
         * @lends pepper/form/workflowWizard/objectList/ValueArrayInputWrapper#
         */
        {
            /**
             * @type {dijit.form.TextBox}
             */
            wrappedInput: null,

            /**
             * Fire add events for items that are already in the input.
             *
             * @type {boolean}
             */
            eventsOnCreate: false,

            /**
             * We'll block behind a deferred, so we don't have to care about load time.
             *
             * @type {dojo.Deferred}
             */
            _loadDeferred: null,

            /**
             * Used for uniqueness testing.
             *
             * @type {Object}
             */
            _hashIndex: null,

            constructor: function () {
                this._loadDeferred = new Deferred();
                this._hashIndex = {};
            },

            postCreate: function () {
                this.inherited(arguments);

                this._sync(this.eventsOnCreate);
                this._loadDeferred.resolve();

                on(this.wrappedInput, 'change', lang.hitch(this, function () {
                    this._sync();
                }));
            },

            /**
             * Adds an item to the pool. Or simulates it (needed for aspecting).
             *
             * @param {string} datum The item to add
             * @return {dojo.Deferred.promise.<T>}
             */
            add: function (datum) {
                this.emit('add', datum);
                return this._applyMethodWhenLoaded('_add', [datum]);
            },

            /**
             * Takes an item out of the pool.
             *
             * @param {string} datum The item to remove.
             * @return {dojo.Deferred.promise.<T>}
             */
            remove: function (datum) {
                this.emit('remove', datum);
                return this._applyMethodWhenLoaded('_remove', [datum]);
            },

            /**
             * Get or replace all the items in the collection.
             *
             * @param {Array.<string>} [replaceWith=null] Set to replace the existing values.
             * @return {(dojo.Deferred.promise.<(T|Array.<string>)>)} If you're setting, then return the instance.
             */
            all: function (replaceWith) {
                return this._applyMethodWhenLoaded('_all', [replaceWith]);
            },

            /**
             * @param {boolean} [withEvents=true]
             * @private
             */
            _sync: function (withEvents) {
                var read = this._read();
                _.forEach(read, function (datum) {
                    // Simulate the events for any items that are "snuck" into the input.
                    if (!this._hashIndex[datum]) {
                        this._hashIndex[datum] = true;
                        if (withEvents !== false) {
                            this.emit('add', datum);
                        }
                    }
                }, this);
            },

            /**
             * Pulling out the deferred blocking into a single method, that handles delegation.
             *
             * @param {(string|Function)} method
             * @param {*} args
             * @return {dojo.Deferred.promise} A
             * @private
             */
            _applyMethodWhenLoaded: function (method, args) {
                var waitFor = new Deferred();
                this._loadDeferred.then(lang.hitch(this, function () {
                    waitFor.resolve(this[method].apply(this, args));
                }));
                return waitFor.promise;
            },

            /**
             * Adds an item to the pool.
             *
             * @param {string} datum The item to add
             * @return {T}
             */
            _add: function (datum) {
                var values = this._read();

                if (!_.contains(values, datum)) {
                    values.push(datum);
                }

                return this._write(values);
            },

            /**
             * Takes an item out of the pool.
             *
             * @param {string} datum The item to remove.
             * @return {T}
             */
            _remove: function (datum) {
                var values = this._read();

                values = _.filter(values, function (value) {
                    return lang.trim(value) !== lang.trim(datum);
                });

                return this._write(values);
            },

            /**
             * Get or replace all the items in the collection.
             *
             * @param {Array.<string>} [replaceWith=null] Set to replace the existing values.
             * @return {(Array.<string>|T)} If you're setting, then return the instance.
             */
            _all: function (replaceWith) {
                if (lang.isArray(replaceWith) || lang.isArrayLike(replaceWith)) {
                    return this._write(replaceWith);
                } else {
                    return this._read();
                }
            },

            /**
             *
             * @param {Array.<string>} data
             * @return {T}
             * @private
             */
            _write: function (data) {
                // Wipe the index to ensure it's never out of date.
                this._hashIndex = {};

                var value = _.map(data,function (datum) {
                    this._hashIndex[datum] = true;
                    return datum.replace(/^['"]|['"]$/g, '');
                }, this).join(',');

                return this.set('value', value);
            },

            /**
             * Read out the current value as an Array.
             *
             * @return {Array.<string>}
             * @private
             */
            _read: function () {
                var value = this.get('value');

                if (!value) {
                    return [];
                } else {
                    return value.split(',');
                }
            },

            /**
             * We're proxying for an input node, so return its value.
             *
             * @return {string}
             * @private
             */
            _getValueAttr: function () {
                var input = this.wrappedInput;

                return lang.trim(input.get('value'));
            },

            /**
             * @param {string} value
             * @return {T}
             * @private
             */
            _setValueAttr: function (value) {
                var input = this.wrappedInput;
                value = lang.trim(value).replace(/^,|,$/, '');

                input.set('value', value);
                return this;
            }

        });
});

},
'pepper/workflow/NextPerformerSelector':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'dojo/on',
    'dojo/dom-class', 'dojo/store/Memory',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'vodori/util/string/camelToTitle',
    'dojo/text!./templates/NextPerformerSelector.html',

    /* Modules for Parser */
    'dijit/form/FilteringSelect'
],
    function (module, provide,
              lang, on,
              domClass, Memory,
              _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
              camelToTitle,
              template) {
        /**
         *
         * @class
         */
        var NextPerformerSelector = {

            templateString: template,
            typePropertyName: 'performerType',
            performerPropertyName: 'performer',

            constructor: function () {

            },

            /**
             * _WidgetBase Lifecycle method
             */
            postMixInProperties: function () {
                this.inherited(arguments);
                this._performerStore = new Memory({data: this.performerData});
                this.groupName = camelToTitle(this.groupName);
            },

            /**
             * _WidgetBase Lifecycle method
             */
            buildRendering: function () {
                this.inherited(arguments);
            },

            /**
             * _WidgetBase Lifecycle method
             */
            postCreate: function () {
                this.inherited(arguments);
                this.performerSelector.set('store', this._performerStore);

                on(this.groupContainer, 'click', lang.hitch(this, function (evt) {
                    this._chooseSelector(this.groupContainer);
                    this.performerType.set('value', 'GROUP');
                }));

                on(this.performerContainer, 'click', lang.hitch(this, function (evt) {
                    this._chooseSelector(this.performerContainer);
                    this.performerType.set('value', 'PERFORMER');
                }));

                on(this.performerSelector, 'change', lang.hitch(this, function (performer) {
                    this.nextPerformer.set('value', performer);
                }));
            },

            /**
             * _WidgetBase Lifecycle method
             */
            startup: function () {
                this.inherited(arguments);
            },

            _chooseSelector: function (selectorContainer) {
                var chosePerformerSelector = (selectorContainer === this.performerContainer);
                domClass.toggle(this.performerContainer, 'selected', chosePerformerSelector);
                domClass.toggle(this.groupContainer, 'selected', !chosePerformerSelector);
                this.performerSelector.set('disabled', !chosePerformerSelector);

            },

            getChildren: function () {
                return [this.nextPerformer, this.performerType];
            }

        };

        return provide(module.id, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], NextPerformerSelector);
    }
);

},
'vodori/util/string/camelToTitle':function(){
define(['dojo/_base/lang', './titleCase'], function (lang, titleCase) {
    /**
     * Converts a camelCase string to Title Case
     *
     * Ex. helloWorld -> 'Hello World'
     *
     * @param {string} str A camelCased string
     * @param {boolean} [splitNumbers] if true, treat numbers as word splitters too
     * @return {string} The Title Case version.
     */
    return function (str, splitNumbers) {
        var regex = !!splitNumbers ? /([A-Z0-9])/g : /([A-Z])/g;


        str = lang.trim(str).replace(regex, ' $1');

        // Capitalize each sub portion.
        return titleCase(str);

    };
});

},
'vodori/util/string/titleCase':function(){
define(function () {
    /**
     * Very basic title case implementation. Will capitalize any letter that starts the words or
     * follows a space.
     *
     * @param {string} str
     * @return {string}
     */
    return function (str) {
        return str.toLocaleLowerCase().replace(/(^|\s+)([a-z])/ig, function (m) {
            return m.toLocaleUpperCase();
        });
    };
});
},
'pepper/ui/LibraryBrowserButton':function(){
define([
	'vodori/provide', 'module', 'require',
	'lodash',
	'dojo/Deferred', 'dojo/_base/lang', 'dojo/json',
	'dojo/query', 'dojo/dom', 'dojo/dom-attr', 'dojo/on', 'dojo/_base/xhr',
	'dijit/registry',
	'pepper/ui/handleNotification',
	'pepper/library/LibraryDialog',
	'vodori/util/node/getParents',
	'vodori/util/node/getFormWidgetForInput',
	'vodori/util/collections/subsetMatch',
	'vodori/ui/Button'
], function (provide, module, require,
             _,
             Deferred, lang, JSON,
             query, dom, domAttr, on, xhr,
             registry,
             handleNotification,
			 LibraryDialog,
             getParents,
             getFormWidgetForInput,
             subsetMatch,
             Button) {
	/**
	 * Creates a button that'll browse pepper for objects and add the objectId of those to an input,
	 * which should probably be hidden.
	 *
	 * Events:
	 *     - selection -> When a collection of objects are selected.
	 *      event = {
     *          selection: Array.<{objectId: string, }>,
     *          inputNode: HTMLInputElement
     *      }
	 *
	 *     - beforeWrite -> When we're preparing to insert our selection into the value field of our
	 *       input.
	 *      event = {
     *          inputNode: HTMLInputElement,
     *          properties: Array.<string>
     *      }
	 *
	 *     - write -> Once the data have been written to the input.
	 *     event = {
     *         inputNode: HTMLInputElement,
     *         properties: Array.<string>
     *     }
	 *
	 */
	return provide(module.id, [Button], {
		/**
		 * The query to start the browser on.
		 *
		 * @see {pepper.library._LibraryBase.updateQuery}
		 */
		query: null,

		/**
		 * The view to set on the library. (Either list or view.)
		 *
		 * @type {string}
		 */
		view: 'list',

		/**
		 * The most recent selection.
		 *
		 * @type {Array}
		 */
		selection: null,

		/**
		 * The property of each selection that'll be written to targetInput.
		 *
		 * NOTEs:
		 *     1. If set to objectId, then we'll muddle id and objectId, since they're
		 *        interchangeable on pepper's backend.
		 *     2. The idProperty *must* be a simple string property or the behavior is undefined.
		 *
		 * @type {string}
		 */
		idProperty: 'objectId',

		/**
		 * Maximum number of selections user is allowed to make.
		 *
		 * @type {number}
		 */
		maxSelections: -1,

		/**
		 * If initially set to a string, then this will query for an input of that *name* within the
		 * parent form. If not found by name, it will query by ID.
		 *
		 * @type {HTMLInputElement}
		 */
		targetInput: null,

		/**
		 * Whether to add the new selections to existing selections or replace.
		 *
		 * @type {boolean}
		 */
		appendToInput: false,

		/**
		 * Whether to setup a click handler that browses the library.
		 *
		 * @type {boolean}
		 */
		browseOnClick: true,

		/**
		 * List of acceptable states for selected objects; if empty, means all states are valid.
		 * @type {Array<string>}
		 */
		validStates: null,

		/**
		 * Map of properties that must be matched to be valid; if empty, means no restrictions based on property alone.
		 *
		 * @type {Object}
		 */
		requiredProperties: null,

		/**
		 * Optional service call with the necessary extra properties for validation.
		 * By default, lists of currentlySelected, currentlyValidated, and currentlyInvalidated
		 * will be part of the params sent, plus anything defined in the object on the extraParams key.
		 *
		 * @type {{command:string, extraParams:object}}
		 */
		validationService: null,

		/**
		 * Initialize collections.
		 */
		constructor: function () {
			this.validStates = [];
			this.requiredProperties = {};
		},

		postMixInProperties: function () {
			this.inherited(arguments);

			// All of our queries will be external.
			this.query = lang.mixin(this.query || {}, {isExternal: true});
		},

		/**
		 * Connect to the click event
		 */
		postCreate: function () {
			this.inherited(arguments);

			this._resolveTargetInputReferenceIfNecessary();

			if (this.browseOnClick) {
				this.on('click', lang.hitch(this, 'browse'));
			}
		},

		/**
		 * targetInput may be a string. If so, resolve it to the element identified by the string.
		 * @private
		 */
		_resolveTargetInputReferenceIfNecessary: function () {
			var _targetInput = this.targetInput;

			if (lang.isString(this.targetInput)) {
				this.targetInput = this._findTargetInputByReference();
			}

			if (!this.targetInput) {
				console.error('No target input found for LibraryBrowserButton.  Using %s', _targetInput);
			}
		},

		/**
		 * Find the input that we're going to bind to.
		 *
		 * @return {Element}
		 * @private
		 */
		_findTargetInputByReference: function () {
			var node = this._findTargetInputByName();
			if (!node) {
				node = this._findTargetInputById();
			}
			return node;
		},

		_findTargetInputByName: function () {
			// If not in a form, just use the top-most element (documentElement if not in a fragment)
			var parentForm = getParents(this.domNode, 'form')[0] || getParents(this.domNode).pop();

			return query('input[name="' + this.targetInput + '"]', parentForm)[0];
		},

		_findTargetInputById: function () {
			return dom.byId(this.targetInput);
		},

		/* Public events. */
		onSelection: function (event) {},
		onBeforeWrite: function (event) {},
		onWrite: function (event) {},
		/* End public events. */

		/**
		 * Launch the browser, returning a selection promise.
		 *
		 * @return {dojo/promise/Promise} a promise resolving to the selection array.
		 */
		browse: function () {
			var deferred = new Deferred();

			// Requiring the library inline, so we can have this as a dep of pepper/commands.
			// SEE: CAYENNE-2097
			require(['pepper/library/LibraryNouveau'], lang.hitch(this, function (LibraryNouveau) {
				var modal = new LibraryDialog({
					widget: new LibraryNouveau({
						readOnly: true,
						showChannels: this.showChannels,
						resultsGridView: this.view,
						query: _.clone(this.query, true),
						confirmHandler: lang.hitch(this, function (selection) {
							this._handleLibraryConfirm(selection);
							deferred.resolve(selection);
						})
					})
				});

				modal.startup();
				modal.show();
			}));

			return deferred.promise;
		},

		/**
		 * Handle library confirm event, when user clicks OK in library.
		 * @param selection
		 * @private
		 */
		_handleLibraryConfirm: function (selection) {
			this.set('selection', selection);

			this.onSelection({
				selection: selection,
				inputNode: this.targetInput
			});

			this._updateTargetInputValue(selection);
		},


		/**
		 * Add the objectIds to the targetInput.
		 *
		 * @param {Array.<{objectId: string}>} selection
		 * @private
		 */
		_updateTargetInputValue: function (selection) {

			var objects = {};
			var validIds = [];
			var invalidIds = [];

			_.forEach(selection, function (object) {
				var selectionId = (this.idProperty === 'objectId') ?
					(object.objectId || object.id) : object[this.idProperty];

				objects[selectionId] = {
					object: object,
					stateInfo: {
						state: this._calculateState(object),
						locked: !!object.lockOwner,
						inWorkflow: !!object.lifecycle.workflow
					}
				};
			}, this);

			var validStates = this.validStates;
			var requiredProperties = this.requiredProperties;
			var ignoreState = validStates.length === 0;
			_.forEach(_.keys(objects), function (id) {
				var stateInfo = objects[id].stateInfo;
				var validState = ignoreState || (_.indexOf(validStates, stateInfo.state) >= 0);
				if (validState && subsetMatch(stateInfo, requiredProperties)) {
					validIds.push(id);
				} else {
					invalidIds.push(id);
				}
			});

			// this is the update method that should get called each time after validation is done to
			// update the status of the fields on the widget
			var callback = lang.hitch(this, function (validIds) {
				this.onBeforeWrite({
					inputNode: this.targetInput,
					properties: validIds
				});

				var idsForValue = validIds;
				if (this.appendToInput) {
					idsForValue = this._getPreselectedIds(validIds);
				}

				this._setTargetValue(idsForValue.join(','));

				this.onWrite({
					inputNode: this.targetInput,
					properties: validIds
				});
			});

			// if a validation service was specified, lets call it.
			if (this.validationService) {

				var params = {
					currentlySelected: this._getPreselectedIds(),
					currentlyValidated: validIds,
					currentlyInvalidated: invalidIds,
					objects: objects,
					maxSelections: this.maxSelections,
					callback: callback,
					extraParams: this.validationService.extraParams
				};

				// validation services should handle toast messages themselves
				this.serviceValidation(params);

			} else {

				// if not validation service was supplied, let's build a message based on the front end validation
				var toastedItems = [];

				_.forEach(invalidIds, function (id) {
					var obj = objects[id].object;
					var message = obj.description || obj.name || '';
					toastedItems.push('<li>' + message + '</li>');
				});

				if (invalidIds.length > 0) {
					handleNotification({
						title: 'Unable To Add Objects',
						message: 'The following were not in the right state to be added: ' +
						'<ul>' + toastedItems.join('') + '</ul>',
						expireAfter: 6000
					});
				}

				var VALIDATED = this.maxSelections > 0 ? validIds.slice(0, this.maxSelections) : validIds;
				callback(VALIDATED);
			}
		},

		/**
		 * Returns a list of the id's for items already in the input set.
		 *
		 * @param {string[]} [extend] Optional ids to append before returning the unique set.
		 * @private
		 */
		_getPreselectedIds: function (extend) {
			var preselected = lang.trim(this.targetInput.value).split(/\s*,\s*/);
			var extended = preselected.concat(extend || []);
			return _.unique(extended);
		},

		/**
		 * Performs server side validation via the service specified in validationService
		 *
		 * @param {object} params
		 */
		serviceValidation: function (params) {
			var validationService = this.validationService;

			// pulling in the validation service as defined in the markup for the widget
			var service = require(validationService.service);
			service(params);
		},

		/*
		 * Calculate the lifecycle state of the various versions of an object
		 * Returns a map of version number to state
		 */
		_calculateState: function (objectData) {
			var lifecycleInfo = objectData.lifecycle;
			var stateVersionMapper = {};
			_.forEach(lifecycleInfo.states, function (state) {
				if (state.version) {
					stateVersionMapper[state.version] = state.id;
				}
			});

			return stateVersionMapper[lifecycleInfo.currentVersion];
		},

		_getTargetValue: function () {
			var widget = getFormWidgetForInput(this.targetInput);
			if (!!widget) {
				return widget.get('value');
			} else {
				domAttr.get(this.targetInput, 'value');
			}
		},

		_setTargetValue: function (value) {
            if (this.targetInput) {
                var widget = getFormWidgetForInput(this.targetInput);
                value = value.replace(/^,|,$/g, '');
                if (!!widget) {
                    return widget.set('value', value);
                } else {
                    domAttr.set(this.targetInput, 'value', value);
                    // onChange event doesn't fire, so we simulate it here
                    on.emit(this.targetInput, 'change', {bubbles: false, cancelable: true, target: this.targetInput});
                }
            }
		},

		destroy: function () {
			_.forEach(this._handles, function (handle) {
				handle.remove();
			});

			return this.inherited(arguments);
		}

	});
});

},
'vodori/util/node/getFormWidgetForInput':function(){
define(['lodash', 'dijit/registry'],
    function (_, registry) {

        /**
         * Return the enclosing form widget for the given input.  If there is no enclosing widget or if the enclosing
         * widget is not a form with the given input as its property, return null.
         *
         * @name vodori.util.node.getFormWidgetForInput
         * @function
         * @param  {Object} input The target input
         * @returns {Object} The enclosing form widget, null if not found
         */
        return function (input) {
            var widget = registry.getEnclosingWidget(input);

            // exit early if no enclosing widget found
            if (!widget) {
                return null;
            }

            var isInputWidget = _.some(_.values(widget), function (propertyValue) {
                return propertyValue === input;
            });

            // exit early if the input isn't a property on the widget
            if (!isInputWidget) {
                return null;
            }

            return widget;
        };

    }
);
},
'vodori/util/collections/subsetMatch':function(){
/**
 * @module vodori/util/collections/subsetMatch
 */
define(
    [
        'lodash'
    ],
    function (_) {
        'use strict';

        /**
         * Check to see if an object is a subset of another object.
         *
         * In short, this means that we see if the object O contains all of the properties
         * of a subset S and that the corresponding values match.
         * O may have *more* properties than S and, if it does, the values of those do not matter.
         *
         * Uses `_.isEqual`, so matches arrays and simple objects correctly. Comparison is always deep
         *
         * @name vodori/util/collections/subsetMatch
         * @function
         *
         * @param {*} object An object
         * @param {*} subsetObject An object that is, potentially, a subset of 'object'
         * @return {boolean} true if subsetObject is a subset of object
         */
        var subsetMatch = function (object, subsetObject) {

            if (object === subsetObject) {
                return true;
            }
            if (_.isUndefined(subsetObject)) {
                console.warn('Did not pass in a subsetObject to subsetMatch. Defaulting to {}');
                /*
                 * Since {} is the empty set and the empty set is a subset of any set,
                 * the answer must be true!
                 */
                return true;
            }

            /*
             * Create a partial object which only has the keys that the subsetObject as
             */
            var partialObject = _.pick(object, _.keys(subsetObject));

            return _.isEqual(partialObject, subsetObject);

        };

        return subsetMatch;
    }
);
},
'pepper/stripe/StripeActionMenu':function(){
/**
 * The action menu in the stripe. Responds to changes of the current page to refresh its options
 */
define([
    'module', 'vodori/provide', 'dojo/_base/lang', 'dojo/when',
    'pepper/menu/_ActionMenu', 'pepper/ui/_QuarantineMixin',
    'pepper/data/PostDescriptorStore', 'pepper/utilities',
    'vodori/util/mixinAndModify'
], function (module, provide, lang, when,
             _ActionMenu, _QuarantineMixin,
             postDescriptorStore, utilities,
             mixinAndModify) {
    return provide(module.id, [ _ActionMenu, _QuarantineMixin], {

        constructor: function () {
            this.inherited(arguments);

            // Remove commands that should never appear in the StripeActionMenu based on CommandName
            mixinAndModify(this, this.actionComparatorFactory, {
                '-items': [
                    {commandName: 'GET_INFO'},
                    {commandName: 'REVIEW'},
                    {commandName: 'FLIP_THROUGH'},
                    {commandName: 'OPEN'},
                    {commandName: 'OPEN_IN_NEW_WINDOW'},
                    {commandName: 'EDIT'},
                    {commandName: 'DELETE_RECEPTION_DOCUMENT'}
                ]
            });
        },

        postCreate: function () {
            this.inherited(arguments);

            var result = postDescriptorStore.getCurrentPageObject();

            if(result) {
                when(result, lang.hitch(this, '_currentPageChangeHandler'));

                this.own(result.observe(lang.hitch(this, '_currentPageChangeHandler')));
            }

        },

        /**
         * Handles when the current page's data changes.
         * @param object
         */
        _currentPageChangeHandler: function (object) {
            this.updateCommandAvailability(utilities.createPayload(object));
        }
    });
});

},
'pepper/menu/_ActionMenu':function(){
define([
    'module', 'vodori/provide',
    'pepper/ui/_PepperServiceMenu',
    'dojo/_base/lang', 'pepper/commands',
    'pepper/commands/dialogs/showSync',
    'pepper/commands/actions/launchInNavigationManager'
], function (
    module, provide,
    _PepperServiceMenu,
    lang, commands,
    showSync,
    launchInNavigationManager) {

    /**
     * This is the abstract class for any menu containing actions to perform on posts,
     * such as Info, Check Out, or Promote.
     * @type {Object}
     * @private
     */
    var _ActionMenu = {
        /**
         * Base class that all Action Menus will have
         * @type {string}
         * @const
         */
        ACT_MENU_BASE_CLASS: 'actionMenu',

        /**
         * Relative paths to icon images that will be displayed next to certain menu items.
         * @type {string}
         * @const
         */
        ICON_LIBRARY: '/static/js/pepper/images/library-tiny.png',
        ICON_NAVMGR: '/static/js/pepper/images/navmanager-tiny.png',
        ICON_EDIT: '/static/js/pepper/images/editicon.png',

        /**
         * Adds the base class and the master list of actions that all menus will have and be able to modify.
         */
        constructor: function () {
            this.baseClass += ' ' + this.ACT_MENU_BASE_CLASS;

            /**
             * General format is an Array of Objects:
             * { label: 'Display Name', commandName: 'BACKEND_COMMAND',
             *   command: path.to.front.end.command }
             * Other properties may be present, such as icon, shortcut, and callback.
             *
             * @type {Array.<Object>}
             */
            this.items = [
                {
                    label: 'Open in Library',
                    commandName: 'OPEN_IN_LIBRARY',
                    command: lang.hitch(commands.actions, 'openInLibrary'),
                    icon: this.ICON_LIBRARY
                },
                {
                    // NOTE: The 'Launch in Navigation Manager' commandNameOverride is here so that any
                    // subclasses can still remove it with actionComparator function, since the Nav Manager
                    // action doesn't have an associated back end command name. Using just commandName would attempt
                    // to match the Nav Manager menu item with a backend command name, which will never be returned by
                    // the backend and would result in this item never being shown in any menu.
                    label: 'Launch in Navigation Manager',
                    commandNameOverride: 'NAV_MGR',
                    command: launchInNavigationManager,
                    icon: this.ICON_NAVMGR
                },

                {},

                {
                    label: 'Info',
                    commandName: 'GET_INFO',
                    command: lang.hitch(commands.dialogs, 'showInfo')
                },
                {
                    label: 'Review',
                    commandName: 'REVIEW',
                    command: lang.hitch(commands.dialogs, 'showReview')
                },
                {
                    label: 'Flip Through',
                    commandName: 'FLIP_THROUGH',
                    command: lang.hitch(commands.dialogs, 'showFlipThrough')
                },
                
                {},

                {
                    label: 'Open',
                    commandName: 'OPEN',
                    command: lang.hitch(commands.actions, 'open')
                },
                {
                    label: 'Open in new window',
                    commandName: 'OPEN_IN_NEW_WINDOW',
                    command: lang.hitch(commands.actions, 'open'),
                    concatDefaultArgs: true,
                    args: [true]
                },
                {
                    label: 'Edit',
                    commandName: 'EDIT',
                    command: lang.hitch(commands.actions, 'edit')
                },

                {},

                {
                    label: 'View Associated Workflow',
                    commandName: 'SHOW_CURRENT_WORKFLOW',
                    command: lang.hitch(commands.actions, 'viewAssociatedWorkflow')
                },

                {},

                {
                    label: 'Save and check in',
                    commandName: 'SAVE_AND_CHECK_IN',
                    command: lang.hitch(commands.actions, 'saveAndCheckIn'),
                    callback: true
                },
                {
                    label: 'Check in',
                    commandName: 'CHECK_IN',
                    command: lang.hitch(commands.actions, 'checkIn'),
                    callback: true
                },
                {
                    label: 'Check out',
                    commandName: 'CHECK_OUT',
                    command: lang.hitch(commands.actions, 'checkOut'),
                    callback: true
                },
                {
                    label: 'Check out',
                    commandName: 'DEMOTE_AND_CHECKOUT',
                    command: lang.hitch(commands.actions, 'demoteAndCheckout'),
                    callback: true
                },
                {
                    label: 'Cancel checkout',
                    commandName: 'CANCEL',
                    command: lang.hitch(commands.actions, 'cancelCheckOut'),
                    callback: true
                },
                {
                    label: 'Delete',
                    commandName: 'DELETE_RECEPTION_DOCUMENT',
                    command: lang.hitch(commands.actions, 'cancelCheckOut'),
                    callback: true
                },

                {},

                {
                    label: 'Initiate Workflow',
                    commandName: 'INITIATE_WORKFLOW',
                    command: lang.hitch(commands.dialogs, 'showWorkflowWizard')
                },
                {
                    label: 'Promote',
                    commandName: 'PROMOTE',
                    command: lang.hitch(commands.actions, 'promote'),
                    callback: true
                },
                {
                    label: 'Approve',
                    commandName: 'EXPRESS_PROMOTE',
                    command: lang.hitch(commands.actions, 'expressPromote'),
                    callback: true
                },
                {
                    label: 'Demote',
                    commandName: 'DEMOTE',
                    command: lang.hitch(commands.actions, 'demote'),
                    callback: true
                },
                {
                    label: 'Delete',
                    commandName: 'DELETE',
                    command: lang.hitch(commands.actions, 'deleteObjects'),
                    callback: true
                },
                {
                    label: 'Reinstate',
                    commandName: 'REINSTATE',
                    command: lang.hitch(commands.actions, 'reinstate'),
                    callback: true
                },
                {
                    label: 'Expire',
                    commandName: 'EXPIRE',
                    command: lang.hitch(commands.actions, 'expire'),
                    callback: true
                },
                {
                    label: 'Revive',
                    commandName: 'REVIVE',
                    command: lang.hitch(commands.actions, 'revive'),
                    callback: true
                },

                {},

                {
                    label: 'Toggle Edit Mode',
                    commandName: 'PEEK',
                    command: lang.hitch(commands.actions.peek, 'toggle'),
                    shortcut: 'Ctrl+E',
                    icon: this.ICON_EDIT
                },
                {
                    label: 'Save',
                    commandName: 'SAVE',
                    command: lang.hitch(commands.actions, 'save'),
                    shortcut: 'Ctrl+S'
                },

                {},

                {
                    label: 'Copy',
                    commandName: 'COPY',
                    command: lang.hitch(commands.actions, 'copy')
                },

                {
                    label: 'Distribute',
                    commandName: 'DISTRIBUTE',
                    command: lang.hitch(commands.actions, 'distribute')
                },

                {
                    label: 'Compare & sync',
                    commandName: 'SYNC',
                    command: showSync
                }
            ];
        },

        /**
         * Manufactures a comparator function instance for actions, so that subclasses can remove actions based on
         * commandName alone. Supports a commandNameOverride check as well, in case the command doesn't have a
         * commandName. This is necessary because giving a commandName to an action without a corresponding back end
         * command name value will result in it never appearing in a menu.
         * @param comparisonValue The value to compare to the analogous targetValue
         * @return {Function} The manufactured function that drives the comparison, which accepts the targetValue
         */
        actionComparatorFactory: function (comparisonValue) {
            return function (targetValue) {
                var compCmdName = comparisonValue.commandNameOverride || comparisonValue.commandName,
                    trgtCmdName = targetValue.commandNameOverride || targetValue.commandName;
                return compCmdName && trgtCmdName && compCmdName === trgtCmdName;
            };
        }

    };

    return provide(module.id, [_PepperServiceMenu], _ActionMenu);
});

},
'pepper/ui/_PepperServiceMenu':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/dom-style',
    'dojo/Deferred', 'dojo/_base/lang',
    'dijit/MenuSeparator',
    'pepper/ui/Menu',
    'pepper/services', 'pepper/utilities',
    /* Unreference MIDs */
    'vodori/ui/KeyboardShortcut'
], function(module, provide,
            _,
            domStyle,
            Deferred, lang,
            DijitMenuSeparator,
            Menu,
            services, utilities) {
    /**
     * This is an extension of the Vodori Menu to use Pepper service calls as menu
     * items and also hide/show menu items based on availability
     *
     * You must extend this and implement how updateCommandAvailability is called.
     */
    return provide(module.id, [Menu], {
        /**
         * Menu items
         *
         * @type {Array.<{label: string, commandName: string, command: Function}>}
         */
        items: null,

        /**
         * // A reference to the previous args used to open the menu
         * @type {{target: Element}}
         */
        previousArgs: null,

        /**
         * @type {boolean}
         */
        isActive: false,

        /**
         * A reference to the service call that will retrieve available commands
         *
         * @type {Function}
         */
        getAvailableCommands: services.getAvailableCommands,

        /**
         * @type {boolean}
         * @protected
         */
        _disablingCurrentItems: false, // if the current item display is being disabled

        /**
         * Overridden to add a loading item to the menu.
         */
        startup: function () {
            this.items.push({
                label: 'Loading...',
                commandName: 'LOADING'
            });
            this.inherited(arguments);
        },

        /**
         * Overridden to allow callbacks to be attached to menu items.
         *
         * All commands executed, if the menu item is marked as "callback", should *probably* return a deferred. If a
         * deferred is not returned but the item is marked to callback, then you may see some rather erratic behavior.
         * @param item
         */
        _itemSelected: function (item) {
            if (item.callback) {
                this.onCallbackItemStart(this, item);
                this.disableCurrentItems();
            }

            var deferred = this.inherited(arguments);

            if (item.callback) {
                if (deferred && (deferred.then || deferred instanceof Deferred)) {
                    deferred.then(
                        lang.hitch(this, 'onCallbackItemCompletion'),
                        lang.hitch(this, 'onCallbackItemError')
                    );
                    deferred.then(
                        lang.hitch(this, 'enableCurrentItems'),
                        lang.hitch(this, 'enableCurrentItems')
                    );
                } else {
                    this.onCallbackItemCompletion();
                    this.enableCurrentItems();
                }
            }
        },

        /**
         * What happens when a menu item that is marked as "callback" begins
         */
        onCallbackItemStart: function (context, item) {
        },

        /**
         * What happens when a menu item that is marked as "callback" completes.
         */
        onCallbackItemCompletion: function () {
        },

        /**
         * Error handler for menu item actions marked as "callback"
         */
        onCallbackItemError: function () {
        },

        /**
         * Encapsulates repositioning related actions.
         *
         * @param {{target: Element}} event
         */
        repositionToEvent: function (event) {
            this.bindDomNode(event.target);
        },

        /**
         * This will use the getAvailableCommands service call to query for available commands.
         *
         * @param selectedItems an array of selected items to run the commands on
         */
        updateCommandAvailability: function (/* Array */ selectedItems) {
            // The current selection will be the arguments for the menu command.
            this.defaultArgs = [selectedItems];

            this.lastUsedSelectedItems = selectedItems;
            this.disableItems(); // disable menu items while we fetch new ones from the server

            // Reposition the popup after items have changed
            if (this.isActive && this.previousArgs) {
                this.repositionToEvent(this.previousArgs);
            }

            this.getAvailableCommands({
                params: {
                    objects: utilities.createPayload(selectedItems)
                }
            }).then(lang.hitch(this, function (response) {
                    this.lastUsedCommands = response.results;
                    this.updateItemsDisplay(response.results);
                }));
        },

        /**
         * Refreshes the commands for whatever the current menu is displaying commands for. Uses the last-used
         * selection(s)
         */
        refreshCommands: function () {
            this.updateCommandAvailability(this.lastUsedSelectedItems);
        },

        /**
         * Clears the available commands
         */
        clearCommands: function () {
            this.updateItemsDisplay([]);
        },

        /**
         * Disables every menu item
         */
        disableItems: function () {
            _.forEach(this.getFlatItems(), function (item) {
                if (item._menuItem) {
                    if (item.commandName !== 'LOADING') {
                        this._disableMenuItem(item);
                    } else {
                        item._menuItem.set('disabled', true);
                        domStyle.set(item._menuItem.domNode, 'display', '');
                    }
                }
            }, this);
        },

        disableCurrentItems: function () {
            this._disablingCurrentItems = true;
            _.forEach(this.getFlatItems(), function (item) {
                if (item._menuItem && item.enabled) {
                    item._menuItem.set('disabled', true);
                }
            });
        },

        /**
         * Enables all of the items that are available via GET_AVAILABLE_COMMANDS
         */
        enableCurrentItems: function () {
            this._disablingCurrentItems = false;
            _.forEach(this.getFlatItems(), function (item) {
                if (item._menuItem && item.enabled) {
                    item._menuItem.set('disabled', false);
                }
            });
        },

        _isSeparator: function(item) {
            return item && item._menuItem.isInstanceOf(DijitMenuSeparator);
        },

        _shouldBeEnabled: function(item, items, availableCommands) {
            if (item.commandName === 'LOADING') {
                return false;
            } else if (this._isSeparator(item)) {
                return true;
            } else {
                var available = !item.commandName || _.indexOf(availableCommands, item.commandName) >= 0;
                return this.checkAvailabilityConditions(available, item, items);
            }
        },

        /**
         * Eliminate leading, trailing, and adjacent separators from the enabled list.
         *
         * @param enabledItems
         * @param disabledItems items removed from the enabled list will be added here
         * @private
         */
        _pruneSeparators: function(enabledItems, disabledItems) {
            // remove all leading separators
            while (this._isSeparator(enabledItems[0])) {
                disabledItems.push(enabledItems.shift());
            }
            // remove all trailing separators
            while (this._isSeparator(enabledItems[enabledItems.length - 1])) {
                disabledItems.push(enabledItems.pop());
            }
            // when more than one separator in a row, prune to one.
            var previousIsSeparator = false;
            for (var i = 0; i < enabledItems.length; i++) {
                if (this._isSeparator(enabledItems[i])) {
                    if (previousIsSeparator) {
                        disabledItems.push( enabledItems.splice(i, 1)[0] );
                        i--;
                    }
                    previousIsSeparator = true;
                } else {
                    previousIsSeparator = false;
                }
            }
        },

        /**
         * This will hide/show the available commands that are returned
         *
         * @param availableCommands an array of available commands
         */
        updateItemsDisplay: function(/* Array */ availableCommands) {
            if (!availableCommands) {
                availableCommands = this.lastUsedCommands;
            }

            var enabledItems = [];
            var disabledItems = [];

            _.forEach(this.getFlatItems(), function(item, i, items) {
                if (this._shouldBeEnabled(item, items, availableCommands)) {
                    enabledItems.push(item);
                } else {
                    disabledItems.push(item);
                }
            }, this);
            this._pruneSeparators(enabledItems, disabledItems);

            // NOTE: we show enabled items and focus on one before hiding the disabled ones because we get problems if
            // we disable the currently focused item.
            _.forEach(enabledItems, this._enableMenuItem, this);
            if (enabledItems[0]) {
                this.focusChild(enabledItems[0]._menuItem);
            }
            _.forEach(disabledItems, this._disableMenuItem, this);

            // Reposition the popup after items have changed
            if (this.isActive && this.previousArgs) {
                this.repositionToEvent(this.previousArgs);
            }
        },

        /**
         * Do any additional availability processing for a menu item. Intention of this is to be overridden
         * @param currentAvailability if the item is currently available based on GET_AVAILABLE_COMMANDS
         * @param item the item
         * @param items all of the items for the menu
         */
        checkAvailabilityConditions: function (currentAvailability, item, items) {
            return currentAvailability;
        },

        _setMenuItemEnabledStatus: function(item, enabled) {
            item.enabled = enabled;
            domStyle.set(item._menuItem.domNode, 'display', enabled ? '' : 'none');
            item._menuItem.set('disabled', (!enabled || this._disablingCurrentItems));

            // If the menu item has a shortcut associated with it, enabled/disable that
            if (item.shortcut) {
                var kbShortcut = this._shortcuts[item.shortcut];
                if (kbShortcut) {
                    kbShortcut.setEnabled(enabled);
                }
            }
        },

        _disableMenuItem: function (item) {
            this._setMenuItemEnabledStatus(item, false);
        },

        _enableMenuItem: function (item) {
            this._setMenuItemEnabledStatus(item, true);
        },

        /**
         * Overriding to save the last used args for menu repositioning
         *
         * @inheritDoc
         * @protected
         */
        _openMyself: function (args) {
            this.previousArgs = args;
            this.inherited(arguments);
        },

        /**
         * If the menu item doesn't have a command attribute, this function will be
         * called instead
         *
         * @param selectedItems an array of selected items to run the commands on
         */
        defaultCommand: function (/* Array */ selectedItems) {
            console.log('Will run...', this.commandName, selectedItems);
        }
    });
});

},
'pepper/commands/dialogs/showSync':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'pepper/services', 'pepper/utilities/createPayload',
    'pepper/dialogs/sync/Sync',
    'pepper/ui/ComposingDialog'
], function (services, createPayload, Sync, ComposingDialog) {

    /**
     * @memberOf pepper/commands/dialogs
     *
     * @param {Array.<Object>} object the object to open the sync dialog for
     */
    return function showSync(object) {

        services.getSyncInfo({
            params: {
                objects: createPayload(object)
            }
        }).then(function(response) {
            var result = response.results[0];
            var syncWidget = new Sync({
                syncMessage: result.syncMessage,
                latestSyncInfo: result.latestSyncInfo,
                outOfDateInfo: result.outOfDateInfo,
                contentUpdated: result.contentUpdated,
                propertiesUpdated: result.propertiesUpdated
            });

            var modal = new ComposingDialog({
                destroyOnHide: true,
                parseOnFirstShow: false,
                widget: syncWidget,
                title: 'Side by Side Version Comparison'
            });

            modal.startup();
            modal.show();
        });
    };
});

},
'pepper/dialogs/sync/Sync':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'dojo/_base/declare',
    'lodash',
    'dojo/_base/lang', 'dojo/topic','dojo/dom-style',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'pepper/services', 'pepper/events',
    'vodori/layout/_Composable', 'vodori/ui/_ButtonMappingMixin',
    'pepper/utilities/renderLocalDate',
    'dojo/text!./templates/Sync.html',
    /* Unreferenced MIDs */
    'pepper/ui/ThumbnailPreviewer',
    'pepper/workflow/ViewInfoButton'
], function (
    declare,
    _,
    lang, topic, domStyle,
    _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
    services, events,
    _Composable, _ButtonMappingMixin,
    renderLocalDate,
    template) {

    return declare([_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, _Composable, _ButtonMappingMixin], {

        templateString: template,

        baseClass: 'syncWidget',

        // attach points
        messageNode: null,

        latestSyncInfo: null,
        outOfDateInfo: null,
        syncMessage: null,
        contentUpdated: false,
        propertiesUpdated: false,

        _buttonMappings: {
            cancelButton: '_onCancel',
            updateButton: '_onUpdate'
        },

        postMixInProperties: function() {
            this.inherited(arguments);
            this._prepareData();
        },

        _prepareData: function() {
            if (!this.latestSyncInfo || !this.outOfDateInfo) {
                throw new Error('The necessary information to view the sync info was not supplied.');
            }
            this.latestSyncInfo.available.friendlyDate = renderLocalDate(this.latestSyncInfo.available.date);

            this.outOfDateInfo.lastSyncDate.friendlyDate = renderLocalDate(this.outOfDateInfo.lastSyncDate.date);

            this._parseAndSetUpdateText();
        },

        _parseAndSetUpdateText: function() {
            var updateText;
            if (this.contentUpdated && this.propertiesUpdated) {
                updateText = 'content & properties';
            } else if (this.contentUpdated) {
                updateText = 'content';
            } else if (this.propertiesUpdated) {
                updateText = 'properties';
            } else {
                updateText = 'nothing';
            }
            this.updateText = updateText;
        },

        buildRendering: function(){
            this.inherited(arguments);

            if(!this.syncMessage){
                domStyle.set(this.messageNode, {display: 'none'});
            }
        },

        hide: function() {
            this.fireCompose({
                methods : {
                    'hide' : {}
                }
            });
        },

        _onCancel: function() {
            this.hide();
        },

        _onUpdate: function() {
            // do the sync
            var syncDeferred = services.sync({params: {
                objects: [{
                    objectId: this.outOfDateInfo.objectId
                }],
                version: this.latestSyncInfo.version
            }});

            syncDeferred.then(lang.hitch(this, function() {
                topic.publish(events.library.refresh);
                this.hide();
            }));
        }
    });
});

},
'pepper/ui/ThumbnailPreviewer':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'dojo/_base/declare',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin',
    'dojo/text!./templates/ThumbnailPreviewer.html'
], function (
    declare,
    _WidgetBase, _TemplatedMixin,
    template) {

    return declare([_WidgetBase, _TemplatedMixin], {

        templateString: template,

        baseClass: 'pepperThumbnailPreviewer',

        /**
         * Thumbnail size, either 'small', or 'medium'
         */
        size: 'small',

        targetUri: null,
        thumbnailUri: null,
        caption: null
    });
});

},
'pepper/workflow/ViewInfoButton':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'vodori/ui/Button',
    'pepper/services', 'pepper/commands/dialogs/showInfo'
], function (
    module, provide,
    lang,
    Button,
    services, showInfo
    ) {
    /**
     * Show's info for an object id.
     */
    return provide(module.id, [Button], {

        /**
         * The objectId to show.
         *
         * @type {string}
         */
        objectId: '',

        /**
         * The tab to show in the properties viewer.
         *
         * @type {number}
         */
        tabToShow: 0,

        postMixInProperties: function () {
            this.inherited(arguments);
        },

        postCreate: function () {
            this.inherited(arguments);

            // Attach our handler.
            this.on('click', lang.hitch(this, '_showInfo'));
        },

        /**
         * Launch the showInfo dialog for our objectId.
         *
         * @private
         */
        _showInfo: function () {
            if (!!this.objectId) {
                services.getInfo({
                    params: {objects: [{objectId: this.objectId}]}
                }).then(lang.hitch(this, function (response) {
                        showInfo(this.tabToShow, response.results);
                    }));
            }
        }
    });
});

},
'vodori/util/mixinAndModify':function(){
/*
 * Must use dojo/_base/array and not lodash here, because this module may be used
 * before the lodash module is defined
 */
define(
    [
        'dojo/_base/lang', 'dojo/_base/array', 'dojo/_base/json'
    ],
    function (lang, array, JSON) {
        /**
         * @name vodori.util
         * @namespace
         */

        /*
         * The default comparator factory function used for comparing values during modification.
         * Will be used if a comparator factory is not provided during construction.
         * @param comparisonValue The value to compare against
         * @return {Function} The comparator function driving the comparison
         */
        var defaultComplexComparatorFactory = function (comparisonValue) {
            return function (targetValue) {
                return JSON.toJson(targetValue) === JSON.toJson(comparisonValue);
            };
        };

        // Used to call the Array.slice function on the arguments variable
        var aSlice = Array.prototype.slice;

        function addToBase(mixinProperty, index, base, prop) {
            var spliceArgs;

            if (lang.isArray(mixinProperty)) {
                spliceArgs = [index, 0].concat(mixinProperty);
                base[prop].splice.apply(base[prop], spliceArgs);

            } else if (lang.isString(mixinProperty) || !isNaN(mixinProperty)) {
                // Strings and/or numbers can just be added together.
                base[prop] += mixinProperty;
            }
            else {
                // Object properties get mixinAndModify-ed recursively.
                mixinAndModify(base[prop], mixinProperty);
            }
            return spliceArgs;
        }

        function removeFromBase(mixinProperty, base, prop, jsonComparatorFactory, mixin, propName) {

            if (lang.isArray(mixinProperty)) {
                base[prop] = array.filter(base[prop], function (value) {
                    var comparator = jsonComparatorFactory(value);
                    return !array.some(mixinProperty, comparator);
                });
            } else if (isFinite(+mixinProperty)) {
                base[prop] -= +mixinProperty;
            } else if (lang.isString(mixinProperty)) {
                base[prop] = base[prop].split(mixinProperty).join('');
            } else if (mixinProperty === true) {
                delete base[prop];
            }
            else {
                mixinAndModify(base[prop], mixin[propName]);
            }
        }

        function mixinToBase(mixin, base, jsonComparatorFactory) {
            for (var propName in mixin) {
                if (!mixin.hasOwnProperty(propName)) {
                    continue;
                }

                // This regular expression is a bit imperfect.
                var pieces = propName.match(/([\-+]?)([^:]+):?(\d{0,})/) || [null, propName, null];

                /*
                 * Remember that pieces[0] is the last matched string...
                 * not one of the capture groups
                 */
                var prop = pieces[2];
                var prefix = pieces[1] || null;
                var index = parseInt(pieces[3], 10) || (base[prop] && base[prop].length);

                var mixinProperty = mixin[propName];

                if (prefix && prop in base) {
                    if (typeof base[prop] !== typeof mixinProperty) {
                        console.error('Base/Mixin property type mismatch: ' + prop);
                    }
                    if (prefix === '+') {
                        // A plus sign prefix will combine existing items.
                        addToBase(mixinProperty, index, base, prop);
                    } else if (prefix === '-') {
                        // A "-" prefix will remove matching things from an array.
                        removeFromBase(mixinProperty, base, prop, jsonComparatorFactory,
                            mixin, propName);
                    }
                }
                else {
                    // No prefix? Just act like a normal mixin.
                    base[prop] = mixin[propName];
                }
            }
        }

        /**
         * This function takes two (or more) objects.
         * It mixes the second into the first, like dojo.mixin.
         *
         * If properties of the second begin with a "+" or "-",
         * it modifies the property in the first instead of replacing them.
         *
         * Optionally it can also take a comparator factory function that will
         * be used for comparison between objects during the "-" operation.
         *
         * Providing an ":n" suffix indicates an index at which point to insert the items.
         *
         * Arrays get new values pushed on, strings get concatenated,
         * numbers get added, and objects get recursively mixinAndModify-ed.
         *
         * @name vodori.util.mixinAndModify
         * @function
         * @param {Object} base Modified in place
         * @param {Function} [complexComparatorFactory] Optional comparator factory function
         *                                              for object comparison
         * @param {...Object} mixin Mixin(s) used to modify base
         * @returns {Object} The modified base
         *
         */
        function mixinAndModify(base, complexComparatorFactory, mixin) {
            var jsonComparatorFactory = defaultComplexComparatorFactory;

            // Convert arguments to Array for shifting around argument variable assignment
            var args = aSlice.call(arguments, 0);

            // Check for a comparator factory
            if (typeof complexComparatorFactory === 'function') {
                jsonComparatorFactory = complexComparatorFactory;
                // Ignore the comparator from here on out.
                args.splice(1, 1);
            }
            else {
                // Shift them back to where they would've been.
                //noinspection JSValidateTypes
                mixin = complexComparatorFactory;
            }


            if (args.length > 2) {
                for (var i = 1; i < args.length; i++) {
                    mixinAndModify(base, args[i]);
                }

                return base;
            }

            mixinToBase(mixin, base, jsonComparatorFactory);

            return base;
        }

        return mixinAndModify;
    });

},
'pepper/stripe/LifecycleButton':function(){
define([
    'vodori/provide',
    'module',
    'dojo/dom-construct',
    '../ui/DropDownButton',
    'pepper/stripe/Wayfinder',
    'pepper/data/PostDescriptorStore'
], function (provide, module, domConstruct, DropDownButton, Wayfinder, postDescriptorStore) {
    return provide(module.id, [DropDownButton], {
        wayfinderContainer: null,

        postCreate: function () {
            this.inherited(arguments);

            this.wayfinderContainer = domConstruct.create('span', {}, this.containerNode, 'first');

            // Because browsers freak out when we put a <div> inside... almost anything
            domConstruct.create('br', {}, this.wayfinderContainer, 'after');

            this.wayfinder = new Wayfinder({
                objectId: postDescriptorStore.getCurrentPageObjectId()
            }, this.wayfinderContainer);

            // NOTE: Changing the button's label will wipe out the wayfinder.
            // Let's just count on the label never changing for now.
        }
    });
});

},
'pepper/stripe/Wayfinder':function(){
define([
    'module',
    'vodori/provide',
    'pepper/ui/Wayfinder'
], function (module, provide, Wayfinder) {
    /**
     * This was an extension of pepper.ui.Wayfinder to monitor changes to "currentPage" instead of an object.
     * However, given that this situation doesn't seem to exist (currentPage only seems to get updated via
     * full page refreshes), we let it use the default Observe functionality
     */
    return provide(module.id, [ Wayfinder ], {

    });
});

},
'pepper/stripe/LifecyclePopup':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/date/locale', 'dojo/on',
    'dojo/topic', 'dojo/query', 'dojo/when',
    'dojo/dom-attr','dojo/dom-class', 'dojo/dom-construct', 'dojo/dom-style',
    'vodori/util/string/capitalize',
    'vodori/util/date/getDateFromIsoString',
    'vodori/renderTemplate',
    'pepper/ui/Popup', 'pepper/utilities/renderLocalDate',
    'pepper/events', 'pepper/data/PostDescriptorStore',
    'pepper/commands/dialogs/showInfo',

    'dojo/text!./templates/Lifecycle/Lifecycle-state.html',
    'dojo/text!./templates/Lifecycle/Lifecycle-workflow.html',
    'dojo/text!./templates/Lifecycle/Lifecycle-versions.html',
    'dojo/text!./templates/Lifecycle/Lifecycle-info.html',
    'dojo/text!./templates/Lifecycle/Lifecycle-details.html',
    'dojo/text!./templates/Lifecycle/Lifecycle-history.html'

], function(
    module, provide,
    _,
    lang, dateLocale, on,
    topic, query, when,
    domAttr, domClass, domConstruct, domStyle,
    capitalize,
    getDateFromIsoString,
    renderTemplate,
    Popup, renderLocalDate,
    events, postDescriptorStore,
    showInfo,

    stateTemplate, workflowTemplate, versionsTemplate, infoTemplate, detailsTemplate, historyTemplate
    ) {

    /**
     * This popup contains extended at-a-glance information about the current document
     * and its lifecycle. It shows the version number of each lifecycle state as well as
     * information about when each state was reached and by who. It is also an entrypoint
     * to viewing Dead document versions. Clicking on the states in this popup will let
     * the user view that document version.
     */
    return provide(module.id, [Popup], {
        baseClass: 'pepperLifecyclePopup',

        title: 'Progress Snapshot',

        DRAFT_CLASS: 'draft',
        REVIEW_CLASS: 'review',
        UNBORN_CLASS: 'unborn',
        CURRENT_VERSION_CLASS: 'currentVersion',

        LIFECYCLE_VERSION_ATTR: 'data-lifecycle-version',
        LIFECYCLE_ID_ATTR: 'data-lifecycle-id',
        LIFECYCLE_URL_ATTR: 'data-lifecycle-url',
        LIFECYCLE_PANEL_ATTR: 'data-lifecycle-panel',

        _activeVersion: null, // The current active state
        _states: [], // Reference to each state node
        _handles: [], // Keep track of event listeners
        _workflowNode: null, // Reference to the workflow node
        _openPanel: false, // Whether or not to open the past versions panel when the popup is opened

        _pastVersionsPanel: null, // Reference to the past versions fly-out panel
        _pastVersionsPanelHandle: null, // Reference to the past versions fly-out handle
        _pastVersionsContent: null, // Reference to the past versions fly-out content node
        _detailsPane: null, // Reference to the document details node
        _historyPane: null, // Reference to the document history node

        constructor: function () {
        },

        startup: function () {
            this.inherited(arguments);

            this._createVersionsPanel();
            this._createDetailsPane();


            // This function is used in multiple places
            // Define it once (it updates the display)
            var updateDisplayFunc = lang.hitch(this, function (result) {

                // Update the display
                this.gotNewStatus(result);

            });

            // Fetch the content by objectId and set the value
            var result = postDescriptorStore.getCurrentPageObject();

            if (result) {
                // Render the new status
                when(result, lang.hitch(this, updateDisplayFunc));

                // Ensure that any future updates to this object also update the display
                this.own(result.observe(updateDisplayFunc));
            }

        },

        /**
         * Update the rendering based on new life cycle information
         * @param {Object} newStatus New status for Lifecycle.
         */
        gotNewStatus: function (newStatus) {
            var lifecycle = newStatus.lifecycle;

            this.clear();

            if (!lifecycle) {
                return;
            }

            this._activeVersion = lifecycle.currentVersion;

            // hide/show versions panel depending on the document
            this._updateVersionsPanel(lifecycle.states);

            // create new nodes containing the lifecycle states
            var stateNodes = _.map(lifecycle.states, this._createLifecycleState, this);

            // place same version states in the same container and apply styling
            this._placeLifecycleStates(stateNodes, this._activeVersion);

            // if in a workflow, create the workflow node
            if (lifecycle.workflow !== null) {
                this._createWorkflowNode(lifecycle.workflow);
                this.opener.repositionPopup();
            }

            // Display file details in the details pane
            // Lock owner is not a part of details and must be passed in separately
            this._populateDetails(lifecycle.details, newStatus.lockOwner, newStatus.lockedByCurrentUser);

            // Display file history (if any) in the history pane
            this._populateHistory(lifecycle.history);
        },

        /**
         * Activate the given document version
         */
        activate: function (/* Float */ activeVersion, /* String */ activeState) {
            topic.publish(events.lifecycle.changedState, [
                {currentVersion: activeVersion}
            ]);

            _.forEach(this._states, function (state) {
                var version = domAttr.get(state, this.LIFECYCLE_VERSION_ATTR);
                if (version === this._activeVersion) {
                    domClass.remove(state, this.CURRENT_VERSION_CLASS);
                } else if (version === activeVersion) {
                    domClass.add(state, this.CURRENT_VERSION_CLASS);
                }
            }, this);

            if (this._workflowNode) {
                if (activeState === this.DRAFT_CLASS || activeState === this.REVIEW_CLASS) {
                    domClass.add(this._workflowNode, this.CURRENT_VERSION_CLASS);
                } else {
                    domClass.remove(this._workflowNode, this.CURRENT_VERSION_CLASS);
                }
            }

            this._activeVersion = activeVersion;
        },

        /**
         * Create a single Lifecycle state entry
         */
        _createLifecycleState: function (/* Object */ state) {
            var nodeText = this._createLifecycleTemplate(state);
            return domConstruct.toDom(lang.trim(nodeText));
        },

        _createStateContainer: function (current, versionParam, url) {
            current.container = domConstruct.create('a', {
                'className': 'stateContainer'
            });
            domAttr.set(current.container, this.LIFECYCLE_ID_ATTR, current.id);
            domAttr.set(current.container, this.LIFECYCLE_VERSION_ATTR, current.version);

            // Add an "at<State>" class if the version has been "born"
            if (current.version !== null && current.version !== '' && current.version !== 'null') {
                domClass.add(current.container, 'at' + capitalize(current.id));
            } else {
                domClass.add(current.container, 'at' + capitalize(this.UNBORN_CLASS));
            }

            // If the displayed version is the version we're creating, assign it the current version class
            if (current.version === versionParam) {
                domClass.add(current.container, this.CURRENT_VERSION_CLASS);
            } else {
                // Only assign hrefs to state containers that are not the current displayed version
                if (url && url !== '') {
                    domAttr.set(current.container, 'href', url);
                }
            }

            // Connect the click event
            var handle = on(current.container, 'click', this._handleClick);

            this._states.push(current.container);

            this.own(handle);

            this._handles.push(handle);

            // If showing a dead version, place it in the fly-out panel
            if (current.id === 'dead') {
                domConstruct.place(current.container, this._pastVersionsContent);

                this._openPanel = true;
            } else {
                domConstruct.place(current.container, this.containerNode, 'first');
            }
            return handle;
        },

        /**
         * Place the lifecycle state nodes into visible nodes
         *
         * @param {Array} stateNodes
         * @param {Float} versionParam
         * @private
         */
        _placeLifecycleStates: function (stateNodes, versionParam) {
            var current = {
                    version: null,
                    id: null,
                    container: null
                },
                index = stateNodes.length - 1;

            this._openPanel = false;

            // Place the nodes starting from Live, going backward in state, so
            // clicking on states will always link to the furthest state reached
            // for that version
            for (; index >= 0; index--) {
                var stateNode = stateNodes[index],
                    version   = domAttr.get(stateNode, this.LIFECYCLE_VERSION_ATTR),
                    id        = domAttr.get(stateNode, this.LIFECYCLE_ID_ATTR),
                    url       = domAttr.get(stateNode, this.LIFECYCLE_URL_ATTR);

                // If we're on a new version, create a new container for the state
                if (version !== current.version) {
                    current.version = version;
                    current.id = id;

                    // Create the container and set identifying attributes
                    this._createStateContainer(current, versionParam, url);
                }

                domConstruct.place(stateNode, current.container, 'first');
            }
        },

        /**
         * Returns a new Lifecycle state template String
         */
        _createLifecycleTemplate: function (/* Object */ state) {
            // Replace template fields with respective data from the current state
            return renderTemplate(stateTemplate, lang.mixin(state, {
                // Convert the date into a human-readable string as well as rendering it in the user's locale
                getDate: function() {
                    return renderLocalDate(this.date);
                },
                // Hides the version if this is an unborn state
                getDisplayVersion: function () {
                    var version = state.version;
                    if (version === null || version === '' || version === 'null' || version === '0.0') {
                        return '&mdash;';
                    }
                    return version;
                }
            }));
        },

        /**
         * Create the workflow icon and data node and place it between
         * Draft and Review
         */
        _createWorkflowNode: function (/* Object */ workflowData) {
            var task, workflowTasks = workflowData.tasks;

            // Extract the active task
            if (workflowTasks && workflowTasks.length > 0) {
                task = workflowTasks[workflowTasks.length - 1];
            } else {
                // If no tasks exist, just make the task an empty object so that all the
                // default values will be used in the template (and to avoid TypeErrors).
                task = {};
            }

            // Data for the workflow section of the lifecycle popup's template
            // Some defaulting done here if the default values were to look ugly in the template logic
            var workflowTemplateData = {
                workflowName: workflowData.name,                     // Name of the workflow
                taskName: task.name,                                 // Name of the active task
                taskId: task.id,                                     // ID of the active task
                createdDate: renderLocalDate(task.createdDate),      // Creation date of the active task
                assignee: task.assignee,                             // User the active task is assigned to
                assignedDate: renderLocalDate(task.assignedDate)     // Date the active task was assigned
            };

            // Generate the workflow node
            var workflowText = renderTemplate(workflowTemplate, workflowTemplateData);
            var workflowContainer = domConstruct.toDom(lang.trim(workflowText));

            // Place workflow node between Draft and Review
            domConstruct.place(workflowContainer, this.domNode, 2);

            this._workflowNode = workflowContainer;
        },

        /**
         * Event handler for when one of the lifecycle states is clicked
         */
        _handleClick: function (/* Object */ event) {
            var activeVersion = domAttr.get(event.currentTarget, this.LIFECYCLE_VERSION_ATTR);

            if (activeVersion !== '' && activeVersion !== 'null' && activeVersion !== null &&
                activeVersion !== this._activeVersion) {
                var activeState = domAttr.get(event.currentTarget, this.LIFECYCLE_ID_ATTR);
                this.activate(activeVersion, activeState);
            }
        },

        /**
         * Generate the past versions panel
         */
        _createVersionsPanel: function () {
            var versionsPanel = domConstruct.toDom(lang.trim(versionsTemplate));
            // A ghetto way to get this to display behind the main popup
            domConstruct.place(versionsPanel, this.domNode.parentNode);

            this._pastVersionsPanel = versionsPanel;
            this._pastVersionsPanelHandle = query('.handle', this._pastVersionsPanel)[0];
            this._pastVersionsContent = query('.content', this._pastVersionsPanel)[0];

            on(this._pastVersionsPanelHandle, 'click', this.toggleVersionsPanel);
        },

        /**
         * Generate the details pane node
         */
        _createDetailsPane: function () {
            var detailsNode = domConstruct.toDom(lang.trim(infoTemplate));
            domConstruct.place(detailsNode, this.domNode);

            this._detailsPane = query('.details', detailsNode)[0];
            this._historyPane = query('.history', detailsNode)[0];
        },

        /**
         * Fill in the details pane with the given data
         * @param details The details to put into the popup
         * @param lockOwner The lock owner of the page
         * @param isLockedByCurrentUser Whether the page is locked by the current user or not
         */
        _populateDetails: function (/* Object */ details, /* String */ lockOwner, /* Boolean */ isLockedByCurrentUser) {
            domConstruct.empty(this._detailsPane);

            if (details === null) {
                return;
            }

            // Need to clone the details object, due to the below date assignments otherwise changing
            // the original object, which has been passed via reference from the PostDescriptorStore.
            // This then changes the PostDescriptorStore's data, which causes errors later.
            var detailsClone = lang.clone(details);

            // Dates are put into the details as an ISO string (yyyy-MM-dd'T'HH:mmZ)
            // Convert them to the locale of the user
            detailsClone.versionCreateDate = renderLocalDate(detailsClone.versionCreateDate);
            detailsClone.modified = renderLocalDate(detailsClone.modified);
            detailsClone.createDate = renderLocalDate(detailsClone.createDate);
            // This prop is missing if object is not locked.
            if (!!detailsClone.lockedDate) {
                detailsClone.lockedDate = renderLocalDate(detailsClone.lockedDate);
            }

            // If the current user has locked the page, append '(you)' to the lock owner string
            if (lockOwner && isLockedByCurrentUser) {
                lockOwner = lockOwner + ' (you)';
            }

            // If there is a lock owner, then indicate who currently has the page locked.
            // Otherwise, say that the page is not locked.
            var lockStatus = 'Page is not locked';
            if(lockOwner) {
                lockStatus = 'Currently locked by:<br>' +
                             '<span>' + lockOwner + '<br>' + renderLocalDate(detailsClone.lockedDate) + '</span>';
            }

            // Mix in the lock status with the details, since the details don't contain
            // any lock status info, which had to be passed in separately.
            lang.mixin(detailsClone, {lockStatus: lockStatus});

            var detailsString = renderTemplate(detailsTemplate, detailsClone);
            domConstruct.place(domConstruct.toDom(lang.trim(detailsString)), this._detailsPane);
        },

        /**
         * Fill in the history pane with the given data
         */
        _populateHistory: function (/* Object */ history) {
            domConstruct.empty(this._historyPane);

            if (_.isEmpty(history)) {
                return;
            }

            var historyString = renderTemplate(historyTemplate, history);
            domConstruct.place(domConstruct.toDom(lang.trim(historyString)), this._historyPane);
        },

        /**
         * Hide/Show the versions panel depending on the version history of the document
         */
        _updateVersionsPanel: function (/* Array */ states) {
            // If there are more versions than 1.0, display the versions panel
            if (_.some(states, function (state) {
                return state.version > 1.0;
            }, this)) {
                domStyle.set(this._pastVersionsPanel, 'display', 'block');
            } else {
                domStyle.set(this._pastVersionsPanel, 'display', 'none');
            }
        },

        /**
         * Toggle the open/close state of the past versions panel
         * Setting open to true will force the panel to open
         */
        toggleVersionsPanel: function (/* boolean */ forceOpen) {
            showInfo('Versions');
        },

        /**
         * Clear all events in the popup
         */
        clear: function () {
            // Disconnect all events
            _.forEach(this._handles, this.disconnect);
            this._handles.length = 0;

            // Clear out the existing proxies
            if (this._workflowNode) {
                domConstruct.destroy(this._workflowNode);
                this._workflowNode = null;
            }

            _.forEach(this._states, domConstruct.destroy);
            this._states.length = 0;
        }
    });
});

},
'pepper/stripe/MessagesPopup':function(){
define([
    'require',
    'module', 'vodori/provide',
    'dojo/on', 'dojo/string',
    'dojo/dom-construct',
    '../ui/LazyPopup',
    'dojo/text!./templates/Messages.html',
    'dojo/text!./templates/MessageItem.html'
], function (require, module, provide, on, string, domConstruct, LazyPopup, messagesPopupTemplate, messageTemplate) {

    return provide(module.id, [LazyPopup], {

        contentHref: require.toUrl('./templates/Messages.html'),
        messageTemplateString: messageTemplate,

        messagesContainerNode: null,

        baseClass: 'pepperMessagesPopup tempNoShow',

        /**
         * Updates the Stripe's Inbox button popup with a condensed list of all unread messages.
         *
         * @param {Array<object>} messages The list of messages that the server returned
         */
        updateMessagesList: function (messages) {
            this.lazy(function () {
                this.messagesContainerNode.innerHTML = '';

                for (var i = 0; i < messages.length; i++) {
                    domConstruct.create('div', {
                        innerHTML: string.substitute(this.messageTemplateString, messages[i])
                    }, this.messagesContainerNode);
                }

                this.opener.repositionPopup();

                this.focus();
            });
        }
    });
});

},
'pepper/ui/LazyPopup':function(){
define([
    'module',
    'vodori/provide',
    'vodori/ui/LazyPopup',
    './_QuarantineMixin'
], function (module, provide, LazyPopup, _QuarantineMixin) {
    return provide(module.id, [LazyPopup, _QuarantineMixin], {

        /**
         * Appending a specific className to the container, so we know which
         * quarantine nodes contain popups.
         */
        constructor: function () {
            this.quarantineAreaClassNames += ' popupContainer';
        }
    });
});

},
'vodori/ui/LazyPopup':function(){
define([
    'lodash',
    'dojo/_base/declare', 'dojo/_base/lang',
    './Popup',
    'vodori/layout/_LazyAttachPoints',
    'dojo/text!./templates/LazyPopup.html'
], function (_, declare, lang, Popup, _LazyAttachPoints, template) {
    return declare([Popup, _LazyAttachPoints], {
        templateString: template,

        contentHref: '',

        /**
         * List of methods to attach to the click event of a button
         *
         * Create a map of 'buttonAttachPoint' to 'methodName'
         *
         * @type {Object}
         */
        _buttonMappings: {},

        constructor: function () {
            if (this.lazyPanes) {
                this.lazyPanes.push('lazyContainerNode');
            } else {
                this.lazyPanes = ['lazyContainerNode'];
            }
        },

        postCreate: function () {
            this.inherited(arguments);

            _.forEach(this._buttonMappings, function (handler, attachPoint) {
                this.lazyOn(attachPoint, 'click', lang.hitch(this, handler));
                if (this._buttonMapHandler) {
                    this._buttonMapHandler(handler, attachPoint);
                }
            }, this);
        },

        _setHrefAttr: function (href) {
            this.lazyContainerNode.set('href', href);
        },

        _getHrefAttr: function (content) {
            return this.lazyContainerNode.get('href');
        },

        _setContentAttr: function (content) {
            this.lazyContainerNode.set('content', content);
        },

        _getContentAttr: function (content) {
            return this.lazyContainerNode.get('content');
        }

    });
});

},
'pepper/stripe/MessagesButton':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'dojo/_base/fx',
    'dojo/dom-construct',
    '../ui/DropDownButton',
    'pepper/services'
], function (module, provide, lang, fx, domConstruct, AdminDropDownButton, services) {
    return provide(module.id, [AdminDropDownButton], {
        baseClass: 'pepperMessagesButton',
        BADGE_CLASS: 'badge',

        /**
         * Frequency in milliseconds with which to check for new messages
         * @type {int}
         */
        updateFrequency: 120000, // 2 minutes

        /**
         * Keeps track of whether we are currently updating the messages button/popup,
         * so that we don't run the risk of accidentally building up queries to the server.
         * @type {boolean}
         */
        _updating: false,

        /**
         * This button does not create a popup, so let's hide the arrow
         */
        hideArrow: true,


        buildRendering: function () {
            this.inherited(arguments);

            this.badgeNode = domConstruct.create('span', {
                'class': this.BADGE_CLASS,
                style: {
                    opacity: 0
                }
            }, this.containerNode, 'after');
        },

        startup: function () {
            this.inherited(arguments);

            // Initially fetch messages from the server, and then put the message querying
            // on a timer.
            this._fetchMessages();
            setInterval(lang.hitch(this, '_fetchMessages'), this.updateFrequency);
        },

        /**
         * Queries the server for messages and hooks up the callback for when the messages
         * are received. Sets itself to fire every so often (see this.updateFrequency).
         * Will not query the server if it is already updating (see this._updating).
         * @private
         */
        _fetchMessages: function () {
            // Exit if we're in the middle of updating
            if (this._updating) {
                return;
            }

            // We are now updating
            this._updating = true;

            // Query the server for inbox messages, and hitch the callback
            var assignedToMeQuery = {
                params: {
                    query: {
                        myTasks: ['ASSIGNED_TO']
                    }
                }
            };

            services.queryInbox(assignedToMeQuery).then(lang.hitch(this, function (result) {
                // The callback for when we've received messages from the server
                if (result) {
                    this._receivedNewMessages(result.totalResults);
                }
                // We're no longer updating at this point
                this._updating = false;
            }));
        },

        /**
         * Callback function for when messages are received from the server after a query.
         * Responsible for calling various update functions.
         * @param {number} count The number of messages that the server returned
         * @private
         */
        _receivedNewMessages: function (count) {
            // Updates the badge on the Stripe's Inbox button with the number of unread messages
            this.updateBadge(count);

            // Sets the count of the number of unread messages in the Inbox button popup
            //this.dropDown.messagesCountNode.innerHTML = count;
            // Updates the message list in the Inbox button popup with the current unread messages
            //this.dropDown.updateMessagesList(messages);
        },

        /**
         * Updates the Inbox button's badge with the count of unread messages,
         * or fades it out when there are no new messages.
         * @param {number} newMessageCount The number of unread messages
         */
        updateBadge: function (newMessageCount) {
            if (typeof newMessageCount !== 'number') {
                return;
            }

            this.badgeNode.innerHTML = newMessageCount;

            var inOrOut = (newMessageCount > 0) ? 'In' : 'Out';
            fx['fade' + inOrOut]({
                node: this.badgeNode
            }).play();
        }
    });
});

},
'pepper/stripe/PepperPopup':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'vodori/util/_InPageTemplatedMixin',
    'pepper/ui/Popup'
], function (module, provide, _, _InPageTemplatedMixin, Popup) {
    return provide(module.id, [Popup, _InPageTemplatedMixin], {
        user: null,
        userRoles: [],

        baseClass: 'pepperPepperPopup',
        emailSpan: null,
        rolesList: null,

        _setUserAttr: function (user) {
            this.user = user;
            this.emailSpan.innerHTML = user;
        },

        /**
         * Construct the list of roles that the current user has
         * @param {Array.<string>} userRoles The list of roles
         * @private
         */
        _setUserRolesAttr: function (userRoles) {
            this.userRoles = userRoles || [];
            // Start of list
            var roleList = '<span>you are signed in as...</span>' + '\n' + '<ul class="userRoles">';

            // Insert each role as a list item
            _.forEach(this.userRoles, function (role) {
                if (role) {
                    roleList += '<li class="role ' + role + '">' + role + '</li>' + '\n';
                }
            });

            // Set the list into the rolesList div's innerHTML
            this.rolesList.innerHTML = roleList + '</ul>';
        }
    });
});

},
'pepper/stripe/SearchBox':function(){
define([
    'dojo/_base/declare',
    'dojo/_base/lang', 'dojo/on',
    'dojo/dom-style',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'dojo/text!./templates/SearchBox.html',
    /* Unreferenced MIDS */
    'vodori/input/TextBox'
], function (
    declare,
    lang, on,
    domStyle,
    _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
    template) {

    /**
     * The search text box in the stripe for quick searching and launching those searches from the library.
     */
    return declare([_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
        baseClass: 'pepperSearchBox',

        templateString: template,

        /* attach points */

        textbox: null,
        popup: null,

        postCreate: function() {
            this.inherited(arguments);

            this.own(on(this.textbox, 'change', lang.hitch(this, function() {
                this.popup.handleQuery(this.textbox.value);
            })));
        },

        startup: function() {
            this.inherited(arguments);

            this.popup.hide();
        },

        _setDisabledAttr: function(disabled) {
            this.textbox.set('disabled', disabled);
        }
    });
});

},
'vodori/input/TextBox':function(){
define([
    'vodori/provide', 'module',
    'dojo/_base/lang',
    'dijit/form/TextBox',
    'vodori/ui/Button'
], function (provide, module, lang, TextBox, Button) {
    return provide(module.id, [TextBox], {
        clearable: false,

        baseClass: 'vodoriTextBox',

        clearButton: null,

        buildRendering: function () {
            this.inherited(arguments);

            if (this.clearable) {
                this._addClearButton();
            }
        },

        _addClearButton: function () {
            this.clearButton = new Button({
                'class': 'clearButton',

                label: '&times;',

                disabled: this.get('value') === '',

                onClick: lang.hitch(this, function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    this.set('value', '');
                    this.focus();
                })
            });

            this.watch('value', function (changed, from, to) {
                this.clearButton.set('disabled', to === '');
            });

            this.clearButton.placeAt(this.domNode);

            this.clearButton.startup();
        }
    });
});

},
'pepper/stripe/SearchPopup':function(){
define([
    'module',
    'vodori/provide', 'require',
    'lodash',
    'dojo/_base/lang', 'dojo/on',
    'dojo/dom-attr', 'dojo/dom-class', 'dojo/dom-construct', 'dojo/dom-style',
    'dojo/Evented', 'dojo/topic',
    'pepper/ui/LazyPopup', 'pepper/commands/dialogs/showLibrary',
    'vodori/util/debounce', 'vodori/util/string/capitalize', 'vodori/util/string/isBlank',
    'pepper/events', 'pepper/services',
    /* Unreferenced MIDs */
    'dojo/text!./templates/SearchPopup.html'
], function (module,
             provide, require,
             _,
             lang, on,
             domAttr, domClass, domConstruct, domStyle,
             Evented, topic,
             LazyPopup, showLibrary,
             debounce, capitalize, isBlank,
             events, services) {
    /**
     * The popup for results that come back from the search field in the toolbar
     */
    return provide(module.id, [LazyPopup, Evented], {
        title: 'Search results',

        contentHref: require.toUrl('./templates/SearchPopup.html'),

        _buttonMappings: {
            'viewAllButton': '_viewAllResultsHandler'
        },

        baseClass: 'pepperSearchPopup',

        RESULTS_CATEGORY_CLASS: 'category',
        RESULTS_LINK_CLASS: 'result',
        NO_RESULTS_CLASS: 'noResults',

        resultsTable: null,

        postCreate: function () {
            this.inherited(arguments);

            on(this.containerNode, 'click', lang.hitch(this, '_handleClick'));
            on(window, 'click', lang.hitch(this, 'hide'));
        },

        startup: function() {
            this.inherited(arguments);
            this.hide();
        },

        _handleClick: function(event) {

            // Stop propagation of the event to prevent closing of the popup if the user clicks on the container,
            // but not on a result.
            event.stopPropagation();
            event.preventDefault();
            if (domClass.contains(event.target, this.RESULTS_LINK_CLASS)) {
                var primaryUri = domAttr.get(event.target, 'href');

                this._viewAllResultsHandler(primaryUri);
                this.hide();
            }
        },

        /**
         * Takes the query parameter and debounces the actual service call for when the user keeps typing
         */
        handleQuery: function (searchString) {
            this.searchString = searchString;
            debounce(lang.hitch(this, 'fetchResults'), 150)();
        },

        /**
         * Queries the server for results
         */
        fetchResults: function () {
            // A blank query hides the popup
            if (isBlank(this.searchString)) {
                this.hide();
                return;
            }

            services.stripeQuery({
                params: {
                    search: this.searchString
                }
            }).then(lang.hitch(this, 'resultsHandler'));
        },

        /**
         * Callback once results are fetched
         */
        resultsHandler: function (response) {
            this.show();
            this.categories = [];
            var results = response.results[0].searchResults;
            for (var category in results) {
                this.categories.push({
                    label: category,
                    results: results[category]
                });
            }

            this.rebuildResultsTable();
            this.clearResults();
        },

        /**
         * Update the results table with the latest results
         */
        rebuildResultsTable: function () {
            this.lazy(function () {
                // Clear out the results table
                while (this.resultsTable.rows.length > 0) {
                    this.resultsTable.deleteRow(-1);
                }

                var tr, td, ul, li;
                _.forEach(this.categories, function (category) {
                    if (category.results.length > 0) {
                        tr = this.resultsTable.insertRow(-1);

                        td = tr.insertCell(-1);
                        domConstruct.create('span', {
                            'class': this.RESULTS_CATEGORY_CLASS,
                            innerHTML: capitalize(category.label)
                        }, td);

                        td = tr.insertCell(-1);
                        ul = domConstruct.create('ul', {}, td);

                        _.forEach(category.results, function (result) {
                            li = domConstruct.create('li', {}, ul);

                            domConstruct.create('a', {
                                'class': this.RESULTS_LINK_CLASS,
                                href: result.uri,
                                innerHTML: result.name
                            }, li);
                        }, this);
                    }
                }, this);

                domStyle.set(this.viewAllButton.domNode, {
                    display: this.resultsTable.rows.length > 0 ? '' : 'none'
                });

                // Inform user of zero results
                if (this.resultsTable.rows.length === 0) {
                    td = this.resultsTable.insertRow(-1).insertCell(-1);

                    domConstruct.create('span', {
                        'class': this.NO_RESULTS_CLASS,
                        innerHTML: 'No results'
                    }, td);
                }
            });
        },

        clearResults: function () {
            _.forEach(this.categories, function (category) {
                category.results = [];
            });
        },

        hide: function () {
            this.lazy(function () {
                domClass.add(this.domNode, 'hidden');
            });
        },

        show: function () {
            this.lazy(function () {
                domClass.remove(this.domNode, 'hidden');
            });
        },

        /**
         * Triggers the display of the library for single or all search results.
         *
         * When the View All Results button is clicked, this method is called with an event object, triggering the
         * _.isObject(path) logic that shows the Library with the search string that was entered into the Stripe's
         * search box.
         *
         * When a single result is clicked, _handleClick calls this handler with the href string of the single
         * search result link that was clicked. This href string is passed on to the Library dialog and used as the
         * search string to show the single result.
         *
         * @private
         */
        _viewAllResultsHandler: function (path) {
            if (_.isObject(path)) {
                path = this.searchString;
            }

            showLibrary({query: {search: path}});
        }
    });
});

},
'pepper/stripe/ToolbarPin':function(){
/**
 * The pin button on the Stripe
 */
define([
    'vodori/provide',
    'module',
    'vodori/ui/Button',
    'require',
    'vodori/util/getDijitAncestorByClass',
    'pepper/stripe/Toolbar' // NOTE: Circular dependency
], function (provide, module, Button, require, getDijitAncestorByClass) {
    return provide(module.id, [Button], {
        baseClass: 'pepperToolbarPinButton',

        toolbar: null,

        startup: function () {
            this.inherited(arguments);

            // Synchronous "post-require" resolves circular dependency
            var Toolbar = require('pepper/stripe/Toolbar');
            this.toolbar = getDijitAncestorByClass(this.domNode, Toolbar);
        },

        onClick: function () {
            this.toolbar.togglePinning();
        }
    });
});

},
'abbott/authorMain':function(){
require({
    packages: [
        'simple-approval-workflow'
    ]
});

define([
    'abbott/editing/blockConfigs/augmentSharedBlockConfigs',
    'abbott/editing/blockConfigs/molecularCatalogFullWidthBlockConfig',

    'pepper/main',
    'pepper/library/filter/LibraryFilters',
    'pepper/commands/dialogs/showLibrary',
    'pepper/commands/actions/launchInNavigationManager',
    'pepper/ui/LibraryBrowserButton',

    'vodori/filter/model/Search',
    'vodori/input/Wysiwyg',
    'vodori/input/FilteringCheckedSelect',
    'vodori/input/FormBasedEditor',
    'vodori/input/StampDecorator',
    'vodori/ui/util/NodeRepeater',

    'dijit/form/MultiSelect',

    'abbott/editing/ui/formBasedEditor/orderingInformation/sortable/MolecularCatalogOrderingInformationFormBasedEditorSelect',
    'abbott/editing/ui/formBasedEditor/orderingInformation/sortable/MolecularCatalogOrderingInformationSingleRowRenderer',
    'abbott/editing/ui/formBasedEditor/CertificateOfAnalysisBlock',
    'abbott/editing/ui/formBasedEditor/InstructionsForUseBlock',
    'abbott/editing/ui/formBasedEditor/PanelBackgroundVideoWithImageOverlayBlock',
    'abbott/editing/ui/formBasedEditor/MolecularCatalogFBETabWrapper',
    'abbott/editing/ui/formBasedEditor/MolecularCatalogProductFormBasedEditor',
    'abbott/editing/ui/formBasedEditor/MolecularCatalogProductOrderingInformation',
    'abbott/editing/ui/formBasedEditor/MolecularCatalogProductOrderingInformationMultiSelect',
    'abbott/editing/ui/formBasedEditor/MolecularCatalogProducts',
    'abbott/editing/ui/formBasedEditor/ProbeInfoSelect',
    'abbott/editing/ui/formBasedEditor/ProductDiseaseStateFormBasedEditorSelect',
    'abbott/editing/ui/formBasedEditor/ProductOrderingInfoSelect',

    'abbott/pandx/ifu/InstructionsForUseExpiredLotNumberModal',

    // Editor Configs
    'abbott/editorConfigs/base',
    'abbott/editorConfigs/distributorPortalConfigs',
    'abbott/editorConfigs/amBannerConfig',
    'abbott/editorConfigs/amThinBannerConfig',
    'abbott/editorConfigs/amAboutUsConfig',
    'abbott/editorConfigs/amProductDetailConfig',
    'abbott/editorConfigs/amProductsLandingConfig',
    'abbott/editorConfigs/amEventsAndConferencesConfig',
    'abbott/editorConfigs/amHomeConfig',
    'abbott/editorConfigs/amOneColWNavConfig',
    'abbott/editorConfigs/amOneColConfig',
    'abbott/editorConfigs/amSitewideCalloutConfig',
    'abbott/editorConfigs/abbottAlkConfig',
    'abbott/editorConfigs/cdxConfig',
    'abbott/editorConfigs/cynogenConfig',
    'abbott/editorConfigs/goMolecularConfig',    
    'abbott/editorConfigs/inlineEditorConfig',
    'abbott/editorConfigs/iridicaConfig',
    'abbott/editorConfigs/iridicaFullWidthConfig',
    'abbott/editorConfigs/iridicaSmallConfig',
    'abbott/editorConfigs/iridicaRotatorConfig',
    'abbott/editorConfigs/mqOneColumnConfig',
    'abbott/editorConfigs/mqRotatorConfig',
    'abbott/editorConfigs/portal/amPortalDashboardConfig',

    'abbott/iridica/ui/IridicaTileSectionFormBasedEditor',

    'abbott/util/OtherInput',

    'abbott/ui/ImageInput',
    'abbott/ui/VideoInput',
    'abbott/ui/NodeRepeater',
    'abbott/ui/TranslatorHtml',

    'abbott/input/LibraryInput',
    'abbott/input/OverrideLibraryBrowserButton',
    'abbott/input/config/LibraryBrowserConfigs',
    'abbott/input/video/VideoFlyoutList',

    // Customer Portal
    'abbott/ui/am/customerPortal/admin/ResourceBrowserButton',
    'abbott/ui/am/customerPortal/admin/ResourceTable',

    // Info Dialog
    'abbott/infoDialog/ByteConversion',
    'abbott/infoDialog/FilteringSelect',
    'abbott/infoDialog/GSSParentDocumentBrowserButton',
    'abbott/infoDialog/ProductMultiSelect',
    'abbott/infoDialog/ProductSpecificationMultiSelect',

    'abbott/product/MolecularCatalogProductFilteringSelect',
    'abbott/product/ProductFilteringSelect',
    'abbott/productChangeRequest/form/discontinue/ProductChangeRequestDiscontinueForm',
    'abbott/productChangeRequest/ProductChangeRequestDashboardResultsWrapper',
    'abbott/productChangeRequest/ProductChangeRequestDiscontinueProductRequest',
    'abbott/productChangeRequest/ProductChangeRequestExistingProductResults',
    'abbott/productChangeRequest/ProductChangeRequestNewRequest',
    'abbott/productChangeRequest/ProductChangeRequestReviewScreen',
    'abbott/productChangeRequest/form/ProductChangeRequestForm',
    'abbott/productChangeRequest/form/generalInfo/ProductChangeRequestFormGeneralInfo',
    'abbott/productChangeRequest/form/probeInfo/ProductChangeRequestFormProbeInfo',
    'abbott/productChangeRequest/form/orderingInfo/ProductChangeRequestFormOrderingInfo',
    'abbott/productChangeRequest/review/ProbeInfoReview',
    'abbott/productChangeRequest/review/ProductOrderingInfoReview',

    // Workflow
    'abbott/workflow/WorkflowWizardFormValidator',
    'abbott/workflow/TriageForm',
    'abbott/workflow/ApproveReject',
    'abbott/workflow/MockFormSubmit',
    'abbott/workflow/CancelRejectionButton',
    'abbott/workflow/IncludeRelatedDistributionsCheckbox',
    
    // Console
    'abbott/pepperConsole/Badge',

    // simple approval workflow
    'simple-approval-workflow/authorMain'

], function(augmentSharedBlockConfigs) {

    // Add AMD blocks to shared block configs
    augmentSharedBlockConfigs.augment();
});
},
'abbott/editing/blockConfigs/augmentSharedBlockConfigs':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'abbott-shared/editing/blockConfigs/blockConfigAugmentationUtil',
    'abbott-shared/editing/ui/dynamicBlock/DynamicBlockUtil'
], function (
    module, provide,
    lang,
    blockConfigAugmentationUtil,
    DynamicBlockUtil
) {
    return provide(module.id, {
        augment: function() {
            blockConfigAugmentationUtil.augment({

                /**
                 * Add to Full-width shared block config
                 */
                'abbott-shared/editing/blockConfigs/fullWidthSharedBlockConfig': {
                    '+blockConfig':
                    {
                        "+categories": [
                            {
                                id: 'molecular-blocks',
                                name: 'Molecular',
                                templates: [
                                    {
                                        name: 'Chromosome Selector',
                                        blockType: DynamicBlockUtil.blockTypes.formEditor,
                                        thumbnail: '/static/images/abbott/pepper/blockThumbs/chromosome-selector.png',
                                        template: '/static/js/abbott/editing/ui/block/formBased/ChromosomeSelectorBlock.html',
                                        templateName: 'chromosome-selector-form-editor-block',
                                        description: 'The Chromosome Selector allows a user to select a Chromosome to advance to that part of the Chromosome Search.'
                                    },{
                                        name: 'Ordering Information',
                                        blockType: DynamicBlockUtil.blockTypes.formEditor,
                                        thumbnail: '/static/images/abbott/pepper/blockThumbs/ordering-info.png',
                                        template: '/static/js/abbott/editing/ui/block/formBased/OrderingInfoBlock.html',
                                        templateName: 'ordering-info-editor-block',
                                        description: 'The Ordering Information displays the quantity, order number, and GTIN for a selected product.'
                                    },{
                                        name: 'Probe Information',
                                        blockType: DynamicBlockUtil.blockTypes.formEditor,
                                        thumbnail: '/static/images/abbott/pepper/blockThumbs/probe-information-thumbnail.png',
                                        template: '/static/js/abbott/editing/ui/block/formBased/ProbeInfoBlock.html',
                                        templateName: 'probe-info-form-editor-block',
                                        description: 'The Probe Information displays the probe name, fluorophore, chromosome, cytogenic location/STS, hybridization photo, and probe map for a selected product.'
                                    },{
                                        name: 'Molecular Catalog Product Filter',
                                        blockType: DynamicBlockUtil.blockTypes.formEditor,
                                        thumbnail: '/static/images/abbott/pepper/blockThumbs/molecular-catalog-webpage-filter-block-thumbnail.png',
                                        template: '/static/js/abbott/editing/ui/block/formBased/MolecularCatalogProductFilter.html',
                                        templateName: 'molecular-catalog-product-filter-form-editor-block',
                                        description: 'The Molecular Catalog Product Filter is a product filter'
                                    },{
                                        name: 'Instructions for Use',
                                        blockType: DynamicBlockUtil.blockTypes.formEditor,
                                        thumbnail: '/static/images/abbott/pepper/blockThumbs/instructions-for-use-block-thumbnail.png',
                                        template: '/static/js/abbott/editing/ui/block/formBased/instructionsForUse/InstructionsForUseBlock.html',
                                        templateName: 'instructions-for-use-block',
                                        description: 'IFU database searching block with the ability to search by the lot number, product group or Abbott order number.'
                                    },{
                                        name: 'Panel Background Video with Image Overlay',
                                        blockType: DynamicBlockUtil.blockTypes.formEditor,
                                        thumbnail: '/static/images/abbott/pepper/blockThumbs/panel-background-video-with-image-overlay-block-thumbnail.png',
                                        template: '/static/js/abbott/editing/ui/block/formBased/PanelBackgroundVideoWithImageOverlayBlock.html',
                                        templateName: 'panel-background-video-with-image-overlay-block',
                                        description: 'The Panel Background Video with Image Overlay displays header text, subheader text, buttons, and a video in the background that loops with no sound with an image overlay.'
                                    },{
                                        name: 'Certificate of Analysis',
                                        blockType: DynamicBlockUtil.blockTypes.formEditor,
                                        thumbnail: '/static/images/abbott/pepper/blockThumbs/certificate-of-analysis-block-thumbnail.png',
                                        template: '/static/js/abbott/editing/ui/block/formBased/CertificateOfAnalysisBlock.html',
                                        templateName: 'certificate-of-analysis-block',
                                        description: 'COA database searching block with the ability to search by the lot number.'
                                    }
                                ]
                            }
                        ]
                    }
                },
                /**
                 * Add to left rail shared block config
                 */
                'abbott-shared/editing/blockConfigs/leftBodySharedBlockConfig': {
                    '+blockConfig':
                    {
                        "+categories": [
                            {
                                id: 'molecular-blocks',
                                name: 'Molecular',
                                templates: [
                                   {
                                        name: 'Ordering Information',
                                        blockType: DynamicBlockUtil.blockTypes.formEditor,
                                        thumbnail: '/static/images/abbott/pepper/blockThumbs/ordering-info.png',
                                        template: '/static/js/abbott/editing/ui/block/formBased/OrderingInfoBlock.html',
                                        templateName: 'ordering-info-editor-block',
                                        description: 'The Ordering Information displays the quantity, order number, and GTIN for a selected product.'
                                   },{
                                        name: 'Probe Information',
                                        blockType: DynamicBlockUtil.blockTypes.formEditor,
                                        thumbnail: '/static/images/abbott/pepper/blockThumbs/probe-information-thumbnail.png',
                                        template: '/static/js/abbott/editing/ui/block/formBased/ProbeInfoBlock.html',
                                        templateName: 'probe-info-form-editor-block',
                                        description: 'The Probe Information displays the probe name, fluorophore, chromosome, cytogenic location/STS, hybridization photo, and probe map for a selected product.'
                                    }
                                ]
                            }
                        ]
                    }
                }
            });
        }
    });
});
},
'abbott-shared/editing/blockConfigs/blockConfigAugmentationUtil':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'vodori/util/mixinAndModify',
    'lodash'
], function (
    module, provide,
    lang,
    mixinAndModify,
    _
) {

    /**
     * This module provides a mechanism for consuming applications to modify the block configs used by the shared
     * templates. To use it, just call "augment" from the client package's authorMain, and pass an object with the
     * configuration changes, like so:
     *
     * ```
     * blockConfigAugmentationUtil.augment({
     *     'abbott-shared/editing/blockConfigs/fullWidthSharedBlockConfig': {
     *         '+blockConfig': {
     *             "+categories": [
     *                 {
     *                     id: 'project-full-width-blocks',
     *                     name: 'Project',
     *                     templates: [
     *                         {
     *                             name: 'Project Full Width Block',
     *                             blockType: DynamicBlockUtil.blockTypes.formEditor,
     *                             thumbnail: '/static/images/abbott/pepper/blockThumbs/full-width.png',
     *                             template: '/static/js/abbott/editing/ui/block/formBased/FullWidth.html',
     *                             templateName: 'project-full-width-block',
     *                             description: 'A project full-width block.'
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *     },
     *     'abbott-shared/editing/blockConfigs/halfColumnSharedBlockConfig': {
     *         '+blockConfig': {
     *             "+categories": [
     *                 {
     *                     id: 'project-half-column-blocks',
     *                     name: 'Project',
     *                     templates: [
     *                         {
     *                             name: 'Project Half Column Block',
     *                             blockType: DynamicBlockUtil.blockTypes.formEditor,
     *                             thumbnail: '/static/images/abbott/pepper/blockThumbs/half-column.png',
     *                             template: '/static/js/abbott/editing/ui/block/formBased/HalfColumn.html',
     *                             templateName: 'project-half-column-block',
     *                             description: 'A project half-column block'
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *     }
     * });
     * ```
     *
     * The keys should be the full module paths of the shared block configs you want to augment, and the values
     * should be configuration objects with mixinAndModify syntax. These values will be combined with the original
     * abbott-shared configs so that all sections using that blockConfig will receive the augmentation.
     */
    return provide(module.id, {
        augment: function(augments) {

            // For each property on the augments object
            _.forEach(augments, lang.hitch(this, function(value, key) {

                // Require the original abbott-shared blockConfig
                require([key], lang.hitch(this, function(blockConfig) {

                    // Augment it
                    blockConfig._raw = mixinAndModify(lang.clone(blockConfig._raw), value);
                }));
            }));
        }
    });
});
},
'abbott/editing/blockConfigs/molecularCatalogFullWidthBlockConfig':function(){
define([
    'module', 'vodori/provide',
    'abbott-shared/editing/ui/dynamicBlock/DynamicBlockUtil',
    'abbott-shared/editing/blockConfigs/blockConfig'
], function (
    module, provide,
    DynamicBlockUtil,
    blockConfig
) {
    return provide(module.id, new blockConfig({
        '+blockConfig':
            {
                "name": "molecular-catalog-full-width-config-section",
                "templateId": "molecularCatalogFullWidthBlockTemplate",
                "categories": [
                    {
                        id: 'molecularCatalog',
                        name: 'Molecular Catalog',
                        templates: [
                           {
                                name: 'Molecular Catalog Product',
                                blockType: DynamicBlockUtil.blockTypes.formEditor,
                                thumbnail: '/static/images/abbott/pepper/blockThumbs/molecular-catalog-product-block-thumbnail.png',
                                template: '/static/js/abbott/editing/ui/block/formBased/MolecularCatalogWebpage.html',
                                templateName: 'molecular-catalog-product',
                                description: 'The Molecular Catalog Product displays information regarding products included in the Print Catalog'
                            }
                        ]
                    }
                ]
            }
    }));
});

},
'abbott-shared/editing/blockConfigs/blockConfig':function(){
/* jshint -W106 */
define([
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'vodori/util/mixinAndModify',
        'vodori/tinymce/all'
], function (
    module, provide,
    lang,
    mixinAndModify
) {
    // Set up the default config object.
    var defaults = {
        'blockConfig': [
        ]
    };

    return provide(module.id, null, {
        _raw: null,    // Base config + overrides
        _config: null, // Out to TinyMCE

        // Instantiate with a base config and some overrides.
        constructor: function(baseConfig, overrides) {
            // If no base config is passed in, adopt the defaults.
            if (arguments.length < 2) {
                overrides = baseConfig;
                baseConfig = {'_raw': defaults};
            }
            // Clone the base so this new instance doesn't modify it.
            this._raw = mixinAndModify(lang.clone(baseConfig._raw), overrides);
        },

        // Return a proper TinyMCE config object.
        toConfig: function() {
            // Only process each configuration once.
            if (this._config) {
                return this._config;
            }

            this._config = {};

            for (var prop in this._raw) {
                this._config[prop] = this._raw[prop];
            }

            return this._config;
        }
    });
});
},
'vodori/tinymce/all':function(){
// Gather all the tinymce plugins, so we cna bake them into the build.
define([
    './AddDojo',
    './AddSpace',
    './AdvLink',
    './AgressivelyAllowEmptyContent',
    './Antenna',
    './AutoRotator',
    './Background',
    './ButtonGroupLabeler',
    './CleanBookmarks',
    './CodeMirror',
    './CollapsingTabContainer',
    './ConfigurableTransformer',
    './EditableConfigurableTransformer',
    './CustomAutoResize',
    './DialogPopup',
    './Expander',
    './FixedToolbar',
    './IFrame',
    './KeyboardShortcuts',
    './LimitHeight',
    './LimelightVideo',
    './OverrideContextCommand',
    './Placeholder',
    './PreventLineBreaks',
    './RandomImage',
    './RegEx',
    './RemoveForcedRoots',
    './RemoveMarkup',
    './RemoveSingleForcedRoot',
    './LiveStyling',
    './Stamp',
    './StampValidator',
    './SubPageDropDown',
    './TabContainer',
    './TableControls',
    './Twitter',
    './Validation',
    './VodoriImage',
    'vodori/amd/tinymce'
], function () {
    return {};
});
},
'vodori/tinymce/AddDojo':function(){
define([
    'lodash', 'dojo/_base/lang',
    'dojo/dom-construct', 'dojo/dom-attr',
    'dijit/registry',
    'vodori/amd/tinymce',
    'vodori/provide', 'module',
    'vodori/tinymce/util/getPluginName', 'vodori/tinymce/util/getResourceUrl',
    'vodori/util/node/createFragmentedElement', 'vodori/util/addLoaderToFrame',
    /* Template MIDs */
    'dijit/WidgetSet',
    'vodori/tinymce/EditorLoaded'
], function (_, lang,
             domConstruct, domAttr,
             registry,
             tinymce,
             provide, module,
             getPluginName, getResourceUrl,
             createFragmentedElement, addLoaderToFrame) {

    var pluginName = getPluginName(module);

    var plugin = provide(module.id, null, {
        ed: null, // Set in init
        url: '', // Set in init
        pluginName: pluginName,

        /**
         * The editor Iframe has its own separate dojo instance.
         * This module contains lines of code that will be executed in the editor iFrame and lines of code that will
         * be executed in the browser.
         * This field will contain references to modules in the editor IFrame.
         */
        editorDojo: null,

        /**
         * Parse the contents of the editor with Dojo
         * @param edLoaded onEditorLoaded handler
         * @private
         */
        _parseEditorContent:  function(edLoaded) {
            if (!this.doneLoading) {
                this.doneLoading = true;

                var win = this.ed.getWin();

                // Require our editor widgets
                win.require([
                    'dojo/parser',
                    'dojo/_base/lang',
                    'dojo/dom-construct', 'dojo/query',
                    'dijit/registry',
                    'vodori/ui/editor/TabContainer',
                    'vodori/input/editor/ValidatedContent',
                    'vodori/input/editor/StampDecorator',
                    'dijit/WidgetSet' // This gets us registry.forEach.
                ], lang.hitch(this, function (parser, lang, domConstruct, query, dijitRegistry) {
                    this.editorDojo.registry = dijitRegistry;
                    this.editorDojo.parser = parser;
                    this.editorDojo.domConstruct = domConstruct;
                    this.editorDojo.query = query;
                    this.editorDojo.domAttr = domAttr;
                    this.editorDojo.getObject = lang.getObject;

                    this._flipWidgetsIntoEditMode();

                    parser.parse({template:false}).then(function () {
                        console.log('releasing frame');

                        // Cleanup the listener.
                        if(edLoaded) {
                            edLoaded.unpause();
                        }
                    });


                }));


            }
        },

        init: function(ed) {
            this.ed = ed;
            this.url = getResourceUrl(module);
            this.editorDojo = {};

            // The pausing has to happen inside preInit or the event might not be ready to connect to.
            var edLoaded = null;
            ed.onPreInit.add(function () {
                edLoaded = ed.onEditorLoaded;
                if (edLoaded) {
                    edLoaded.pause();
                }
            });

            this.doneLoading = false;
            ed.onInit.add(function(ed) {
                addLoaderToFrame(ed.getWin()).then(lang.hitch(this, '_parseEditorContent', edLoaded));

                // Setup events
                ed.onBeforeSetContent.add(this._onBeforeSetContent, this);
                ed.onSetContent.add(this._onSetContent, this);

                ed.serializer.onPreProcess.add(this._onPreProcessSerialization, this);

                // NOTE: added to top so that it executes before Wysiwyg content normalizer
                ed.undoManager.onBeforeAdd.addToTop(this._useSerializedContentForUndoManager, this);

            }, this);
        },


        /**
         * Before setting content, destroy all widgets so the registry is clean.
         */
        _onBeforeSetContent: function() {
            if (this.editorDojo.registry) {
                this.editorDojo.registry._destroyAll();
            }
        },

        /**
         * When setting content, first try to flip all widgets into their editing form, then parse the widgets.
         */
        _onSetContent: function() {
            if (this.editorDojo && this.editorDojo.parser) {
                this._flipWidgetsIntoEditMode();
                this.editorDojo.parser.parse();
            }
        },

        /**
         * By default, the undo manager skips events when it takes snapshots of the content. This would mean that the
         * dojo widgets (such as tab containers) don't get deserialized. In order to make undo work with dojo widgets
         * in the content we need to override this behavior.
         */
        _useSerializedContentForUndoManager: function(undoManager, level) {
            level.content = this.ed.getContent();
        },

        /**
         * This is called before the editor's serializer is fired. Here we flip the editable widgets back to their
         * preview form.
         * @param serializerFail the editor's serializer (well, it's supposed to be)
         * @param args an object with various items, including the root node that is being serialized
         * @private
         */
        _onPreProcessSerialization: function(serializerFail, args) {
            // NOTE: args.node here is a copy of the dom tree from the actual editor.
            this._serializeWidgets(args.node);
        },

        /**
         * Go through each widget in the editor and if it's an editor widget replace the rendered widget's markup with
         * the serialized HTML.
         *
         * @param rootNode
         */
        _serializeWidgets: function(rootNode) {
            if (this.editorDojo.registry) {
                var editorWidgets = this._getAllEditorWidgets();
                this._serializeEditorWidgets(editorWidgets, rootNode);

                // Try to remove the HTML of all other widgets that are not editor widgets
                var nodes = rootNode.querySelectorAll('[id]');
                for (var i = 0; i < nodes.length; i++) {
                    if (this.editorDojo.registry.byNode(nodes[i])) {
                        this.editorDojo.domConstruct.destroy(nodes[i]);
                    }
                }
            } else {
                console.warn('No Dijit Registry found, when trying to serialize editor.',
                    'This is not an error if it comes up when you switch to Edit Mode for the first time.');
            }
        },

        /**
         * Get all the editor widgets in the registry. Ancestor's in the dom are guaranteed to come before their
         * descendants.
         * @returns {Array}
         * @private
         */
        _getAllEditorWidgets: function() {
            var registry = this.editorDojo.registry;
            var allWidgets = [];

            function addWidgetsIn(node) {
                if (node) {
                    _.forEach(registry.findWidgets(node), function (widget) {
                        if (widget.isEditorWidget) {
                            allWidgets.push(widget);
                        }
                        addWidgetsIn(widget.domNode);
                    });
                }
            }

            addWidgetsIn(this.ed.getDoc().body);
            return allWidgets;
        },

        _serializeEditorWidgets: function(editorWidgets, container) {
            _.forEach(editorWidgets, function(widget) {
                var node = container.querySelector('#' + widget.id);
                if (node) {
                    node.outerHTML = widget.serialize();
                }
            });
        },

        /**
         * This function will attempt to switch every dojo widget into it's editor version if it exists.
         *
         * The editor widget has to live as a sibling of the non-editor widget and in a 'editor' folder.
         * Example: vodori.ui.TabContainer would be vodori.ui.editor.TabContainer
         */
        _flipWidgetsIntoEditMode: function() {
            // Note: This uses the dojo instance from the editor window (iframe), not the global dojo instance.
            var widgetList = this.editorDojo.query('[data-dojo-type]');
            for (var i = 0; i < widgetList.length; i++) {
                var widget = widgetList[i];
                var widgetName = this.editorDojo.domAttr.get(widget, 'data-dojo-type');

                var packageName = widgetName.split('.');
                packageName.splice(packageName.length - 1, 0, 'editor');
                var editorPackage = packageName.join('.');

                if (this.editorDojo.getObject(editorPackage)) {
                    console.log('Editor widget found: ' + editorPackage);
                    this.editorDojo.domAttr.set(widget, 'data-dojo-type', editorPackage);
                }

            }
        }
    });


    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});
},
'vodori/amd/tinymce':function(){
// This is just a slug. Eventually, this might load tinymce, but routing
// through prevents extra effort if we do move away from a separate script tag
// in dev mode.
define(function () {
    // This is just an AMD wrapper for TinyMCE.
    return window.tinymce;
});

},
'vodori/tinymce/util/getPluginName':function(){
define(['vodori/provide', 'module'], function (provide, _module) {
    /** Standard way for getting a tinymce pluginName from the module object.
     *
     * @param {Object.<*>} module
     * @return {string}
     */
    return provide(_module.id, function (module) {
        return module.id.replace(/^.+[\/]/g, '').toLowerCase();
    });
});

},
'vodori/tinymce/util/getResourceUrl':function(){
define(['vodori/provide', 'module'], function (provide, _module) {
    /** Standard way to get the resource file from the module object.
     *
     * @param {Object.<*>} module
     * @return {string}
     */
    return provide(_module.id, function (module) {
        return module.uri.replace(/([^\/]+)\.js$/, function (_, folder) {
            return folder.toLowerCase();
        });
    });
});

},
'vodori/util/addLoaderToFrame':function(){
define([
    'dojo/dom', 'dojo/dom-attr',
    'dojo/Deferred',
    'vodori/util/loadScript'
], function (dom, domAttr, Deferred, loadScript) {
    'use strict';

    /**
     * Constants that specify the DOM id value and configuration attribute key for both the loader (dojo.js) and
     * configuration (configuration.js) script tags that are to be copied from the parent document to the child iframe.
     *
     * @type {{loader: {id: string, configAttr: string}, config: {id: string, configAttr: string}}}
     */
    var SCRIPT_SETTINGS = {
        // Settings for the script tag that loads dojo.js
        loader: {
            id: 'vodori-script-loader',
            configAttr: 'data-dojo-config'
        },
        // Settings for the script tag that loads the configuration.js file
        config: {
            id: 'config-script',
            configAttr: 'data-configuration'
        }
    };

    /**
     * Gets a reference to the script and adds it to a frame if it's not already present.
     *
     * @param {Object} scriptSettings - value from SCRIPT_SETTINGS containing the id value and config attribute
     * (configAttr) to copy from the top document
     * @param {HTMLDocument} targetDocument
     * @return {dojo.Deferred.promise}
     */
    var setupScript = function (scriptSettings, targetDocument) {
        var topScript = dom.byId(scriptSettings.id, window.top.document);

        var scriptAttrs = {
            id: scriptSettings.id,
            src: domAttr.get(topScript, 'src')
        };

        scriptAttrs[scriptSettings.configAttr] = domAttr.get(topScript, scriptSettings.configAttr);

        return loadScript(scriptAttrs, targetDocument);
    };

    /**
     * Add a loader to a given frame, unless one already exists.
     *
     * @param {Window} frame
     * @return {dojo.Deferred.promise} promise that resolves to the frame's require method.
     */
    return function (frame) {
        var loadingDeferred = new Deferred();

        // add the configuration.js script tag
        setupScript(SCRIPT_SETTINGS.config, frame.document)
            .then(function () {
                // add the dojo.js script tag
                setupScript(SCRIPT_SETTINGS.loader, frame.document)
                    .then(function () {
                        loadingDeferred.resolve(frame.require);
                    });
            });

        return loadingDeferred.promise;
    };
});

},
'vodori/util/loadScript':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
        'dojo/dom-construct', 'dojo/dom-attr', 'dojo/_base/window', 'dojo/has', 'dojo/Deferred', 'dojo/on',
        /* dojo/request/script is included because it defines has('script-readystatechange') */
        'dojo/request/script'
], function(domConstruct, domAttr, window, has, Deferred, on) {

    var inFlightPromises = {};

    function normalizeFrameDoc(frameDoc) {
        return frameDoc || window.doc;
    }

    function getHeadElement(frameDoc) {
        return frameDoc.getElementsByTagName('head')[0];
    }

    function getExistingPromise(scriptAttrs, frameDoc) {
        var id = scriptAttrs.id;
        if (id) {
            var scriptTag = frameDoc.getElementById(id);
            if (scriptTag) {
                var promise = inFlightPromises[id];
                if (!promise) {
                    promise = new Deferred();
                    promise.resolve(scriptTag);
                    promise = promise.promise;
                }
                return promise;
            }
        }
        return null; // no existing promise
    }

    function createPromise(scriptTag) {
        var deferred = new Deferred();
        var handle;

        function onScriptLoad() {
            handle.remove();
            removeInFlightPromise(scriptTag);
            deferred.resolve(scriptTag);
        }

        // There are different ways to handle this depending on the browser. I borrowed this conceptually from
        // dojo/request/script.
        if (has('script-readystatechange')) {
            handle = on(scriptTag, 'readystatechange', function(evt) {
                if (/complete|loaded/.test(scriptTag.readyState)) {
                    onScriptLoad();
                }
            });
        } else {
            handle = on(scriptTag, 'load', onScriptLoad);
        }

        addInFlightPromise(scriptTag, deferred.promise);
        return deferred.promise;
    }

    function addInFlightPromise(scriptTag, promise) {
        var id = domAttr.get(scriptTag, 'id');
        if (id) {
            inFlightPromises[id] = promise;
        }
    }

    function removeInFlightPromise(scriptTag) {
        var id = domAttr.get(scriptTag, 'id');
        if (id) {
            delete inFlightPromises[id];
        }
    }

    /**
     * Load a script by creating a <script> tag in the specified document and return a promise that resolves when the
     * script has finished loading.
     *
     * @param {Object} scriptAttrs Hash of attributes to set on the script tag.
     * @param {String} scriptAttrs.src URL of the script file to load
     * @param {String} [scriptAttrs.id] ID of the script tag. If another element with this ID already exists, the
     *                 function will return immediately with a promise resolving to that element. (Optional)
     * @param {Document} [frameDoc] The document object of the frame in which the script should load. (Optional - if
     *                              omitted, load in the current frame)
     * @return {Promise} a promise that resolves to the script tag when it loads successfully.
     */
    return function(scriptAttrs, frameDoc) {
        frameDoc = normalizeFrameDoc(frameDoc);
        var existingPromise = getExistingPromise(scriptAttrs, frameDoc);
        if (existingPromise) {
            return existingPromise;
        }

        var script = domConstruct.create('script', scriptAttrs);
        var promise = createPromise(script);

        domConstruct.place(script, getHeadElement(frameDoc));
        return promise;
    };
});
},
'vodori/tinymce/EditorLoaded':function(){
define([
    'vodori/provide', 'module',
    'dojo/_base/lang', 'dojo/dom-class',
    'vodori/amd/tinymce', 'vodori/tinymce/_GetInfoMixin',
    'vodori/tinymce/util/getPluginName',
    'vodori/tinymce/util/PausableDispatcher'
], function (provide, module, lang, domClass, tinymce, _GetInfoMixin, getPluginName, PausableDispatcher) {
    var pluginName = getPluginName(module);

    var LOADING_CLASS = 'editorLoading';

    var Constructor = provide(module.id, [_GetInfoMixin], {
        /**
         * @type {string}
         */
        pluginName: pluginName,

        /**
         * @param {tinymce.Editor} editor
         */
        init: function (editor) {
            // This kind of sucks, but the element is wrapped and hidden, so we'll set a class on the parent.
            var container = editor.getElement().parentNode;

            domClass.add(container, LOADING_CLASS);

            // Setup the new event.
            var dispatcher = editor.onEditorLoaded = new PausableDispatcher(editor);

            // Fire the event if we're not told to stop it.
            var handle = editor.onPostRender.add(function () {
                dispatcher.dispatch(editor);

                editor.onPostRender.remove(handle);
            }, this);

            dispatcher.add(function () {
                domClass.remove(container, LOADING_CLASS);
            });
        }

    });

    tinymce.PluginManager.add(pluginName, Constructor);

    return Constructor;
});


},
'vodori/tinymce/_GetInfoMixin':function(){
/**
 * Implements the standard tinymce getInfo method in reusable way.
 */
define([
    '../amd/tinymce',
    'require', 'vodori/provide', 'module'
], function (tinymce, require, provide, module) {
    return provide(module.id, null, {
        /**
         * Name of the plugin. Should be set by the mixer.
         *
         * @type {string}
         */
        pluginName: '',

        /**
         * A tinymce standardized way to find out the name of a plugin.
         *
         * @return {Object.<string>}
         */
        getInfo: function () {
            return {
                longname: 'Vodori ' + this.pluginName,
                author: 'Vodori Inc.',
                authorurl: 'http://www.vodori.com',
                infourl: 'http://www.vodori.com',
                version: tinymce.majorVersion + "." + tinymce.minorVersion
            };
        }
    });
});

},
'vodori/tinymce/util/PausableDispatcher':function(){
/**
 * Extend tinymce's dispatcher to allow for pausing of the load event.
 *
 * {@inheritDoc}
 */
define([
    'module',
    'dojo/_base/lang', 'dojo/Deferred',
    '../../amd/tinymce'
], function (module, lang, Deferred, tinymce) {
    // Make the module.id into a dotted string.
    var moduleName = module.id.replace(/\//g, '.');

    tinymce.create(moduleName + ':tinymce.util.Dispatcher', {
        /**
         * @type {Array.<*>}
         */
        callbackArgs: null,

        /**
         * @type {dojo.Deferred}
         */
        _pauser: null,

        /**
         * @param {Object} scope
         * @constructor
         */
        PausableDispatcher: function (scope) {
            this.parent(scope);
        },

        /**
         * Stop propagation of the event.
         */
        pause: function () {
            this._pauser = new Deferred();
        },

        /**
         * Let propagation continue.
         */
        unpause: function () {
            this._pauser.resolve();
        },

        /**
         * Fire the event. Extends tinymce's built in to allow for pause and unpause.
         */
        dispatch: function () {
            this.callbackArgs = arguments.length ? arguments : this.callbackArgs || [];

            this._pauser.then(lang.hitch(this, 'parent', this.callbackArgs));
        }
    });

    // Sadly, tinymce won't allow us to use anonymous Objects.
    return lang.getObject(moduleName);
});
},
'vodori/tinymce/AddSpace':function(){
define([
    '../amd/tinymce',
    'vodori/provide', 'module',
    './util/getPluginName', './_GetInfoMixin'
], function (tinymce, provide, module, getPluginName, _GetInfoMixin) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, [_GetInfoMixin], {
        ed: null,

        init: function (ed) {
            this.ed = ed;

            ed.addCommand('mceAddSpace', function (ui, v) {
                if (v.position === 'top') {
                    this.addSpaceTop();
                } else if (v.position === 'bottom') {
                    this.addSpaceBottom();
                } else {
                    console.error('We somehow got a request to add a space, but got a position of: ' + v.position);
                }
            }, this);

            // Add an "Add space to..." context menu
            if (ed.getParam('add_space_menu', true)) {
                ed.onInit.add(this.addContextMenuItems, this);
            }

            // Add clickable targets above and below the editor
            if (ed.getParam('add_space_targets', true)) {
                ed.onInit.add(this.addClickableTargets, this);
            }
        },

        addSpaceTop: function () {
            var body = this.ed.getBody();
            var firstChild = body.children[0];

            var newP = this.ed.dom.create('p', {}, '&nbsp;');

            body.insertBefore(newP, firstChild);

            this.ed.selection.select(newP);
        },

        addSpaceBottom: function () {
            var newP = this.ed.dom.add(this.ed.getBody(), 'p', {}, '&nbsp;');
            this.ed.selection.select(newP);
        },

        addContextMenuItems: function () {
            var ed = this.ed;

            if (ed && ed.plugins && ed.plugins.contextmenu) {
                ed.plugins.contextmenu.onContextMenu.add(function (th, m, e) {
                    m.addSeparator();

                    var am = m.addMenu({
                        title: 'Add space to...'
                    });

                    am.add({
                        title: 'Top of editor',
                        icon: 'add_space_top',
                        cmd: 'mceAddSpace',
                        ui: true,
                        value: {position: "top"}
                    });

                    am.add({
                        title: 'Bottom of editor',
                        icon: 'add_space_bottom',
                        cmd: 'mceAddSpace',
                        ui: true,
                        value: {position: "bottom"}
                    });

                    m.addSeparator();
                });
            }
        },

        addClickableTargets: function () {
            var ed = this.ed;

            var frame = ed.getWin().frameElement;

            var addToTop = document.createElement('span');
            frame.parentNode.insertBefore(addToTop, frame);

            ed.dom.setAttribs(addToTop, {
                'class': 'mceAddSpaceTop',
                title: 'Add space to top'
            });

            ed.dom.bind(addToTop, 'click', function () {
                ed.execCommand('mceAddSpace', false, {position: 'top'});
            });

            var addToBottom = document.createElement('span');
            ed.dom.insertAfter(addToBottom, frame);

            ed.dom.setAttribs(addToBottom, {
                'class': 'mceAddSpaceBottom',
                title: 'Add space to bottom'
            });

            ed.dom.bind(addToBottom, 'click', function () {
                console.log('Adding some space');
                ed.execCommand('mceAddSpace', false, {position: 'bottom'});
            });
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});
},
'vodori/tinymce/AdvLink':function(){
/** A pepper-3 packaged version of AdvLink, see copyright below.
 *
 * $Id: editor_plugin_src.js 539 2008-01-14 19:08:58Z spocke $
 *
 * @author Moxiecode
 * @copyright Copyright 2004-2008, Moxiecode Systems AB, All rights reserved.
 */
define([
    '../amd/tinymce',
    'vodori/provide', 'module',
    './util/getPluginName', './util/getResourceUrl',
    './_GetInfoMixin'
], function (tinymce, provide, module, getPluginName, getResourceUrl, _GetInfoMixin) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, [_GetInfoMixin], {
        pluginName: pluginName,
        init: function (ed) {
            var url = this.url = getResourceUrl(module);
            this.editor = ed;

            // Register commands
            ed.addCommand('mceAdvLink', function () {
                var se = ed.selection;

                // No selection and not in link
                if (se.isCollapsed() && !ed.dom.getParent(se.getNode(), 'A')) {
                    return;
                }

                ed.windowManager.open({
                    file: url + '/link.htm',
                    width: 480 + parseInt(ed.getLang('advlink.delta_width', 0), 10),
                    height: 400 + parseInt(ed.getLang('advlink.delta_height', 0), 10),
                    inline: 1
                }, {
                    /* jshint -W106 */
                    plugin_url: url
                    /* jshint +W106 */
                });
            });

            // Register buttons
            ed.addButton('link', {
                title: 'advlink.link_desc',
                cmd: 'mceAdvLink'
            });

            ed.addShortcut('ctrl+k', 'advlink.advlink_desc', 'mceAdvLink');

            ed.onNodeChange.add(function (ed, cm, n, co) {
                cm.setDisabled('link', co && n.nodeName !== 'A');
                cm.setActive('link', n.nodeName === 'A' && !n.name);
            });
        },

        getInfo: function () {
            return {
                longname: 'Advanced link',
                author: 'Moxiecode Systems AB',
                authorurl: 'http://tinymce.moxiecode.com',
                infourl: 'http://wiki.moxiecode.com/index.php/TinyMCE:Plugins/advlink',
                version: tinymce.majorVersion + "." + tinymce.minorVersion
            };
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});
},
'vodori/tinymce/AgressivelyAllowEmptyContent':function(){
/**
 * Note this is a plugin to force completely empty content areas when they have a "forced_root_block" and no content
 */
define([
    '../amd/tinymce',
    'vodori/provide', 'module',
    './util/getPluginName',
    './_GetInfoMixin'
], function (tinymce, provide, module, getPluginName, _GetInfoMixin) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, [_GetInfoMixin], {

        pluginName: pluginName,

        init: function (ed, url) {

            ed.onPostProcess.add(function (ed, o) {

                // If there's a forced root block, check if it has any content
                if (ed.getParam("forced_root_block")) {

                    var startTag = "<" + ed.getParam("forced_root_block") + ">";
                    var endTag = "</" + ed.getParam("forced_root_block") + ">";

                    // Construct an example empty piece of content to test against.. e.g. <h3></h3>
                    // note that TinyMCE can produce a variety of markup that all represents empty content
                    var emptyContentTestArray = [
                        "&nbsp;",
                        "",
                        "<br/>"
                    ];

                    // Create the string to compare.. remove all newlines and whitespace
                    var stringToCompare = o.content.toLowerCase().replace(/\r|\n|\r\n| /g, "");

                    for (var i = 0; i < emptyContentTestArray.length; ++i) {
                        var testString = startTag + emptyContentTestArray[i] + endTag;

                        // See if the current content is the same as our empty test condition..
                        if (stringToCompare === testString) {

                            // .. if so, return an empty string
                            o.content = "";

                        }

                    }

                }

                // If we get here, do nothing the content untouched
                // no-op

            });
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});
},
'vodori/tinymce/Antenna':function(){
/**
 * Add a method to TinyMCE that adds a listener to every event. Useful for
 * debugging.
 */
define([
    '../amd/tinymce',
    'vodori/provide', 'module',
    './util/getPluginName',
    './_GetInfoMixin'
], function (tinymce, provide, module, getPluginName, _GetInfoMixin) {
    var pluginName = getPluginName(module);
    var aSlice = Array.prototype.slice;

    var plugin = provide(module.id, [_GetInfoMixin], {
        pluginName: pluginName,

        // Tiny wasn't letting me each it's properties, so I gather them once
        // before doing something with them.
        init: function (ed) {
            var attrs = [];

            for (var attr in ed) {
                if (ed.hasOwnProperty(attr)) {
                    attrs.push(attr);
                }
            }

            ed[pluginName] = function (fn) {
                var that = this;
                tinymce.each(attrs, function (attr) {
                    // Only try to add callback to events.
                    if (attr.indexOf('on') === 0 && that[attr].hasOwnProperty('listeners')) {
                        that[attr].add(function () {
                            var args = aSlice.call(arguments);
                            args.unshift(attr);
                            fn.apply(that, args);
                        });
                    }
                });

            };

            // In annoying mode, tinymce.antenna tells you everything
            if(ed.getParam('dump_all_events')) {
                ed.antenna(function () {
                    var nodeArgs = aSlice.call(arguments, 0).filter(function (arg) {
                        return arg && arg.nodeType;
                    }).map(function (arg) {
                        return arg.outerHTML;
                    });

                    console.log(this, arguments, nodeArgs);
                });
            }
        }

    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});


},
'vodori/tinymce/AutoRotator':function(){
define([
    'vodori/provide', 'module',
    'dojo/aspect', 'dojo/_base/lang', 'dojo/query', 'dojo/dom-construct',
    'vodori/ui/AutoRotator',
    'vodori/amd/tinymce', './TabularTransformer',
    './util/getPluginName', './util/getResourceUrl',
    './_GetInfoMixin'
], function (
    provide, module,
    aspect, lang, query, domConstruct,
    AutoRotator,
    tinymce, TabularTransformer,
    getPluginName, getResourceUrl,
    _GetInfoMixin) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, [TabularTransformer, _GetInfoMixin], {
        pluginName: pluginName,

        dijitDeclaredClass: AutoRotator.prototype.declaredClass,

        editor: null,

        button: {
            label: '',
            image: 'img/pictures.png',
            title: 'Insert a content rotator',
            changeStates: {
                highlight: [pluginName],
                enable: [],
                disable: []
            }
        },

        popupWidth: 400,
        popupHeight: 550,

        defaultAttrs: {
            width: '',
            height: '',
            autoStart: true,
            duration: 3000,
            suspendOnHover: true,
            pauseOnManualChange: true,
            manualChangeOnHover: false,
            random: false,
            transition: 'crossFade',
            transitionDuration: 1500,
            showPlayPause: false,
            showPrevNext: false,
            showIndicators: false,
            showTitles: false,
            controllerPosition: 'after'
        },

        /**
         * @see ConfigurableTransformer#useTemplate
         */
        useTemplate: true,

        popupOnCreate: true,

        url: getResourceUrl(module),

        styleSheet: true,

        init: function (ed, url) {
            this.editor = ed;

            // Intercept TinyMCE's execCommand and check if it's trying to add a col to a table. If it is, and the
            // cursor is inside an auto rotator then return our own commands. This is because the default TinyMCE
            // insertCol behavior will try to clone part of the originating cell which will cause issues with
            // the rotator. Instead we will insert the col ourselves with only a nbsp; inside the cell.
            aspect.before(ed, 'execCommand', lang.hitch(this, function (command) {
                if (command === 'mceTableInsertColAfter' || command === 'mceTableInsertColBefore') {

                    var parents = this.getParents();

                    // Loop through the array of parent elements and check if any of them are the vodori auto rotator
                    for (var i = 0; i < parents.length; i++) {
                        if (ed.dom.hasClass(parents[i], this.dijitDeclaredClassCSS)) {
                            return [command + "ForAutoRotator"];
                        }
                    }
                    return arguments;
                }
                return arguments;
            }));

            ed.addCommand('mceTableInsertColAfterForAutoRotator', this.insertColAfter, this);
            ed.addCommand('mceTableInsertColBeforeForAutoRotator', this.insertColBefore, this);

            this.inherited(arguments);
        },

        insertColAfter: function () {
            this.insertCol(false);
        },

        insertColBefore: function () {
            this.insertCol(true);
        },

        /**
         * Insert a column to a table of the Auto Rotator.
         *
         * @param {boolean} before Whether the column should come before the current cell
         */
        insertCol: function (before) {
            var table, tableCols, selectedCell, colPosition = 0;
            var parents = this.getParents();

            // Loop through the array of parent elements to find all the elements of the table we need
            for (var i = 0; i < parents.length; i++) {
                if (parents[i].nodeName === "TABLE") {
                    table = parents[i];
                }

                if (parents[i].nodeName === "TR") {
                    tableCols = parents[i].children.length; // Number of columns in the table
                }

                if (parents[i].nodeName === "TD") {
                    var node = parents[i];
                    // Get the column position based on how man siblings there are before the current column
                    while ((node = node.previousSibling) !== null) {
                        // Only count 'ELEMENT_NODE' or the position will be incorrect
                        if (node.nodeType === 1) {
                            colPosition++;
                        }
                    }
                }
            }

            // Error check, if not all three variables are defined there is no way to add a column
            if (table === undefined || tableCols === undefined || colPosition === undefined) {
                console.error("Unable to get all elements of the table. Cannot insert column.");
                return;
            }

            // Add the table cells, loop through twice since there are two rows in the auto rotator
            for (var x = 0; x < 2; x++) {
                selectedCell = query('tr', table)[x].children[colPosition];
                domConstruct.create('td', {innerHTML: '&nbsp;'}, selectedCell, before ? 'before' : 'after');
            }
        },

        /**
         * Get all parent nodes based on cursor position.
         *
         * @return An array of nodes that are parents of the node the cursor is currently in
         */
        getParents: function () {
            var selNode = this.editor.selection.getNode();
            return this.editor.dom.getParents(selNode);
        }

    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'vodori/tinymce/TabularTransformer':function(){
/**
 * @name TabularTransformer
 */
define([
    'vodori/provide', 'module',
    'dojo/dom-attr',
    'vodori/amd/tinymce',
    './ConfigurableTransformer',
    'vodori/util/objectToProps', 'vodori/util/propsToObject',
    'vodori/util/node/Manipulation'
], function (provide, module, domAttr, tinymce, ConfigurableTransformer, objectToProps, propsToObject, Manipulation) {

    var TabularTransformer = provide(module.id, [ConfigurableTransformer],
        /** @lends TabularTransformer **/
        {
            /**
             * @constructs
             * @param {tinymce.Editor} ed
             */
            init: function (ed) {
                this.inherited(arguments);

                this.ed = ed;

                this.ed.addCommand('mce_insert_tab_before', function () {
                    this.insertTab(false);
                }, this);
                this.ed.addCommand('mce_insert_tab_after', function () {
                    this.insertTab(true);
                }, this);

                this.ed.addCommand('mce_shift_tab_left', function () {
                    this.shiftTab(false);
                }, this);
                this.ed.addCommand('mce_shift_tab_right', function () {
                    this.shiftTab(true);
                }, this);

                this.ed.addCommand('mce_delete_tab', function () {
                    this.deleteTab();
                }, this);

                this.addTabButtons();
            },

            addTabButtons: function () {
                this.ed.addButton('inserttabbefore', {
                    cmd: 'mce_insert_tab_before',
                    image: false, // this.url + '/addTab.png',
                    label: 'Insert before',
                    title: 'Insert a new tab before the current one'
                });

                this.ed.addButton('inserttabafter', {
                    cmd: 'mce_insert_tab_after',
                    image: false, // this.url + '/addTab.png',
                    label: 'Insert after',
                    title: 'Insert a new tab after the current one'
                });

                this.ed.addButton('shifttableft', {
                    cmd: 'mce_shift_tab_left',
                    image: false, // this.url + '/addTab.png',
                    label: 'Shift left',
                    title: 'Shift this tab to the left'
                });

                this.ed.addButton('shifttabright', {
                    cmd: 'mce_shift_tab_right',
                    image: false, // this.url + '/addTab.png',
                    label: 'Shift right',
                    title: 'Shift this tab to the right'
                });

                this.ed.addButton('deletetab', {
                    cmd: 'mce_delete_tab',
                    image: false, // this.url + '/addTab.png',
                    label: 'Delete',
                    title: 'Delete the current tab'
                });
            },

            // This function just returns some things we need sometimes
            findTableInfo: function () {
                var ed = this.ed;

                // The node the cursor is currently in
                var selNode = this.ed.selection.getNode();

                var table = ed.dom.getParents(selNode, function (n) {
                    return n.nodeName.toLowerCase() === 'table';
                })[0];

                var selRow = ed.dom.getParents(selNode, function (n) {
                    return n.nodeName.toLowerCase() === 'tr';
                })[0];

                var selCell = ed.dom.getParents(selNode, function (n) {
                    return n.nodeName.toLowerCase() === 'td';
                })[0];

                // The indexes of the selected cell
                var selRowIndex = selRow.rowIndex;
                var selColIndex = selCell.cellIndex;

                var selTabContainer = ed.dom.getParents(selNode, function (n) {
                    return ed.dom.hasClass(n, 'TabContainer');
                })[0];

                var tcRows = ed.dom.select('> table', selTabContainer)[0].rows;

                return {
                    selTabContainer: selTabContainer,
                    selNode: selNode,
                    selCell: selCell,
                    table: table,
                    row: selRowIndex,
                    col: selColIndex,
                    rows: tcRows
                };
            },

            // Insert a table column representing a tab
            insertTab: function (after) {
                var ed = this.ed;
                var table = this.findTableInfo();

                var newCells = [];
                tinymce.each(table.rows, function (r) {
                    newCells.push(r.insertCell(table.col + (after ? 1 : 0)));
                });

                newCells[0].innerHTML = 'New tab';
                newCells[1].innerHTML = 'New content';

                newCells[0].scrollIntoView();

                ed.selection.select(newCells[0], true);
            },

            // Shift a column left or right
            shiftTab: function (right) {
                var ed = this.ed;
                var table = this.findTableInfo();

                tinymce.each(table.rows, function (r) {
                    var pos = table.col + (right ? 2 : -1);

                    if (pos === -1 || pos > r.cells.length) {
                        return;
                    }

                    var oldCell = r.cells[table.col];
                    var newCell = r.insertCell(pos);

                    newCell.innerHTML = oldCell.innerHTML;

                    r.deleteCell(oldCell.cellIndex);

                    newCell.scrollIntoView();

                    if (r.rowIndex === 0) {
                        ed.selection.select(newCell, true);
                    }
                });
            },

            // Delete a table column representing a tab
            deleteTab: function () {
                var table = this.findTableInfo();

                tinymce.each(table.rows, function (r) {
                    r.deleteCell(table.col);
                });
            },

            /**
             *
             * @param {tinymce.dom.DOMUtils} dom
             * @param widget
             */
            convertToEditorVersion: function (dom, widget) {
                this._updatePlaceHolderAttrs(widget);
                var wrapper = this._createWrapper({
                    'data-dojo-props': domAttr.get(widget, 'data-dojo-props')
                });


                var paneNodes = dom.select('> *', widget);

                var table = dom.add(wrapper, 'table', {});
                var headersRow = table.insertRow(-1);
                var contentsRow = table.insertRow(-1);

                tinymce.each(paneNodes, function (paneNode) {
                    var children = paneNode.children;
                    var headerNode = null;
                    var contentNode = null;
                    var isContentPane = children.length < 2;

                    if (isContentPane) {
                        contentNode = children[0];
                        headerNode = dom.create('div', {
                            'innerHTML': contentNode.title
                        });
                    } else { // It's an assumedPane
                        headerNode = children[0];
                        contentNode = children[1];
                    }

                    var headerCell = headersRow.insertCell(-1);
                    var contentCell = contentsRow.insertCell(-1);

                    Manipulation.transferNodes(headerNode, headerCell);
                    Manipulation.transferNodes(contentNode, contentCell);

                    dom.setAttrib(contentCell, 'style', dom.getAttrib(contentNode, 'style'));
                }, this);
                dom.replace(wrapper, widget);
                return wrapper;
            },

            /**
             *
             * @see ConfigurableTransformer.prototype.convertToPreviewVersion
             */
            convertToPreviewVersion: function (dom, setDojoType, wrapper) {
                this._updatePlaceHolderAttrs(wrapper);
                var widget = this._createWidget({
                    'data-dojo-props': domAttr.get(wrapper, 'data-dojo-props')
                });

                var table = dom.select('> table', wrapper)[0];
                var rows = table && table.rows;

                if (!rows || rows.length < 1) {
                    return;
                }

                var headers = rows[0].cells;
                var contents = rows[1].cells;

                var newPanes = [];

                for (var i = 0, len = headers.length; i < len; i++) {
                    // Add a pane for each column
                    newPanes[i] = dom.add(widget, 'div', {});

                    // Keep whatever inline styles the header cell has
                    var headerStyle = {
                        style: dom.getAttrib(headers[i], 'style')
                    };
                    // Keep whatever inline styles the content cell has
                    var contentStyle = {
                        style: dom.getAttrib(contents[i], 'style')
                    };

                    // Add two DIVs inside the pane
                    dom.add(newPanes[i], 'div', headerStyle, headers[i].innerHTML);
                    dom.add(newPanes[i], 'div', contentStyle, contents[i].innerHTML);
                }

                var outerProps = propsToObject(
                    dom.getAttrib(widget, 'data-dojo-props')
                );

                dom.setStyles(widget, {
                    height: outerProps.height || '',
                    width: outerProps.width || ''
                });

                dom.replace(widget, wrapper);

                return widget;
            }
        });

    return TabularTransformer;
});

},
'vodori/tinymce/ConfigurableTransformer':function(){
define([
    'module', 'vodori/provide', 'require',
    'lodash',
    'dojo/_base/lang',
    'dojo/dom-attr',
    'vodori/amd/tinymce',
    './util/getPluginName', './util/getResourceUrl', 'vodori/util/objectToProps', 'vodori/util/propsToObject',
    'vodori/util/node/getParents'
], function (
    module, provide, require,
    _,
    lang,
    domAttr,
    tinymce,
    getPluginName, getResourceUrl, objectToProps, propsToObject,
    getParents
    ) {
    var pluginName = getPluginName(module);

    var CONFIGURABLE_TRANSFORMER_CSS_CLASS = 'ConfigurableTransformer';

    //noinspection JSUnusedLocalSymbols,MagicNumberJS
    var ConfigurableTransformer = provide(module.id, null, {
        /** Overwrite this with the .prototype.declaredClass of the dijit
         * you'll be inserting.
         *
         * @type {string}
         */
        dijitDeclaredClass: '',

        /** Set in init. Will be this.dijitDeclaredClass.replace(/\./g, '_')
         * @type {string}
         */
        dijitDeclaredClassCSS: '',

        /**
         * @type {Object.<*>}
         */
        defaultAttrs: { // Don't set the data-dojo-type
            width: '',
            height: '',
            checkedBox: true,
            radioButton: 'this',
            selectOption: 'two'
        },

        /** Override this with attributes that you wish to have passed to your placeholder elements
         * @type {Object.<*>}
         */
        placeHolderAttrs: {},

        /**
         * @type {tinymce.Editor}
         */
        editor: null, // Set this in init

        /** Overwrite this with `getResourceUrl(module)`. Still working out a
         * way to make that inherited.
         *
         * @type {String}
         */
        url: getResourceUrl(module),

        /** Set in this.init
         * @type {String}
         */
        pluginName: pluginName,

        /** Used to fill the object for the tinymce.ui.Button constructor
         *
         * @type {Object.<*>}
         */
        button: {
            label: 'Transformer',
            image: false,
            title: 'Insert a configurable transformer',

            // Change some buttons' states when the cursor is in a widget
            changeStates: {
                highlight: [pluginName],
                enable: [],
                disable: []
            }
        },

        /**
         * @type {Array.<string>}
         */
        disallowedAncestors: null, /* For example: [ 'p', 'br', '#bar .foo' ]*/

        /**popup window width
         *
         * @type {number}
         */
        popupWidth: 390,

        /**popup window height
         *
         * @type {number}
         */
        popupHeight: 510,

        /**Open the popup when creating the widget
         *
         * @type {boolean}
         */
        popupOnCreate: false,

        /** tagName of the wrapper element used to contain the dijit._Widget
         *
         * @type {String}
         */
        wrapperTagName: 'div',

        /** tagName of the element that holds the place of your widget in the editor.
         *  Defaults to wrapperTagName
         *
         *  @type {String}
         */
        placeHolderWrapperTagName: undefined,


        /** If nothing is selected, "{{selection}}" in the template will be this
         *
         * @type {String}
         */
        loremIpsum: 'Lorem ipsum dolor sit amet...',

        /**
         * If you extend this and have some styling, set this to true and put the styling in
         * <plugin>/css/<plugin>.css
         * @type {Boolean}
         */
        styleSheet: true,

        /**
         * ConfigurableTransformers can use templates for defining Wrappers. However, some
         * are just generated programattically.
         * These fields allow you to configure this
         * Indicate whether a template should be used
         * @type {Boolean}
         */
        useTemplate: false,
        /**
         * Template text (once it has been retrieved)
         * @type {String}
         */
        template: '',

        /**
         * @constructs
         * @name init
         * @param {tinymce.Editor} ed
         * @return {void}
         */
        init: function (ed) {
            // Store reference to the editor
            this.editor = ed;

            if (this.useTemplate) {
                var template = this.url + '/template/' + this.pluginName + '.htm';
                require(['dojo/text!' + template], lang.hitch(this, function (template) {
                    this.template = template;
                }));
            }

            this.placeHolderWrapperTagName = this.placeHolderWrapperTagName || this.wrapperTagName;

            this.dijitDeclaredClassCSS = this.dijitDeclaredClass.replace(/\./g, '_');

            // Check the editor config for a defaults mixin
            var configDefaultAttrs = ed.getParam(this.pluginName + '_defaultAttrs', {});

            _.forOwn(configDefaultAttrs, function (attr) {
                if (configDefaultAttrs.hasOwnProperty(attr)) {
                    this.defaultAttrs[attr] = configDefaultAttrs[attr];
                }
            }, this);

            // Add a command and button to the editor
            ed.addCommand('mce_' + this.pluginName, this.insertOrPopup, this);
            if (this.button) {
                this.addButton();
            }

            // Highlight/enable/disable the appropriate buttons
            //noinspection JSUnresolvedVariable
            ed.onNodeChange.add(this.setButtonStates, this);
            if (typeof this.handleNodeChange !== 'undefined') {
                //noinspection JSUnresolvedVariable
                ed.onNodeChange.add(this.handleNodeChange, this);
            }

            //noinspection JSUnresolvedVariable
            /*
             * Whenever the content of the editor is set, we convert the widgets to wrappers
             */
            if (this.dijitDeclaredClass !== '') {
                ed.onSetContent.add(lang.hitch(this, function (ed) {
                    //noinspection JSPotentiallyInvalidUsageOfThis
                    this.convertToWrappers(ed, ed.getBody());
                }));
            }


            /*
             * After the content of the editor is serialized (during a get), we convert the content
             * into widgets (from wrappers)
             */
            ed.onGetContent.add(function (ed, args) {
                var holder = ed.dom.create('div', {}, args.content);
                this.convertToWidgets(ed, holder, true);
                args.content = holder.innerHTML;
            }, this);

            // Add a style sheet, maybe
            var handle = ed.onInit.add(function () {
                this.loadStyleSheet();
                ed.onActivate.remove(handle);
            }, this);

            this._updatePlaceHolderAttrs();
        },

        /**
         * @return {void}
         */
        insertOrPopup: function () {
            var ed = this.editor;
            var selectedNode = ed.selection.getNode();
            var wrapper = this.getWrapperOf(selectedNode);
            var initial = false;

            // If there's currently no wrapper, then it's a new insert
            if (!wrapper) {
                wrapper = this.insertNew();
                initial = true;
            }

            // If we're supposed to launch the popup on creation
            if (this.popupOnCreate) {
                // If this is the initial creation we need to keep track
                //  so that we can delete content if they cancel
                this.popupOptionsFor(wrapper, initial);
            }
        },

        /**
         * @param {Object} attrs a set of attributes to apply to the created wrapper
         * @param {Boolean} [useTemplate] create the wrapper using the template
         * @return {Element} the created wrapper
         * @protected
         */
        _createWrapper: function (attrs, useTemplate) {
            var ed = this.editor;
            attrs = attrs || {};

            var selectedContent = ed.selection.getContent();

            var replacedTemplate = '';
            if (useTemplate) {
                // Place the selection in the content
                replacedTemplate = this.template.replace(
                    /\{\$selection\}/g,
                    selectedContent || this.loremIpsum
                );
            }


            /*
             * Need to support additional HTML class definitions from Objects that
             * are ConfigurableTransformers
             */
            var wrapperClasses = [this.dijitDeclaredClassCSS, CONFIGURABLE_TRANSFORMER_CSS_CLASS];
            if (typeof this.placeHolderAttrs['class'] !== 'undefined') {
                wrapperClasses = wrapperClasses.concat(this.placeHolderAttrs['class'].split(/\s+/));
            }

            return ed.dom.create(this.placeHolderWrapperTagName, lang.mixin({}, this.placeHolderAttrs, {
                'class': _.unique(wrapperClasses).join(' '),
                'data-dojo-props': objectToProps(this.defaultAttrs)
            }, attrs), replacedTemplate);
        },

        /**
         * @param {Object} attrs  a set of attributes to apply to the created wrapper
         * @param {Boolean} [setDojoType] whether or not to set the data-dojo-type attribute
         * @return {Element} the created Dijit widget
         * @private
         */
        _createWidget: function (attrs, setDojoType) {
            var ed = this.editor;
            var dom = ed.dom;
            attrs = attrs || {};

            return dom.create(this.wrapperTagName, lang.mixin({}, {
                'data-dojo-type': setDojoType === false ? '' : this.dijitDeclaredClass
            }, attrs));
        },

        /**
         * @return {void}
         */
        insertNew: function () {
            var ed = this.editor;

            var wrapper = this._createWrapper({}, true);

            var currentNode = ed.selection.getNode();

            if (this.placeHolderWrapperTagName === 'span') {
                // Inline elements get replaced
                ed.selection.setNode(wrapper);
                wrapper = ed.selection.getEnd();
            } else if (currentNode === ed.getBody()) {
                // If the body is the selected node, block wrappers get appended
                ed.dom.add(currentNode, wrapper);
            } else {
                // Otherwise block wrappers get inserted after
                ed.dom.insertAfter(wrapper, this.getValidInsertionPoint(currentNode));
            }

            // Select the first text node
            ed.selection.select(wrapper, true);
            ed.selection.collapse(true);

            // Force a redraw
            ed.addVisual();

            this.postInsertNew(wrapper);

            return wrapper;
        },

        /**
         * @param {HTMLElement} node The node where insert action was taken.
         * @return {HTMLElement} the node within or after which this stamp can go.
         */
        getValidInsertionPoint: function (node) {
            // If there are no rules, then node must be valid.
            var disallowed = this.disallowedAncestors;
            if (!disallowed) {
                return node;
            }

            // We need all ancestors that are either the body or inside of it.
            var parents = getParents(node);

            // The selected node might also, be valid.
            parents.unshift(node);

            var validSibling = null;
            // Look for the last invalid node, so we can place after it.
            _.forEach(parents, function (ancestor) {
                var isInvalid = _.some(this.disallowedAncestors, function (selector) {
                    return tinymce.DOM.is(ancestor, selector);
                });

                // We wan't the last invalid ancestor to be our sibling.
                if (isInvalid) {
                    validSibling = ancestor;
                }
            }, this);

            if (!validSibling) {
                return node;
            }

            return validSibling;
        },

        /**
         * Called after this.insertNew
         *
         * @param {Element} wrapper
         * @return {*}
         */
        postInsertNew: function (wrapper) {
        },

        /**
         * @param {Element} wrapper
         * @param {boolean} isInitial
         * @return {void}
         */
        popupOptionsFor: function (wrapper, isInitial) {
            var ed = this.editor;

            ed.windowManager.open({
                file: this.url + '/' + this.pluginName + '.htm',
                width: this.popupWidth + ed.getLang('iframe.delta_width', 0),
                height: this.popupHeight + ed.getLang('iframe.delta_height', 0),
                inline: true
            }, {
                plugin: this,
                wrapper: wrapper,
                attrs: propsToObject(domAttr.get(wrapper, 'data-dojo-props')),
                isInitial: isInitial
            });
        },

        _populateInput: function (input, ed, attr, attrs, form) {
            var inputName = (!!input.length) ? input[0].nodeName.toLowerCase()
                : input.nodeName.toLowerCase();

            if (!!input.length && inputName === 'input') {
                // It's a radio button group
                input = ed.dom.select('[name=' + attr + '][value=' + attrs[attr] + ']', form)[0];
                if (input) {
                    input.checked = true;
                }
            } else if (inputName === 'input' || inputName === 'textarea') {
                if (input.type === 'checkbox') {
                    // It's a checkbox
                    input.checked = attrs[attr].toString().match(/true/i);
                } else {
                    // It's a text or password input or a textarea
                    input.value = attrs[attr];
                }
            } else if (inputName === 'select' || inputName === 'option') {
                // It's a select menu or list
                input.selectedIndex = ed.dom.select('option[value=' + attrs[attr] + ']', input)[0].index;
            }

            return input;
        },

        /**
         * Fill in a popup form with attributes' values
         *
         * @param form
         * @param attrs
         * @return {void}
         */
        populateForm: function (form, attrs) {
            var ed = this.editor;

            for (var attr in attrs) {
                if (attrs.hasOwnProperty(attr)) {

                    var input = form.elements[attr];

                    if (attr.indexOf('_') === 0) { // Allow private attributes.
                        continue;
                    }

                    if (!input) {
                        // An attribute in the list is not named in the form
                        console.error('Input ' + attr + ' not found in form.');
                        continue;
                    }


                    this._populateInput(input, ed, attr, attrs, form);
                }
            }
        },

        _getAttributesFromFormElement: function (formElement, attr, ed, form) {
            var elementType = formElement.type,
                attribute;
            if (elementType) {
                if (elementType === 'text' || elementType === 'textarea' || elementType === 'hidden') {
                    console.log(attr + ' is text.');
                    attribute = formElement.value;
                } else if (elementType === 'checkbox') {
                    console.log(attr + ' is a checkbox.');
                    attribute = formElement.checked;
                } else if (elementType.indexOf('select') === 0) {
                    console.log(attr + ' is a select.');
                    attribute = formElement[formElement.selectedIndex].value;
                }
            } else {
                // It's a radio button group
                console.log(attr + ' is a radio button group.');
                attribute = ed.dom.select('[name=' + attr + ']:checked', form)[0].value;
            }
            return attribute;
        },

        /**
         * Convert a popup form back to a widget's attributes and store them
         * in the wrapper's data-dojo-props.
         *
         * @param {Element} wrapper
         * @param {HTMLFormElement} form
         * @return {void}
         */
        updateWrapper: function (wrapper, form) {
            var ed = this.editor;

            var attrs = {};

            for (var attr in this.defaultAttrs) {
                if (this.defaultAttrs.hasOwnProperty(attr)) {
                    if (attr.indexOf('_') === 0) { // Let private attrs go by.
                        continue;
                    }
                    var formElement = form.elements[attr];

                    attrs[attr] = this._getAttributesFromFormElement(formElement, attr, ed, form);
                }
            }

            attrs = this.filterAttrs(attrs);

            domAttr.set(wrapper, 'data-dojo-props', objectToProps(attrs));

            this.postUpdateWrapper(wrapper);
        },

        /**
         * Called after attrs have come back from the user form, but before they are applied
         * to the wrapper
         *
         * @param attrs
         * @return {*}
         */
        filterAttrs: function (attrs) {
            return attrs;
        },

        /**
         * Called after this.updateWrapper
         *
         * @param {Element} wrapper
         * @return {*}
         */
        postUpdateWrapper: function (wrapper) {
            this._updatePlaceHolderAttrs(wrapper);
        },

        /**
         * @return {void}
         */
        addButton: function () {
            var button = this.button;

            this.editor.addButton(this.pluginName, {
                cmd: 'mce_' + this.pluginName || '',
                image: button.image ? this.url + '/' + button.image : '',
                label: button.label || '',
                title: button.title || ''
            });
        },

        /**
         * @param {Element} node
         * @return {Element}
         */
        getWrapperOf: function (node) {
            var ed = this.editor,
                dom = ed.dom,
                declaredCSS = this.dijitDeclaredClassCSS;

            if (ed.getParam('allow_nested_' + this.pluginName, false)) {
                return dom.hasClass(node, declaredCSS) && node;
            } else {
                return dom.getParent(node, function (p) {
                    return dom.hasClass(p, declaredCSS);
                });
            }
        },

        /**
         * @param {tinymce.Editor} ed
         * @param {tinymce.ControlManager} cm
         * @param {Element} n
         * @return {void}
         */
        setButtonStates: function (ed, cm, n) {
            var inWidget = !!this.getWrapperOf(n);

            var states = this.button.changeStates;

            tinymce.each(states.highlight, function (button) {
                cm.setActive(button, inWidget);
            });

            tinymce.each(states.enable, function (button) {
                cm.setDisabled(button, !inWidget);
            });

            tinymce.each(states.disable, function (button) {
                cm.setDisabled(button, inWidget);
                cm.setActive(button, false);
            });
        },

        /**
         * @return {void}
         */
        loadStyleSheet: function () {
            var ed = this.editor;

            if (this.styleSheet === true) {
                ed.dom.loadCSS(this.url + '/css/' + this.pluginName + '.css');
            } else if (typeof this.styleSheet === 'string') {
                ed.dom.loadCSS(this.styleSheet);
            }
        },

        /**
         * This function is to be implemented by extenders of ConfigurableTransformer.
         * When called, it should update any attributes that should be applied to the wrapper placeholder
         *
         * @param {Node} wrapperNode
         * @private
         */
        _updatePlaceHolderAttrs: function (wrapperNode) {
        },

        /**
         * Hide the widget's identity from the parser
         *
         * @param {tinymce.Editor} ed
         * @param {Element} node The DOM node to look into for widgets
         * @return {Array.<Element>}
         */
        convertToWrappers: function (ed, node) {
            var dom = ed.dom;

            var widgets = dom.select(
                '[data-dojo-type="' + this.dijitDeclaredClass + '"]',
                node
            ).reverse(); // reverse, so we work inside out.

            return _.map(widgets, lang.hitch(this, 'convertToEditorVersion', dom));
        },

        /**
         * @param {tinymce.dom.DOMUtils} dom TinyMCE DOM Utils
         * @param {Element} widget Widget node to convert to Wrapper node
         * @return {Element} a Wysiwyg wrapped node
         */
        convertToEditorVersion: function (dom, widget) {
            this._updatePlaceHolderAttrs(widget);
            var wrapper = this._createWrapper({
                'data-dojo-props': domAttr.get(widget, 'data-dojo-props')
            });

            dom.replace(wrapper, widget, true);

            return wrapper;
        },

        /**
         * Show the widgets identity.
         *
         * @param {tinymce.Editor} ed TinyMCE Editor
         * @param {Element} node The DOM node to look into for widgets
         * @param {Boolean} [setDojoType]
         * @return {Array.<Element>}
         */
        convertToWidgets: function (ed, node, setDojoType) {
            var dom = ed.dom;

            // The `'_'` prevents a query for `.`, which'll throw an error.
            var wrappers = dom.select('.' + (this.dijitDeclaredClassCSS || '_'), node);

            return _.map(wrappers, lang.hitch(this, 'convertToPreviewVersion', dom, setDojoType));
        },

        /**
         * @param {tinymce.dom.DOMUtils} dom TinyMCE DOM Utils
         * @param {Boolean} setDojoType
         * @param {Node} wrapper A Wysiwyg wrapper node
         * @return {Node} A Widget Node
         */
        convertToPreviewVersion: function (dom, setDojoType, wrapper) {
            var widget = this._createWidget({
                'data-dojo-props': domAttr.get(wrapper, 'data-dojo-props')
            }, setDojoType);

            dom.replace(widget, wrapper, true);

            return widget;
        }
    });

    tinymce.PluginManager.add(pluginName, ConfigurableTransformer);

    return ConfigurableTransformer;
});

},
'vodori/util/objectToProps':function(){
define([
    'vodori/provide', 'module',
    'dojo/json'
], function (provide, module, JSON) {
    'use strict';
    /**
     * Standardized way to convert an object of any kind into a data-dojo-props compatible value.
     *
     * @param {(Object|Array)} object
     * @return {string}
     */
    return provide(module.id, function (object) {
        // Encode as JSON, then trim off the outer portions.
        return JSON.stringify(object).replace(/^(\{|\[)|(\}|\])$/g, '');
    });
});

},
'vodori/tinymce/Background':function(){
/**
 * A plugin to allow users to edit background styles of the content block they're editing.
 * It works by having 2 basic modes
 *
 * 1. When editing using TinyMCE, any selected style is applied to TinyMCE's <body> tag
 *
 * 2. When flipping into actual content to be saved or previewed, it will take the iframe body style and put it as
 * the style attribute of a <div> that surrounds all of the content.  Note that this <div> will be tagged with a class
 * to identify it later.
 *
 */
define([
    '../amd/tinymce',
    'vodori/provide',
    'module',
    'vodori/tinymce/util/getResourceUrl',
    'vodori/tinymce/util/getPluginName'
], function (tinymce, provide, module, getResourceUrl, getPluginName) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, null, {

        // Use this class to identify <div>s that have been put into the markup by this plugin
        _identiferClass: "backgroundContainer",

        init: function (ed, url) {
            var t = this;

            t.editor = ed;

            // Define a pop-up to handle all of the configuration
            ed.addCommand('mceBackgroundStyle', function () {
                ed.windowManager.open({
                    file: getResourceUrl(module) + '/props.htm',
                    width: 480 + parseInt(ed.getLang('style.delta_width', 0), 10),
                    height: 320 + parseInt(ed.getLang('style.delta_height', 0), 10),
                    inline: 1
                }, {
                    /* jshint -W106 */
                    plugin_url: url,
                    style_text: ed.getBody().style.cssText
                    /* jshint +W106 */
                });
            });

            // Register buttons
            ed.addButton('background', {title: 'Background Image', cmd: 'mceBackgroundStyle'});


            /**
             * On saving, this will take any user-created styling and turn it into a <div> that surrounds
             * the entire piece of content and has the same styles.
             */
            ed.onPostProcess.add(function (ed, o) {

                if (o.get) {

                    var style = ed.getBody().style.cssText;
                    if (style && style.length > 2) {

                        var className = t._identiferClass;
                        o.content = "<div class='" + className + "' style='" + style + "'>" + o.content + "</div>";
                        console.log("Just added a background to an editor");
                    }
                }
            });


            ed.onSetContent.add(function (ed, o) {

                if (o.set) {

                    var outerDiv = ed.dom.select("div." + t._identiferClass, ed.getBody());
                    if (outerDiv.length > 1) {
                        throw new Error(
                            {
                                message: "Found 2 divs with a class of " + t._identiferClass +
                                         "This is unsupported with the Background plugin"
                            }
                        );
                    } else if (outerDiv.length === 1) {

                        // Grab this temp outer <div> that contains our inline style
                        outerDiv = outerDiv[0];

                        // Move the style from it to the TinyMCE iframe body
                        ed.getBody().style.cssText = outerDiv.style.cssText;

                        // Note that this remove method will replace the parent element with it's children
                        // (that's what the 2nd boolean is for)
                        ed.dom.remove(outerDiv, true);

                    }

                }
            });

        }

    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'vodori/tinymce/ButtonGroupLabeler':function(){
/**
 * @purpose Create a label for any button listed in an editor's
 * `settings.labels` string. Please note, this doesn't hide or remove any
 * leavings, since CSS seems more appropriate for that.
 *
 * @use To use, add the buttons you want converted into labels to the labels
 * attribute of your tinymce config object. Then in your
 * theme_advanced_buttons<n> prefix the buttons to group with the label name
 * and postfix a separator (i.e. "|"). See the test page for an example.
 *
 *
 * @return {tinymce.create.p}
 */
define([
    '../util/string/startsWith',
    'vodori/amd/tinymce',
    'module',
    'vodori/provide',
    'vodori/tinymce/util/getPluginName'
], function (startsWith, tinymce, module, provide, getPluginName) {

    var plugin = provide(module.id, null, {

        /**
         * @type {Array.<string>}
         */
        labelKeys: [],

        /**
         * @type {Object.<Object.<string>>}
         */
        labelGroups: {},

        /**
         *  @type {tinymce.create.Editor}
         */
        editor: {},

        /**
         * @type {Array.<string>}
         */
        buttonSettingKeys: [],

        /**
         * @type {Array.<Object.<string>}
         */
        labelAndLastPairs: [],

        /**
         * @return {void}
         */
        noop: function () {
            return;
        },

        /**
         * @type {Element}
         */
        toolbarNode: {},

        /**
         * @param {tinymce.create.Editor} ed
         * @return {void}
         */
        init: function (ed) {
            this.editor = ed;

            this.labelGroups = ed.getParam('label_groups');
            this.toolbarNode = document.getElementById(ed.getParam('fixed_toolbar_node'));
            this.labelKeys = this.getLabelKeys(this.labelGroups);
            this.buttonSettingKeys = this.getButtonSettingKeys();
            this.labelAndLastPairs = this.getLabelAndLastPairs();

            tinymce.each(this.labelKeys, function (labelKey) {
                return this.makeLabel(labelKey);
            }, this);

            // Differentiate these from real buttons
            ed.onPreInit.add(function (ed) {

                tinymce.each(this.labelKeys, function (labelKey) {
                    var labelElements = tinymce.DOM.select('a.mce_' + labelKey,
                        ed.editorContainer);

                    tinymce.each(labelElements, function (element) {
                        var icons = [];

                        ed.dom.addClass(element, 'vodori-mce-label');
                        icons = ed.dom.select('.mceIcon', element);
                        // Labels don't need to be clickable.
                        ed.controlManager.setDisabled(labelKey, true);

                    }, this);
                }, this);

            }, this);

            ed.onInit.add(this.groupButtons, this);
        },

        /**
         * @return {Array.<Object.<string>>}
         */
        getLabelAndLastPairs: function () {
            var keys = this.getButtonSettingKeys(),
                settings = this.editor.settings,
                pairs = [];

            tinymce.each(keys, function (key) {
                // Removing whitespace makes this a lot easier.
                var setting = settings[key].replace(/\s/g, '');

                tinymce.each(this.labelKeys, function (labelKey) {
                    // Ensure it's this and only this string.
                    var labIndex = setting.indexOf(labelKey + ',('),
                        subStr = setting.slice(labIndex);

                    if (labIndex > -1) {
                        pairs.push({
                            name: labelKey,
                            last: subStr.split(')')[0].split(',').slice(-2, -1)[0].trim()
                        });
                    }

                }, this);

            }, this);

            return pairs;
        },

        /**
         * Scans the settings object and finds all button holding keys that are
         * used. (Must be dynamic to support advanced containers.)
         *
         * @return {Array.<string>}
         */
        getButtonSettingKeys: function () {
            var keys = [],
                settings = this.editor.settings,
                key = '';

            for (key in settings) {
                if (startsWith(key, 'theme_advanced_buttons') ||
                    startsWith(key, 'theme_advanced_container')) {
                    keys.push(key);
                }
            }

            return keys;
        },

        /**
         * @param {tinymce.create.Editor} ed
         * @return {void}
         */
        groupButtons: function (ed) {
            // Must use tinymce.DOM, so we have the expanded scope?
            var dom = tinymce.DOM,
                toolbars = dom.select('table.mceToolbar:not(.grouped)',
                    this.toolbarNode);

            tinymce.each(toolbars, function (toolbar) {
                var labelElements = dom.select('.vodori-mce-label', toolbar),
                    currentCell = {},
                    last = '',
                    labelKey = '',
                    groupCount = 0,
                    i = 0,
                    len = labelElements.length,
                    newRow = dom.create('tr', {'class': 'labelRow'});

                dom.addClass(toolbar.firstChild.firstChild, 'buttonRow');
                toolbar.firstChild.insertBefore(newRow, toolbar.firstChild.firstChild);

                for (; i < len; i++) {
                    // We want to work with the containing td.
                    currentCell = labelElements[i].parentNode;

                    labelKey = this.getLabelKeyByElement(labelElements[i]);
                    last = this.getLastByLabelKey(labelKey);

                    // Stop counting when we get to last grouped cell.
                    /* jshint -W083 */
                    groupCount = this.countNextSiblingsWhile(currentCell, function (element) {

                        if (!this.holdsToolName(element, last)) {

                            if (this.isSeparator(element.firstChild)) {
                                dom.addClass(element, 'separator');
                            } else if (element.nextSibling &&
                                this.isSeparator(element.nextSibling.firstChild)) {
                                dom.addClass(element, 'closingButton');
                            }

                            return true;

                        } else {

                            if (i !== (len - 1)) {
                                dom.insertAfter(dom.create('td', {
                                    colspan: '1',
                                    'class': 'lowerSpacer'
                                }), element);
                            }

                            dom.addClass(element, 'closingButton');

                            return false;
                        }

                    }, this);
                    /* jshint +W083 */

                    // Add an extra column to the first and last labels.
                    if (i === 0 || i === len) {
                        groupCount++;
                    }

                    dom.remove(currentCell);
                    newRow.appendChild(currentCell);
                    dom.setAttrib(currentCell, 'colspan', ++groupCount);

                    if (i !== (len - 1)) {
                        dom.insertAfter(dom.create('td', {
                            colspan: '1',
                            'class': 'spacer'
                        }), currentCell);
                    }
                }

                // So, we don't keep grouping the buttons.
                dom.addClass(toolbar, 'grouped');
            }, this);
        },

        /**
         * @param {Element} elem
         * @param {string} toolName
         * @return {boolean}
         */
        holdsToolName: function (elem, toolName) {
            return !!tinymce.DOM.select('.mce_' + toolName, elem).length;
        },

        /**
         * @param {Element} element
         * @param {Function} filter
         * @param {T} context
         * @return {number}
         */
        countNextSiblingsWhile: function (element, filter, context) {
            var count = 0,
                current = element.nextSibling;

            while (current) {
                if (!filter.call(context, current)) {
                    break;
                }
                current = current.nextSibling;
                count++;
            }

            return count;
        },

        /** Replace a label with the lower-cased output version. Allows us to
         * use unique names for buttonGroupLabels
         *
         * @param {element} elem
         * @return {string}
         */
        getLabelKeyByElement: function (elem) {
            var label = elem.getAttribute('title').toLowerCase(),
                key = '',
                groups = this.labelGroups;

            for (key in groups) {
                if (groups.hasOwnProperty(key) &&
                    groups[key].label.toLowerCase() === label) {

                    return key;
                }
            }

            return label;
        },

        /**
         * @param {string} label
         * @return {string}
         */
        getLastByLabelKey: function (labelKey) {
            var pairs = this.labelAndLastPairs,
                limit = pairs.length;

            while (limit--) {
                if (pairs[limit].name === labelKey) {
                    return pairs[limit].last;
                }
            }

            return -1;
        },

        /**
         * Add a decorative button to tinymce's toolbar.
         * @param {string} labelKey
         * @return {void}
         */
        makeLabel: function (labelKey) {
            var label = this.labelGroups[labelKey].label;

            this.editor.addButton(labelKey, {
                label: label,
                image: false,
                title: label,
                onclick: this.noop,
                scope: this
            });
        },

        /**
         * @param {Object} labelGroups
         * @return {Array.<string>}
         */
        getLabelKeys: function (labelGroups) {
            var labelKeys = [],
                prop = '';

            for (prop in labelGroups) {
                if (labelGroups.hasOwnProperty(prop)) {
                    labelKeys.push(prop);
                }
            }

            return labelKeys;
        },

        /**
         * @param {Element} elem
         * @return {boolean}
         */
        isSeparator: function (elem) {
            return tinymce.DOM.hasClass(elem, 'mceSeparator');
        }
    });

    tinymce.PluginManager.add(getPluginName(module), plugin);

    return plugin;
});




},
'vodori/tinymce/CleanBookmarks':function(){
define([
    'module', './util/providePlugin',
    'lodash', 'vodori/amd/tinymce',
    'dojo/_base/lang',
    'vodori/util/function/flip'
], function (
    module, providePlugin,
    _, tinymce,
    lang,
    flip
) {
    'use strict';

    /**
     * Cleans up bookmarks accidentally left over from previous tinymce sessions.
     */
    return providePlugin(module, {

        BOOKMARK_SELECTOR: '[data-mce-type="bookmark"]',

        _editor: null,

        init: function (ed) {
            this._editor = ed;
            ed.onLoad.add(this._removeBookmarks, this);
        },

        _removeBookmarks: function () {
            var dom = tinymce.DOM;

            _.forEach(dom.select(this.BOOKMARK_SELECTOR, this._editor.getBody()).reverse(), function (node) {
                var children = node.children;
                var hasChildren = children.length;
                var text = lang.trim(node.innerText);
                var replacement = null;

                // Unwrap the children.
                if (hasChildren) {
                    //noinspection JSCheckFunctionSignatures
                    _.forEach(children, lang.hitch(dom, flip(dom.insertAfter), node));
                    dom.remove(node);
                }
                // Swap the node for its text.
                else if (text !== '') {
                    replacement = this._editor.getDoc().createTextNode(text);
                    //noinspection JSCheckFunctionSignatures
                    dom.replace(replacement, node, false);
                }
                else {
                    dom.remove(node);
                }
            }, this);
        }
    });
});


},
'vodori/tinymce/util/providePlugin':function(){
define([
    'vodori/provide',
    'lodash',
    'vodori/amd/tinymce',
    './getPluginName',
    'vodori/tinymce/_GetInfoMixin'
], function (
    provide,
    _,
    tinymce,
    getPluginName,
    _GetInfoMixin
) {
    /**
     * Like vodori/provide but handles additionaly boilerplate needed by tinymce plugins.
     *
     * @param {id: string} module The module object. Used to register the plugin w/ tinymce.
     * @param {Array.<function>} [lineage] Additional mixins (includes _GetInfoMixin automatically).
     * @param {Object} declaration The plugin's prototype. Unlike vodori/provide this is not optional
     * @return {Object} A tinymce plugin ready to be instantiated.
     */
    return function (module, lineage, declaration) {
        if (_.size(arguments) === 2) {
            declaration = lineage;
            lineage = [_GetInfoMixin];
        } else {
            lineage.push(_GetInfoMixin);
        }

        var pluginName = declaration.pluginName = getPluginName(module);

        var Plugin = provide(module, lineage, declaration);

        tinymce.PluginManager.add(pluginName, Plugin);

        return Plugin;
    };
});

},
'vodori/util/function/flip':function(){
define(['lodash'], function (_) {
    /**
     * Takes a function ((a, b) -> c) and converts to ((b, a) -> c). Additionally, it's possible to
     * swap args at arbitrary indices.
     *
     * The length of your arguments is unchecked, so (a -> c) -> ((undefined, a) -> c)
     *
     * @param {Function} fn The function that'll have its args flipped.
     * @param {number} [context] Defaults to dynamic context if undefined or null.
     * @param {number} [left=0] Index of the arg to flip rightward.
     * @param {number} [right=1] Index of the arg to flip leftward.
     */
    return function (fn, context, left, right) {
        left = _.isUndefined(left) ? 0 : left;
        right = _.isUndefined(right) ? 1 : right;

        return function () {
            // toArray lets us move things to arbitrary indices w/o caring is the original arguments
            // was laid out the same.
            var args = _.toArray(arguments),
                first = args[left];
            args[left] = args[right];
            args[right] = first;
            return fn.apply(context || this, args);
        };
    };
});
},
'vodori/tinymce/CodeMirror':function(){
define([
    'dojo/_base/declare', 'dojo/_base/lang',
    'dojo/on',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    '../amd/tinymce', '../amd/js-beautify',
    'vodori/provide', 'module',
    '../layout/_Composable',
    './util/getResourceUrl', './util/getPluginName',
    'pepper/ui/ComposingDialog',
    'dojo/text!./codemirror/templates/CodeEditorDialog.html',

    '../input/CodeEditor'
], function (
    declare, lang,
    on,
    _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
    tinymce, jsBeautify,
    provide, module,
    _Composable,
    getResourceUrl, getPluginName,
    ComposingDialog,
    CodeEditorDialogTemplate) {

    var TinyMCEHTMLEditor = declare([_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, _Composable], {

        title: 'HTML Editor',

        templateString: CodeEditorDialogTemplate,

        postCreate: function() {
            this.inherited(arguments);

            this.onClick(this.cancel, function() {
                this.closeContainer();
            });

            this.onClick(this.insert, function () {
                var value =  this.codeEditor.get('value');
                this.tinyMCEEditor.setContent(value);

                this.closeContainer();
            });
        },


        startup: function() {
            this.inherited(arguments);
            this.fireCompose({
                props: {
                    title: this.title
                }
            });
        },

        onClick: function(node, handler) {
            this.own(on(node, 'click', lang.hitch(this, handler)));
        },


        closeContainer: function() {
            on.emit(this.domNode, 'compose', {
                methods: {
                    hide: true
                },
                bubbles: true,
                cancelable: true
            });
        }

    });

    var pluginName = getPluginName(module);

    var plugin = provide(module.id, null, {
        init: function (ed) {

            var resourcePath = getResourceUrl(module);

            ed.addCommand('mce' + pluginName, function () {
                var rawCode = ed.getContent();

                var dialog = new ComposingDialog({
                    destroyOnHide: true,
                    parseOnFirstShow: false,
                    widget: new TinyMCEHTMLEditor({
                        value: jsBeautify.html(rawCode),
                        tinyMCEEditor: ed
                    })
                });

                dialog.startup();

                dialog.show().then(lang.hitch(dialog.widget, function(){
                    // call refresh after show so that codemirror does a redraw
                    this.codeEditor.refresh();
                }));
            });

            // Register buttons
            ed.addButton(pluginName, {
                cmd: 'mce' + pluginName,
                title: 'HTML code',
                image: resourcePath + '/img/html.png'
            });
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});
},
'vodori/amd/js-beautify':function(){
/**
 * This is an AMD wrapper for js-beautify's three beautifier files, each of which declares a global function (yuck!).
 * The names of each function are also not standardized, and so are difficult to remember.
 * If you include js-beautifier in your AMD module/class, then you will get an object with three functions hanging
 * off of it, following a naming pattern. There is one function each for formatting CSS, HTML, and JS:
 *
 *      require(['vodori/amd/js-beautify'], function(jsBeautify) {
 *          var formattedCss  = jsBeautify.css(cssStrToFormat);
 *          var formattedHtml = jsBeautify.html(htmlStrToFormat);
 *          var formattedJs   = jsBeautify.js(jsStrToFormat);
 *      }
 *
 * The global function references are removed from the global scope.
 * Note this won't happen if this module is not included.
 *
 * Since the function signature for each of js-beautify's core HTML/CSS/JS modules remains the same, the second argument
 * can be an object with whatever options are supported by the module in question.  The return of each function is
 * a string of your input string with formatting characters inserted into it.
 */
define([
    'exports', 'dojo/_base/kernel'
], function(exports, kernel) {

    var exportOrError = function (globalName, exportName, fileName) {
        var globalModule = kernel.global[globalName];
        if (typeof globalModule !== 'function') {
            throw new Error('Global variable ' + globalName +  ' not found. ' +
                            'The original source for this should be ' + fileName + '.');
        }
        exports[exportName] = globalModule;
        delete kernel.global[globalName];
    };

    exportOrError('js_beautify', 'js', 'js-beautify/beautify.js');
    exportOrError('css_beautify', 'css', 'js-beautify/beautify-css.js');
    exportOrError('style_html', 'html', 'js-beautify/beautify-html.js');

});

},
'vodori/input/CodeEditor':function(){
define([
    'module', 'vodori/provide',
    'lodash', 'codemirror',
    'dojo/dom-construct', 'dojo/dom-class',
    'dojo/aspect',
    'dojo/_base/lang', 'dojo/topic',
    'dijit/_WidgetBase', 'dijit/form/Button',
    'vodori/input/_Activatable', 'vodori/input/_LazyInitializable',
    'vodori/util/node/descendsFrom', 'vodori/util/node/createFragmentedElement',

    'xstyle/css!codemirror/lib/codemirror.css',
    'xstyle/css!codemirror/theme/eclipse.css',
    'xstyle/css!codemirror/addon/dialog/dialog.css',

    'codemirror/addon/search/search',
    'codemirror/addon/edit/closetag',
    'codemirror/addon/edit/matchtags',
    'codemirror/mode/htmlmixed/htmlmixed'
], function (module, provide,
             _, CodeMirror,
             domConstruct, domClass,
             aspect, lang, topic,
             _WidgetBase, Button,
             _Activatable, _LazyInitializable,
             descendsFrom, createFragmentedElement) {

    var CLASS_CONSTANTS = {
        INIT_EVENT: 'editor/codeeditor/init'
    };

    // Use with pepper.PropertyWrapper if you want it to store content
    // If you need to move its node, make sure you call topic.publish('editors/redraw', [newParentNode])
    // Instantiation can be delayed by setting property 'delayInitialization' to true

    // Usage: <textarea data-dojo-type="vodori/input/CodeEditor"
    //                  data-dojo-props="value: 'Content here'; delayInitialization: true"></textarea>

    // Note: Each CodeMirror module is sublicensed, so if you change the config for a new language, theme, etc. and the
    // do not load it dynamically, then you might need to update copyright.txt.
    return provide(module.id, [_WidgetBase, _Activatable, _LazyInitializable], {
        baseClass: 'CodeEditor',

        configuration: {
            theme: 'eclipse',
            mode: 'htmlmixed',
            width: '100%',
            lineNumbers: true,
            autoCloseTags: true,
            fixedGutter: false,
            matchTags: {bothTags: true},
            height: 500,
            extraKeys: {'Ctrl-J': 'toMatchingTag'}
        },

        persistsAcrossRefresh: false, // Normal form elements do this, but this thing probably shouldn't

        hasToolbars: false,

        toolbarHolder: null,

        value: '',

        constructor: function () {
            this.markClean();
        },

        postMixInProperties: function () {
            this.inherited(arguments);

            // Reset the <textarea> from scratch
            if (!this.persistsAcrossRefresh) {
                this.srcNodeRef.value = this.srcNodeRef.defaultValue;
            }

        },

        postCreate: function () {
            this.inherited(arguments);

            // Mix the defaults and the overrides into a new object
            this.configuration = lang.mixin(this.constructor.prototype.configuration, this.configuration);
        },

        startup: function () {
            this.inherited(arguments);
            this.initializeEditorWhenReady();
            this.subscribe('editors/redraw', 'redraw');
        },

        /**
         * @inheritDoc
         */
        initializeNow: function () {
            if (!this._isInitialized()) {
                this.initializeEditorNow();
            }
        },

        _isInitialized: function () {
            return domClass.contains(this.domNode, 'initialized');
        },

        // Associate an editor with the widget
        // If delayInitialization, instantiation can be delayed until initializeNow() is called
        initializeEditorWhenReady: function () {
            if (!this.delayInitialization) {
                this.initializeEditorNow();
            }
        },

        initializeEditorNow: function () {
            this.domNode.value = this.get('value');
            this.editor = CodeMirror.fromTextArea(this.domNode, _.clone(this.configuration));
            this.editor.on('change', lang.hitch(this, 'onEditorChange'));
            domClass.add(this.domNode, 'initialized');
            topic.publish(CLASS_CONSTANTS.INIT_EVENT, [this]);
        },

        // calls refresh on the editor to perform a redraw
        refresh: function () {
            if (this.editor) {
                this.editor.refresh();
            }
        },

        // Check to see if an ancestor has changed dramatically enough to warrant resetting the editor
        redraw: function (root) {
            if (descendsFrom(this.domNode, root)) {
                this.resetEditor();
            }
        },

        // If this widget moves, its editor will break and must be recreated
        resetEditor: function () {
            console.info('Resetting editor', this.editor);
            if (this.editor) {
                this.editor.toTextArea();
                this.editor = null;
                this.initializeEditorWhenReady();
            }
        },

        // This should fire when the editor's content changes
        onEditorChange: function () {
            this.markDirty();
        },

        uninitialize: function () {
            if(this.editor){
                this.editor.toTextArea();
            }
            this.inherited(arguments);
        },

        // Make sure the editor stays with its widget
        placeAt: function (destination, position) {
            this.inherited(arguments);
            if (this.editor) {
                domConstruct.place(this.editor.toTextArea(), this.domNode, 'after');
                this.initializeEditorWhenReady();
            }
        },

        generateToolbars: function (options) {
            this.holder = domConstruct.create('div');
            var tb = domConstruct.create('div');

            domConstruct.place(tb, this.holder, 'last');
            domConstruct.place(domConstruct.create('button', {id: 'indentButton'}), tb);
            domConstruct.place(domConstruct.create('button', {id: 'lineNumbersButton'}), tb);

            domConstruct.place(this.holder, options.container, 'last');

            /* jshint -W031 */
            new Button({
                label: '&#8677;',
                onClick: lang.hitch(this, function () {
                    this.reindent();
                })
            }, 'indentButton');
            new Button({
                label: '#',
                onClick: lang.hitch(this, function () {
                    this.toggleLineNumbers();
                })
            }, 'lineNumbersButton');
            /* jshint +W031 */

            this.own(aspect.after(this.getParent(), 'activate', lang.hitch(this, function () {
                options.onActivate(this, this.toolbarTabs);
            })));
            this.own(aspect.after(this.getParent(), 'deactivate', lang.hitch(this, function () {
                options.onDeactivate(this, this.toolbarTabs);
            })));

            this.toolbars = [tb];

            this.toolbarTabs = ['Code'];

            return this.toolbarTabs;
        },


        getToolbarHolder: function () {
            return this.holder;
        },

        getToolbars: function () {
            return this.toolbars;
        },

        toggleLineNumbers: function () {
            this.editor.setOption('lineNumbers', !this.editor.getOption('lineNumbers'));
        },

        reindent: function () {
            var limit = this.editor.lineCount(),
                i = 0;
            for (; i < limit; i++) {
                this.editor.indentLine(i);
            }
        },

        isDirty: function () {
            return this.dirty;
        },

        markDirty: function () {
            this.dirty = true;
        },

        markClean: function () {
            this.dirty = false;
        },

        _getValueAttr: function () {
            var editor = this._getCurrentEditor(),
                value = editor ? editor.getValue() : this.value;

            return this._stringifyHTML(value);
        },

        _setValueAttr: function (value, refreshEditor) {
            var cleanedValue = this._stringifyHTML(value);
            this.value = cleanedValue;
            this.domNode.value = cleanedValue;

            if (refreshEditor !== false) {
                if (this.editor) {
                    this.editor.setValue(cleanedValue);
                }
            }
        },

        _getCurrentEditor: function () {
            return this.editor;
        },

        _stringifyHTML: function (html) {
            var container = createFragmentedElement();

            if (lang.isString(html)) {
                container.innerHTML = html;
            } else {
                domConstruct.place(html, container);
            }

            var stringified = container.innerHTML;
            domConstruct.destroy(container);

            return stringified;
        }


    }, CLASS_CONSTANTS);
});

},
'codemirror/lib/codemirror':function(){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    module.exports = mod();
  else if (typeof define == "function" && define.amd) // AMD
    return define([], mod);
  else // Plain browser env
    this.CodeMirror = mod();
})(function() {
  "use strict";

  // BROWSER SNIFFING

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.

  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  // ie_uptoN means Internet Explorer version N or lower
  var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
  var ie_upto7 = ie_upto10 && (document.documentMode == null || document.documentMode < 8);
  var ie_upto8 = ie_upto10 && (document.documentMode == null || document.documentMode < 9);
  var ie_upto9 = ie_upto10 && (document.documentMode == null || document.documentMode < 10);
  var ie_11up = /Trident\/([7-9]|\d{2,})\./.test(navigator.userAgent);
  var ie = ie_upto10 || ie_11up;
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var presto = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var khtml = /KHTML\//.test(navigator.userAgent);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);

  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /win/i.test(navigator.platform);

  var presto_version = presto && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) presto_version = Number(presto_version[1]);
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && !ie_upto8);

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  // EDITOR CONSTRUCTOR

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

    this.options = options = options || {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);

    var doc = options.value;
    if (typeof doc == "string") doc = new Doc(doc, options.mode);
    this.doc = doc;

    var display = this.display = new Display(place, doc);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += " CodeMirror-wrap";
    if (options.autofocus && !mobile) focusInput(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false, focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in readInput
      draggingText: false,
      highlight: new Delayed() // stores highlight worker timeout
    };

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie_upto10) setTimeout(bind(resetInput, this, true), 20);

    registerEventHandlers(this);
    ensureGlobalHandlers();

    var cm = this;
    runInOp(this, function() {
      cm.curOp.forceUpdate = true;
      attachDoc(cm, doc);

      if ((options.autofocus && !mobile) || activeElt() == display.input)
        setTimeout(bind(onFocus, cm), 20);
      else
        onBlur(cm);

      for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))
        optionHandlers[opt](cm, options[opt], Init);
      for (var i = 0; i < initHooks.length; ++i) initHooks[i](cm);
    });
  }

  // DISPLAY CONSTRUCTOR

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc) {
    var d = this;

    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) input.style.width = "1000px";
    else input.setAttribute("wrap", "off");
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) input.style.border = "1px solid black";
    input.setAttribute("autocorrect", "off"); input.setAttribute("autocapitalize", "off"); input.setAttribute("spellcheck", "false");

    // Wraps and hides input textarea
    d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The fake scrollbar elements.
    d.scrollbarH = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    d.scrollbarV = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = elt("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerCutOff + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV,
                            d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie_upto7) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    // Needed to hide big blue blinking cursor on Mobile Safari
    if (ios) input.style.width = "0px";
    if (!webkit) d.scroller.draggable = true;
    // Needed to handle Tab key in KHTML
    if (khtml) { d.inputDiv.style.height = "1px"; d.inputDiv.style.position = "absolute"; }
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie_upto7) d.scrollbarH.style.minHeight = d.scrollbarV.style.minWidth = "18px";

    if (place.appendChild) place.appendChild(d.wrapper);
    else place(d.wrapper);

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastSizeC = 0;
    d.updateLineNumbers = null;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // See readInput and resetInput
    d.prevInput = "";
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;
    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    d.pollingFast = false;
    // Self-resetting timeout for the poller
    d.poll = new Delayed();

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks when resetInput has punted to just putting a short
    // string into the textarea instead of the full selection.
    d.inaccurateSelection = false;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;
  }

  // STATE UPDATES

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function(line) {
      if (line.stateAfter) line.stateAfter = null;
      if (line.styles) line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) regChange(cm);
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function(){updateScrollbars(cm);}, 100);
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line)) return 0;

      var widgetsHeight = 0;
      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
      }

      if (wrapping)
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return widgetsHeight + th;
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) updateLineHeight(line, estHeight);
    });
  }

  function keyMapChanged(cm) {
    var map = keyMap[cm.options.keyMap], style = map.style;
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, "") +
      (style ? " cm-keymap-" + style : "");
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function(){alignHorizontally(cm);}, 20);
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
    updateGutterSpace(cm);
  }

  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + "px";
    cm.display.scrollbarH.style.left = cm.options.fixedGutter ? width + "px" : 0;
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find(0, true);
      len -= cur.text.length - found.from.ch;
      cur = found.to.line;
      len += cur.text.length - found.to.ch;
    }
    return len;
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function(line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var scroll = cm.display.scroller;
    return {
      clientHeight: scroll.clientHeight,
      barHeight: cm.display.scrollbarV.clientHeight,
      scrollWidth: scroll.scrollWidth, clientWidth: scroll.clientWidth,
      barWidth: cm.display.scrollbarH.clientWidth,
      docHeight: Math.round(cm.doc.height + paddingVert(cm.display))
    };
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbars(cm, measure) {
    if (!measure) measure = measureForScrollbars(cm);
    var d = cm.display;
    var scrollHeight = measure.docHeight + scrollerCutOff;
    var needsH = measure.scrollWidth > measure.clientWidth;
    var needsV = scrollHeight > measure.clientHeight;
    if (needsV) {
      d.scrollbarV.style.display = "block";
      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + "px" : "0";
      // A bug in IE8 can cause this value to be negative, so guard it.
      d.scrollbarV.firstChild.style.height =
        Math.max(0, scrollHeight - measure.clientHeight + (measure.barHeight || d.scrollbarV.clientHeight)) + "px";
    } else {
      d.scrollbarV.style.display = "";
      d.scrollbarV.firstChild.style.height = "0";
    }
    if (needsH) {
      d.scrollbarH.style.display = "block";
      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + "px" : "0";
      d.scrollbarH.firstChild.style.width =
        (measure.scrollWidth - measure.clientWidth + (measure.barWidth || d.scrollbarH.clientWidth)) + "px";
    } else {
      d.scrollbarH.style.display = "";
      d.scrollbarH.firstChild.style.width = "0";
    }
    if (needsH && needsV) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + "px";
    } else d.scrollbarFiller.style.display = "";
    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = scrollbarWidth(d.measure) + "px";
      d.gutterFiller.style.width = d.gutters.offsetWidth + "px";
    } else d.gutterFiller.style.display = "";

    if (!cm.state.checkedOverlayScrollbar && measure.clientHeight > 0) {
      if (scrollbarWidth(d.measure) === 0) {
        var w = mac && !mac_geMountainLion ? "12px" : "18px";
        d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = w;
        var barMouseDown = function(e) {
          if (e_target(e) != d.scrollbarV && e_target(e) != d.scrollbarH)
            operation(cm, onMouseDown)(e);
        };
        on(d.scrollbarV, "mousedown", barMouseDown);
        on(d.scrollbarH, "mousedown", barMouseDown);
      }
      cm.state.checkedOverlayScrollbar = true;
    }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewPort may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewPort) {
    var top = viewPort && viewPort.top != null ? Math.max(0, viewPort.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewPort && viewPort.bottom != null ? viewPort.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewPort && viewPort.ensure) {
      var ensureFrom = viewPort.ensure.from.line, ensureTo = viewPort.ensure.to.line;
      if (ensureFrom < from)
        return {from: ensureFrom,
                to: lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)};
      if (Math.min(ensureTo, doc.lastLine()) >= to)
        return {from: lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight),
                to: ensureTo};
    }
    return {from: from, to: Math.max(to, from + 1)};
  }

  // LINE NUMBERS

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {
      if (cm.options.fixedGutter && view[i].gutter)
        view[i].gutter.style.left = left;
      var align = view[i].alignable;
      if (align) for (var j = 0; j < align.length; j++)
        align[j].style.left = left;
    }
    if (cm.options.fixedGutter)
      display.gutters.style.left = (comp + gutterW) + "px";
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm);
      return true;
    }
    return false;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }

  // DISPLAY DRAWING

  // Updates the display, selection, and scrollbars, using the
  // information in display.view to find out which nodes are no longer
  // up-to-date. Tries to bail out early when no changes are needed,
  // unless forced is true.
  // Returns true if an actual update happened, false otherwise.
  function updateDisplay(cm, viewPort, forced) {
    var oldFrom = cm.display.viewFrom, oldTo = cm.display.viewTo, updated;
    var visible = visibleLines(cm.display, cm.doc, viewPort);
    for (var first = true;; first = false) {
      var oldWidth = cm.display.scroller.clientWidth;
      if (!updateDisplayInner(cm, visible, forced)) break;
      updated = true;

      // If the max line changed since it was last measured, measure it,
      // and ensure the document's width matches it.
      if (cm.display.maxLineChanged && !cm.options.lineWrapping)
        adjustContentWidth(cm);

      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      setDocumentHeight(cm, barMeasure);
      updateScrollbars(cm, barMeasure);
      if (webkit && cm.options.lineWrapping)
        checkForWebkitWidthBug(cm, barMeasure); // (Issue #2420)
      if (first && cm.options.lineWrapping && oldWidth != cm.display.scroller.clientWidth) {
        forced = true;
        continue;
      }
      forced = false;

      // Clip forced viewport to actual scrollable area.
      if (viewPort && viewPort.top != null)
        viewPort = {top: Math.min(barMeasure.docHeight - scrollerCutOff - barMeasure.clientHeight, viewPort.top)};
      // Updated line heights might result in the drawn area not
      // actually covering the viewport. Keep looping until it does.
      visible = visibleLines(cm.display, cm.doc, viewPort);
      if (visible.from >= cm.display.viewFrom && visible.to <= cm.display.viewTo)
        break;
    }

    cm.display.updateLineNumbers = null;
    if (updated) {
      signalLater(cm, "update", cm);
      if (cm.display.viewFrom != oldFrom || cm.display.viewTo != oldTo)
        signalLater(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
    }
    return updated;
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayInner(cm, visible, forced) {
    var display = cm.display, doc = cm.doc;
    if (!display.wrapper.offsetWidth) {
      resetView(cm);
      return;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!forced && visible.from >= display.viewFrom && visible.to <= display.viewTo &&
        countDirtyView(cm) == 0)
      return;

    if (maybeUpdateLineNumberWidth(cm))
      resetView(cm);
    var dims = getDimensions(cm);

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);
    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastSizeC != display.wrapper.clientHeight;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !forced) return;

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var focused = activeElt();
    if (toUpdate > 4) display.lineDiv.style.display = "none";
    patchDisplay(cm, display.updateLineNumbers, dims);
    if (toUpdate > 4) display.lineDiv.style.display = "";
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();

    // Prevent selection and cursors from interfering with the scroll
    // width.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);

    if (different) {
      display.lastSizeC = display.wrapper.clientHeight;
      startWorker(cm, 400);
    }

    updateHeightsInViewport(cm);

    return true;
  }

  function adjustContentWidth(cm) {
    var display = cm.display;
    var width = measureChar(cm, display.maxLine, display.maxLine.text.length).left;
    display.maxLineChanged = false;
    var minWidth = Math.max(0, width + 3);
    var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + minWidth + scrollerCutOff - display.scroller.clientWidth);
    display.sizer.style.minWidth = minWidth + "px";
    if (maxScrollLeft < cm.doc.scrollLeft)
      setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = Math.max(measure.docHeight, measure.clientHeight - scrollerCutOff) + "px";
  }

  function checkForWebkitWidthBug(cm, measure) {
    // Work around Webkit bug where it sometimes reserves space for a
    // non-existing phantom scrollbar in the scroller (Issue #2420)
    if (cm.display.sizer.offsetWidth + cm.display.gutters.offsetWidth < cm.display.scroller.clientWidth - 1) {
      cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = "0px";
      cm.display.gutters.style.height = measure.docHeight + "px";
    }
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], height;
      if (cur.hidden) continue;
      if (ie_upto7) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }
      var diff = cur.line.height - height;
      if (height < 2) height = textHeight(display);
      if (diff > .001 || diff < -.001) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)
          updateWidgetHeight(cur.rest[j]);
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)
      line.widgets[i].height = line.widgets[i].node.offsetHeight;
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft;
      width[cm.options.gutters[i]] = n.offsetWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth};
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        node.style.display = "none";
      else
        node.parentNode.removeChild(node);
      return next;
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) {
      } else if (!lineView.node) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) cur = rm(cur);
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) cur = rm(cur);
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") updateLineText(cm, lineView);
      else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);
      else if (type == "class") updateLineClasses(lineView);
      else if (type == "widget") updateLineWidgets(lineView, dims);
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      lineView.node.appendChild(lineView.text);
      if (ie_upto7) lineView.node.style.zIndex = 2;
    }
    return lineView.node;
  }

  function updateLineBackground(lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) cls += " CodeMirror-linebackground";
    if (lineView.background) {
      if (cls) lineView.background.className = cls;
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) lineView.node = built.pre;
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(lineView) {
    updateLineBackground(lineView);
    if (lineView.line.wrapClass)
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    else if (lineView.node != lineView.text)
      lineView.node.className = "";
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter =
        wrap.insertBefore(elt("div", null, "CodeMirror-gutter-wrapper", "position: absolute; left: " +
                              (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"),
                          lineView.text);
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
              + cm.display.lineNumInnerWidth + "px"));
      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                     dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
      }
    }
  }

  function updateLineWidgets(lineView, dims) {
    if (lineView.alignable) lineView.alignable = null;
    for (var node = lineView.node.firstChild, next; node; node = next) {
      var next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget")
        lineView.node.removeChild(node);
    }
    insertLineWidgets(lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) lineView.bgClass = built.bgClass;
    if (built.textClass) lineView.textClass = built.textClass;

    updateLineClasses(lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(lineView, dims);
    return lineView.node;
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(lineView, dims) {
    insertLineWidgetsFor(lineView.line, lineView, dims, true);
    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
      insertLineWidgetsFor(lineView.rest[i], lineView, dims, false);
  }

  function insertLineWidgetsFor(line, lineView, dims, allowAbove) {
    if (!line.widgets) return;
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) node.ignoreEvents = true;
      positionLineWidget(widget, node, lineView, dims);
      if (allowAbove && widget.above)
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      else
        wrap.appendChild(node);
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
    }
  }

  // POSITION OBJECT

  // A Pos instance represents a position within the text.
  var Pos = CodeMirror.Pos = function(line, ch) {
    if (!(this instanceof Pos)) return new Pos(line, ch);
    this.line = line; this.ch = ch;
  };

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };

  function copyPos(x) {return Pos(x.line, x.ch);}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }

  // SELECTION / CURSOR

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  function Selection(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  }

  Selection.prototype = {
    primary: function() { return this.ranges[this.primIndex]; },
    equals: function(other) {
      if (other == this) return true;
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
      for (var i = 0; i < this.ranges.length; i++) {
        var here = this.ranges[i], there = other.ranges[i];
        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;
      }
      return true;
    },
    deepCopy: function() {
      for (var out = [], i = 0; i < this.ranges.length; i++)
        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
      return new Selection(out, this.primIndex);
    },
    somethingSelected: function() {
      for (var i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].empty()) return true;
      return false;
    },
    contains: function(pos, end) {
      if (!end) end = pos;
      for (var i = 0; i < this.ranges.length; i++) {
        var range = this.ranges[i];
        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
          return i;
      }
      return -1;
    }
  };

  function Range(anchor, head) {
    this.anchor = anchor; this.head = head;
  }

  Range.prototype = {
    from: function() { return minPos(this.anchor, this.head); },
    to: function() { return maxPos(this.anchor, this.head); },
    empty: function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    }
  };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(ranges, primIndex) {
    var prim = ranges[primIndex];
    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      if (cmp(prev.to(), cur.from()) >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) --primIndex;
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
    else if (ch < 0) return Pos(pos.line, 0);
    else return pos;
  }
  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}
  function clipPosArray(doc, array) {
    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
    return out;
  }

  // SELECTION UPDATES

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(doc, range, head, other) {
    if (doc.cm && doc.cm.display.shift || doc.extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options) {
    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
    var newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head));
      }
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);
    else return sel;
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      sel = filterSelectionChange(doc, sel);

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      ensureCursorVisible(doc.cm);
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) return;

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) out = sel.ranges.slice(0, i);
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(out, sel.primIndex) : sel;
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search: for (;;) {
      var line = getLine(doc, curPos.line);
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var sp = line.markedSpans[i], m = sp.marker;
          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&
              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
            if (mayClear) {
              signal(m, "beforeCursorEnter");
              if (m.explicitlyCleared) {
                if (!line.markedSpans) break;
                else {--i; continue;}
              }
            }
            if (!m.atomic) continue;
            var newPos = m.find(dir < 0 ? -1 : 1);
            if (cmp(newPos, curPos) == 0) {
              newPos.ch += dir;
              if (newPos.ch < 0) {
                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));
                else newPos = null;
              } else if (newPos.ch > line.text.length) {
                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);
                else newPos = null;
              }
              if (!newPos) {
                if (flipped) {
                  // Driven in a corner -- no valid cursor position found at all
                  // -- try again *with* clearing, if we didn't already
                  if (!mayClear) return skipAtomic(doc, pos, bias, true);
                  // Otherwise, turn off editing until further notice, and return the start of the doc
                  doc.cantEdit = true;
                  return Pos(doc.first, 0);
                }
                flipped = true; newPos = pos; dir = -dir;
              }
            }
            curPos = newPos;
            continue search;
          }
        }
      }
      return curPos;
    }
  }

  // SELECTION DRAWING

  // Redraw the selection and/or cursor
  function updateSelection(cm) {
    var display = cm.display, doc = cm.doc;
    var curFragment = document.createDocumentFragment();
    var selFragment = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      var collapsed = range.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        drawSelectionCursor(cm, range, curFragment);
      if (!collapsed)
        drawSelectionRange(cm, range, selFragment);
    }

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      var top = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                     headPos.top + lineOff.top - wrapOff.top));
      var left = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                      headPos.left + lineOff.left - wrapOff.left));
      display.inputDiv.style.top = top + "px";
      display.inputDiv.style.left = left + "px";
    }

    removeChildrenAndAdd(display.cursorDiv, curFragment);
    removeChildrenAndAdd(display.selectionDiv, selFragment);
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, range, output) {
    var pos = cursorCoords(cm, range.head, "div");

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left, rightSide = display.lineSpace.offsetWidth - padding.right;

    function add(left, top, width, bottom) {
      if (top < 0) top = 0;
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                               "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +
                               "px; height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
        var leftPos = coords(from, "left"), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, "right");
          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0) left = leftSide;
        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = leftSide;
          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen) right = rightSide;
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
          start = leftPos;
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
          end = rightPos;
        if (left < leftSide + 1) left = leftSide;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return {start: start, end: end};
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        add(leftSide, leftEnd.bottom, null, rightStart.top);
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      display.blinker = setInterval(function() {
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first) doc.frontier = doc.first;
    if (doc.frontier >= cm.display.viewTo) return;
    var end = +new Date + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));

    runInOp(cm, function() {
    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
      if (doc.frontier >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var highlighted = highlightLine(cm, line, state, true);
        line.styles = highlighted.styles;
        if (highlighted.classes) line.styleClasses = highlighted.classes;
        else if (line.styleClasses) line.styleClasses = null;
        var ischange = !oldStyles || oldStyles.length != line.styles.length;
        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
        if (ischange) regLineChange(cm, doc.frontier, "text");
        line.stateAfter = copyState(doc.mode, state);
      } else {
        processLine(cm, line.text, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    });
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  function getStateBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) return true;
    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
    if (!state) state = startState(doc.mode);
    else state = copyState(doc.mode, state);
    doc.iter(pos, n, function(line) {
      processLine(cm, line.text, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    if (precise) doc.frontier = pos;
    return state;
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop;}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
  function paddingH(display) {
    if (display.cachedPaddingH) return display.cachedPaddingH;
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;
    return data;
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && cm.display.scroller.clientWidth;
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            heights.push((cur.bottom + next.top) / 2 - rect.top);
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      return {map: lineView.measure.map, cache: lineView.measure.cache};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineView.rest[i] == line)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineNo(lineView.rest[i]) > lineN)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      return cm.display.view[findViewIndex(cm, lineN)];
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      return ext;
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text)
      view = null;
    else if (view && view.changes)
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
    if (!view)
      view = updateExternalMeasurement(cm, line);

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    };
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias) {
    if (prepared.before) ch = -1;
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        prepared.rect = prepared.view.text.getBoundingClientRect();
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) prepared.cache[key] = found;
    }
    return {left: found.left, right: found.right, top: found.top, bottom: found.bottom};
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function measureCharInner(cm, prepared, ch, bias) {
    var map = prepared.map;

    var node, start, end, collapse;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      var mStart = map[i], mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) collapse = "right";
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          collapse = bias;
        if (bias == "left" && start == 0)
          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          }
        if (bias == "right" && start == mEnd - mStart)
          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          }
        break;
      }
    }

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      while (start && isExtendingChar(prepared.line.text.charAt(mStart + start))) --start;
      while (mStart + end < mEnd && isExtendingChar(prepared.line.text.charAt(mStart + end))) ++end;
      if (ie_upto8 && start == 0 && end == mEnd - mStart) {
        rect = node.parentNode.getBoundingClientRect();
      } else if (ie && cm.options.lineWrapping) {
        var rects = range(node, start, end).getClientRects();
        if (rects.length)
          rect = rects[bias == "right" ? rects.length - 1 : 0];
        else
          rect = nullRect;
      } else {
        rect = range(node, start, end).getBoundingClientRect() || nullRect;
      }
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) collapse = bias = "right";
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      else
        rect = node.getBoundingClientRect();
    }
    if (ie_upto8 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
      else
        rect = nullRect;
    }

    var top, bot = (rect.bottom + rect.top) / 2 - prepared.rect.top;
    var heights = prepared.view.measure.heights;
    for (var i = 0; i < heights.length - 1; i++)
      if (bot < heights[i]) break;
    top = i ? heights[i - 1] : 0; bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) result.bogus = true;
    return result;
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
        lineView.measure.caches[i] = {};
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      clearLineMeasurementCacheFor(cm.display.view[i]);
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }

  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"/null (editor), or "page".
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
      var size = widgetHeight(lineObj.widgets[i]);
      rect.top += size; rect.bottom += size;
    }
    if (context == "line") return rect;
    if (!context) context = "local";
    var yOff = heightAtLine(lineObj);
    if (context == "local") yOff += paddingTop(cm.display);
    else yOff -= cm.display.viewOffset;
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect;
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"/null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") return coords;
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left");
      if (right) m.left = m.right; else m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos], right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from) return get(ch - 1);
      return get(ch, right);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order) return get(ch);
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
    return val;
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0, pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height};
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, outside, xRel) {
    var pos = Pos(line, ch);
    pos.xRel = xRel;
    if (outside) pos.outside = true;
    return pos;
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    if (x < 0) x = 0;

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find(0, true);
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
        lineN = lineNo(lineObj = mergedPos.to.line);
      else
        return found;
    }
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);

    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
      wrongLine = true;
      if (innerOff > sp.bottom) return sp.left - adjust;
      else if (innerOff < sp.top) return sp.left + adjust;
      else wrongLine = false;
      return sp.left;
    }

    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var xDiff = x - (ch == from ? fromX : toX);
        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
    }
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) return display.cachedCharWidth;
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) display.cachedCharWidth = width;
    return width || 10;
  }

  // OPERATIONS

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: null,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      id: ++nextOpId           // Unique ID
    };
    if (!delayedCallbackDepth++) delayedCallbacks = [];
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp, doc = cm.doc, display = cm.display;
    cm.curOp = null;

    if (op.updateMaxLine) findMaxLine(cm);

    // If it looks like an update might be needed, call updateDisplay
    if (op.viewChanged || op.forceUpdate || op.scrollTop != null ||
        op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                           op.scrollToPos.to.line >= display.viewTo) ||
        display.maxLineChanged && cm.options.lineWrapping) {
      var updated = updateDisplay(cm, {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
      if (cm.display.scroller.offsetHeight) cm.doc.scrollTop = cm.display.scroller.scrollTop;
    }
    // If no update was run, but the selection changed, redraw that.
    if (!updated && op.selectionChanged) updateSelection(cm);
    if (!updated && op.startHeight != cm.doc.height) updateScrollbars(cm);

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      display.wheelStartX = display.wheelStartY = null;

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null && display.scroller.scrollTop != op.scrollTop) {
      var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;
    }
    if (op.scrollLeft != null && display.scroller.scrollLeft != op.scrollLeft) {
      var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;
      alignHorizontally(cm);
    }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var coords = scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos.from),
                                     clipPos(cm.doc, op.scrollToPos.to), op.scrollToPos.margin);
      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);
    }

    if (op.selectionChanged) restartBlink(cm);

    if (cm.state.focused && op.updateInput)
      resetInput(cm, op.typing);

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) for (var i = 0; i < hidden.length; ++i)
      if (!hidden[i].lines.length) signal(hidden[i], "hide");
    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

    var delayed;
    if (!--delayedCallbackDepth) {
      delayed = delayedCallbacks;
      delayedCallbacks = null;
    }
    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      signal(cm, "changes", cm, op.changeObjs);
    if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();
    if (op.cursorActivityHandlers)
      for (var i = 0; i < op.cursorActivityHandlers.length; i++)
        op.cursorActivityHandlers[i](cm);
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) return f();
    startOperation(cm);
    try { return f(); }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) return f.apply(cm, arguments);
      startOperation(cm);
      try { return f.apply(cm, arguments); }
      finally { endOperation(cm); }
    };
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) return f.apply(this, arguments);
      startOperation(this);
      try { return f.apply(this, arguments); }
      finally { endOperation(this); }
    };
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) return f.apply(this, arguments);
      startOperation(cm);
      try { return f.apply(this, arguments); }
      finally { endOperation(cm); }
    };
  }

  // VIEW TRACKING

  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) from = cm.doc.first;
    if (to == null) to = cm.doc.first + cm.doc.size;
    if (!lendiff) lendiff = 0;

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      display.updateLineNumbers = from;

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        resetView(cm);
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut = viewCuttingPoint(cm, from, from, -1);
      if (cut) {
        display.view = display.view.slice(0, cut.index);
        display.viewTo = cut.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        ext.lineN += lendiff;
      else if (from < ext.lineN + ext.size)
        display.externalMeasured = null;
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      display.externalMeasured = null;

    if (line < display.viewFrom || line >= display.viewTo) return;
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) return;
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) arr.push(type);
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) return null;
    n -= cm.display.viewFrom;
    if (n < 0) return null;
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) return i;
    }
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      return {index: index, lineN: newN};
    for (var i = 0, n = cm.display.viewFrom; i < index; i++)
      n += view[i].size;
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) return null;
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) return null;
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN};
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      else if (display.viewFrom < from)
        display.view = display.view.slice(findViewIndex(cm, from));
      display.viewFrom = from;
      if (display.viewTo < to)
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      else if (display.viewTo > to)
        display.view = display.view.slice(0, findViewIndex(cm, to));
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;
    }
    return dirty;
  }

  // INPUT HANDLING

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  function slowPoll(cm) {
    if (cm.display.pollingFast) return;
    cm.display.poll.set(cm.options.pollInterval, function() {
      readInput(cm);
      if (cm.state.focused) slowPoll(cm);
    });
  }

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  function fastPoll(cm) {
    var missed = false;
    cm.display.pollingFast = true;
    function p() {
      var changed = readInput(cm);
      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}
      else {cm.display.pollingFast = false; slowPoll(cm);}
    }
    cm.display.poll.set(20, p);
  }

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  function readInput(cm) {
    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (!cm.state.focused || (hasSelection(input) && !prevInput) || isReadOnly(cm) || cm.options.disableInput)
      return false;
    // See paste handler for more on the fakedLastChar kludge
    if (cm.state.pasteIncoming && cm.state.fakedLastChar) {
      input.value = input.value.substring(0, input.value.length - 1);
      cm.state.fakedLastChar = false;
    }
    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) return false;
    // Work around nonsensical selection resetting in IE9/10
    if (ie && !ie_upto8 && cm.display.inputHasSelection === text) {
      resetInput(cm);
      return false;
    }

    var withOp = !cm.curOp;
    if (withOp) startOperation(cm);
    cm.display.shift = false;

    if (text.charCodeAt(0) == 0x200b && doc.sel == cm.display.selForContextMenu && !prevInput)
      prevInput = "\u200b";
    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;
    var inserted = text.slice(same), textLines = splitLines(inserted);

    // When pasing N lines into N selections, insert one line per selection
    var multiPaste = cm.state.pasteIncoming && textLines.length > 1 && doc.sel.ranges.length == textLines.length;

    // Normal behavior is to insert the new text into every selection
    for (var i = doc.sel.ranges.length - 1; i >= 0; i--) {
      var range = doc.sel.ranges[i];
      var from = range.from(), to = range.to();
      // Handle deletion
      if (same < prevInput.length)
        from = Pos(from.line, from.ch - (prevInput.length - same));
      // Handle overwrite
      else if (cm.state.overwrite && range.empty() && !cm.state.pasteIncoming)
        to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
      var updateInput = cm.curOp.updateInput;
      var changeEvent = {from: from, to: to, text: multiPaste ? [textLines[i]] : textLines,
                         origin: cm.state.pasteIncoming ? "paste" : cm.state.cutIncoming ? "cut" : "+input"};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
      // When an 'electric' character is inserted, immediately trigger a reindent
      if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&
          cm.options.smartIndent && range.head.ch < 100 &&
          (!i || doc.sel.ranges[i - 1].head.line != range.head.line)) {
        var mode = cm.getModeAt(range.head);
        if (mode.electricChars) {
          for (var j = 0; j < mode.electricChars.length; j++)
            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
              indentLine(cm, range.head.line, "smart");
              break;
            }
        } else if (mode.electricInput) {
          var end = changeEnd(changeEvent);
          if (mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)))
            indentLine(cm, range.head.line, "smart");
        }
      }
    }
    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = true;

    // Don't leave long text in the textarea, since it makes further polling slow
    if (text.length > 1000 || text.indexOf("\n") > -1) input.value = cm.display.prevInput = "";
    else cm.display.prevInput = text;
    if (withOp) endOperation(cm);
    cm.state.pasteIncoming = cm.state.cutIncoming = false;
    return true;
  }

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  function resetInput(cm, typing) {
    var minimal, selected, doc = cm.doc;
    if (cm.somethingSelected()) {
      cm.display.prevInput = "";
      var range = doc.sel.primary();
      minimal = hasCopyEvent &&
        (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
      var content = minimal ? "-" : selected || cm.getSelection();
      cm.display.input.value = content;
      if (cm.state.focused) selectInput(cm.display.input);
      if (ie && !ie_upto8) cm.display.inputHasSelection = content;
    } else if (!typing) {
      cm.display.prevInput = cm.display.input.value = "";
      if (ie && !ie_upto8) cm.display.inputHasSelection = null;
    }
    cm.display.inaccurateSelection = minimal;
  }

  function focusInput(cm) {
    if (cm.options.readOnly != "nocursor" && (!mobile || activeElt() != cm.display.input))
      cm.display.input.focus();
  }

  function ensureFocus(cm) {
    if (!cm.state.focused) { focusInput(cm); onFocus(cm); }
  }

  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }

  // EVENT HANDLERS

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie_upto10)
      on(d.scroller, "dblclick", operation(cm, function(e) {
        if (signalDOMEvent(cm, e)) return;
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
        e_preventDefault(e);
        var word = findWordAt(cm, pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    else
      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
    // Prevent normal selection in the editor (we handle our own)
    on(d.lineSpace, "selectstart", function(e) {
      if (!eventInWidget(d, e)) e_preventDefault(e);
    });
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function() {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });
    on(d.scrollbarV, "scroll", function() {
      if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);
    });
    on(d.scrollbarH, "scroll", function() {
      if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

    // Prevent clicks in the scrollbars from killing focus
    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }
    on(d.scrollbarH, "mousedown", reFocus);
    on(d.scrollbarV, "mousedown", reFocus);
    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    on(d.input, "keyup", operation(cm, onKeyUp));
    on(d.input, "input", function() {
      if (ie && !ie_upto8 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;
      fastPoll(cm);
    });
    on(d.input, "keydown", operation(cm, onKeyDown));
    on(d.input, "keypress", operation(cm, onKeyPress));
    on(d.input, "focus", bind(onFocus, cm));
    on(d.input, "blur", bind(onBlur, cm));

    function drag_(e) {
      if (!signalDOMEvent(cm, e)) e_stop(e);
    }
    if (cm.options.dragDrop) {
      on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});
      on(d.scroller, "dragenter", drag_);
      on(d.scroller, "dragover", drag_);
      on(d.scroller, "drop", operation(cm, onDrop));
    }
    on(d.scroller, "paste", function(e) {
      if (eventInWidget(d, e)) return;
      cm.state.pasteIncoming = true;
      focusInput(cm);
      fastPoll(cm);
    });
    on(d.input, "paste", function() {
      // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206
      // Add a char to the end of textarea before paste occur so that
      // selection doesn't span to the end of textarea.
      if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {
        var start = d.input.selectionStart, end = d.input.selectionEnd;
        d.input.value += "$";
        d.input.selectionStart = start;
        d.input.selectionEnd = end;
        cm.state.fakedLastChar = true;
      }
      cm.state.pasteIncoming = true;
      fastPoll(cm);
    });

    function prepareCopyCut(e) {
      if (cm.somethingSelected()) {
        if (d.inaccurateSelection) {
          d.prevInput = "";
          d.inaccurateSelection = false;
          d.input.value = cm.getSelection();
          selectInput(d.input);
        }
      } else {
        var text = "", ranges = [];
        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
          var line = cm.doc.sel.ranges[i].head.line;
          var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
          ranges.push(lineRange);
          text += cm.getRange(lineRange.anchor, lineRange.head);
        }
        if (e.type == "cut") {
          cm.setSelections(ranges, null, sel_dontScroll);
        } else {
          d.prevInput = "";
          d.input.value = text;
          selectInput(d.input);
        }
      }
      if (e.type == "cut") cm.state.cutIncoming = true;
    }
    on(d.input, "cut", prepareCopyCut);
    on(d.input, "copy", prepareCopyCut);

    // Needed to handle Tab key in KHTML
    if (khtml) on(d.sizer, "mouseup", function() {
      if (activeElt() == d.input) d.input.blur();
      focusInput(cm);
    });
  }

  // Called when the window resizes
  function onResize(cm) {
    // Might be a text scaling operation, clear size caches.
    var d = cm.display;
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    cm.setSize();
  }

  // MOUSE EVENTS

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;
    }
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal) {
      var target = e_target(e);
      if (target == display.scrollbarH || target == display.scrollbarV ||
          target == display.scrollbarFiller || target == display.gutterFiller) return null;
    }
    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e) { return null; }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    if (signalDOMEvent(this, e)) return;
    var cm = this, display = cm.display;
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function(){display.scroller.draggable = true;}, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) return;
    var start = posFromMouse(cm, e);
    window.focus();

    switch (e_button(e)) {
    case 1:
      if (start)
        leftButtonDown(cm, e, start);
      else if (e_target(e) == display.scroller)
        e_preventDefault(e);
      break;
    case 2:
      if (webkit) cm.state.lastMiddleDown = +new Date;
      if (start) extendSelection(cm.doc, start);
      setTimeout(bind(focusInput, cm), 20);
      e_preventDefault(e);
      break;
    case 3:
      if (captureRightClick) onContextMenu(cm, e);
      break;
    }
  }

  var lastClick, lastDoubleClick;
  function leftButtonDown(cm, e, start) {
    setTimeout(bind(ensureFocus, cm), 0);

    var now = +new Date, type;
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
      type = "triple";
    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
      type = "double";
      lastDoubleClick = {time: now, pos: start};
    } else {
      type = "single";
      lastClick = {time: now, pos: start};
    }

    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey;
    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) &&
        type == "single" && sel.contains(start) > -1 && sel.somethingSelected())
      leftButtonStartDrag(cm, e, start, modifier);
    else
      leftButtonSelect(cm, e, start, type, modifier);
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, e, start, modifier) {
    var display = cm.display;
    var dragEnd = operation(cm, function(e2) {
      if (webkit) display.scroller.draggable = false;
      cm.state.draggingText = false;
      off(document, "mouseup", dragEnd);
      off(display.scroller, "drop", dragEnd);
      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
        e_preventDefault(e2);
        if (!modifier)
          extendSelection(cm.doc, start);
        focusInput(cm);
        // Work around unexplainable focus problem in IE9 (#2127)
        if (ie_upto10 && !ie_upto8)
          setTimeout(function() {document.body.focus(); focusInput(cm);}, 20);
      }
    });
    // Let the drag handler handle this.
    if (webkit) display.scroller.draggable = true;
    cm.state.draggingText = dragEnd;
    // IE's approach to draggable
    if (display.scroller.dragDrop) display.scroller.dragDrop();
    on(document, "mouseup", dragEnd);
    on(display.scroller, "drop", dragEnd);
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, e, start, type, addNew) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(e);

    var ourRange, ourIndex, startSel = doc.sel;
    if (addNew && !e.shiftKey) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        ourRange = doc.sel.ranges[ourIndex];
      else
        ourRange = new Range(start, start);
    } else {
      ourRange = doc.sel.primary();
    }

    if (e.altKey) {
      type = "rect";
      if (!addNew) ourRange = new Range(start, start);
      start = posFromMouse(cm, e, true, true);
      ourIndex = -1;
    } else if (type == "double") {
      var word = findWordAt(cm, start);
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
      else
        ourRange = word;
    } else if (type == "triple") {
      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
      else
        ourRange = line;
    } else {
      ourRange = extendRange(doc, ourRange, start);
    }

    if (!addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex > -1) {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    } else {
      ourIndex = doc.sel.ranges.length;
      setSelection(doc, normalizeSelection(doc.sel.ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) return;
      lastPos = pos;

      if (type == "rect") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          else if (text.length > leftPos)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
        }
        if (!ranges.length) ranges.push(new Range(start, start));
        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var anchor = oldRange.anchor, head = pos;
        if (type != "single") {
          if (type == "double")
            var range = findWordAt(cm, pos);
          else
            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
          if (cmp(range.anchor, anchor) > 0) {
            head = range.head;
            anchor = minPos(oldRange.from(), range.anchor);
          } else {
            head = range.anchor;
            anchor = maxPos(oldRange.to(), range.head);
          }
        }
        var ranges = startSel.ranges.slice(0);
        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, type == "rect");
      if (!cur) return;
      if (cmp(cur, lastPos) != 0) {
        ensureFocus(cm);
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) setTimeout(operation(cm, function() {
          if (counter != curCount) return;
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50);
      }
    }

    function done(e) {
      counter = Infinity;
      e_preventDefault(e);
      focusInput(cm);
      off(document, "mousemove", move);
      off(document, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function(e) {
      if ((ie && !ie_upto9) ?  !e.buttons : !e_button(e)) done(e);
      else extend(e);
    });
    var up = operation(cm, done);
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent, signalfn) {
    try { var mX = e.clientX, mY = e.clientY; }
    catch(e) { return false; }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
    if (prevent) e_preventDefault(e);

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalfn(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e);
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true, signalLater);
  }

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      return;
    e_preventDefault(e);
    if (ie) lastDrop = +new Date;
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm)) return;
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function(file, i) {
        var reader = new FileReader;
        reader.onload = operation(cm, function() {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos, text: splitLines(text.join("\n")), origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) loadFile(files[i], i);
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(bind(focusInput, cm), 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData("Text");
        if (text) {
          if (cm.state.draggingText && !(mac ? e.metaKey : e.ctrlKey))
            var selected = cm.listSelections();
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) for (var i = 0; i < selected.length; ++i)
            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
          cm.replaceSelection(text, "around", "paste");
          focusInput(cm);
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

    e.dataTransfer.setData("Text", cm.getSelection());

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) img.parentNode.removeChild(img);
    }
  }

  // SCROLL EVENTS

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
    cm.doc.scrollTop = val;
    if (!gecko) updateDisplay(cm, {top: val});
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;
    if (gecko) updateDisplay(cm);
    startWorker(cm, 100);
  }
  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) wheelPixelsPerUnit = -.53;
  else if (gecko) wheelPixelsPerUnit = 15;
  else if (chrome) wheelPixelsPerUnit = -.7;
  else if (safari) wheelPixelsPerUnit = -1/3;

  function onScrollWheel(cm, e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
    else if (dy == null) dy = e.wheelDelta;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||
          dy && scroll.scrollHeight > scroll.clientHeight)) return;

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) top = Math.max(0, top + pixels - 50);
      else bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplay(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // KEY EVENTS

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;
    var prevShift = cm.display.shift, done = false;
    try {
      if (isReadOnly(cm)) cm.state.suppressEdits = true;
      if (dropShift) cm.display.shift = false;
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  // Collect the currently active keymaps.
  function allKeyMaps(cm) {
    var maps = cm.state.keyMaps.slice(0);
    if (cm.options.extraKeys) maps.push(cm.options.extraKeys);
    maps.push(cm.options.keyMap);
    return maps;
  }

  var maybeTransition;
  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    // Handle automatic keymap transitions
    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
    clearTimeout(maybeTransition);
    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {
      if (getKeyMap(cm.options.keyMap) == startMap) {
        cm.options.keyMap = (next.call ? next.call(null, cm) : next);
        keyMapChanged(cm);
      }
    }, 50);

    var name = keyName(e, true), handled = false;
    if (!name) return false;
    var keymaps = allKeyMaps(cm);

    if (e.shiftKey) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      handled = lookupKey("Shift-" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})
             || lookupKey(name, keymaps, function(b) {
                  if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                    return doHandleBinding(cm, b);
                });
    } else {
      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });
    }

    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      signalLater(cm, "keyHandled", cm, name, e);
    }
    return handled;
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    var handled = lookupKey("'" + ch + "'", allKeyMaps(cm),
                            function(b) { return doHandleBinding(cm, b, true); });
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      signalLater(cm, "keyHandled", cm, "'" + ch + "'", e);
    }
    return handled;
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    ensureFocus(cm);
    if (signalDOMEvent(cm, e)) return;
    // IE does strange things with escape.
    if (ie_upto10 && e.keyCode == 27) e.returnValue = false;
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection("", null, "cut");
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      showCrossHair(cm);
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (signalDOMEvent(this, e)) return;
    if (e.keyCode == 16) this.doc.sel.shift = false;
  }

  function onKeyPress(e) {
    var cm = this;
    if (signalDOMEvent(cm, e)) return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
    if (((presto && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (handleCharBinding(cm, e, ch)) return;
    if (ie && !ie_upto8) cm.display.inputHasSelection = null;
    fastPoll(cm);
  }

  // FOCUS/BLUR EVENTS

  function onFocus(cm) {
    if (cm.options.readOnly == "nocursor") return;
    if (!cm.state.focused) {
      signal(cm, "focus", cm);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // The prevInput test prevents this from firing when a context
      // menu is closed (since the resetInput would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        resetInput(cm);
        if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730
      }
    }
    slowPoll(cm);
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.focused) {
      signal(cm, "blur", cm);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (signalDOMEvent(cm, e, "contextmenu")) return;
    var display = cm.display;
    if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;

    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) return; // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);

    var oldCSS = display.input.style.cssText;
    display.inputDiv.style.position = "absolute";
    display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +
      "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: " +
      (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
      "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    focusInput(cm);
    resetInput(cm);
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) display.input.value = display.prevInput = " ";
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (display.input.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = display.input.value = "\u200b" + (selected ? display.input.value : "");
        display.prevInput = selected ? "" : "\u200b";
        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      display.inputDiv.style.position = "relative";
      display.input.style.cssText = oldCSS;
      if (ie_upto8) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
      slowPoll(cm);

      // Try to detect the user choosing select-all
      if (display.input.selectionStart != null) {
        if (!ie || ie_upto8) prepareSelectAllHack();
        var i = 0, poll = function() {
          if (display.selForContextMenu == cm.doc.sel && display.input.selectionStart == 0)
            operation(cm, commands.selectAll)(cm);
          else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);
          else resetInput(cm);
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && !ie_upto8) prepareSelectAllHack();
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function() {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) return false;
    return gutterEvent(cm, e, "gutterContextMenu", false, signal);
  }

  // UPDATING

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  var changeEnd = CodeMirror.changeEnd = function(change) {
    if (!change.text) return change.to;
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  };

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) return pos;
    if (cmp(pos, change.to) <= 0) return changeEnd(change);

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
    return Pos(line, ch);
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(out, doc.sel.primIndex);
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    else
      return Pos(nw.line + (pos.line - old.line), pos.ch);
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() { this.canceled = true; }
    };
    if (update) obj.update = function(from, to, text, origin) {
      if (from) this.from = clipPos(doc, from);
      if (to) this.to = clipPos(doc, to);
      if (text) this.text = text;
      if (origin !== undefined) this.origin = origin;
    };
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

    if (obj.canceled) return null;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      if (doc.cm.state.suppressEdits) return;
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) return;
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function(doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    if (doc.cm && doc.cm.state.suppressEdits) return;

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    for (var i = 0; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        break;
    }
    if (i == source.length) return;
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return;
        }
        selAfter = event;
      }
      else break;
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return;
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change, null) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) doc.cm.scrollIntoView(change);
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) return;
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function(range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
                       Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        regLineChange(doc.cm, l, "gutter");
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) return;

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
    else updateDoc(doc, change, spans);
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      signalCursorActivity(cm);

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      regLineChange(cm, from.line, "text");
    else
      regChange(cm, from.line, to.line + 1, lendiff);

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) signalLater(cm, "change", cm, obj);
      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    if (!to) to = from;
    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
    if (typeof code == "string") code = splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, coords) {
    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (coords.top + box.top < 0) doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
                           (coords.bottom - coords.top + scrollerCutOff) + "px; left: " +
                           coords.left + "px; width: 2px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) margin = 0;
    for (;;) {
      var changed = false, coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
                                         Math.min(coords.top, endCoords.top) - margin,
                                         Math.max(coords.left, endCoords.left),
                                         Math.max(coords.bottom, endCoords.bottom) + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
      }
      if (!changed) return coords;
    }
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0) y1 = 0;
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = display.scroller.clientHeight - scrollerCutOff, result = {};
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop) result.scrollTop = newTop;
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = display.scroller.clientWidth - scrollerCutOff;
    x1 += display.gutters.offsetWidth; x2 += display.gutters.offsetWidth;
    var gutterw = display.gutters.offsetWidth;
    var atLeft = x1 < gutterw + 10;
    if (x1 < screenleft + gutterw || atLeft) {
      if (atLeft) x1 = 0;
      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
    } else if (x2 > screenw + screenleft - 3) {
      result.scrollLeft = x2 + 10 - screenw;
    }
    return result;
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollPos(cm, left, top) {
    if (left != null || top != null) resolveScrollToPos(cm);
    if (left != null)
      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
    if (top != null)
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor(), from = cur, to = cur;
    if (!cm.options.lineWrapping) {
      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
      to = Pos(cur.line, cur.ch + 1);
    }
    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
                                    Math.min(from.top, to.top) - range.margin,
                                    Math.max(from.right, to.right),
                                    Math.max(from.bottom, to.bottom) + range.margin);
      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
    }
  }

  // API UTILITIES

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) how = "add";
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!cm.doc.mode.indent) how = "prev";
      else state = getStateBefore(cm, n);
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) line.stateAfter = null;
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass) {
        if (!aggressive) return;
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
      else indentation = 0;
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
    if (pos < indentation) indentString += spaceStr(indentation - pos);

    if (indentString != curSpaceString) {
      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i = 0; i < doc.sel.ranges.length; i++) {
        var range = doc.sel.ranges[i];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i, new Range(pos, pos));
          break;
        }
      }
    }
    line.stateAfter = null;
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(cm, handle, changeType, op) {
    var no = handle, line = handle, doc = cm.doc;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
    else no = lineNo(handle);
    if (no == null) return null;
    if (op(line, no)) regLineChange(cm, no, changeType);
    return line;
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function() {
      for (var i = kill.length - 1; i >= 0; i--)
        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      ensureCursorVisible(cm);
    });
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else ch = dir < 0 ? lineObj.text.length : 0;
        } else return (possible = false);
      } else ch = next;
      return true;
    }

    if (unit == "char") moveOnce();
    else if (unit == "column") moveOnce(true);
    else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) break;
        var cur = lineObj.text.charAt(ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) type = "s";
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce();}
          break;
        }

        if (type) sawType = type;
        if (dir > 0 && !moveOnce(!first)) break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), origDir, true);
    if (!possible) result.hitSide = true;
    return result;
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside) break;
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
      y += dir * 5;
    }
    return target;
  }

  // Find the word at the given position (as returned by coordsChar).
  function findWordAt(cm, pos) {
    var doc = cm.doc, line = getLine(doc, pos.line).text;
    var start = pos.ch, end = pos.ch;
    if (line) {
      var helper = cm.getHelper(pos, "wordChars");
      if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
      var startChar = line.charAt(start);
      var check = isWordChar(startChar, helper)
        ? function(ch) { return isWordChar(ch, helper); }
        : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
        : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
      while (start > 0 && check(line.charAt(start - 1))) --start;
      while (end < line.length && check(line.charAt(end))) ++end;
    }
    return new Range(Pos(pos.line, start), Pos(pos.line, end));
  }

  // EDITOR METHODS

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); focusInput(this); fastPoll(this);},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },

    getOption: function(option) {return this.options[option];},
    getDoc: function() {return this.doc;},

    addKeyMap: function(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](map);
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if (maps[i] == map || (typeof maps[i] != "string" && maps[i].name == map)) {
          maps.splice(i, 1);
          return true;
        }
    },

    addOverlay: methodOp(function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: methodOp(function(spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),

    indentLine: methodOp(function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
        else dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
    }),
    indentSelection: methodOp(function(how) {
      var ranges = this.doc.sel.ranges, end = -1;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (!range.empty()) {
          var start = Math.max(end, range.from().line);
          var to = range.to();
          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
          for (var j = start; j < end; ++j)
            indentLine(this, j, how);
        } else if (range.head.line > end) {
          indentLine(this, range.head.line, how, true);
          end = range.head.line;
          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
        }
      }
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      var doc = this.doc;
      pos = clipPos(doc, pos);
      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;
      var line = getLine(doc, pos.line);
      var stream = new StringStream(line.text, this.options.tabSize);
      while (stream.pos < pos.ch && !stream.eol()) {
        stream.start = stream.pos;
        var style = readToken(mode, stream, state);
      }
      return {start: stream.start,
              end: stream.pos,
              string: stream.current(),
              type: style || null,
              state: state};
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      var type;
      if (ch == 0) type = styles[2];
      else for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
        else { type = styles[mid * 2 + 2]; break; }
      }
      var cut = type ? type.indexOf("cm-overlay ") : -1;
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },

    getHelper: function(pos, type) {
      return this.getHelpers(pos, type)[0];
    },

    getHelpers: function(pos, type) {
      var found = [];
      if (!helpers.hasOwnProperty(type)) return helpers;
      var help = helpers[type], mode = this.getModeAt(pos);
      if (typeof mode[type] == "string") {
        if (help[mode[type]]) found.push(help[mode[type]]);
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]];
          if (val) found.push(val);
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }
      for (var i = 0; i < help._global.length; i++) {
        var cur = help._global[i];
        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
          found.push(cur.val);
      }
      return found;
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getStateBefore(this, line + 1, precise);
    },

    cursorCoords: function(start, mode) {
      var pos, range = this.doc.sel.primary();
      if (start == null) pos = range.head;
      else if (typeof start == "object") pos = clipPos(this.doc, start);
      else pos = start ? range.from() : range.to();
      return cursorCoords(this, pos, mode || "page");
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top);
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function(line, mode) {
      var end = false, last = this.doc.first + this.doc.size - 1;
      if (line < this.doc.first) line = this.doc.first;
      else if (line > last) { line = last; end = true; }
      var lineObj = getLine(this.doc, line);
      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
        (end ? this.doc.height - heightAtLine(lineObj) : 0);
    },

    defaultTextHeight: function() { return textHeight(this.display); },
    defaultCharWidth: function() { return charWidth(this.display); },

    setGutterMarker: methodOp(function(line, gutterID, value) {
      return changeLine(this, line, "gutter", function(line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) line.gutterMarkers = null;
        return true;
      });
    }),

    clearGutter: methodOp(function(gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regLineChange(cm, i, "gutter");
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
        }
        ++i;
      });
    }),

    addLineClass: methodOp(function(handle, where, cls) {
      return changeLine(this, handle, "class", function(line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
        if (!line[prop]) line[prop] = cls;
        else if (new RegExp("(?:^|\\s)" + cls + "(?:$|\\s)").test(line[prop])) return false;
        else line[prop] += " " + cls;
        return true;
      });
    }),

    removeLineClass: methodOp(function(handle, where, cls) {
      return changeLine(this, handle, "class", function(line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) return false;
        else if (cls == null) line[prop] = null;
        else {
          var found = cur.match(new RegExp("(?:^|\\s+)" + cls + "(?:$|\\s+)"));
          if (!found) return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    addLineWidget: methodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),

    removeLineWidget: function(widget) { widget.clear(); },

    lineInfo: function(line) {
      if (typeof line == "number") {
        if (!isLine(this.doc, line)) return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line) return null;
      } else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: methodOp(onKeyUp),

    execCommand: function(cmd) {
      if (commands.hasOwnProperty(cmd))
        return commands[cmd](this);
    },

    findPosH: function(from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveH: methodOp(function(dir, unit) {
      var cm = this;
      cm.extendSelectionsBy(function(range) {
        if (cm.display.shift || cm.doc.extend || range.empty())
          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
        else
          return dir < 0 ? range.from() : range.to();
      }, sel_move);
    }),

    deleteH: methodOp(function(dir, unit) {
      var sel = this.doc.sel, doc = this.doc;
      if (sel.somethingSelected())
        doc.replaceSelection("", null, "+delete");
      else
        deleteNearSelection(this, function(range) {
          var other = findPosH(doc, range.head, dir, unit, false);
          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
        });
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, "div");
        if (x == null) x = coords.left;
        else coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveV: methodOp(function(dir, unit) {
      var cm = this, doc = this.doc, goals = [];
      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy(function(range) {
        if (collapse)
          return dir < 0 ? range.from() : range.to();
        var headPos = cursorCoords(cm, range.head, "div");
        if (range.goalColumn != null) headPos.left = range.goalColumn;
        goals.push(headPos.left);
        var pos = findPosV(cm, headPos, dir, unit);
        if (unit == "page" && range == doc.sel.primary())
          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
        return pos;
      }, sel_move);
      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
        doc.sel.ranges[i].goalColumn = goals[i];
    }),

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) return;
      if (this.state.overwrite = !this.state.overwrite)
        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
      else
        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");

      signal(this, "overwriteToggle", this, this.state.overwrite);
    },
    hasFocus: function() { return activeElt() == this.display.input; },

    scrollTo: methodOp(function(x, y) {
      if (x != null || y != null) resolveScrollToPos(this);
      if (x != null) this.curOp.scrollLeft = x;
      if (y != null) this.curOp.scrollTop = y;
    }),
    getScrollInfo: function() {
      var scroller = this.display.scroller, co = scrollerCutOff;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,
              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};
    },

    scrollIntoView: methodOp(function(range, margin) {
      if (range == null) {
        range = {from: this.doc.sel.primary().head, to: null};
        if (margin == null) margin = this.options.cursorScrollMargin;
      } else if (typeof range == "number") {
        range = {from: Pos(range, 0), to: null};
      } else if (range.from == null) {
        range = {from: range, to: null};
      }
      if (!range.to) range.to = range.from;
      range.margin = margin || 0;

      if (range.from.line != null) {
        resolveScrollToPos(this);
        this.curOp.scrollToPos = range;
      } else {
        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
                                      Math.min(range.from.top, range.to.top) - range.margin,
                                      Math.max(range.from.right, range.to.right),
                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);
        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
      }
    }),

    setSize: methodOp(function(width, height) {
      function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      }
      if (width != null) this.display.wrapper.style.width = interpret(width);
      if (height != null) this.display.wrapper.style.height = interpret(height);
      if (this.options.lineWrapping) clearLineMeasurementCache(this);
      this.curOp.forceUpdate = true;
      signal(this, "refresh", this);
    }),

    operation: function(f){return runInOp(this, f);},

    refresh: methodOp(function() {
      var oldHeight = this.display.cachedTextHeight;
      regChange(this);
      this.curOp.forceUpdate = true;
      clearCaches(this);
      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
      updateGutterSpace(this);
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
        estimateLineHeights(this);
      signal(this, "refresh", this);
    }),

    swapDoc: methodOp(function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      resetInput(this);
      this.scrollTo(doc.scrollLeft, doc.scrollTop);
      signalLater(this, "swapDoc", this, old);
      return old;
    }),

    getInputField: function(){return this.display.input;},
    getWrapperElement: function(){return this.display.wrapper;},
    getScrollerElement: function(){return this.display.scroller;},
    getGutterElement: function(){return this.display.gutters;}
  };
  eventMixin(CodeMirror);

  // OPTION DEFAULTS

  // The default configuration options.
  var defaults = CodeMirror.defaults = {};
  // Functions to run when options are changed.
  var optionHandlers = CodeMirror.optionHandlers = {};

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) optionHandlers[name] =
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
  }

  // Passed to option handlers when there is no old value.
  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function(cm, val) {
    cm.setValue(val);
  }, true);
  option("mode", null, function(cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function(cm) {
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option("specialChars", /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\ufeff]/g, function(cm, val) {
    cm.options.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
    cm.refresh();
  }, true);
  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
  option("electricChars", true);
  option("rtlMoveVisually", !windows);
  option("wholeLineUpdateBefore", true);

  option("theme", "default", function(cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", keyMapChanged);
  option("extraKeys", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function(cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, updateScrollbars, true);
  option("lineNumbers", false, function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("resetSelectionOnContextMenu", true);

  option("readOnly", false, function(cm, val) {
    if (val == "nocursor") {
      onBlur(cm);
      cm.display.input.blur();
      cm.display.disabled = true;
    } else {
      cm.display.disabled = false;
      if (!val) resetInput(cm);
    }
  });
  option("disableInput", false, function(cm, val) {if (!val) resetInput(cm);}, true);
  option("dragDrop", true);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true, resetModeState, true);
  option("addModeClass", false, resetModeState, true);
  option("pollInterval", 100);
  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
  option("historyEventDelay", 1250);
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
  option("maxHighlightLength", 10000, resetModeState, true);
  option("moveInputWithCursor", true, function(cm, val) {
    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
  });

  option("tabindex", null, function(cm, val) {
    cm.display.input.tabIndex = val || "";
  });
  option("autofocus", null);

  // MODE DEFINITION AND QUERYING

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    if (arguments.length > 2) {
      mode.dependencies = [];
      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);
    }
    modes[name] = mode;
  };

  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") found = {name: found};
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode("application/xml");
    }
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  CodeMirror.getMode = function(options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) continue;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) modeObj.helperType = spec.helperType;
    if (spec.modeProps) for (var prop in spec.modeProps)
      modeObj[prop] = spec.modeProps[prop];

    return modeObj;
  };

  // Minimal default mode.
  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };

  // EXTENSIONS

  CodeMirror.defineExtension = function(name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;

  var initHooks = [];
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

  var helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };

  // MODE STATE HANDLING

  // Utility functions for working with state. Exported because nested
  // modes need to do this for their inner modes.

  var copyState = CodeMirror.copyState = function(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  };

  var startState = CodeMirror.startState = function(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  };

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  CodeMirror.innerMode = function(mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      if (!info || info.mode == mode) break;
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state};
  };

  // STANDARD COMMANDS

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
    singleSelection: function(cm) {
      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine())
            return {from: range.head, to: Pos(range.head.line + 1, 0)};
          else
            return {from: range.head, to: Pos(range.head.line, len)};
        } else {
          return {from: range.from(), to: range.to()};
        }
      });
    },
    deleteLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0),
                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
      });
    },
    delLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0), to: range.from()};
      });
    },
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    undoSelection: function(cm) {cm.undoSelection();},
    redoSelection: function(cm) {cm.redoSelection();},
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); }, sel_move);
    },
    goLineStartSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var start = lineStart(cm, range.head.line);
        var line = cm.getLineHandle(start.line);
        var order = getOrder(line);
        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(0, line.text.search(/\S/));
          var inWS = range.head.line == start.line && range.head.ch <= firstNonWS && range.head.ch;
          return Pos(start.line, inWS ? 0 : firstNonWS);
        }
        return start;
      }, sel_move);
    },
    goLineEnd: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); }, sel_move);
    },
    goLineRight: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      }, sel_move);
    },
    goLineLeft: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: 0, top: top}, "div");
      }, sel_move);
    },
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goGroupRight: function(cm) {cm.moveH(1, "group");},
    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
    delCharAfter: function(cm) {cm.deleteH(1, "char");},
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
    delWordAfter: function(cm) {cm.deleteH(1, "word");},
    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t");},
    insertSoftTab: function(cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(new Array(tabSize - col % tabSize + 1).join(" "));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function(cm) {
      if (cm.somethingSelected()) cm.indentSelection("add");
      else cm.execCommand("insertTab");
    },
    transposeChars: function(cm) {
      runInOp(cm, function() {
        var ranges = cm.listSelections(), newSel = [];
        for (var i = 0; i < ranges.length; i++) {
          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                              Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev)
                cm.replaceRange(line.charAt(0) + "\n" + prev.charAt(prev.length - 1),
                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function(cm) {
      runInOp(cm, function() {
        var len = cm.listSelections().length;
        for (var i = 0; i < len; i++) {
          var range = cm.listSelections()[i];
          cm.replaceRange("\n", range.anchor, range.head, "+input");
          cm.indentLine(range.from().line + 1, null, true);
          ensureCursorVisible(cm);
        }
      });
    },
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };

  // STANDARD KEYMAPS

  var keyMap = CodeMirror.keyMap = {};
  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    fallthrough: "basic"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineStart", "Cmd-Right": "goLineEnd", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delLineLeft",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection",
    fallthrough: ["basic", "emacsy"]
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function getKeyMap(val) {
    if (typeof val == "string") return keyMap[val];
    else return val;
  }

  // Given an array of keymaps and a key name, call handle on any
  // bindings found, until that returns a truthy value, at which point
  // we consider the key handled. Implements things like binding a key
  // to false stopping further handling and keymap fallthrough.
  var lookupKey = CodeMirror.lookupKey = function(name, maps, handle) {
    function lookup(map) {
      map = getKeyMap(map);
      var found = map[name];
      if (found === false) return "stop";
      if (found != null && handle(found)) return true;
      if (map.nofallthrough) return "stop";

      var fallthrough = map.fallthrough;
      if (fallthrough == null) return false;
      if (Object.prototype.toString.call(fallthrough) != "[object Array]")
        return lookup(fallthrough);
      for (var i = 0; i < fallthrough.length; ++i) {
        var done = lookup(fallthrough[i]);
        if (done) return done;
      }
      return false;
    }

    for (var i = 0; i < maps.length; ++i) {
      var done = lookup(maps[i]);
      if (done) return done != "stop";
    }
  };

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  var isModifierKey = CodeMirror.isModifierKey = function(event) {
    var name = keyNames[event.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  };

  // Look up the name of a key as indicated by an event object.
  var keyName = CodeMirror.keyName = function(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) return false;
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) return false;
    if (event.altKey) name = "Alt-" + name;
    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = "Ctrl-" + name;
    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = "Cmd-" + name;
    if (!noShift && event.shiftKey) name = "Shift-" + name;
    return name;
  };

  // FROMTEXTAREA

  CodeMirror.fromTextArea = function(textarea, options) {
    if (!options) options = {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabindex)
      options.tabindex = textarea.tabindex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    textarea.style.display = "none";
    var cm = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    cm.save = save;
    cm.getTextArea = function() { return textarea; };
    cm.toTextArea = function() {
      save();
      textarea.parentNode.removeChild(cm.getWrapperElement());
      textarea.style.display = "";
      if (textarea.form) {
        off(textarea.form, "submit", save);
        if (typeof textarea.form.submit == "function")
          textarea.form.submit = realSubmit;
      }
    };
    return cm;
  };

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = CodeMirror.StringStream = function(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
  };

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == this.lineStart;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    indentation: function() {
      return countColumn(this.string, null, this.tabSize) -
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);},
    hideFirstChars: function(n, inner) {
      this.lineStart += n;
      try { return inner(); }
      finally { this.lineStart -= n; }
    }
  };

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  var TextMarker = CodeMirror.TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
  };
  eventMixin(TextMarker);

  // Clear the marker.
  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) startOperation(cm);
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) signalLater(this, "clear", found.from, found.to);
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
      else if (cm) {
        if (span.to != null) max = lineNo(line);
        if (span.from != null) min = lineNo(line);
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
      var visual = visualLine(this.lines[i]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    }

    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) reCheckSelection(cm.doc);
    }
    if (cm) signalLater(cm, "markerCleared", cm, this);
    if (withOp) endOperation(cm);
    if (this.parent) this.parent.clear();
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function(side, lineObj) {
    if (side == null && this.type == "bookmark") side = 1;
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) return from;
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) return to;
      }
    }
    return from && {from: from, to: to};
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function() {
    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) return;
    runInOp(cm, function() {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          updateLineHeight(line, line.height + dHeight);
      }
    });
  };

  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) return markTextShared(doc, from, to, options, type);
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) copyObj(options, marker, false);
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      return marker;
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) marker.widgetNode.ignoreEvents = true;
      if (options.insertLeft) marker.widgetNode.insertLeft = true;
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      sawCollapsedSpans = true;
    }

    if (marker.addToHistory)
      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        updateMaxLine = true;
      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
    });

    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) cm.curOp.updateMaxLine = true;
      if (marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      else if (marker.className || marker.title || marker.startStyle || marker.endStyle)
        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
      if (marker.atomic) reCheckSelection(cm.doc);
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      markers[i].parent = this;
  };
  eventMixin(SharedTextMarker);

  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function(side, lineObj) {
    return this.primary.find(side, lineObj);
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function(doc) {
      if (widget) options.widgetNode = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent) return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
                         function(m) { return m.parent; });
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], linked = [marker.primary.doc];;
      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    }
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) return span;
    }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span) (r || (r = [])).push(spans[i]);
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    }
    return nw;
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) return null;

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) span.to = startCh;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null) span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine) (first || (first = [])).push(span);
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) first = clearEmptySpans(first);
    if (last && last != first) last = clearEmptySpans(last);

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        spans.splice(i--, 1);
    }
    if (!spans.length) return null;
    return spans;
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) return stretched;
    if (!stretched) return old;

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker) continue spans;
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
    });
    if (!markers) return null;
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          newParts.push({from: p.from, to: m.from});
        if (dto > 0 || !mk.inclusiveRight && !dto)
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) return lenDiff;
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) return -fromCmp;
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) return toCmp;
    return b.id - a.id;
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        found = sp.marker;
    }
    return found;
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) continue;
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
      if (fromCmp <= 0 && (cmp(found.to, from) || extraRight(sp.marker) - extraLeft(marker)) > 0 ||
          fromCmp >= 0 && (cmp(found.from, to) || extraLeft(sp.marker) - extraRight(marker)) < 0)
        return true;
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = merged.find(-1, true).line;
    return line;
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) return lineN;
    return lineNo(vis);
  }
  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) return lineN;
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) return lineN;
    while (merged = collapsedSpanAtEnd(line))
      line = merged.find(1, true).line;
    return lineNo(line) + 1;
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if (sp.from == null) return true;
      if (sp.marker.widgetNode) continue;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) return true;
    }
  }

  // LINE WIDGETS

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {
    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
      this[opt] = options[opt];
    this.cm = cm;
    this.node = node;
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      addToScrollPos(cm, null, diff);
  }

  LineWidget.prototype.clear = function() {
    var cm = this.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) return;
    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
    if (!ws.length) line.widgets = null;
    var height = widgetHeight(this);
    runInOp(cm, function() {
      adjustScrollWhenAboveVisible(cm, line, -height);
      regLineChange(cm, no, "widget");
      updateLineHeight(line, Math.max(0, line.height - height));
    });
  };
  LineWidget.prototype.changed = function() {
    var oldH = this.height, cm = this.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) return;
    runInOp(cm, function() {
      cm.curOp.forceUpdate = true;
      adjustScrollWhenAboveVisible(cm, line, diff);
      updateLineHeight(line, line.height + diff);
    });
  };

  function widgetHeight(widget) {
    if (widget.height != null) return widget.height;
    if (!contains(document.body, widget.node))
      removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, "position: relative"));
    return widget.height = widget.node.offsetHeight;
  }

  function addLineWidget(cm, handle, node, options) {
    var widget = new LineWidget(cm, node, options);
    if (widget.noHScroll) cm.display.alignWidgets = true;
    changeLine(cm, handle, "widget", function(line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) widgets.push(widget);
      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      widget.line = line;
      if (!lineIsHidden(cm.doc, line)) {
        var aboveVisible = heightAtLine(line) < cm.doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) addToScrollPos(cm, null, widget.height);
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    return widget;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };
  eventMixin(Line);
  Line.prototype.lineNo = function() { return lineNo(this); };

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) line.stateAfter = null;
    if (line.styles) line.styles = null;
    if (line.order != null) line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) updateLineHeight(line, estHeight);
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  function extractLineClasses(type, output) {
    if (type) for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) break;
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        output[prop] = lineClass[2];
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        output[prop] += " " + lineClass[2];
    }
    return type;
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) return mode.blankLine(state);
    if (!mode.innerMode) return;
    var inner = CodeMirror.innerMode(mode, state);
    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
  }

  function readToken(mode, stream, state) {
    for (var i = 0; i < 10; i++) {
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) return style;
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) processLine(cm, text, state, stream.pos);
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, state), lineClasses);
      }
      if (cm.options.addModeClass) {
        var mName = CodeMirror.innerMode(mode, state).mode.name;
        if (mName) style = "m-" + (style ? mName + " " + style : mName);
      }
      if (!flattenSpans || curStyle != style) {
        if (curStart < stream.start) f(stream.start, curStyle);
        curStart = stream.start; curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444 characters
      var pos = Math.min(stream.pos, curStart + 50000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, state, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
      st.push(end, style);
    }, lineClasses, forceToEnd);

    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function(end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i+1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, "cm-overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
          }
        }
      }, lineClasses);
    }

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
  }

  function getLineStyles(cm, line) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
      line.styles = result.styles;
      if (result.classes) line.styleClasses = result.classes;
      else if (line.styleClasses) line.styleClasses = null;
    }
    return line.styles;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, state, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize);
    stream.start = stream.pos = startAt || 0;
    if (text == "") callBlankLine(mode, state);
    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
      readToken(mode, stream, state);
      stream.start = stream.pos;
    }
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) return null;
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"));
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: elt("pre", [content]), content: content, col: 0, pos: 0, cm: cm};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if ((ie || webkit) && cm.getOption("lineWrapping"))
        builder.addToken = buildTokenSplitSpaces(builder.addToken);
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      builder.map = [];
      insertLineContent(line, builder, getLineStyles(cm, line));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        if (line.styleClasses.textClass)
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
    return builder;
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    return token;
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, title) {
    if (!text) return;
    var special = builder.cm.options.specialChars, mustWrap = false;
    if (!special.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(text);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie_upto8) mustWrap = true;
      builder.pos += text.length;
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(text.slice(pos, pos + skipped));
          if (ie_upto8) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) break;
        pos += skipped + 1;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          builder.col += tabWidth;
        } else {
          var txt = builder.cm.options.specialCharPlaceholder(m[0]);
          if (ie_upto8) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt);
        builder.pos++;
      }
    }
    if (style || startStyle || endStyle || mustWrap) {
      var fullStyle = style || "";
      if (startStyle) fullStyle += startStyle;
      if (endStyle) fullStyle += endStyle;
      var token = elt("span", [content], fullStyle);
      if (title) token.title = title;
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }

  function buildTokenSplitSpaces(inner) {
    function split(old) {
      var out = " ";
      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
      out += " ";
      return out;
    }
    return function(builder, text, style, startStyle, endStyle, title) {
      inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);
    };
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function(builder, text, style, startStyle, endStyle, title) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        for (var i = 0; i < order.length; i++) {
          var part = order[i];
          if (part.to > start && part.from <= start) break;
        }
        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title);
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) {
      builder.map.push(builder.pos, builder.pos + size, widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i+=2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
      return;
    }

    var len = allText.length, pos = 0, i = 1, text = "", style;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = "";
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [];
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }
            if (m.className) spanStyle += " " + m.className;
            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;
            if (m.title && !title) title = m.title;
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) foundBookmarks.push(m);
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) return;
        }
        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)
          buildCollapsedSpan(builder, 0, foundBookmarks[j]);
      }
      if (pos >= len) break;

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      for (var i = 0, added = []; i < text.length - 1; ++i)
        added.push(new Line(text[i], spansFor(i), estimateHeight));
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) doc.remove(from.line, nlines);
      if (added.length) doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        for (var added = [], i = 1; i < text.length - 1; ++i)
          added.push(new Line(text[i], spansFor(i), estimateHeight));
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      for (var i = 1, added = []; i < text.length - 1; ++i)
        added.push(new Line(text[i], spansFor(i), estimateHeight));
      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }

    signalLater(doc, "change", doc, change);
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, height = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
    },
    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);
    if (firstLine == null) firstLine = 0;

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;

    if (typeof text == "string") text = splitLines(text);
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) this.iterN(from - this.first, to - from, op);
      else this.iterN(this.first, this.first + this.size, from);
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: splitLines(code), origin: "setValue"}, true);
      setSelection(this, simpleSelection(top));
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},

    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
    getLineNumber: function(line) {return lineNo(line);},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") line = getLine(this, line);
      return visualLine(line);
    },

    lineCount: function() {return this.size;},
    firstLine: function() {return this.first;},
    lastLine: function() {return this.first + this.size - 1;},

    clipPos: function(pos) {return clipPos(this, pos);},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") pos = range.head;
      else if (start == "anchor") pos = range.anchor;
      else if (start == "end" || start == "to" || start === false) pos = range.to();
      else pos = range.from();
      return pos;
    },
    listSelections: function() { return this.sel.ranges; },
    somethingSelected: function() {return this.sel.somethingSelected();},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads, options));
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      extendSelections(this, map(this.sel.ranges, f), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) return;
      for (var i = 0, out = []; i < ranges.length; i++)
        out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head));
      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) return lines;
      else return lines.join(lineSep || "\n");
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) sel = sel.join(lineSep || "\n");
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        dup[i] = code;
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i = changes.length - 1; i >= 0; i--)
        makeChange(this, changes[i]);
      if (newSel) setSelectionReplaceHistory(this, newSel);
      else if (this.cm) ensureCursorVisible(this.cm);
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend;},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
      return {undo: done, redo: undone};
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        this.history.lastOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)};
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      return markers;
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function(line) {
        var spans = line.markedSpans;
        if (spans) for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(lineNo == from.line && from.ch > span.to ||
                span.from == null && lineNo != from.line||
                lineNo == to.line && span.from > to.ch) &&
              (!filter || filter(span.marker)))
            found.push(span.marker.parent || span.marker);
        }
        ++lineNo;
      });
      return found;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i)
          if (sps[i].from != null) markers.push(sps[i].marker);
      });
      return markers;
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first;
      this.iter(function(line) {
        var sz = line.text.length + 1;
        if (sz > off) { ch = off; return true; }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function(options) {
      if (!options) options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) from = options.from;
      if (options.to != null && options.to < to) to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist) copy.history = this.history;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) other = other.doc;
      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) continue;
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break;
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode;},
    getEditor: function() {return this.cm;}
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor".split(" ");
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments);};
    })(Doc.prototype[prop]);

  eventMixin(Doc);

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) continue;
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) throw new Error("This document is already in use.");
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) findMaxLine(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  // LINE UTILITIES

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
    for (var chunk = doc; !chunk.lines;) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) text = text.slice(0, end.ch);
      if (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function(line) { out.push(line.text); });
    return out;
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) for (var n = line; n; n = n.parent) n.height += diff;
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i = 0; i < chunk.children.length; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }


  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) break;
      else h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk) break;
        else h += cur.height;
      }
    }
    return h;
  }

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line) {
    var order = line.order;
    if (order == null) order = line.order = bidiOrdering(line.text);
    return order;
  }

  // HISTORY

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
    return histChange;
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) array.pop();
      else break;
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, ore are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        pushSelectionToHistory(doc.sel, hist.done);
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) hist.done.shift();
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) signal(doc, "historyAdded");
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      hist.done[hist.done.length - 1] = sel;
    else
      pushSelectionToHistory(sel, hist.done);

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastOp = opId;
    if (options && options.clearRedo !== false)
      clearSelectionEvents(hist.undone);
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      dest.push(sel);
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
      if (line.markedSpans)
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
      else if (out) out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        }
      }
    }
    return copy;
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // EVENT UTILITIES

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  };
  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  };
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};

  function e_target(e) {return e.target || e.srcElement;}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) b = 1;
      else if (e.button & 2) b = 3;
      else if (e.button & 4) b = 2;
    }
    if (mac && e.ctrlKey && b == 1) b = 3;
    return b;
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var on = CodeMirror.on = function(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent("on" + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  };

  var off = CodeMirror.off = function(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent("on" + type, f);
    else {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr) return;
      for (var i = 0; i < arr.length; ++i)
        if (arr[i] == f) { arr.splice(i, 1); break; }
    }
  };

  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
  };

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  var delayedCallbacks, delayedCallbackDepth = 0;
  function signalLater(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    if (!delayedCallbacks) {
      ++delayedCallbackDepth;
      delayedCallbacks = [];
      setTimeout(fireDelayed, 0);
    }
    function bnd(f) {return function(){f.apply(null, args);};};
    for (var i = 0; i < arr.length; ++i)
      delayedCallbacks.push(bnd(arr[i]));
  }

  function fireDelayed() {
    --delayedCallbackDepth;
    var delayed = delayedCallbacks;
    delayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) return;
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)
      set.push(arr[i]);
  }

  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // MISC UTILITIES

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerCutOff = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  function Delayed() {this.id = null;}
  Delayed.prototype.set = function(ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        return n + (end - i);
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  };

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) nextTab = string.length;
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        return pos + Math.min(skipped, goal - col);
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) return pos;
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + " ");
    return spaceStrs[n];
  }

  function lst(arr) { return arr[arr.length-1]; }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };
  else if (ie) // Suppress mysterious IE10 errors
    selectInput = function(node) { try { node.select(); } catch(_e) {} };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      if (array[i] == elt) return i;
    return -1;
  }
  if ([].indexOf) indexOf = function(array, elt) { return array.indexOf(elt); };
  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
    return out;
  }
  if ([].map) map = function(array, f) { return array.map(f); };

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      var ctor = function() {};
      ctor.prototype = base;
      inst = new ctor();
    }
    if (props) copyObj(props, inst);
    return inst;
  };

  function copyObj(obj, target, overwrite) {
    if (!target) target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        target[prop] = obj[prop];
    return target;
  }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args);};
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  };
  function isWordChar(ch, helper) {
    if (!helper) return isWordCharBasic(ch);
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) return true;
    return helper.test(ch);
  }

  function isEmpty(obj) {
    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
    return true;
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }

  // DOM UTILITIES

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) e.className = className;
    if (style) e.style.cssText = style;
    if (typeof content == "string") e.appendChild(document.createTextNode(content));
    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
    return e;
  }

  var range;
  if (document.createRange) range = function(node, start, end) {
    var r = document.createRange();
    r.setEnd(node, end);
    r.setStart(node, start);
    return r;
  };
  else range = function(node, start, end) {
    var r = document.body.createTextRange();
    r.moveToElementText(node.parentNode);
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r;
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  function contains(parent, child) {
    if (parent.contains)
      return parent.contains(child);
    while (child = child.parentNode)
      if (child == parent) return true;
  }

  function activeElt() { return document.activeElement; }
  // Older versions of IE throws unspecified error when touching
  // document.activeElement in some cases (during loading, in iframe)
  if (ie_upto10) activeElt = function() {
    try { return document.activeElement; }
    catch(e) { return document.body; }
  };

  function classTest(cls) { return new RegExp("\\b" + cls + "\\b\\s*"); }
  function rmClass(node, cls) {
    var test = classTest(cls);
    if (test.test(node.className)) node.className = node.className.replace(test, "");
  }
  function addClass(node, cls) {
    if (!classTest(cls).test(node.className)) node.className += " " + cls;
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];
    return b;
  }

  // WINDOW-WIDE EVENTS

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.body.getElementsByClassName) return;
    var byClass = document.body.getElementsByClassName("CodeMirror");
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) f(cm);
    }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) return;
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function() {
      if (resizeTimer == null) resizeTimer = setTimeout(function() {
        resizeTimer = null;
        knownScrollbarWidth = null;
        forEachCodeMirror(onResize);
      }, 100);
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function() {
      forEachCodeMirror(onBlur);
    });
  }

  // FEATURE DETECTION

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie_upto8) return false;
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  var knownScrollbarWidth;
  function scrollbarWidth(measure) {
    if (knownScrollbarWidth != null) return knownScrollbarWidth;
    var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");
    removeChildrenAndAdd(measure, test);
    if (test.offsetWidth)
      knownScrollbarWidth = test.offsetHeight - test.clientHeight;
    return knownScrollbarWidth || 0;
  }

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_upto7;
    }
    if (zwspSupported) return elt("span", "\u200b");
    else return elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) return badBidiRects;
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    if (r0.left == r0.right) return false;
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    return badBidiRects = (r1.right - r0.right < 3);
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLines = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) nl = string.length;
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string){return string.split(/\r\n?|\n/);};

  var hasSelection = window.getSelection ? function(te) {
    try { return te.selectionStart != te.selectionEnd; }
    catch(e) { return false; }
  } : function(te) {
    try {var range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) return false;
    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  var hasCopyEvent = (function() {
    var e = elt("div");
    if ("oncopy" in e) return true;
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  })();

  // KEY NAMES

  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
                  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 107: "=", 109: "-", 127: "Delete",
                  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
                  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
                  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"};
  CodeMirror.keyNames = keyNames;
  (function() {
    // Number keys
    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
  })();

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) return f(from, to, "ltr");
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
        found = true;
      }
    }
    if (!found) f(from, to, "ltr");
  }

  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order) return line.text.length;
    return bidiRight(lst(order));
  }

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line = getLine(cm.doc, lineN);
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      lineN = null;
    }
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN == null ? lineNo(line) : lineN, ch);
  }

  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir) return true;
    if (b == linedir) return false;
    return a < b;
  }
  var bidiOther;
  function getBidiPartAt(order, pos) {
    bidiOther = null;
    for (var i = 0, found; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos) return i;
      if ((cur.from == pos || cur.to == pos)) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          if (cur.from != cur.to) bidiOther = found;
          return i;
        } else {
          if (cur.from != cur.to) bidiOther = i;
          return found;
        }
      }
    }
    return found;
  }

  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit) return pos + dir;
    do pos += dir;
    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
    return pos;
  }

  // This is needed in order to move 'visually' through bi-directional
  // text -- i.e., pressing left should make the cursor go left, even
  // when in RTL text. The tricky part is the 'jumps', where RTL and
  // LTR text touch each other. This often requires the cursor offset
  // to move more than one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi) return moveLogically(line, start, dir, byUnit);
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

    for (;;) {
      if (target > part.from && target < part.to) return target;
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos) return target;
        part = bidi[pos += dir];
        return (dir > 0) == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part) return null;
        if ((dir > 0) == part.level % 2)
          target = moveInLine(line, part.to, -1, byUnit);
        else
          target = moveInLine(line, part.from, 1, byUnit);
      }
    }
  }

  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6ff
    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
    function charType(code) {
      if (code <= 0xf7) return lowTypes.charAt(code);
      else if (0x590 <= code && code <= 0x5f4) return "R";
      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);
      else if (0x6ee <= code && code <= 0x8ac) return "r";
      else if (0x2000 <= code && code <= 0x200b) return "w";
      else if (code == 0x200c) return "b";
      else return "L";
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    // Browsers seem to always treat the boundaries of block elements as being L.
    var outerType = "L";

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str) {
      if (!bidiRE.test(str)) return false;
      var len = str.length, types = [];
      for (var i = 0, type; i < len; ++i)
        types.push(type = charType(str.charCodeAt(i)));

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i = 0, prev = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "m") types[i] = prev;
        else prev = type;
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "1" && cur == "r") types[i] = "n";
        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
        var type = types[i];
        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
        else if (type == "," && prev == types[i+1] &&
                 (prev == "1" || prev == "n")) types[i] = prev;
        prev = type;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type == ",") types[i] = "N";
        else if (type == "%") {
          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (cur == "L" && type == "1") types[i] = "L";
        else if (isStrong.test(type)) cur = type;
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i = 0; i < len; ++i) {
        if (isNeutral.test(types[i])) {
          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
          var before = (i ? types[i-1] : outerType) == "L";
          var after = (end < len ? types[end] : outerType) == "L";
          var replace = before || after ? "L" : "R";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i = 0; i < len;) {
        if (countsAsLeft.test(types[i])) {
          var start = i;
          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
          order.push(new BidiSpan(0, start, i));
        } else {
          var pos = i, at = order.length;
          for (++i; i < len && types[i] != "L"; ++i) {}
          for (var j = pos; j < i;) {
            if (countsAsNum.test(types[j])) {
              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));
              var nstart = j;
              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j));
              pos = j;
            } else ++j;
          }
          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));
        }
      }
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift(new BidiSpan(0, 0, m[0].length));
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push(new BidiSpan(0, len - m[0].length, len));
      }
      if (order[0].level != lst(order).level)
        order.push(new BidiSpan(order[0].level, len, len));

      return order;
    };
  })();

  // THE END

  CodeMirror.version = "4.2.0";

  return CodeMirror;
});

},
'codemirror/addon/search/search':function(){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// Define search commands. Depends on dialog.js or another
// implementation of the openDialog method.

// Replace works a little oddly -- it will do the replace on the next
// Ctrl-G (or whatever is bound to findNext) press. You prevent a
// replace by making sure the match is no longer selected when hitting
// Ctrl-G.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("./searchcursor"), require("../dialog/dialog"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "./searchcursor", "../dialog/dialog"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";
  function searchOverlay(query, caseInsensitive) {
    if (typeof query == "string")
      query = new RegExp(query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), caseInsensitive ? "gi" : "g");
    else if (!query.global)
      query = new RegExp(query.source, query.ignoreCase ? "gi" : "g");

    return {token: function(stream) {
      query.lastIndex = stream.pos;
      var match = query.exec(stream.string);
      if (match && match.index == stream.pos) {
        stream.pos += match[0].length;
        return "searching";
      } else if (match) {
        stream.pos = match.index;
      } else {
        stream.skipToEnd();
      }
    }};
  }

  function SearchState() {
    this.posFrom = this.posTo = this.query = null;
    this.overlay = null;
  }
  function getSearchState(cm) {
    return cm.state.search || (cm.state.search = new SearchState());
  }
  function queryCaseInsensitive(query) {
    return typeof query == "string" && query == query.toLowerCase();
  }
  function getSearchCursor(cm, query, pos) {
    // Heuristic: if the query string is all lowercase, do a case insensitive search.
    return cm.getSearchCursor(query, pos, queryCaseInsensitive(query));
  }
  function dialog(cm, text, shortText, deflt, f) {
    if (cm.openDialog) cm.openDialog(text, f, {value: deflt});
    else f(prompt(shortText, deflt));
  }
  function confirmDialog(cm, text, shortText, fs) {
    if (cm.openConfirm) cm.openConfirm(text, fs);
    else if (confirm(shortText)) fs[0]();
  }
  function parseQuery(query) {
    var isRE = query.match(/^\/(.*)\/([a-z]*)$/);
    if (isRE) {
      query = new RegExp(isRE[1], isRE[2].indexOf("i") == -1 ? "" : "i");
      if (query.test("")) query = /x^/;
    } else if (query == "") {
      query = /x^/;
    }
    return query;
  }
  var queryDialog =
    'Search: <input type="text" style="width: 10em"/> <span style="color: #888">(Use /re/ syntax for regexp search)</span>';
  function doSearch(cm, rev) {
    var state = getSearchState(cm);
    if (state.query) return findNext(cm, rev);
    dialog(cm, queryDialog, "Search for:", cm.getSelection(), function(query) {
      cm.operation(function() {
        if (!query || state.query) return;
        state.query = parseQuery(query);
        cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));
        state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));
        cm.addOverlay(state.overlay);
        state.posFrom = state.posTo = cm.getCursor();
        findNext(cm, rev);
      });
    });
  }
  function findNext(cm, rev) {cm.operation(function() {
    var state = getSearchState(cm);
    var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);
    if (!cursor.find(rev)) {
      cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));
      if (!cursor.find(rev)) return;
    }
    cm.setSelection(cursor.from(), cursor.to());
    cm.scrollIntoView({from: cursor.from(), to: cursor.to()});
    state.posFrom = cursor.from(); state.posTo = cursor.to();
  });}
  function clearSearch(cm) {cm.operation(function() {
    var state = getSearchState(cm);
    if (!state.query) return;
    state.query = null;
    cm.removeOverlay(state.overlay);
  });}

  var replaceQueryDialog =
    'Replace: <input type="text" style="width: 10em"/> <span style="color: #888">(Use /re/ syntax for regexp search)</span>';
  var replacementQueryDialog = 'With: <input type="text" style="width: 10em"/>';
  var doReplaceConfirm = "Replace? <button>Yes</button> <button>No</button> <button>Stop</button>";
  function replace(cm, all) {
    dialog(cm, replaceQueryDialog, "Replace:", cm.getSelection(), function(query) {
      if (!query) return;
      query = parseQuery(query);
      dialog(cm, replacementQueryDialog, "Replace with:", "", function(text) {
        if (all) {
          cm.operation(function() {
            for (var cursor = getSearchCursor(cm, query); cursor.findNext();) {
              if (typeof query != "string") {
                var match = cm.getRange(cursor.from(), cursor.to()).match(query);
                cursor.replace(text.replace(/\$(\d)/g, function(_, i) {return match[i];}));
              } else cursor.replace(text);
            }
          });
        } else {
          clearSearch(cm);
          var cursor = getSearchCursor(cm, query, cm.getCursor());
          var advance = function() {
            var start = cursor.from(), match;
            if (!(match = cursor.findNext())) {
              cursor = getSearchCursor(cm, query);
              if (!(match = cursor.findNext()) ||
                  (start && cursor.from().line == start.line && cursor.from().ch == start.ch)) return;
            }
            cm.setSelection(cursor.from(), cursor.to());
            cm.scrollIntoView({from: cursor.from(), to: cursor.to()});
            confirmDialog(cm, doReplaceConfirm, "Replace?",
                          [function() {doReplace(match);}, advance]);
          };
          var doReplace = function(match) {
            cursor.replace(typeof query == "string" ? text :
                           text.replace(/\$(\d)/g, function(_, i) {return match[i];}));
            advance();
          };
          advance();
        }
      });
    });
  }

  CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};
  CodeMirror.commands.findNext = doSearch;
  CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};
  CodeMirror.commands.clearSearch = clearSearch;
  CodeMirror.commands.replace = replace;
  CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};
});

},
'codemirror/addon/search/searchcursor':function(){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";
  var Pos = CodeMirror.Pos;

  function SearchCursor(doc, query, pos, caseFold) {
    this.atOccurrence = false; this.doc = doc;
    if (caseFold == null && typeof query == "string") caseFold = false;

    pos = pos ? doc.clipPos(pos) : Pos(0, 0);
    this.pos = {from: pos, to: pos};

    // The matches method is filled in based on the type of query.
    // It takes a position and a direction, and returns an object
    // describing the next occurrence of the query, or null if no
    // more matches were found.
    if (typeof query != "string") { // Regexp match
      if (!query.global) query = new RegExp(query.source, query.ignoreCase ? "ig" : "g");
      this.matches = function(reverse, pos) {
        if (reverse) {
          query.lastIndex = 0;
          var line = doc.getLine(pos.line).slice(0, pos.ch), cutOff = 0, match, start;
          for (;;) {
            query.lastIndex = cutOff;
            var newMatch = query.exec(line);
            if (!newMatch) break;
            match = newMatch;
            start = match.index;
            cutOff = match.index + (match[0].length || 1);
            if (cutOff == line.length) break;
          }
          var matchLen = (match && match[0].length) || 0;
          if (!matchLen) {
            if (start == 0 && line.length == 0) {match = undefined;}
            else if (start != doc.getLine(pos.line).length) {
              matchLen++;
            }
          }
        } else {
          query.lastIndex = pos.ch;
          var line = doc.getLine(pos.line), match = query.exec(line);
          var matchLen = (match && match[0].length) || 0;
          var start = match && match.index;
          if (start + matchLen != line.length && !matchLen) matchLen = 1;
        }
        if (match && matchLen)
          return {from: Pos(pos.line, start),
                  to: Pos(pos.line, start + matchLen),
                  match: match};
      };
    } else { // String query
      var origQuery = query;
      if (caseFold) query = query.toLowerCase();
      var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};
      var target = query.split("\n");
      // Different methods for single-line and multi-line queries
      if (target.length == 1) {
        if (!query.length) {
          // Empty string would match anything and never progress, so
          // we define it to match nothing instead.
          this.matches = function() {};
        } else {
          this.matches = function(reverse, pos) {
            if (reverse) {
              var orig = doc.getLine(pos.line).slice(0, pos.ch), line = fold(orig);
              var match = line.lastIndexOf(query);
              if (match > -1) {
                match = adjustPos(orig, line, match);
                return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};
              }
             } else {
               var orig = doc.getLine(pos.line).slice(pos.ch), line = fold(orig);
               var match = line.indexOf(query);
               if (match > -1) {
                 match = adjustPos(orig, line, match) + pos.ch;
                 return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};
               }
            }
          };
        }
      } else {
        var origTarget = origQuery.split("\n");
        this.matches = function(reverse, pos) {
          var last = target.length - 1;
          if (reverse) {
            if (pos.line - (target.length - 1) < doc.firstLine()) return;
            if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;
            var to = Pos(pos.line, origTarget[last].length);
            for (var ln = pos.line - 1, i = last - 1; i >= 1; --i, --ln)
              if (target[i] != fold(doc.getLine(ln))) return;
            var line = doc.getLine(ln), cut = line.length - origTarget[0].length;
            if (fold(line.slice(cut)) != target[0]) return;
            return {from: Pos(ln, cut), to: to};
          } else {
            if (pos.line + (target.length - 1) > doc.lastLine()) return;
            var line = doc.getLine(pos.line), cut = line.length - origTarget[0].length;
            if (fold(line.slice(cut)) != target[0]) return;
            var from = Pos(pos.line, cut);
            for (var ln = pos.line + 1, i = 1; i < last; ++i, ++ln)
              if (target[i] != fold(doc.getLine(ln))) return;
            if (doc.getLine(ln).slice(0, origTarget[last].length) != target[last]) return;
            return {from: from, to: Pos(ln, origTarget[last].length)};
          }
        };
      }
    }
  }

  SearchCursor.prototype = {
    findNext: function() {return this.find(false);},
    findPrevious: function() {return this.find(true);},

    find: function(reverse) {
      var self = this, pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);
      function savePosAndFail(line) {
        var pos = Pos(line, 0);
        self.pos = {from: pos, to: pos};
        self.atOccurrence = false;
        return false;
      }

      for (;;) {
        if (this.pos = this.matches(reverse, pos)) {
          this.atOccurrence = true;
          return this.pos.match || true;
        }
        if (reverse) {
          if (!pos.line) return savePosAndFail(0);
          pos = Pos(pos.line-1, this.doc.getLine(pos.line-1).length);
        }
        else {
          var maxLine = this.doc.lineCount();
          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);
          pos = Pos(pos.line + 1, 0);
        }
      }
    },

    from: function() {if (this.atOccurrence) return this.pos.from;},
    to: function() {if (this.atOccurrence) return this.pos.to;},

    replace: function(newText) {
      if (!this.atOccurrence) return;
      var lines = CodeMirror.splitLines(newText);
      this.doc.replaceRange(lines, this.pos.from, this.pos.to);
      this.pos.to = Pos(this.pos.from.line + lines.length - 1,
                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));
    }
  };

  // Maps a position in a case-folded line back to a position in the original line
  // (compensating for codepoints increasing in number during folding)
  function adjustPos(orig, folded, pos) {
    if (orig.length == folded.length) return pos;
    for (var pos1 = Math.min(pos, orig.length);;) {
      var len1 = orig.slice(0, pos1).toLowerCase().length;
      if (len1 < pos) ++pos1;
      else if (len1 > pos) --pos1;
      else return pos1;
    }
  }

  CodeMirror.defineExtension("getSearchCursor", function(query, pos, caseFold) {
    return new SearchCursor(this.doc, query, pos, caseFold);
  });
  CodeMirror.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {
    return new SearchCursor(this, query, pos, caseFold);
  });

  CodeMirror.defineExtension("selectMatches", function(query, caseFold) {
    var ranges = [], next;
    var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);
    while (next = cur.findNext()) {
      if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break;
      ranges.push({anchor: cur.from(), head: cur.to()});
    }
    if (ranges.length)
      this.setSelections(ranges, 0);
  });
});

},
'codemirror/addon/dialog/dialog':function(){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// Open simple dialogs on top of an editor. Relies on dialog.css.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  function dialogDiv(cm, template, bottom) {
    var wrap = cm.getWrapperElement();
    var dialog;
    dialog = wrap.appendChild(document.createElement("div"));
    if (bottom) {
      dialog.className = "CodeMirror-dialog CodeMirror-dialog-bottom";
    } else {
      dialog.className = "CodeMirror-dialog CodeMirror-dialog-top";
    }
    if (typeof template == "string") {
      dialog.innerHTML = template;
    } else { // Assuming it's a detached DOM element.
      dialog.appendChild(template);
    }
    return dialog;
  }

  function closeNotification(cm, newVal) {
    if (cm.state.currentNotificationClose)
      cm.state.currentNotificationClose();
    cm.state.currentNotificationClose = newVal;
  }

  CodeMirror.defineExtension("openDialog", function(template, callback, options) {
    closeNotification(this, null);
    var dialog = dialogDiv(this, template, options && options.bottom);
    var closed = false, me = this;
    function close() {
      if (closed) return;
      closed = true;
      dialog.parentNode.removeChild(dialog);
    }
    var inp = dialog.getElementsByTagName("input")[0], button;
    if (inp) {
      if (options && options.value) inp.value = options.value;
      CodeMirror.on(inp, "keydown", function(e) {
        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }
        if (e.keyCode == 13 || e.keyCode == 27) {
          inp.blur();
          CodeMirror.e_stop(e);
          close();
          me.focus();
          if (e.keyCode == 13) callback(inp.value);
        }
      });
      if (options && options.onKeyUp) {
        CodeMirror.on(inp, "keyup", function(e) {options.onKeyUp(e, inp.value, close);});
      }
      if (options && options.value) inp.value = options.value;
      inp.focus();
      CodeMirror.on(inp, "blur", close);
    } else if (button = dialog.getElementsByTagName("button")[0]) {
      CodeMirror.on(button, "click", function() {
        close();
        me.focus();
      });
      button.focus();
      CodeMirror.on(button, "blur", close);
    }
    return close;
  });

  CodeMirror.defineExtension("openConfirm", function(template, callbacks, options) {
    closeNotification(this, null);
    var dialog = dialogDiv(this, template, options && options.bottom);
    var buttons = dialog.getElementsByTagName("button");
    var closed = false, me = this, blurring = 1;
    function close() {
      if (closed) return;
      closed = true;
      dialog.parentNode.removeChild(dialog);
      me.focus();
    }
    buttons[0].focus();
    for (var i = 0; i < buttons.length; ++i) {
      var b = buttons[i];
      (function(callback) {
        CodeMirror.on(b, "click", function(e) {
          CodeMirror.e_preventDefault(e);
          close();
          if (callback) callback(me);
        });
      })(callbacks[i]);
      CodeMirror.on(b, "blur", function() {
        --blurring;
        setTimeout(function() { if (blurring <= 0) close(); }, 200);
      });
      CodeMirror.on(b, "focus", function() { ++blurring; });
    }
  });

  /*
   * openNotification
   * Opens a notification, that can be closed with an optional timer
   * (default 5000ms timer) and always closes on click.
   *
   * If a notification is opened while another is opened, it will close the
   * currently opened one and open the new one immediately.
   */
  CodeMirror.defineExtension("openNotification", function(template, options) {
    closeNotification(this, close);
    var dialog = dialogDiv(this, template, options && options.bottom);
    var duration = options && (options.duration === undefined ? 5000 : options.duration);
    var closed = false, doneTimer;

    function close() {
      if (closed) return;
      closed = true;
      clearTimeout(doneTimer);
      dialog.parentNode.removeChild(dialog);
    }

    CodeMirror.on(dialog, 'click', function(e) {
      CodeMirror.e_preventDefault(e);
      close();
    });
    if (duration)
      doneTimer = setTimeout(close, options.duration);
  });
});

},
'codemirror/addon/edit/closetag':function(){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

/**
 * Tag-closer extension for CodeMirror.
 *
 * This extension adds an "autoCloseTags" option that can be set to
 * either true to get the default behavior, or an object to further
 * configure its behavior.
 *
 * These are supported options:
 *
 * `whenClosing` (default true)
 *   Whether to autoclose when the '/' of a closing tag is typed.
 * `whenOpening` (default true)
 *   Whether to autoclose the tag when the final '>' of an opening
 *   tag is typed.
 * `dontCloseTags` (default is empty tags for HTML, none for XML)
 *   An array of tag names that should not be autoclosed.
 * `indentTags` (default is block tags for HTML, none for XML)
 *   An array of tag names that should, when opened, cause a
 *   blank line to be added inside the tag, and the blank line and
 *   closing line to be indented.
 *
 * See demos/closetag.html for a usage example.
 */

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("../fold/xml-fold"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "../fold/xml-fold"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  CodeMirror.defineOption("autoCloseTags", false, function(cm, val, old) {
    if (old != CodeMirror.Init && old)
      cm.removeKeyMap("autoCloseTags");
    if (!val) return;
    var map = {name: "autoCloseTags"};
    if (typeof val != "object" || val.whenClosing)
      map["'/'"] = function(cm) { return autoCloseSlash(cm); };
    if (typeof val != "object" || val.whenOpening)
      map["'>'"] = function(cm) { return autoCloseGT(cm); };
    cm.addKeyMap(map);
  });

  var htmlDontClose = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param",
                       "source", "track", "wbr"];
  var htmlIndent = ["applet", "blockquote", "body", "button", "div", "dl", "fieldset", "form", "frameset", "h1", "h2", "h3", "h4",
                    "h5", "h6", "head", "html", "iframe", "layer", "legend", "object", "ol", "p", "select", "table", "ul"];

  function autoCloseGT(cm) {
    if (cm.getOption("disableInput")) return CodeMirror.Pass;
    var ranges = cm.listSelections(), replacements = [];
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var pos = ranges[i].head, tok = cm.getTokenAt(pos);
      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;
      if (inner.mode.name != "xml" || !state.tagName) return CodeMirror.Pass;

      var opt = cm.getOption("autoCloseTags"), html = inner.mode.configuration == "html";
      var dontCloseTags = (typeof opt == "object" && opt.dontCloseTags) || (html && htmlDontClose);
      var indentTags = (typeof opt == "object" && opt.indentTags) || (html && htmlIndent);

      var tagName = state.tagName;
      if (tok.end > pos.ch) tagName = tagName.slice(0, tagName.length - tok.end + pos.ch);
      var lowerTagName = tagName.toLowerCase();
      // Don't process the '>' at the end of an end-tag or self-closing tag
      if (!tagName ||
          tok.type == "string" && (tok.end != pos.ch || !/[\"\']/.test(tok.string.charAt(tok.string.length - 1)) || tok.string.length == 1) ||
          tok.type == "tag" && state.type == "closeTag" ||
          tok.string.indexOf("/") == (tok.string.length - 1) || // match something like <someTagName />
          dontCloseTags && indexOf(dontCloseTags, lowerTagName) > -1 ||
          closingTagExists(cm, tagName, pos, state, true))
        return CodeMirror.Pass;

      var indent = indentTags && indexOf(indentTags, lowerTagName) > -1;
      replacements[i] = {indent: indent,
                         text: ">" + (indent ? "\n\n" : "") + "</" + tagName + ">",
                         newPos: indent ? CodeMirror.Pos(pos.line + 1, 0) : CodeMirror.Pos(pos.line, pos.ch + 1)};
    }

    for (var i = ranges.length - 1; i >= 0; i--) {
      var info = replacements[i];
      cm.replaceRange(info.text, ranges[i].head, ranges[i].anchor, "+insert");
      var sel = cm.listSelections().slice(0);
      sel[i] = {head: info.newPos, anchor: info.newPos};
      cm.setSelections(sel);
      if (info.indent) {
        cm.indentLine(info.newPos.line, null, true);
        cm.indentLine(info.newPos.line + 1, null, true);
      }
    }
  }

  function autoCloseSlash(cm) {
    if (cm.getOption("disableInput")) return CodeMirror.Pass;
    var ranges = cm.listSelections(), replacements = [];
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var pos = ranges[i].head, tok = cm.getTokenAt(pos);
      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;
      if (tok.type == "string" || tok.string.charAt(0) != "<" ||
          tok.start != pos.ch - 1 || inner.mode.name != "xml" ||
          !state.context || !state.context.tagName ||
          closingTagExists(cm, state.context.tagName, pos, state))
        return CodeMirror.Pass;
      replacements[i] = "/" + state.context.tagName + ">";
    }
    cm.replaceSelections(replacements);
  }

  function indexOf(collection, elt) {
    if (collection.indexOf) return collection.indexOf(elt);
    for (var i = 0, e = collection.length; i < e; ++i)
      if (collection[i] == elt) return i;
    return -1;
  }

  // If xml-fold is loaded, we use its functionality to try and verify
  // whether a given tag is actually unclosed.
  function closingTagExists(cm, tagName, pos, state, newTag) {
    if (!CodeMirror.scanForClosingTag) return false;
    var end = Math.min(cm.lastLine() + 1, pos.line + 500);
    var nextClose = CodeMirror.scanForClosingTag(cm, pos, null, end);
    if (!nextClose || nextClose.tag != tagName) return false;
    var cx = state.context;
    // If the immediate wrapping context contains onCx instances of
    // the same tag, a closing tag only exists if there are at least
    // that many closing tags of that type following.
    for (var onCx = newTag ? 1 : 0; cx && cx.tagName == tagName; cx = cx.prev) ++onCx;
    pos = nextClose.to;
    for (var i = 1; i < onCx; i++) {
      var next = CodeMirror.scanForClosingTag(cm, pos, null, end);
      if (!next || next.tag != tagName) return false;
      pos = next.to;
    }
    return true;
  }
});

},
'codemirror/addon/fold/xml-fold':function(){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var Pos = CodeMirror.Pos;
  function cmp(a, b) { return a.line - b.line || a.ch - b.ch; }

  var nameStartChar = "A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
  var nameChar = nameStartChar + "\-\:\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
  var xmlTagStart = new RegExp("<(/?)([" + nameStartChar + "][" + nameChar + "]*)", "g");

  function Iter(cm, line, ch, range) {
    this.line = line; this.ch = ch;
    this.cm = cm; this.text = cm.getLine(line);
    this.min = range ? range.from : cm.firstLine();
    this.max = range ? range.to - 1 : cm.lastLine();
  }

  function tagAt(iter, ch) {
    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));
    return type && /\btag\b/.test(type);
  }

  function nextLine(iter) {
    if (iter.line >= iter.max) return;
    iter.ch = 0;
    iter.text = iter.cm.getLine(++iter.line);
    return true;
  }
  function prevLine(iter) {
    if (iter.line <= iter.min) return;
    iter.text = iter.cm.getLine(--iter.line);
    iter.ch = iter.text.length;
    return true;
  }

  function toTagEnd(iter) {
    for (;;) {
      var gt = iter.text.indexOf(">", iter.ch);
      if (gt == -1) { if (nextLine(iter)) continue; else return; }
      if (!tagAt(iter, gt + 1)) { iter.ch = gt + 1; continue; }
      var lastSlash = iter.text.lastIndexOf("/", gt);
      var selfClose = lastSlash > -1 && !/\S/.test(iter.text.slice(lastSlash + 1, gt));
      iter.ch = gt + 1;
      return selfClose ? "selfClose" : "regular";
    }
  }
  function toTagStart(iter) {
    for (;;) {
      var lt = iter.ch ? iter.text.lastIndexOf("<", iter.ch - 1) : -1;
      if (lt == -1) { if (prevLine(iter)) continue; else return; }
      if (!tagAt(iter, lt + 1)) { iter.ch = lt; continue; }
      xmlTagStart.lastIndex = lt;
      iter.ch = lt;
      var match = xmlTagStart.exec(iter.text);
      if (match && match.index == lt) return match;
    }
  }

  function toNextTag(iter) {
    for (;;) {
      xmlTagStart.lastIndex = iter.ch;
      var found = xmlTagStart.exec(iter.text);
      if (!found) { if (nextLine(iter)) continue; else return; }
      if (!tagAt(iter, found.index + 1)) { iter.ch = found.index + 1; continue; }
      iter.ch = found.index + found[0].length;
      return found;
    }
  }
  function toPrevTag(iter) {
    for (;;) {
      var gt = iter.ch ? iter.text.lastIndexOf(">", iter.ch - 1) : -1;
      if (gt == -1) { if (prevLine(iter)) continue; else return; }
      if (!tagAt(iter, gt + 1)) { iter.ch = gt; continue; }
      var lastSlash = iter.text.lastIndexOf("/", gt);
      var selfClose = lastSlash > -1 && !/\S/.test(iter.text.slice(lastSlash + 1, gt));
      iter.ch = gt + 1;
      return selfClose ? "selfClose" : "regular";
    }
  }

  function findMatchingClose(iter, tag) {
    var stack = [];
    for (;;) {
      var next = toNextTag(iter), end, startLine = iter.line, startCh = iter.ch - (next ? next[0].length : 0);
      if (!next || !(end = toTagEnd(iter))) return;
      if (end == "selfClose") continue;
      if (next[1]) { // closing tag
        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == next[2]) {
          stack.length = i;
          break;
        }
        if (i < 0 && (!tag || tag == next[2])) return {
          tag: next[2],
          from: Pos(startLine, startCh),
          to: Pos(iter.line, iter.ch)
        };
      } else { // opening tag
        stack.push(next[2]);
      }
    }
  }
  function findMatchingOpen(iter, tag) {
    var stack = [];
    for (;;) {
      var prev = toPrevTag(iter);
      if (!prev) return;
      if (prev == "selfClose") { toTagStart(iter); continue; }
      var endLine = iter.line, endCh = iter.ch;
      var start = toTagStart(iter);
      if (!start) return;
      if (start[1]) { // closing tag
        stack.push(start[2]);
      } else { // opening tag
        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == start[2]) {
          stack.length = i;
          break;
        }
        if (i < 0 && (!tag || tag == start[2])) return {
          tag: start[2],
          from: Pos(iter.line, iter.ch),
          to: Pos(endLine, endCh)
        };
      }
    }
  }

  CodeMirror.registerHelper("fold", "xml", function(cm, start) {
    var iter = new Iter(cm, start.line, 0);
    for (;;) {
      var openTag = toNextTag(iter), end;
      if (!openTag || iter.line != start.line || !(end = toTagEnd(iter))) return;
      if (!openTag[1] && end != "selfClose") {
        var start = Pos(iter.line, iter.ch);
        var close = findMatchingClose(iter, openTag[2]);
        return close && {from: start, to: close.from};
      }
    }
  });
  CodeMirror.findMatchingTag = function(cm, pos, range) {
    var iter = new Iter(cm, pos.line, pos.ch, range);
    if (iter.text.indexOf(">") == -1 && iter.text.indexOf("<") == -1) return;
    var end = toTagEnd(iter), to = end && Pos(iter.line, iter.ch);
    var start = end && toTagStart(iter);
    if (!end || end == "selfClose" || !start || cmp(iter, pos) > 0) return;
    var here = {from: Pos(iter.line, iter.ch), to: to, tag: start[2]};

    if (start[1]) { // closing tag
      return {open: findMatchingOpen(iter, start[2]), close: here, at: "close"};
    } else { // opening tag
      iter = new Iter(cm, to.line, to.ch, range);
      return {open: here, close: findMatchingClose(iter, start[2]), at: "open"};
    }
  };

  CodeMirror.findEnclosingTag = function(cm, pos, range) {
    var iter = new Iter(cm, pos.line, pos.ch, range);
    for (;;) {
      var open = findMatchingOpen(iter);
      if (!open) break;
      var forward = new Iter(cm, pos.line, pos.ch, range);
      var close = findMatchingClose(forward, open.tag);
      if (close) return {open: open, close: close};
    }
  };

  // Used by addon/edit/closetag.js
  CodeMirror.scanForClosingTag = function(cm, pos, name, end) {
    var iter = new Iter(cm, pos.line, pos.ch, end ? {from: 0, to: end} : null);
    return findMatchingClose(iter, name);
  };
});

},
'codemirror/addon/edit/matchtags':function(){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("../fold/xml-fold"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "../fold/xml-fold"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineOption("matchTags", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.off("cursorActivity", doMatchTags);
      cm.off("viewportChange", maybeUpdateMatch);
      clear(cm);
    }
    if (val) {
      cm.state.matchBothTags = typeof val == "object" && val.bothTags;
      cm.on("cursorActivity", doMatchTags);
      cm.on("viewportChange", maybeUpdateMatch);
      doMatchTags(cm);
    }
  });

  function clear(cm) {
    if (cm.state.tagHit) cm.state.tagHit.clear();
    if (cm.state.tagOther) cm.state.tagOther.clear();
    cm.state.tagHit = cm.state.tagOther = null;
  }

  function doMatchTags(cm) {
    cm.state.failedTagMatch = false;
    cm.operation(function() {
      clear(cm);
      if (cm.somethingSelected()) return;
      var cur = cm.getCursor(), range = cm.getViewport();
      range.from = Math.min(range.from, cur.line); range.to = Math.max(cur.line + 1, range.to);
      var match = CodeMirror.findMatchingTag(cm, cur, range);
      if (!match) return;
      if (cm.state.matchBothTags) {
        var hit = match.at == "open" ? match.open : match.close;
        if (hit) cm.state.tagHit = cm.markText(hit.from, hit.to, {className: "CodeMirror-matchingtag"});
      }
      var other = match.at == "close" ? match.open : match.close;
      if (other)
        cm.state.tagOther = cm.markText(other.from, other.to, {className: "CodeMirror-matchingtag"});
      else
        cm.state.failedTagMatch = true;
    });
  }

  function maybeUpdateMatch(cm) {
    if (cm.state.failedTagMatch) doMatchTags(cm);
  }

  CodeMirror.commands.toMatchingTag = function(cm) {
    var found = CodeMirror.findMatchingTag(cm, cm.getCursor());
    if (found) {
      var other = found.at == "close" ? found.open : found.close;
      if (other) cm.extendSelection(other.to, other.from);
    }
  };
});

},
'codemirror/mode/htmlmixed/htmlmixed':function(){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("../xml/xml"), require("../javascript/javascript"), require("../css/css"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript", "../css/css"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("htmlmixed", function(config, parserConfig) {
  var htmlMode = CodeMirror.getMode(config, {name: "xml",
                                             htmlMode: true,
                                             multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
                                             multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag});
  var cssMode = CodeMirror.getMode(config, "css");

  var scriptTypes = [], scriptTypesConf = parserConfig && parserConfig.scriptTypes;
  scriptTypes.push({matches: /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^$/i,
                    mode: CodeMirror.getMode(config, "javascript")});
  if (scriptTypesConf) for (var i = 0; i < scriptTypesConf.length; ++i) {
    var conf = scriptTypesConf[i];
    scriptTypes.push({matches: conf.matches, mode: conf.mode && CodeMirror.getMode(config, conf.mode)});
  }
  scriptTypes.push({matches: /./,
                    mode: CodeMirror.getMode(config, "text/plain")});

  function html(stream, state) {
    var tagName = state.htmlState.tagName;
    var style = htmlMode.token(stream, state.htmlState);
    if (tagName == "script" && /\btag\b/.test(style) && stream.current() == ">") {
      // Script block: mode to change to depends on type attribute
      var scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\btype\s*=\s*("[^"]+"|'[^']+'|\S+)[^<]*$/i);
      scriptType = scriptType ? scriptType[1] : "";
      if (scriptType && /[\"\']/.test(scriptType.charAt(0))) scriptType = scriptType.slice(1, scriptType.length - 1);
      for (var i = 0; i < scriptTypes.length; ++i) {
        var tp = scriptTypes[i];
        if (typeof tp.matches == "string" ? scriptType == tp.matches : tp.matches.test(scriptType)) {
          if (tp.mode) {
            state.token = script;
            state.localMode = tp.mode;
            state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, ""));
          }
          break;
        }
      }
    } else if (tagName == "style" && /\btag\b/.test(style) && stream.current() == ">") {
      state.token = css;
      state.localMode = cssMode;
      state.localState = cssMode.startState(htmlMode.indent(state.htmlState, ""));
    }
    return style;
  }
  function maybeBackup(stream, pat, style) {
    var cur = stream.current();
    var close = cur.search(pat), m;
    if (close > -1) stream.backUp(cur.length - close);
    else if (m = cur.match(/<\/?$/)) {
      stream.backUp(cur.length);
      if (!stream.match(pat, false)) stream.match(cur);
    }
    return style;
  }
  function script(stream, state) {
    if (stream.match(/^<\/\s*script\s*>/i, false)) {
      state.token = html;
      state.localState = state.localMode = null;
      return html(stream, state);
    }
    return maybeBackup(stream, /<\/\s*script\s*>/,
                       state.localMode.token(stream, state.localState));
  }
  function css(stream, state) {
    if (stream.match(/^<\/\s*style\s*>/i, false)) {
      state.token = html;
      state.localState = state.localMode = null;
      return html(stream, state);
    }
    return maybeBackup(stream, /<\/\s*style\s*>/,
                       cssMode.token(stream, state.localState));
  }

  return {
    startState: function() {
      var state = htmlMode.startState();
      return {token: html, localMode: null, localState: null, htmlState: state};
    },

    copyState: function(state) {
      if (state.localState)
        var local = CodeMirror.copyState(state.localMode, state.localState);
      return {token: state.token, localMode: state.localMode, localState: local,
              htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
    },

    token: function(stream, state) {
      return state.token(stream, state);
    },

    indent: function(state, textAfter) {
      if (!state.localMode || /^\s*<\//.test(textAfter))
        return htmlMode.indent(state.htmlState, textAfter);
      else if (state.localMode.indent)
        return state.localMode.indent(state.localState, textAfter);
      else
        return CodeMirror.Pass;
    },

    innerMode: function(state) {
      return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
    }
  };
}, "xml", "javascript", "css");

CodeMirror.defineMIME("text/html", "htmlmixed");

});

},
'codemirror/mode/xml/xml':function(){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("xml", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;
  var multilineTagIndentPastTag = parserConfig.multilineTagIndentPastTag;
  if (multilineTagIndentPastTag == null) multilineTagIndentPastTag = true;

  var Kludges = parserConfig.htmlMode ? {
    autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
                      'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
                      'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
                      'track': true, 'wbr': true},
    implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
                       'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
                       'th': true, 'tr': true},
    contextGrabbers: {
      'dd': {'dd': true, 'dt': true},
      'dt': {'dd': true, 'dt': true},
      'li': {'li': true},
      'option': {'option': true, 'optgroup': true},
      'optgroup': {'optgroup': true},
      'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
            'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
            'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
            'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
            'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
      'rp': {'rp': true, 'rt': true},
      'rt': {'rp': true, 'rt': true},
      'tbody': {'tbody': true, 'tfoot': true},
      'td': {'td': true, 'th': true},
      'tfoot': {'tbody': true},
      'th': {'td': true, 'th': true},
      'thead': {'tbody': true, 'tfoot': true},
      'tr': {'tr': true}
    },
    doNotIndent: {"pre": true},
    allowUnquoted: true,
    allowMissing: true,
    caseFold: true
  } : {
    autoSelfClosers: {},
    implicitlyClosed: {},
    contextGrabbers: {},
    doNotIndent: {},
    allowUnquoted: false,
    allowMissing: false,
    caseFold: false
  };
  var alignCDATA = parserConfig.alignCDATA;

  // Return variables for tokenizers
  var type, setStyle;

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var ch = stream.next();
    if (ch == "<") {
      if (stream.eat("!")) {
        if (stream.eat("[")) {
          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
          else return null;
        } else if (stream.match("--")) {
          return chain(inBlock("comment", "-->"));
        } else if (stream.match("DOCTYPE", true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else {
          return null;
        }
      } else if (stream.eat("?")) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock("meta", "?>");
        return "meta";
      } else {
        type = stream.eat("/") ? "closeTag" : "openTag";
        state.tokenize = inTag;
        return "tag bracket";
      }
    } else if (ch == "&") {
      var ok;
      if (stream.eat("#")) {
        if (stream.eat("x")) {
          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
        } else {
          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
      }
      return ok ? "atom" : "error";
    } else {
      stream.eatWhile(/[^&<]/);
      return null;
    }
  }

  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
      state.tokenize = inText;
      type = ch == ">" ? "endTag" : "selfcloseTag";
      return "tag bracket";
    } else if (ch == "=") {
      type = "equals";
      return null;
    } else if (ch == "<") {
      state.tokenize = inText;
      state.state = baseState;
      state.tagName = state.tagStart = null;
      var next = state.tokenize(stream, state);
      return next ? next + " tag error" : "tag error";
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      state.stringStartCol = stream.column();
      return state.tokenize(stream, state);
    } else {
      stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
      return "word";
    }
  }

  function inAttribute(quote) {
    var closure = function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return "string";
    };
    closure.isInAttribute = true;
    return closure;
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    };
  }
  function doctype(depth) {
    return function(stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == "<") {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == ">") {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return "meta";
    };
  }

  function Context(state, tagName, startOfLine) {
    this.prev = state.context;
    this.tagName = tagName;
    this.indent = state.indented;
    this.startOfLine = startOfLine;
    if (Kludges.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
      this.noIndent = true;
  }
  function popContext(state) {
    if (state.context) state.context = state.context.prev;
  }
  function maybePopContext(state, nextTagName) {
    var parentTagName;
    while (true) {
      if (!state.context) {
        return;
      }
      parentTagName = state.context.tagName;
      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) ||
          !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
        return;
      }
      popContext(state);
    }
  }

  function baseState(type, stream, state) {
    if (type == "openTag") {
      state.tagStart = stream.column();
      return tagNameState;
    } else if (type == "closeTag") {
      return closeTagNameState;
    } else {
      return baseState;
    }
  }
  function tagNameState(type, stream, state) {
    if (type == "word") {
      state.tagName = stream.current();
      setStyle = "tag";
      return attrState;
    } else {
      setStyle = "error";
      return tagNameState;
    }
  }
  function closeTagNameState(type, stream, state) {
    if (type == "word") {
      var tagName = stream.current();
      if (state.context && state.context.tagName != tagName &&
          Kludges.implicitlyClosed.hasOwnProperty(state.context.tagName))
        popContext(state);
      if (state.context && state.context.tagName == tagName) {
        setStyle = "tag";
        return closeState;
      } else {
        setStyle = "tag error";
        return closeStateErr;
      }
    } else {
      setStyle = "error";
      return closeStateErr;
    }
  }

  function closeState(type, _stream, state) {
    if (type != "endTag") {
      setStyle = "error";
      return closeState;
    }
    popContext(state);
    return baseState;
  }
  function closeStateErr(type, stream, state) {
    setStyle = "error";
    return closeState(type, stream, state);
  }

  function attrState(type, _stream, state) {
    if (type == "word") {
      setStyle = "attribute";
      return attrEqState;
    } else if (type == "endTag" || type == "selfcloseTag") {
      var tagName = state.tagName, tagStart = state.tagStart;
      state.tagName = state.tagStart = null;
      if (type == "selfcloseTag" ||
          Kludges.autoSelfClosers.hasOwnProperty(tagName)) {
        maybePopContext(state, tagName);
      } else {
        maybePopContext(state, tagName);
        state.context = new Context(state, tagName, tagStart == state.indented);
      }
      return baseState;
    }
    setStyle = "error";
    return attrState;
  }
  function attrEqState(type, stream, state) {
    if (type == "equals") return attrValueState;
    if (!Kludges.allowMissing) setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrValueState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    if (type == "word" && Kludges.allowUnquoted) {setStyle = "string"; return attrState;}
    setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrContinuedState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    return attrState(type, stream, state);
  }

  return {
    startState: function() {
      return {tokenize: inText,
              state: baseState,
              indented: 0,
              tagName: null, tagStart: null,
              context: null};
    },

    token: function(stream, state) {
      if (!state.tagName && stream.sol())
        state.indented = stream.indentation();

      if (stream.eatSpace()) return null;
      type = null;
      var style = state.tokenize(stream, state);
      if ((style || type) && style != "comment") {
        setStyle = null;
        state.state = state.state(type || style, stream, state);
        if (setStyle)
          style = setStyle == "error" ? style + " error" : setStyle;
      }
      return style;
    },

    indent: function(state, textAfter, fullLine) {
      var context = state.context;
      // Indent multi-line strings (e.g. css).
      if (state.tokenize.isInAttribute) {
        if (state.tagStart == state.indented)
          return state.stringStartCol + 1;
        else
          return state.indented + indentUnit;
      }
      if (context && context.noIndent) return CodeMirror.Pass;
      if (state.tokenize != inTag && state.tokenize != inText)
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
      // Indent the starts of attribute names.
      if (state.tagName) {
        if (multilineTagIndentPastTag)
          return state.tagStart + state.tagName.length + 2;
        else
          return state.tagStart + indentUnit * multilineTagIndentFactor;
      }
      if (alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
      if (tagAfter && tagAfter[1]) { // Closing tag spotted
        while (context) {
          if (context.tagName == tagAfter[2]) {
            context = context.prev;
            break;
          } else if (Kludges.implicitlyClosed.hasOwnProperty(context.tagName)) {
            context = context.prev;
          } else {
            break;
          }
        }
      } else if (tagAfter) { // Opening tag spotted
        while (context) {
          var grabbers = Kludges.contextGrabbers[context.tagName];
          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
            context = context.prev;
          else
            break;
        }
      }
      while (context && !context.startOfLine)
        context = context.prev;
      if (context) return context.indent + indentUnit;
      else return 0;
    },

    electricInput: /<\/[\s\w:]+>$/,
    blockCommentStart: "<!--",
    blockCommentEnd: "-->",

    configuration: parserConfig.htmlMode ? "html" : "xml",
    helperType: parserConfig.htmlMode ? "html" : "xml"
  };
});

CodeMirror.defineMIME("text/xml", "xml");
CodeMirror.defineMIME("application/xml", "xml");
if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});

});

},
'codemirror/mode/javascript/javascript':function(){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// TODO actually recognize syntax of TypeScript constructs

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var isTS = parserConfig.typescript;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    var jsKeywords = {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C, "debugger": C,
      "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this"), "module": kw("module"), "class": kw("class"), "super": kw("atom"),
      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C
    };

    // Extend the 'normal' keywords with the TypeScript language extensions
    if (isTS) {
      var type = {type: "variable", style: "variable-3"};
      var tsKeywords = {
        // object-like things
        "interface": kw("interface"),
        "extends": kw("extends"),
        "constructor": kw("constructor"),

        // scope modifiers
        "public": kw("public"),
        "private": kw("private"),
        "protected": kw("protected"),
        "static": kw("static"),

        // types
        "string": type, "number": type, "bool": type, "any": type
      };

      for (var attr in tsKeywords) {
        jsKeywords[attr] = tsKeywords[attr];
      }
    }

    return jsKeywords;
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == "/" && !inSet) return;
        if (next == "[") inSet = true;
        else if (inSet && next == "]") inSet = false;
      }
      escaped = !escaped && next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
      return ret("number", "number");
    } else if (ch == "." && stream.match("..")) {
      return ret("spread", "meta");
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "=" && stream.eat(">")) {
      return ret("=>", "operator");
    } else if (ch == "0" && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    } else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (state.lastType == "operator" || state.lastType == "keyword c" ||
               state.lastType == "sof" || /^[\[{}\(,;:]$/.test(state.lastType)) {
        readRegexp(stream);
        stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla
        return ret("regexp", "string-2");
      } else {
        stream.eatWhile(isOperatorChar);
        return ret("operator", "operator", stream.current());
      }
    } else if (ch == "`") {
      state.tokenize = tokenQuasi;
      return tokenQuasi(stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    } else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret("operator", "operator", stream.current());
    } else {
      stream.eatWhile(/[\w\$_]/);
      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
                     ret("variable", "variable", word);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
        state.tokenize = tokenBase;
        return ret("jsonld-keyword", "meta");
      }
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) break;
        escaped = !escaped && next == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret("string", "string");
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenQuasi(stream, state) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    return ret("quasi", "string-2", stream.current());
  }

  var brackets = "([{}])";
  // This is a crude lookahead trick to try and notice that we're
  // parsing the argument patterns for a fat-arrow function before we
  // actually hit the arrow token. It only works if the arrow is on
  // the same line as the arguments and there's no strange noise
  // (comments) in between. Fallback is to only notice when we hit the
  // arrow, and not declare the arguments as locals for the arrow
  // body.
  function findFatArrow(stream, state) {
    if (state.fatArrowAt) state.fatArrowAt = null;
    var arrow = stream.string.indexOf("=>", stream.start);
    if (arrow < 0) return;

    var depth = 0, sawSomething = false;
    for (var pos = arrow - 1; pos >= 0; --pos) {
      var ch = stream.string.charAt(pos);
      var bracket = brackets.indexOf(ch);
      if (bracket >= 0 && bracket < 3) {
        if (!depth) { ++pos; break; }
        if (--depth == 0) break;
      } else if (bracket >= 3 && bracket < 6) {
        ++depth;
      } else if (/[$\w]/.test(ch)) {
        sawSomething = true;
      } else if (sawSomething && !depth) {
        ++pos;
        break;
      }
    }
    if (sawSomething && !depth) state.fatArrowAt = pos;
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
    for (var cx = state.context; cx; cx = cx.prev) {
      for (var v = cx.vars; v; v = v.next)
        if (v.name == varname) return true;
    }
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname) return true;
      return false;
    }
    var state = cx.state;
    if (state.context) {
      cx.marked = "def";
      if (inList(state.localVars)) return;
      state.localVars = {name: varname, next: state.localVars};
    } else {
      if (inList(state.globalVars)) return;
      if (parserConfig.globalVars)
        state.globalVars = {name: varname, next: state.globalVars};
    }
  }

  // Combinators

  var defaultVars = {name: "this", next: {name: "arguments"}};
  function pushcontext() {
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function exp(type) {
      if (type == wanted) return cont();
      else if (wanted == ";") return pass();
      else return cont(exp);
    };
    return exp;
  }

  function statement(type, value) {
    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "{") return cont(pushlex("}"), block, poplex);
    if (type == ";") return cont();
    if (type == "if") {
      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
        cx.state.cc.pop()();
      return cont(pushlex("form"), expression, statement, poplex, maybeelse);
    }
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
    if (type == "variable") return cont(pushlex("stat"), maybelabel);
    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                      block, poplex, poplex);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                     statement, poplex, popcontext);
    if (type == "module") return cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex);
    if (type == "class") return cont(pushlex("form"), className, objlit, poplex);
    if (type == "export") return cont(pushlex("form"), afterExport, poplex);
    if (type == "import") return cont(pushlex("form"), afterImport, poplex);
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function expression(type) {
    return expressionInner(type, false);
  }
  function expressionNoComma(type) {
    return expressionInner(type, true);
  }
  function expressionInner(type, noComma) {
    if (cx.state.fatArrowAt == cx.stream.start) {
      var body = noComma ? arrowBodyNoComma : arrowBody;
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);
      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
    }

    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef, maybeop);
    if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);
    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
    if (type == "quasi") { return pass(quasi, maybeop); }
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }
  function maybeexpressionNoComma(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expressionNoComma);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(expression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (value == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
    if (type == "operator") {
      if (/\+\+|--/.test(value)) return cont(me);
      if (value == "?") return cont(expression, expect(":"), expr);
      return cont(expr);
    }
    if (type == "quasi") { return pass(quasi, me); }
    if (type == ";") return;
    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
  }
  function quasi(type, value) {
    if (type != "quasi") return pass();
    if (value.slice(value.length - 2) != "${") return cont(quasi);
    return cont(expression, continueQuasi);
  }
  function continueQuasi(type) {
    if (type == "}") {
      cx.marked = "string-2";
      cx.state.tokenize = tokenQuasi;
      return cont(quasi);
    }
  }
  function arrowBody(type) {
    findFatArrow(cx.stream, cx.state);
    if (type == "{") return pass(statement);
    return pass(expression);
  }
  function arrowBodyNoComma(type) {
    findFatArrow(cx.stream, cx.state);
    if (type == "{") return pass(statement);
    return pass(expressionNoComma);
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "variable") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
    } else if (type == "number" || type == "string") {
      cx.marked = jsonldMode ? "property" : (type + " property");
    } else if (type == "[") {
      return cont(expression, expect("]"), afterprop);
    }
    if (atomicTypes.hasOwnProperty(type)) return cont(afterprop);
  }
  function getterSetter(type) {
    if (type != "variable") return pass(afterprop);
    cx.marked = "property";
    return cont(functiondef);
  }
  function afterprop(type) {
    if (type == ":") return cont(expressionNoComma);
    if (type == "(") return pass(functiondef);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(what, proceed);
      }
      if (type == end) return cont();
      return cont(expect(end));
    }
    return function(type) {
      if (type == end) return cont();
      return pass(what, proceed);
    };
  }
  function contCommasep(what, end, info) {
    for (var i = 3; i < arguments.length; i++)
      cx.cc.push(arguments[i]);
    return cont(pushlex(end, info), commasep(what, end), poplex);
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type) {
    if (isTS && type == ":") return cont(typedef);
  }
  function typedef(type) {
    if (type == "variable"){cx.marked = "variable-3"; return cont();}
  }
  function vardef() {
    return pass(pattern, maybetype, maybeAssign, vardefCont);
  }
  function pattern(type, value) {
    if (type == "variable") { register(value); return cont(); }
    if (type == "[") return contCommasep(pattern, "]");
    if (type == "{") return contCommasep(proppattern, "}");
  }
  function proppattern(type, value) {
    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
      register(value);
      return cont(maybeAssign);
    }
    if (type == "variable") cx.marked = "property";
    return cont(expect(":"), pattern, maybeAssign);
  }
  function maybeAssign(_type, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function vardefCont(type) {
    if (type == ",") return cont(vardef);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
  }
  function forspec(type) {
    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef, expect(";"), forspec2);
    if (type == ";") return cont(forspec2);
    if (type == "variable") return cont(formaybeinof);
    return pass(expression, expect(";"), forspec2);
  }
  function formaybeinof(_type, value) {
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return cont(maybeoperatorComma, forspec2);
  }
  function forspec2(type, value) {
    if (type == ";") return cont(forspec3);
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return pass(expression, expect(";"), forspec3);
  }
  function forspec3(type) {
    if (type != ")") cont(expression);
  }
  function functiondef(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, statement, popcontext);
  }
  function funarg(type) {
    if (type == "spread") return cont(funarg);
    return pass(pattern, maybetype);
  }
  function className(type, value) {
    if (type == "variable") {register(value); return cont(classNameAfter);}
  }
  function classNameAfter(_type, value) {
    if (value == "extends") return cont(expression);
  }
  function objlit(type) {
    if (type == "{") return contCommasep(objprop, "}");
  }
  function afterModule(type, value) {
    if (type == "string") return cont(statement);
    if (type == "variable") { register(value); return cont(maybeFrom); }
  }
  function afterExport(_type, value) {
    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
    return pass(statement);
  }
  function afterImport(type) {
    if (type == "string") return cont();
    return pass(importSpec, maybeFrom);
  }
  function importSpec(type, value) {
    if (type == "{") return contCommasep(importSpec, "}");
    if (type == "variable") register(value);
    return cont();
  }
  function maybeFrom(_type, value) {
    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
  }
  function arrayLiteral(type) {
    if (type == "]") return cont();
    return pass(expressionNoComma, maybeArrayComprehension);
  }
  function maybeArrayComprehension(type) {
    if (type == "for") return pass(comprehension, expect("]"));
    if (type == ",") return cont(commasep(expressionNoComma, "]"));
    return pass(commasep(expressionNoComma, "]"));
  }
  function comprehension(type) {
    if (type == "for") return cont(forspec, comprehension);
    if (type == "if") return cont(expression, comprehension);
  }

  // Interface

  return {
    startState: function(basecolumn) {
      var state = {
        tokenize: tokenBase,
        lastType: "sof",
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        context: parserConfig.localVars && {vars: parserConfig.localVars},
        indented: 0
      };
      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
        findFatArrow(stream, state);
      }
      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == tokenComment) return CodeMirror.Pass;
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse) break;
      }
      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricChars: ":{}",
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    lineComment: jsonMode ? null : "//",
    fold: "brace",

    helperType: jsonMode ? "json" : "javascript",
    jsonldMode: jsonldMode,
    jsonMode: jsonMode
  };
});

CodeMirror.registerHelper("wordChars", "javascript", /[\\w$]/);

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

});

},
'codemirror/mode/css/css':function(){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("css", function(config, parserConfig) {
  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

  var indentUnit = config.indentUnit,
      tokenHooks = parserConfig.tokenHooks,
      mediaTypes = parserConfig.mediaTypes || {},
      mediaFeatures = parserConfig.mediaFeatures || {},
      propertyKeywords = parserConfig.propertyKeywords || {},
      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
      colorKeywords = parserConfig.colorKeywords || {},
      valueKeywords = parserConfig.valueKeywords || {},
      fontProperties = parserConfig.fontProperties || {},
      allowNested = parserConfig.allowNested;

  var type, override;
  function ret(style, tp) { type = tp; return style; }

  // Tokenizers

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (tokenHooks[ch]) {
      var result = tokenHooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == "@") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("def", stream.current());
    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
      return ret(null, "compare");
    } else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "#") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("atom", "hash");
    } else if (ch == "!") {
      stream.match(/^\s*\w*/);
      return ret("keyword", "important");
    } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
      stream.eatWhile(/[\w.%]/);
      return ret("number", "unit");
    } else if (ch === "-") {
      if (/[\d.]/.test(stream.peek())) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (stream.match(/^\w+-/)) {
        return ret("meta", "meta");
      }
    } else if (/[,+>*\/]/.test(ch)) {
      return ret(null, "select-op");
    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
      return ret("qualifier", "qualifier");
    } else if (/[:;{}\[\]\(\)]/.test(ch)) {
      return ret(null, ch);
    } else if (ch == "u" && stream.match("rl(")) {
      stream.backUp(1);
      state.tokenize = tokenParenthesized;
      return ret("property", "word");
    } else if (/[\w\\\-]/.test(ch)) {
      stream.eatWhile(/[\w\\\-]/);
      return ret("property", "word");
    } else {
      return ret(null, null);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped) {
          if (quote == ")") stream.backUp(1);
          break;
        }
        escaped = !escaped && ch == "\\";
      }
      if (ch == quote || !escaped && quote != ")") state.tokenize = null;
      return ret("string", "string");
    };
  }

  function tokenParenthesized(stream, state) {
    stream.next(); // Must be '('
    if (!stream.match(/\s*[\"\')]/, false))
      state.tokenize = tokenString(")");
    else
      state.tokenize = null;
    return ret(null, "(");
  }

  // Context management

  function Context(type, indent, prev) {
    this.type = type;
    this.indent = indent;
    this.prev = prev;
  }

  function pushContext(state, stream, type) {
    state.context = new Context(type, stream.indentation() + indentUnit, state.context);
    return type;
  }

  function popContext(state) {
    state.context = state.context.prev;
    return state.context.type;
  }

  function pass(type, stream, state) {
    return states[state.context.type](type, stream, state);
  }
  function popAndPass(type, stream, state, n) {
    for (var i = n || 1; i > 0; i--)
      state.context = state.context.prev;
    return pass(type, stream, state);
  }

  // Parser

  function wordAsValue(stream) {
    var word = stream.current().toLowerCase();
    if (valueKeywords.hasOwnProperty(word))
      override = "atom";
    else if (colorKeywords.hasOwnProperty(word))
      override = "keyword";
    else
      override = "variable";
  }

  var states = {};

  states.top = function(type, stream, state) {
    if (type == "{") {
      return pushContext(state, stream, "block");
    } else if (type == "}" && state.context.prev) {
      return popContext(state);
    } else if (type == "@media") {
      return pushContext(state, stream, "media");
    } else if (type == "@font-face") {
      return "font_face_before";
    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/.test(type)) {
      return "keyframes";
    } else if (type && type.charAt(0) == "@") {
      return pushContext(state, stream, "at");
    } else if (type == "hash") {
      override = "builtin";
    } else if (type == "word") {
      override = "tag";
    } else if (type == "variable-definition") {
      return "maybeprop";
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    } else if (type == ":") {
      return "pseudo";
    } else if (allowNested && type == "(") {
      return pushContext(state, stream, "parens");
    }
    return state.context.type;
  };

  states.block = function(type, stream, state) {
    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (propertyKeywords.hasOwnProperty(word)) {
        override = "property";
        return "maybeprop";
      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
        override = "string-2";
        return "maybeprop";
      } else if (allowNested) {
        override = stream.match(/^\s*:/, false) ? "property" : "tag";
        return "block";
      } else {
        override += " error";
        return "maybeprop";
      }
    } else if (type == "meta") {
      return "block";
    } else if (!allowNested && (type == "hash" || type == "qualifier")) {
      override = "error";
      return "block";
    } else {
      return states.top(type, stream, state);
    }
  };

  states.maybeprop = function(type, stream, state) {
    if (type == ":") return pushContext(state, stream, "prop");
    return pass(type, stream, state);
  };

  states.prop = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
    if (type == "}" || type == "{") return popAndPass(type, stream, state);
    if (type == "(") return pushContext(state, stream, "parens");

    if (type == "hash" && !/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {
      override += " error";
    } else if (type == "word") {
      wordAsValue(stream);
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    }
    return "prop";
  };

  states.propBlock = function(type, _stream, state) {
    if (type == "}") return popContext(state);
    if (type == "word") { override = "property"; return "maybeprop"; }
    return state.context.type;
  };

  states.parens = function(type, stream, state) {
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == ")") return popContext(state);
    if (type == "(") return pushContext(state, stream, "parens");
    if (type == "word") wordAsValue(stream);
    return "parens";
  };

  states.pseudo = function(type, stream, state) {
    if (type == "word") {
      override = "variable-3";
      return state.context.type;
    }
    return pass(type, stream, state);
  };

  states.media = function(type, stream, state) {
    if (type == "(") return pushContext(state, stream, "media_parens");
    if (type == "}") return popAndPass(type, stream, state);
    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");

    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (word == "only" || word == "not" || word == "and")
        override = "keyword";
      else if (mediaTypes.hasOwnProperty(word))
        override = "attribute";
      else if (mediaFeatures.hasOwnProperty(word))
        override = "property";
      else
        override = "error";
    }
    return state.context.type;
  };

  states.media_parens = function(type, stream, state) {
    if (type == ")") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
    return states.media(type, stream, state);
  };

  states.font_face_before = function(type, stream, state) {
    if (type == "{")
      return pushContext(state, stream, "font_face");
    return pass(type, stream, state);
  };

  states.font_face = function(type, stream, state) {
    if (type == "}") return popContext(state);
    if (type == "word") {
      if (!fontProperties.hasOwnProperty(stream.current().toLowerCase()))
        override = "error";
      else
        override = "property";
      return "maybeprop";
    }
    return "font_face";
  };

  states.keyframes = function(type, stream, state) {
    if (type == "word") { override = "variable"; return "keyframes"; }
    if (type == "{") return pushContext(state, stream, "top");
    return pass(type, stream, state);
  };

  states.at = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == "word") override = "tag";
    else if (type == "hash") override = "builtin";
    return "at";
  };

  states.interpolation = function(type, stream, state) {
    if (type == "}") return popContext(state);
    if (type == "{" || type == ";") return popAndPass(type, stream, state);
    if (type != "variable") override = "error";
    return "interpolation";
  };

  return {
    startState: function(base) {
      return {tokenize: null,
              state: "top",
              context: new Context("top", base || 0, null)};
    },

    token: function(stream, state) {
      if (!state.tokenize && stream.eatSpace()) return null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style && typeof style == "object") {
        type = style[1];
        style = style[0];
      }
      override = style;
      state.state = states[state.state](type, stream, state);
      return override;
    },

    indent: function(state, textAfter) {
      var cx = state.context, ch = textAfter && textAfter.charAt(0);
      var indent = cx.indent;
      if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
      if (cx.prev &&
          (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "font_face") ||
           ch == ")" && (cx.type == "parens" || cx.type == "media_parens") ||
           ch == "{" && (cx.type == "at" || cx.type == "media"))) {
        indent = cx.indent - indentUnit;
        cx = cx.prev;
      }
      return indent;
    },

    electricChars: "}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    fold: "brace"
  };
});

  function keySet(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) {
      keys[array[i]] = true;
    }
    return keys;
  }

  var mediaTypes_ = [
    "all", "aural", "braille", "handheld", "print", "projection", "screen",
    "tty", "tv", "embossed"
  ], mediaTypes = keySet(mediaTypes_);

  var mediaFeatures_ = [
    "width", "min-width", "max-width", "height", "min-height", "max-height",
    "device-width", "min-device-width", "max-device-width", "device-height",
    "min-device-height", "max-device-height", "aspect-ratio",
    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
    "max-color", "color-index", "min-color-index", "max-color-index",
    "monochrome", "min-monochrome", "max-monochrome", "resolution",
    "min-resolution", "max-resolution", "scan", "grid"
  ], mediaFeatures = keySet(mediaFeatures_);

  var propertyKeywords_ = [
    "align-content", "align-items", "align-self", "alignment-adjust",
    "alignment-baseline", "anchor-point", "animation", "animation-delay",
    "animation-direction", "animation-duration", "animation-fill-mode",
    "animation-iteration-count", "animation-name", "animation-play-state",
    "animation-timing-function", "appearance", "azimuth", "backface-visibility",
    "background", "background-attachment", "background-clip", "background-color",
    "background-image", "background-origin", "background-position",
    "background-repeat", "background-size", "baseline-shift", "binding",
    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
    "bookmark-target", "border", "border-bottom", "border-bottom-color",
    "border-bottom-left-radius", "border-bottom-right-radius",
    "border-bottom-style", "border-bottom-width", "border-collapse",
    "border-color", "border-image", "border-image-outset",
    "border-image-repeat", "border-image-slice", "border-image-source",
    "border-image-width", "border-left", "border-left-color",
    "border-left-style", "border-left-width", "border-radius", "border-right",
    "border-right-color", "border-right-style", "border-right-width",
    "border-spacing", "border-style", "border-top", "border-top-color",
    "border-top-left-radius", "border-top-right-radius", "border-top-style",
    "border-top-width", "border-width", "bottom", "box-decoration-break",
    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
    "caption-side", "clear", "clip", "color", "color-profile", "column-count",
    "column-fill", "column-gap", "column-rule", "column-rule-color",
    "column-rule-style", "column-rule-width", "column-span", "column-width",
    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
    "cue-after", "cue-before", "cursor", "direction", "display",
    "dominant-baseline", "drop-initial-after-adjust",
    "drop-initial-after-align", "drop-initial-before-adjust",
    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
    "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",
    "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",
    "font-stretch", "font-style", "font-synthesis", "font-variant",
    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
    "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow",
    "grid-auto-position", "grid-auto-rows", "grid-column", "grid-column-end",
    "grid-column-start", "grid-row", "grid-row-end", "grid-row-start",
    "grid-template", "grid-template-areas", "grid-template-columns",
    "grid-template-rows", "hanging-punctuation", "height", "hyphens",
    "icon", "image-orientation", "image-rendering", "image-resolution",
    "inline-box-align", "justify-content", "left", "letter-spacing",
    "line-break", "line-height", "line-stacking", "line-stacking-ruby",
    "line-stacking-shift", "line-stacking-strategy", "list-style",
    "list-style-image", "list-style-position", "list-style-type", "margin",
    "margin-bottom", "margin-left", "margin-right", "margin-top",
    "marker-offset", "marks", "marquee-direction", "marquee-loop",
    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",
    "nav-left", "nav-right", "nav-up", "object-fit", "object-position",
    "opacity", "order", "orphans", "outline",
    "outline-color", "outline-offset", "outline-style", "outline-width",
    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
    "page", "page-break-after", "page-break-before", "page-break-inside",
    "page-policy", "pause", "pause-after", "pause-before", "perspective",
    "perspective-origin", "pitch", "pitch-range", "play-during", "position",
    "presentation-level", "punctuation-trim", "quotes", "region-break-after",
    "region-break-before", "region-break-inside", "region-fragment",
    "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",
    "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",
    "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin",
    "shape-outside", "size", "speak", "speak-as", "speak-header",
    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
    "tab-size", "table-layout", "target", "target-name", "target-new",
    "target-position", "text-align", "text-align-last", "text-decoration",
    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
    "text-decoration-style", "text-emphasis", "text-emphasis-color",
    "text-emphasis-position", "text-emphasis-style", "text-height",
    "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",
    "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",
    "text-wrap", "top", "transform", "transform-origin", "transform-style",
    "transition", "transition-delay", "transition-duration",
    "transition-property", "transition-timing-function", "unicode-bidi",
    "vertical-align", "visibility", "voice-balance", "voice-duration",
    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
    "voice-volume", "volume", "white-space", "widows", "width", "word-break",
    "word-spacing", "word-wrap", "z-index",
    // SVG-specific
    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
    "color-interpolation", "color-interpolation-filters",
    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",
    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
    "glyph-orientation-vertical", "text-anchor", "writing-mode"
  ], propertyKeywords = keySet(propertyKeywords_);

  var nonStandardPropertyKeywords = [
    "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",
    "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",
    "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside",
    "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button",
    "searchfield-results-decoration", "zoom"
  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords);

  var colorKeywords_ = [
    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
    "purple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon",
    "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
    "whitesmoke", "yellow", "yellowgreen"
  ], colorKeywords = keySet(colorKeywords_);

  var valueKeywords_ = [
    "above", "absolute", "activeborder", "activecaption", "afar",
    "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate",
    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
    "arabic-indic", "armenian", "asterisks", "auto", "avoid", "avoid-column", "avoid-page",
    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",
    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
    "both", "bottom", "break", "break-all", "break-word", "button", "button-bevel",
    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian",
    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
    "cell", "center", "checkbox", "circle", "cjk-earthly-branch",
    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
    "col-resize", "collapse", "column", "compact", "condensed", "contain", "content",
    "content-box", "context-menu", "continuous", "copy", "cover", "crop",
    "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal",
    "decimal-leading-zero", "default", "default-button", "destination-atop",
    "destination-in", "destination-out", "destination-over", "devanagari",
    "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted",
    "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et",
    "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed",
    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes",
    "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove",
    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew",
    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore",
    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
    "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert",
    "italic", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer",
    "landscape", "lao", "large", "larger", "left", "level", "lighter",
    "line-through", "linear", "lines", "list-item", "listbox", "listitem",
    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
    "lower-roman", "lowercase", "ltr", "malayalam", "match",
    "media-controls-background", "media-current-time-display",
    "media-fullscreen-button", "media-mute-button", "media-play-button",
    "media-return-to-realtime-button", "media-rewind-button",
    "media-seek-back-button", "media-seek-forward-button", "media-slider",
    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
    "menu", "menulist", "menulist-button", "menulist-text",
    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
    "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize",
    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
    "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote",
    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
    "painted", "page", "paused", "persian", "plus-darker", "plus-lighter", "pointer",
    "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button",
    "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region",
    "relative", "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba",
    "ridge", "right", "round", "row-resize", "rtl", "run-in", "running",
    "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield",
    "searchfield-cancel-button", "searchfield-decoration",
    "searchfield-results-button", "searchfield-results-decoration",
    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
    "single", "skip-white-space", "slide", "slider-horizontal",
    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
    "small", "small-caps", "small-caption", "smaller", "solid", "somali",
    "source-atop", "source-in", "source-out", "source-over", "space", "square",
    "square-button", "start", "static", "status-bar", "stretch", "stroke",
    "sub", "subpixel-antialiased", "super", "sw-resize", "table",
    "table-caption", "table-cell", "table-column", "table-column-group",
    "table-footer-group", "table-header-group", "table-row", "table-row-group",
    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
    "transparent", "ultra-condensed", "ultra-expanded", "underline", "up",
    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
    "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
    "window", "windowframe", "windowtext", "x-large", "x-small", "xor",
    "xx-large", "xx-small"
  ], valueKeywords = keySet(valueKeywords_);

  var fontProperties_ = [
    "font-family", "src", "unicode-range", "font-variant", "font-feature-settings",
    "font-stretch", "font-weight", "font-style"
  ], fontProperties = keySet(fontProperties_);

  var allWords = mediaTypes_.concat(mediaFeatures_).concat(propertyKeywords_)
    .concat(nonStandardPropertyKeywords).concat(colorKeywords_).concat(valueKeywords_);
  CodeMirror.registerHelper("hintWords", "css", allWords);

  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ["comment", "comment"];
  }

  function tokenSGMLComment(stream, state) {
    if (stream.skipTo("-->")) {
      stream.match("-->");
      state.tokenize = null;
    } else {
      stream.skipToEnd();
    }
    return ["comment", "comment"];
  }

  CodeMirror.defineMIME("text/css", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    tokenHooks: {
      "<": function(stream, state) {
        if (!stream.match("!--")) return false;
        state.tokenize = tokenSGMLComment;
        return tokenSGMLComment(stream, state);
      },
      "/": function(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css"
  });

  CodeMirror.defineMIME("text/x-scss", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      ":": function(stream) {
        if (stream.match(/\s*{/))
          return [null, "{"];
        return false;
      },
      "$": function(stream) {
        stream.match(/^[\w-]+/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "#": function(stream) {
        if (!stream.eat("{")) return false;
        return [null, "interpolation"];
      }
    },
    name: "css",
    helperType: "scss"
  });

  CodeMirror.defineMIME("text/x-less", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      "@": function(stream) {
        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/, false)) return false;
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "&": function() {
        return ["atom", "atom"];
      }
    },
    name: "css",
    helperType: "less"
  });

});

},
'vodori/tinymce/CollapsingTabContainer':function(){
define([
    './TabContainer',
    'vodori/ui/CollapsingTabContainer',
    'dijit/layout/ContentPane',
    'vodori/amd/tinymce',
    'vodori/provide',
    'module',
    'vodori/tinymce/util/getPluginName',
    'vodori/tinymce/util/getResourceUrl',
    'vodori/util/objectToProps'
], function (TabContainer,
             CollapsingTabContainer,
             ContentPane,
             tinymce,
             provide,
             module,
             getPluginName,
             getResourceUrl,
             objectToProps) {

    var pluginName = getPluginName(module);

    var plugin = provide(module.id, [TabContainer], {

        pluginName: pluginName,

        url: getResourceUrl(module),

        popupWidth: 390,
        popupHeight: 330,

        dijitDeclaredClass: CollapsingTabContainer.prototype.declaredClass,

        title: "Collapsing tab container table",

        defaultAttrs: {
            width: '',
            tableClass: '',
            align: 'middle',
            border: ''
        },

        button: {
            label: '',
            image: 'img/tab.png',
            title: 'Insert a collapsing tab container',
            changeStates: {
                highlight: [pluginName],
                enable: [],
                disable: []
            }
        },

        styleSheet: false,

        flipToPreview: function (ed, node) {
            var dom = ed.dom;

            // Need to call superclass's method to get around arg filtering by dojo.
            var superclass = this.constructor.superclass;
            var wrappers = superclass.flipToPreview.apply(this, [ed, node, false]);

            tinymce.each(wrappers, function (wrapper) {

                var panes = dom.select('> div', wrapper);

                tinymce.each(panes, function (pane) {
                    var children = pane.children;

                    var newPane = dom.create('div', {
                        'data-dojo-props': objectToProps({
                            title: children[0].innerHTML,
                            content: children[1].innerHTML
                        }),
                        'data-dojo-type': 'dijit/layout/ContentPane'
                    });

                    dom.replace(newPane, pane);

                });

                dom.setAttrib(wrapper, 'data-dojo-type', this.dijitDeclaredClass);

            }, this);

            return wrappers;
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'vodori/tinymce/TabContainer':function(){
define([
    'vodori/provide', 'module',
    'vodori/amd/tinymce',
    'vodori/ui/editor/TabContainer',
    './EditableConfigurableTransformer', './_GetInfoMixin',
    './util/getPluginName', './util/getResourceUrl'
], function (
    provide, module,
    tinymce,
    TabContainer,
    EditableConfigurableTransformer, _GetInfoMixin,
    getPluginName, getResourceUrl
    ) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, [EditableConfigurableTransformer, _GetInfoMixin], {
        useTemplate: true,
        pluginName: pluginName,
        url: getResourceUrl(module),

        disallowedAncestors: ['p', 'br', 'img', 'input', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],

        button: {
            label: '',
            image: 'img/tab.png',
            title: 'Insert a tab container',

            changeStates: {
                highlight: [pluginName],
                enable: [],
                disable: [pluginName]
            }
        },

        styleSheet: true
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'vodori/ui/editor/TabContainer':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/_base/sniff', 'dojo/on',
    'dojo/dom-attr', 'dojo/dom-class', 'dojo/dom-construct',
    'dojo/query',
    'dojo/dnd/Source',
    'dijit/registry',
    'dijit/Menu', 'dijit/MenuItem', 'dijit/PopupMenuItem',
    'dijit/layout/ContentPane',
    'vodori/ui/TabContainer',
    'vodori/editor/_AbstractEditorWidget',
    'dojo/NodeList-manipulate', 'dojo/NodeList-traverse'
], function (
    module, provide,
    _,
    lang, sniff, on,
    domAttr, domClass, domConstruct,
    query,
    Source,
    registry,
    Menu, MenuItem, PopupMenuItem,
    ContentPane,
    TabContainer,
    _AbstractEditorWidget
    ) {
    //noinspection JSUnusedLocalSymbols
    return provide(module.id, [TabContainer, _AbstractEditorWidget], {

        dndSource: null,     // DnD source is updated when a new child is added to the tab container.
        createHashes: false, // Do not change hashes when switching tabs when in TinyMCE (a virtual iframe).
        // This causes FF to freak out.

        postCreate: function () {
            /*
             * If preceded by a <p><br data-mce-bogus></p> then delete it
             * Do this before calling the superclass method, because that might update the DOM
             */
            query('[data-mce-bogus]:only-child', query(this.domNode).prev().pop()).parent().remove();

            this.inherited(arguments);

            this.own(on(this.tablist, 'addChild', lang.hitch(this, function (child) {
                // Make the content pane editable
                domAttr.get(child.domNode, 'contenteditable', 'true');

                // If IE add contenteditable=false to the tab titles. We don't need to do this for FF and Chrome because
                // dojo sets the user-select attribute to none which makes them act like not editable. Also setting
                // CE=false in this case on chrome causes really ugly highlighting issues during DnD.
                if (sniff('ie')) {
                    domAttr.get(child.controlButton.domNode, 'contenteditable', 'false');
                }

                // Add support for a right click menu on the tab titles
                this._addContextMenu(child);

                // Define a tab tile as a Drag n' Drop item then sync the dnd source
                domClass.add(child.controlButton.domNode, 'dojoDndItem');
                if (this.dndSource) {
                    this.dndSource.sync();
                }
            })));

        },

        /**
         * Disable top focus node when in editor. It muddles up the markup.
         */
        _setupTopFocusNode: _.noop,

        startup: function () {
            this.inherited(arguments);

            // Define the DnD source and attach it to the tab titles
            this.dndSource = new Source(this.tablist.containerNode, {
                withHandles: false,
                horizontal: true
            });

            // Switch to a particular tab if the attribute 'data-tabselected' has been set on the tab container
            var selectedTab = parseInt(this.get('data-tabselected'), 10);
            _.forEach(this.getChildren(), function (tab) {
                if (this.tablist.getIndexOfChild(tab.controlButton) === selectedTab) {
                    this.selectChild(tab);
                }
            }, this);
        },

        /**
         * Override the blockTab functionality, so we don't need a re-parse when users add/remove a link from the tab
         * title.
         *
         * @param {dijit.layout._TabButton} tab
         */
        blockTab: function (tab) {
        },

        /**
         * Add a right click context menu to the tab title.
         *
         * @param child A content pane
         */
        _addContextMenu: function (child) {
            var contextMenu = new Menu({
                targetNodeIds: [child.controlButton.domNode],
                contentEditable: 'false'
            });
            // CAYENNE-1755 general workaround for TinyMCE adding a span in a silly place
            this.own(on(contextMenu, 'itemClick', lang.hitch(this, function () {
                this.deleteNonEditableCaret();
            })));

            // Create tab
            contextMenu.addChild(new MenuItem({
                label: 'Create tab',
                onClick: lang.hitch(this, function () {
                    var cp = new ContentPane({
                        title: 'New Tab ' + (this.getChildren().length + 1),
                        content: '<div><p>new Content</p></div>',
                        closable: false
                    });
                    this.addChild(cp);
                    this.mutateEditor();
                })
            }));

            // Delete tab
            contextMenu.addChild(new MenuItem({
                label: 'Delete tab',
                onClick: lang.hitch(this, function () {
                    // Remove child if not last tab, else remove the entire tab container
                    if (this.getChildren().length > 1) {
                        this.removeChild(child);
                        this.mutateEditor();
                    } else {
                        domConstruct.destroy(this.domNode);
                        this.mutateEditor();
                    }
                })
            }));

            //Rename tab
            contextMenu.addChild(new MenuItem({
                label: 'Rename tab',
                onClick: lang.hitch(this, function () {
                    var title = prompt('New title: ', child.get('title'));
                    if (title !== null) {
                        child.set('title', title);
                        this.mutateEditor();
                    }
                })
            }));

            // Add space tab
            var addSpaceMenu = new Menu(); // Create a submenu to allow adding a space above or below
            var _spaceAdder = function (spaceLocation) {
                return function () {
                    // Add a space at the top of the tab container
                    var pTag = domConstruct.create('p', {innerHTML: '&nbsp;'});
                    domConstruct.place(pTag, child.containerNode, spaceLocation);
                    this.mutateEditor();

                    // Select the newly added space
                    var selection = window.getSelection();
                    selection.removeAllRanges();
                    var range = document.createRange();
                    range.selectNode(pTag);
                    selection.addRange(range);
                };
            };
            addSpaceMenu.addChild(new MenuItem({
                label: 'Top of tab container',
                onClick: lang.hitch(this, _spaceAdder('first'))
            }));
            addSpaceMenu.addChild(new MenuItem({
                label: 'Bottom of tab container',
                onClick: lang.hitch(this, _spaceAdder('last'))
            }));
            contextMenu.addChild(new PopupMenuItem({ // Add the submenu to the main menu!
                label: 'Add space to...',
                popup: addSpaceMenu
            }));

            contextMenu.startup();

            // When the menu is opened, set the editor to non-edit mode to eliminate any conflicting behavior
            this.own(on(contextMenu, 'open', lang.hitch(this, function () {
                this.setContentEditingState(false);
                if (sniff('mozilla')) {
                    // Mozilla sets the '_moz_abspos' attribute on an element when it's contenteditable and absolutely
                    // positioned. This causes the some of the native browser WYSIWYG editing tools to become enabled
                    // which we don't need or want, so we just remove the attribute.
                    query('[_moz_abspos]').removeAttr('_moz_abspos');
                }
            })));

            // Return editing to normal when the menu is closed
            this.own(on(contextMenu, 'close', lang.hitch(this, function () {
                this.setContentEditingState(true);
            })));

        },

        /**
         * Construct the declarative markup for the Tab Container
         */
        serialize: function(serializer) {
            var widget = this.createWidgetWrapper(); // Containing node for the serialized markup
            var tabs = this.getChildren();           // Array of this container's tabs
            var serializedTabNodeArray = [];         // Array to hold serialized tab contents

            // Loop over and serialize the contents of each tab
            _.forEach(tabs, function (tab) {
                var tabIndex = this.tablist.getIndexOfChild(tab.controlButton); // get the index to keep tab order

                // Add an attribute to the tab container to persist selected tab index
                if (tab.selected) {
                    domAttr.set(widget, 'data-tabselected', tabIndex);
                }

                // Get the list of classes on the tab and excluded any that are prefixed with 'dijit'
                var classArray = domAttr.get(tab.domNode, 'class').split(' ');
                classArray = _.filter(classArray, function (className) {
                    return className.indexOf('dijit') !== 0;
                });

                // Create the containing node for the serialized markup of this tab
                var newTab = domConstruct.create('div');
                domClass.add(newTab, classArray);

                // Create the tab button
                domConstruct.create('div', {
                    innerHTML: tab.get('title')
                }, newTab);

                // Place the tab contents into the containing node
                var tabContent = tab.get('content');
                domConstruct.create('div', {
                    innerHTML: tabContent
                }, newTab);

                // Place the tab containing node into the array in the right order
                serializedTabNodeArray[tabIndex] = newTab;
            }, this);

            // Append the serialized tabs to the widget wrapper in the correct order
            _.forEach(serializedTabNodeArray, function (tabNode) {
                if (tabNode) {
                    domConstruct.place(tabNode, widget);
                }
            });

            return widget.outerHTML;
        }

    });
});

},
'vodori/tinymce/EditableConfigurableTransformer':function(){
define([
    'vodori/provide', 'module',
    'dojo/parser',
    'vodori/amd/tinymce',
    './util/getPluginName',
    './util/getResourceUrl',
    'vodori/util/objectToProps',
    'vodori/util/propsToObject',
    './ConfigurableTransformer'
], function (provide, module,
             parser,
             tinymce,
             getPluginName,
             getResourceUrl,
             objectToProps,
             propsToObject,
             ConfigurableTransformer) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, [ConfigurableTransformer], {

        /**
         * @return {void}
         */
        insertNew: function () {

            var ed = this.editor;
            var editorDojo = ed.getWin().dojo;

            var selectionNode = ed.selection.getNode();

            var insertionPoint = this.getValidInsertionPoint(selectionNode);
            if (!insertionPoint) {
                console.error("Could not find a valid insertion point for %O", selectionNode);
            }
            var wrapper = ed.dom.create('div', {}, this.template);
            var nodeToPlace = wrapper.firstChild;
            while (nodeToPlace.nodeType !== 1) { // Prevent insertion of a text node in place of this.
                nodeToPlace = nodeToPlace.nextSibling;
            }

            if (insertionPoint === ed.getBody()) {
                // If the body is the selected node, block wrappers get appended
                ed.dom.add(insertionPoint, wrapper);
            } else {
                // Otherwise block wrappers get inserted after
                ed.dom.insertAfter(nodeToPlace, insertionPoint);
            }

            editorDojo.parser.instantiate([nodeToPlace]);
        }

    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'vodori/ui/CollapsingTabContainer':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/fx',
    'dojo/dom-class', 'dojo/dom-geometry', 'dojo/dom-style',
    'dijit/layout/TabContainer',
    'vodori/util/SerializableMixin'
], function (module, provide, fx, domClass, domGeometry, domStyle, TabContainer, _SerializableMixin) {
    return provide(module.id, [TabContainer, _SerializableMixin], {
        collapsed: true,
        duration: 150,

        'class': 'CollapsingTabContainer',

        doLayout: false,
        useMenu: false,
        useSlider: false,
        controllerWidget: 'dijit.layout.TabController',

        tablistSpacer: null,

        startup: function () {
            this.inherited(arguments);

            domClass.add(this.domNode, 'panes_visible');

            // Check for a 'collapsed' attribute in the markup (default is true)
            if (this.collapsed) {
                // Hide immediately
                this.hidePanes(1);
            }

            domClass.add(this.domNode, 'pane_' + this.getIndexOfChild(this.selectedChildWidget) + '_active');

            domStyle.set(this.domNode, {
                overflow: 'hidden',
                position: 'relative'
            });
        },

        // If the selected tab is clicked, hide and show the panes
        selectChild: function (page) {
            var oldSelect = this.selectedChildWidget;

            this.inherited(arguments);

            if (oldSelect === page && !this.collapsed) {
                this.hidePanes();
            } else {
                this.showPanes();
            }

            domClass.remove(this.domNode, 'pane_' + this.getIndexOfChild(oldSelect) + '_active');
            domClass.add(this.domNode, 'pane_' + this.getIndexOfChild(this.selectedChildWidget) + '_active');
        },

        hidePanes: function (duration) {
            duration = duration || this.duration;

            var smallHeight = domGeometry.getContentBox(this.tablist.domNode).h +
                domStyle.get(this.tablist.domNode, 'paddingTop') +
                domStyle.get(this.tablist.domNode, 'paddingBottom') +
                domStyle.get(this.tablist.domNode, 'borderTopWidth') +
                domStyle.get(this.tablist.domNode, 'borderBottomWidth');

            console.log('Hiding panes', this);

            domClass.remove(this.domNode, 'panes_visible');
            domClass.add(this.domNode, 'panes_hidden');

            fx.animateProperty({node: this.domNode, duration: duration, properties: {height: smallHeight}}).play();
            this.collapsed = true;

            this.tablist.pane2button[this.selectedChildWidget.id].attr('checked', false);
        },

        showPanes: function () {
            var largeHeight = domGeometry.getMarginBox(this.tablist.domNode).h +
                domStyle.get(this.tablist.domNode, 'paddingTop') +
                domStyle.get(this.tablist.domNode, 'paddingBottom') +
                domStyle.get(this.tablist.domNode, 'borderTopWidth') +
                domStyle.get(this.tablist.domNode, 'borderBottomWidth') +
                domStyle.get(this.tablist.domNode, 'marginBottom');
            largeHeight += domGeometry.getMarginBox(this.containerNode).h +
                domStyle.get(this.containerNode, 'paddingTop') +
                domStyle.get(this.containerNode, 'paddingBottom') +
                domStyle.get(this.containerNode, 'borderTopWidth') +
                domStyle.get(this.containerNode, 'borderBottomWidth') +
                domStyle.get(this.containerNode, 'marginTop');
            largeHeight += domGeometry.getMarginBox(this.tablistSpacer).h +
                domStyle.get(this.tablistSpacer, 'paddingTop') +
                domStyle.get(this.tablistSpacer, 'paddingBottom') +
                domStyle.get(this.tablistSpacer, 'borderTopWidth') +
                domStyle.get(this.tablistSpacer, 'borderBottomWidth') +
                domStyle.get(this.tablistSpacer, 'marginBottom');

            console.log('Showing panes', this);

            domClass.remove(this.domNode, 'panes_hidden');
            domClass.add(this.domNode, 'panes_visible');

            fx.animateProperty({
                node: this.domNode,
                duration: this.duration,
                properties: {
                    height: largeHeight
                }
            }).play();

            this.collapsed = false;

            this.tablist.pane2button[this.selectedChildWidget.id].attr('checked', true);
        }
    });
});

},
'vodori/tinymce/CustomAutoResize':function(){
/**
 * NOTE: This plugin requires the AutoResizePlugin to be loaded.
 */
define([
    'dojo/_base/lang',
    'dojo/dom-class',
    'dojo/aspect',
    'dijit/registry',
    'vodori/provide', 'module',
    'vodori/amd/tinymce',
    'vodori/tinymce/util/getPluginName'
], function (lang,
             domClass,
             aspect,
             dijitRegistry,
             provide, module,
             tinymce,
             getPluginName) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, null, {

        editor: null,

        init: function (ed) {
            this.editor = ed;

            ed.onPostRender.add(this.connectAutoResize, this);
        },

        /*  Find editors inside content panes inside tab containers and connect a tinyMce resize event to them. 
         *  Will fire when a tab is clicked on. 
         */
        connectAutoResize: function () {

            var cpNode = this.editor.dom.getParents(this.editor.getContainer(), function (n) {
                return dijitRegistry.byNode(n) && domClass.contains(n, 'dijitContentPane');
            })[0];

            var cp;
            if (cpNode) {
                cp = dijitRegistry.byNode(cpNode);
            }

            var tcNode = this.editor.dom.getParents(this.editor.getContainer(), function (n) {
                return dijitRegistry.byNode(n) && domClass.contains(n, 'dijitTabContainer');
            })[0];

            var tc;
            if (tcNode) {
                tc = dijitRegistry.byNode(tcNode);
            }
        }

    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'vodori/tinymce/DialogPopup':function(){
define([
    './ConfigurableTransformer',
    './ui/CustomPopup',
    'vodori/amd/tinymce',
    'vodori/provide', 'module',
    './util/getPluginName', './util/getResourceUrl'
], function (ConfigurableTransformer, CustomPopup, tinymce, provide, module, getPluginName, getResourceUrl) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, [ConfigurableTransformer], {
        dijitDeclaredClass: CustomPopup.prototype.declaredClass,

        url: getResourceUrl(module),

        init: function (editor) {
            editor.onPreProcess.add(function (ed, o) {
                var links = ed.dom.select('a[onclick]', o.node);
                tinymce.each(links, function (link) {
                    var onclick = ed.dom.getAttrib(link, 'onclick');
                    var target = ed.dom.getAttrib(link, 'target');

                    if (onclick.match(/^window\.open\s*\(/) && target !== '_blank') {
                        ed.dom.setAttrib(
                            link,
                            'data-dojo-type',
                            this.dijitDeclaredClass
                        );
                    }
                }, this);
            }, this);
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});
},
'vodori/tinymce/ui/CustomPopup':function(){
define([
    'dojo/_base/lang',
    'dojo/dom-attr', 'dojo/dom-construct',
    'dojo/on',
    '../../ui/Dialog', 'dijit/_Widget',
    'vodori/util/SerializableMixin',
    'vodori/provide', 'module'
], function (lang, domAttr, domConstruct, on, Dialog, _Widget, _SerializableMixin, provide, module) {
    return provide(module.id, [_Widget, _SerializableMixin], {
        // summary: This will turn a link that is configured in TinyMCE to open
        // as a popup into a link that opens in a vodori.ui.Dialog.
        //
        // example:
        //      <!-- markup href example: -->
        //      <a data-dojo-type="vodori/tinymce/ui/CustomPopup" href="..."
        //         onclick="open('some-url')">
        //      </a>
        dialog: null,

        onClick: function () {
        }, // Ignore the onclick attribute

        postCreate: function () {
            var href = domAttr.get(this.domNode, "href");
            var width, height;
            var onclick = this.domNode.getAttribute("onclick").toString();
            if (onclick) {
                this.domNode.onclick = null;

                var params = onclick.match(/'[^']*'|"[^"]*"/g);
                href = params[0].substring(1, params[0].length - 1);

                var options = params[params.length - 1];
                height = /height=(\d+)\b/i.exec(options);
                if (height) {
                    height = height[1];
                }
                width = /width=(\d+)\b/i.exec(options);
                if (width) {
                    width = width[1];
                }
            }

            this.href = href;
            this.height = height;
            this.width = width;

            on(this.domNode, "click", lang.hitch(this, "interceptClick"));

            this.inherited(arguments);
        },

        interceptClick: function (evt) {
            // Stop the event
            evt.stopPropagation();
            evt.preventDefault();

            if (this.dialog === null) {

                this.dialog = new Dialog({
                    content: domConstruct.create('iframe', {
                        src: this.href,
                        width: this.width,
                        height: this.height
                    }),
                    resizable: true,
                    initialSize: 0.8,
                    title: "Custom popup"
                });

            }

            this.dialog.show();
        }
    });
});
},
'vodori/tinymce/Expander':function(){
define([
    '../ui/Expander',
    'vodori/amd/tinymce',
    'vodori/provide',
    'module',
    'vodori/tinymce/util/getPluginName'
], function (Expander, tinymce, provide, module, getPluginName) {

    var plugin = provide(module.id, null, {

        dijitDeclaredClass: Expander.prototype.declaredClass,

        init: function (ed) {
            ed.addButton('expander', {
                label: 'Expander',
                title: 'A clickable title that reveals more content',
                onclick: function () {
                    ed.execCommand('mce_stamp', false, {
                        template: [
                            '<table data-dojo-type=',
                            this.dijitDeclaredClass,
                            '>',
                            '<tbody>',
                            '<tr>',
                            '<td>This will be the title</td>',
                            '</tr>',
                            '<tr>',
                            '<td><p>And this will be the content{|}</p></td>',
                            '</tr>',
                            '</tbody>',
                            '</table>'
                        ].join('')
                    });
                },
                scope: this
            });
        }
    });

    tinymce.PluginManager.add(getPluginName(module), plugin);

    return plugin;
});

},
'vodori/ui/Expander':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'dojo/parser', 'dojo/query',
    'dojo/dom-class', 'dojo/dom-construct', 'dojo/dom-style',
    'dijit/registry',
    'dijit/_Widget', 'dijit/TitlePane'
], function (module, provide,
             lang,
             parser, query,
             domClass, domConstruct, domStyle,
             dijitRegistry,
             _Widget, TitlePane) {
    return provide(module.id, [_Widget], {
        open: false,
        showCloser: true,
        closerContent: 'Close',

        baseClass: 'vodoriExpander',

        _titlePane: null,
        _closer: null,

        buildRendering: function () {
            this.inherited(arguments);

            // Get the title and content of the titlePane
            var title = query('> tbody > tr:nth-child(1) > td', this.domNode)[0].innerHTML;
            var content = query('> tbody > tr:nth-child(2) > td', this.domNode)[0].innerHTML;

            // Create a new node to build a TitlePane on
            var preTitlePane = domConstruct.create('div', {
                innerHTML: content
            }, this.domNode, 'after');

            var closerContainer;
            if (this.showCloser) {
                // Create a paragraph for the close button
                closerContainer = domConstruct.create('p', {
                    'class': this.baseClass + 'CloserContainer'
                }, preTitlePane);

                // Create the extra close button
                this._closer = domConstruct.create('button', {
                    'class': this.baseClass + 'Closer',
                    type: 'button',
                    innerHTML: this.closerContent,
                    onclick: lang.hitch(this, this.toggle)
                }, closerContainer);
            }

            // Create the TitlePane
            this._titlePane = new TitlePane({
                title: title,
                'class': this.baseClass + 'TitlePane',
                open: this.open
            }, preTitlePane);

            // Add a class to indicate the nesting level
            domClass.add(this._titlePane.domNode, 'level_' + this.getNestLevel());

            // Hide the original table
            domStyle.set(this.domNode, 'display', 'none');
        },

        postCreate: function () {
            this.inherited(arguments);

            // Parse the TitlePane's contents
            parser.parse(this._titlePane.containerNode, {template:false});
        },

        toggle: function () {
            this._titlePane.toggle();
        },

        // Count how many of my ancestors are TitlePanes
        getNestLevel: function () {
            var parentExpanders = 0;
            var parent = this.domNode.parentNode;
            while ( parent.nodeName.toLowerCase() !== 'body') {
                var parentWidget = dijitRegistry.byNode(parent);
                if (parentWidget && parentWidget.isInstanceOf(TitlePane)) {
                    parentExpanders++;
                }
                parent = parent.parentNode;
            }

            return parentExpanders;
        }
    });

});

},
'vodori/tinymce/FixedToolbar':function(){
/**
 * @description moves tinymce's toolbar to an arbitrary node.
 *
 * In the tinymce settings, set fixed_toolbar_node to the node, or id of the
 * node, you want the toolbar inside of.
 */

define([
    '../amd/tinymce',
    'vodori/provide',
    'module',
    'vodori/tinymce/util/getPluginName'
], function (tinymce, provide, module, getPluginName) {
    var plugin = provide(module.id, null, {
        toolbarHolder: null, // Holds this editor's toolbar.
        toolbarContainer: null, // Holds the holder. External, probably shared with other editors.

        changeDisplay: false, // Should we actually modify the "display" CSS property?

        init: function (ed, url) {
            this.toolbarContainer = tinymce.DOM.get(ed.getParam('fixed_toolbar_node'), this.toolbarContainer);
            this.changeDisplay = tinymce.DOM.get(ed.getParam('fixed_toolbar_change_display'), this.changeDisplay);

            ed.onPostRender.add(function () {
                this.moveToolbar(ed);
            }, this);
        },

        moveToolbar: function (ed) {
            if (!this.toolbarContainer) {
                return;
            }

            this.toolbarHolder = tinymce.DOM.add(this.toolbarContainer, 'div', {
                id: ed.id + '_fixedToolbar',
                'class': 'defaultSkin mceFixedToolbar'
            });

            // This cell contains the toolbar rows as separate tables
            var toolbarCell = tinymce.DOM.select('td.mceToolbar', tinymce.DOM.get(ed.id + '_parent'))[0];
            ed.dom.setStyle(toolbarCell, 'display', 'none');

            var toolbars = toolbarCell.children;
            while (toolbars.length !== 0) {
                ed.dom.add(this.toolbarHolder, toolbars[0]);
            }

            // Hide the toolbar initially
            this.hideToolbar(ed);
        },

        hideToolbar: function (ed) {
            ed.dom.removeClass(this.toolbarHolder, 'editorActive');
            ed.dom.addClass(this.toolbarHolder, 'editorInactive');

            if (this.changeDisplay) {
                ed.dom.setStyle(this.toolbarHolder, 'display', 'none');
            }

            this.constructor.prototype.hideHook(ed);
        },

        showToolbar: function (ed) {
            ed.dom.addClass(this.toolbarHolder, 'editorActive');
            ed.dom.removeClass(this.toolbarHolder, 'editorInactive');

            if (this.changeDisplay) {
                ed.dom.setStyle(this.toolbarHolder, 'display', '');
            }

            this.constructor.prototype.showHook(ed);
        },

        // These are some weird little hooks you can connect to like so:
        // dojo.connect(tinymce.plugins.FixedToolbar.prototype, 'hideHook', this, function(ed) {})
        hideHook: function (ed) {
        },
        showHook: function (ed) {
        }
    });

    tinymce.PluginManager.add(getPluginName(module), plugin);

    return plugin;
});

},
'vodori/tinymce/IFrame':function(){
define([
    'dojo/_base/lang',
    'dojo/dom-attr',
    '../amd/tinymce',
    'vodori/provide', 'module',
    './ConfigurableTransformer',
    './util/getResourceUrl', './util/getPluginName',
    'vodori/util/objectToProps', 'vodori/util/propsToObject',
    'vodori/ui/IFrame'
], function (lang,
             domAttr,
             tinymce,
             provide, module,
             ConfigurableTransformer,
             getResourceUrl, getPluginName,
             objectToProps, propsToObject,
             IFrame) {

    var pluginName = getPluginName(module);

    var resourceUrl = getResourceUrl(module);

    var plugin = provide(module.id, [ConfigurableTransformer], {

        dijitDeclaredClass: IFrame.prototype.declaredClass,

        url: resourceUrl,
        resourceUrl: resourceUrl,

        pluginName: pluginName,

        title: "iFrame",

        placeholderClass: 'mceIFramePlaceholder',

        popupWidth: 360,
        popupHeight: 200,
        popupOnCreate: true,

        wrapperTagName: 'iframe',
        placeHolderWrapperTagName: 'img',

        button: {
            label: '',
            image: 'iframe.gif',
            title: 'Insert an iFrame.',
            changeStates: {
                highlight: [pluginName],
                enable: [],
                disable: []
            }
        },

        styleSheet: true,

        defaultAttrs: {
            iframeSrc: '',
            iframeHeight: '200',
            iframeWidth: '300'
        },

        _updatePlaceHolderAttrs: function (wrapperNode) {
            var properties = {};
            if (wrapperNode) {
                properties = propsToObject(domAttr.get(wrapperNode, 'data-dojo-props'));
            }
            properties = lang.mixin({}, this.defaultAttrs, properties);

            this.placeHolderAttrs = {
                "style": "height: " + properties.iframeHeight + "px; width:" + properties.iframeWidth + "px",
                "class": "mceItem"
            };
        },

        /**
         * @param {tinymce.Editor} ed
         * @param {Element} node
         * @return {Array.<Element>}
         */
        convertToWidgets: function (ed, node) {
            var wrappers = this.inherited(arguments);
            tinymce.each(wrappers, function (wrapper) {
                var props = propsToObject(domAttr.get(wrapper, 'data-dojo-props'));
                wrapper.style.height = props.iframeHeight + 'px';
                wrapper.style.width = props.iframeWidth + 'px';
                wrapper.src = props.iframeSrc;
            });

            return wrappers;
        },

        /**
         * @param {tinymce.Editor} ed
         * @param {tinymce.ControlManager} cm
         * @param {Element} n
         * @return {void}
         */
        handleNodeChange: function (ed, cm, n) {
            var inWidget = !!this.getWrapperOf(n);
            var dom = ed.dom;
            if (inWidget) {
                dom.addClass(n, 'iframeSelected');
            }
            else {
                dom.removeClass(dom.select('.iframeSelected'), 'iframeSelected');
            }
        },

        filterAttrs: function (attrs) {
            /*
             * Remove any non-digits
             */
            attrs.iframeHeight = attrs.iframeHeight.replace(/[^\d.]/g, "");
            attrs.iframeWidth = attrs.iframeWidth.replace(/[^\d.]/g, "");
            // Disallow an empty src.
            attrs.iframeSrc = lang.trim(attrs.iframeSrc) || '#';

            return attrs;
        },

        postUpdateWrapper: function (wrapper) {
            this.inherited(arguments);
            this._resizeFPO(wrapper);

        },

        _resizeFPO: function (fpo) {
            var props = propsToObject(domAttr.get(fpo, 'data-dojo-props'));
            fpo.style.height = props.iframeHeight + 'px';
            fpo.style.width = props.iframeWidth + 'px';
        }

    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});
},
'vodori/tinymce/KeyboardShortcuts':function(){
/**
 * Add a method to TinyMCE that adds a listener to every event. Useful for
 * debugging.
 */
define([
    'vodori/provide', 'module',
    'lodash',
    'vodori/amd/tinymce',
    './util/getPluginName',
    './_GetInfoMixin',
    'vodori/ui/KeyboardShortcut'
], function (provide, module, _, tinymce, getPluginName, _GetInfoMixin, KeyboardShortcut) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, [_GetInfoMixin], {
        pluginName: pluginName,
        shortcutList: null,
        editor: null,

        /**
         * Adds keyboard shortcuts from the keyboard shortcut list maintained in vodori/ui/KeyboardShortcut.js
         * to an editable region.
         * @param editor The editable region that keyboard shortcuts are being added to
         */
        init: function (editor) {
            // Menu.js *MUST* construct the Action Menu first or this shortcut list will be empty!
            this.shortcutList = KeyboardShortcut.prototype.shortcutList;
            this.editor = editor;

            this.editor.onInit.add(function () {
                _.forEach(this.shortcutList, function (shortcut) {
                    var shortcutString = shortcut.shortcut.toLowerCase();
                    this.editor.addShortcut(shortcutString, shortcutString, function () {
                        // Will only run the shortcut if it is enabled (allows us to not have to reconstruct
                        // the shortcut list in the plugin).
                        if (shortcut.isEnabled()) {
                            shortcut.command();
                        }
                    }, this);
                    shortcutString = shortcut.shortcut;
                    this.editor.addShortcut(shortcutString, shortcutString, function () {
                        // Will only run the shortcut if it is enabled (allows us to not have to reconstruct
                        // the shortcut list in the plugin).
                        if (shortcut.isEnabled()) {
                            shortcut.command();
                        }
                    }, this);
                }, this);
            }, this);
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});


},
'vodori/tinymce/LimitHeight':function(){
// This plugin will limit the height of the editor to the viewport's height,
// minus some arbitrary padding specified in the config (default is 123px).
define([
    '../amd/tinymce',
    'vodori/provide',
    'module',
    'vodori/tinymce/util/getPluginName'
], function (tinymce, provide, module, getPluginName) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, null, {
        init: function (ed, url) {
            // Disable with {limitheight:false} in the config
            if (ed.getParam('limitheight', true)) {
                ed.onPostRender.add(function (ed) {
                    // Customize the padding with {limitheight_padding:n} in the config
                    // Used to make room for toolbars
                    var padding = parseInt(ed.getParam('limitheight_padding', 123), 10);

                    var frame = ed.getWin().frameElement;

                    ed.dom.bind(window, 'resize', function () {
                        var windowHeight = document.documentElement.clientHeight - padding;

                        if (windowHeight - 5 < frame.clientHeight) {
                            ed.dom.setStyle(frame, 'max-height', windowHeight + 'px');
                            ed.dom.setStyle(ed.getBody(), 'overflow-y', 'auto');
                        } else {
                            ed.dom.setStyle(frame, 'max-height', '');
                            ed.dom.setStyle(ed.getBody(), 'overflow-y', '');
                        }
                    });
                });
            }
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});
},
'vodori/tinymce/LimelightVideo':function(){
define([
    'vodori/provide', 'module',
    'dojo/query',
    'dojo/dom-class', 'dojo/dom-prop', 'dojo/dom-attr', 'dojo/dom-construct',
    'vodori/amd/tinymce',
    './ConfigurableTransformer',
    'vodori/video/LimelightVideoPlayer',
    './util/getResourceUrl', './util/getPluginName',
    'vodori/util/propsToObject', 'vodori/util/objectToProps',
    'vodori/util/node/htmlToElement', 'vodori/util/node/getOuterHTML'
], function (provide, module,
             query,
             domClass, domProp, domAttr, domConstruct,
             tinymce,
             ConfigurableTransformer,
             LimelightVideoPlayer,
             getResourceUrl, getPluginName,
             propsToObject, objectToProps,
             htmlToElement, getOuterHTML) {
    var pluginName = getPluginName(module);

    var resourceUrl = getResourceUrl(module);
    var PROTOCOL_REGEX = /h[\r|\n]*t[\r|\n]*t[\r|\n]*p[\r|\n]*(s[\r|\n]*)?:/g;

    var plugin = provide(module.id, [ConfigurableTransformer], {

        dijitDeclaredClass: LimelightVideoPlayer.prototype.declaredClass,

        url: resourceUrl,
        resourceUrl: resourceUrl,

        pluginName: pluginName,

        title: 'Limelight Video',

        placeholderClass: 'mceLimelightVideoPlaceholder',
        placeholderWidth: 100,
        placeholderHeight: 100,

        popupWidth: 500,
        popupHeight: 550,
        popupOnCreate: true,

        wrapperTagName: 'div',
        placeHolderWrapperTagName: 'img',

        frameWindow: null,
        modal: null,

        button: {
            label: '',
            image: 'img/limelight.png',
            title: 'Insert a Limelight video player.',
            changeStates: {
                highlight: [pluginName],
                enable: [],
                disable: []
            }
        },

        styleSheet: true,

        defaultAttrs: {
            videoHTML: ''
        },

        /**
         * Called after this.updateWrapper
         * Overriding in order to apply placeholder attributes to the placeholder, otherwise
         * they aren't applied into edit mode is turned off and back on. This is a workaround
         * until ConfigurableTransformer.js gets its needed heavy refactor.
         *
         * @param {Element} wrapper
         * @return {*}
         */
        postUpdateWrapper: function (wrapper) {
            this.inherited(arguments);
            // Override the style attribute with whatever is here.
            domAttr.set(wrapper, 'style', this.placeHolderAttrs.style);
            // Don't want to overwrite other classes, so just add it.
            domClass.add(wrapper, this.placeHolderAttrs['class']);
        },

        _configureFlashObject: function (flashObject, properties) {
            if (flashObject) {
                properties.videoWidth = domProp.get(flashObject, 'width');
                properties.videoHeight = domProp.get(flashObject, 'height');
                var wmodeParam = query('param[name="wmode"]', flashObject)[0];

                // If there isn't a wmode param, create it and add it to the Flash player object
                if (!wmodeParam) {
                    domConstruct.create('param', { 'name': 'wmode', 'value': 'transparent' }, flashObject);
                }
                // Else if there is a wmode param, but it's value isn't 'transparent', set it to that
                else if (domProp.get(wmodeParam, 'value') !== 'transparent') {
                    domProp.set(wmodeParam, 'value', 'transparent');
                }
            }
        },

        /**
         * Scans the injected video HTML for a wmode parameter, and if it doesn't exist or
         * doesn't have a value of 'transparent', it will be set with 'transparent' to avoid
         * having the video visually laying on top of things like the Stripe. Also extracts
         * the video's set dimensions to make the placeholder the same dimensions.
         * @param wrapperNode
         * @private
         */
        _updatePlaceHolderAttrs: function (wrapperNode) {
            var properties = {};

            if (wrapperNode) {

                // Convert the raw dataset into an object for easy parsing
                var dataset = propsToObject(wrapperNode.getAttribute('data-dojo-props'));

                // Replace all instances of 'http[s]:' with nothing, ignoring newlines between all characters
                // This allows the browser to figure out what protocol to use, and won't cause "insecure content"
                // warnings from the browser that typically require a page reload to load any "insecure" content.
                dataset.videoHTML = dataset.videoHTML.replace(PROTOCOL_REGEX, '');

                // Convert the dataset object's injected HTML into a DOM element tree
                var injectedHTML = htmlToElement(dataset.videoHTML, false);

                // Query for the Flash player object in the injected HTML tree
                var flashObjects = query('object.LimelightEmbeddedPlayerFlash', injectedHTML);

                // If there is a Flash player object, get its width and height and wmode param
                this._configureFlashObject(flashObjects[0], properties);

                // Convert the modified injected HTML tree back to a property string, and
                // replace the wrapper node's dataset with our modified raw dataset.
                wrapperNode.setAttribute('data-dojo-props', objectToProps({videoHTML: getOuterHTML(injectedHTML)}));
            }

            // Set the height and width for the editing-mode placeholder image
            this.placeholderWidth = properties.videoWidth || this.placeholderWidth;
            this.placeholderHeight = properties.videoHeight || this.placeholderHeight;

            // Set attributes of the place holder image, including dimensions
            this.placeHolderAttrs = {
                "style": "width: " + this.placeholderWidth + "px;" +
                    "height: " + this.placeholderHeight + "px; overflow:hidden;",
                "class": "mceItem"
            };
        },

        /**
         * @param {tinymce.Editor} ed
         * @param {tinymce.ControlManager} cm
         * @param {Element} n
         * @return {void}
         */
        handleNodeChange: function (ed, cm, n) {
            var dom = ed.dom;
            if (domClass.contains(n, 'vodori_video_LimelightVideoPlayer')) {
                dom.addClass(n, 'limelightVideoSelected');
            } else {
                this.removeSelectedHighlighting(ed);
            }
        },

        removeSelectedHighlighting: function (ed) {
            query('.limelightVideoSelected', ed.getBody()).forEach(function (node, index, arr) {
                domClass.remove(node, 'limelightVideoSelected');
            });
        }

    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'vodori/video/LimelightVideoPlayer':function(){
define([
    'module', 'vodori/provide',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin',
    'dojo/text!./templates/LimelightVideoPlayer.html'
],
    function (module, provide, _WidgetBase, _TemplatedMixin, template) {

        var LimelightVideoPlayer = {

            templateString: template,
            videoHTML: ''

        };

        return provide(module.id, [_WidgetBase, _TemplatedMixin], LimelightVideoPlayer);
    }
);


},
'vodori/tinymce/OverrideContextCommand':function(){
/**
 * A simple tool for overridding pre-exisitng tinymce context menu entries.
 * Please note, this plugin will only override commands from plugins that are
 * already loaded and should really only be used for "built-in" tinymce
 * functionality.
 */
define([
    '../amd/tinymce',
    'vodori/provide',
    'module',
    'vodori/tinymce/util/getPluginName'
], function (tinymce, provide, module, getPluginName) {
    var plugin = provide(module.id, null, {

        /**
         * @type {tinymce.create.Editor}
         */
        editor: {},

        /**
         * @param {tinymce.create.Editor} ed
         * @return {void}
         */
        init: function (ed) {
            var commands = ed.getParam('overridden_commands');

            this.editor = ed;

            var handle = ed.onContextMenu.add(function () {
                for (var command in commands) {
                    if (commands.hasOwnProperty(command)) {
                        this.overrideContextMenu(command, commands[command]);
                    }
                }

                // Clean up after ourselves.
                tinymce.dom.Event.remove(ed, 'onContextMenu', handle);
            }, this);
        },

        /**
         * @param {string} oldCommand
         * @param {string} newCommand
         * @return {void}
         */
        overrideContextMenu: function (oldCommand, newCommand) {
            var menu = this.editor.plugins.contextmenu._menu.items;
            var option = {};

            for (option in menu) {
                option = menu[option];
                if (option.settings &&
                    option.settings.cmd &&
                    option.settings.cmd === oldCommand) {

                    option.settings.cmd = newCommand;
                    return option.settings;
                }
            }
        }

    });

    tinymce.PluginManager.add(getPluginName(module), plugin);

    return plugin;
});


},
'vodori/tinymce/Placeholder':function(){
define([
    'module', 'vodori/provide',
    'dojo/parser', 'dojo/ready',
    'vodori/amd/tinymce',
    'vodori/tinymce/ui/Placeholder',
    'vodori/tinymce/ConfigurableTransformer',
    'vodori/tinymce/util/getPluginName',
    'vodori/tinymce/util/getResourceUrl',
    'vodori/util/objectToProps', 'vodori/util/propsToObject'
], function (module, provide,
             parser, ready,
             tinymce,
             Placeholder,
             ConfigurableTransformer,
             getPluginName,
             getResourceUrl,
             objectToProps, propsToObject) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, [ConfigurableTransformer], {

        /**
         * @type {string}
         */
        pluginName: pluginName,

        /**
         * @type {string}
         */
        placeholderClass: 'placeholder',

        /**
         * @type {string}
         */
        dijitDeclaredClass: Placeholder.prototype.declaredClass,

        /** Selector for possible placeholder nodes.
         *
         * @type {string}
         */
        include: '',

        /**
         * @type {Object}
         */
        button: {
            label: '',
            image: 'img/brick.gif',
            title: 'Insert a content placeholder',

            changeStates: {
                highlight: [pluginName],
                enable: [],
                disable: []
            }
        },

        /**
         * @type {Array.<string>}
         */
        optionIds: [],

        /**
         * @type {Object}
         */
        defaultAttrs: {
            _contentOptions: [],
            selectedContentOption: 'none'
        },

        /**
         * @type {string}
         */
        url: getResourceUrl(module),

        /**
         * @param {tinymce.Editor} ed
         * @return {void}
         */
        init: function (ed) {
            this.inherited(arguments);
            this.include = ed.getParam('placeholder_content_selector');

            ready(this, function () {
                this.defaultAttrs._contentOptions = this.getOptionIds();
            });
        },

        /** Find potential placeholder content.
         *
         * @return {Array.<string>}
         */
        getOptionIds: function () {
            var dom = tinymce.DOM;

            var placeNodes = dom.select(this.include, document);
            var ids = [];
            tinymce.each(placeNodes, function (node) {
                // Generate a unique ID if the node doesn't already have one
                if (!dom.getAttrib(node, 'id')) {
                    var newIdBase = 'placeable_' + node.nodeName.toLowerCase() + '_';
                    var copyNumber = 1;

                    var newId = newIdBase + copyNumber;
                    while (document.getElementById(newId)) {
                        copyNumber++;
                        newId = newIdBase + copyNumber;
                    }

                    dom.setAttrib(node, 'id', newId);
                }

                // Generate a title if there isn't one specified
                if (!dom.getAttrib(node, 'title')) {
                    dom.setAttrib(node, 'title', 'Untitled node (#' + node.id + ')');
                }

                ids.push(dom.getAttrib(node, 'id'));
            }, this);

            return ids;
        },

        /**
         * @param {Element} wrapper
         * @return {Element}
         */
        postInsertNew: function (wrapper) {
            this.popupOptionsFor(wrapper);
            return wrapper;
        },

        /**
         * @param {tinymce.Editor} ed
         * @param {Element} node
         * @return {Array.<Element>}
         */
        convertToWrappers: function (ed, node) {
            var wrappers = this.inherited(arguments);
            var dom = ed.dom;

            tinymce.each(wrappers, function (wrapper) {
                dom.setAttribs(wrapper, {
                    style: 'height: 100px; width: 100px;',
                    src: '/static/js/vodori/tinymce/placeholder/img/widget.gif'
                });
            }, this);

            return wrappers;
        },

        /**
         * @param {tinymce.Editor} ed
         * @param {Element} node
         * @param {boolean} setDojoType
         * @return {Array.<Element>}
         */
        convertToWidgets: function (ed, node, setDojoType) {
            var dom = ed.dom;

            var placeHolderWidgetNodes = dom.select('.' + this.dijitDeclaredClassCSS, node);

            tinymce.each(placeHolderWidgetNodes, function (node) {
                var props = propsToObject(dom.getAttrib(node, 'data-dojo-props') || '');

                tinymce.extend(props, {
                    include: '#' + props.selectedContentOption
                });

                dom.setAttrib(node, 'data-dojo-props', objectToProps(props));

                var placeholders = dom.select('> .' + this.placeholderClass, node);
                tinymce.each(placeholders, function (placeholder) {
                    dom.remove(placeholder);
                });

            }, this);

            return this.inherited(arguments);
        }

    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'vodori/tinymce/ui/Placeholder':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'dojo/dom', 'dojo/dom-attr', 'dojo/dom-class', 'dojo/dom-construct',
    'dojo/parser', 'dojo/query',
    'dijit/_Widget',
    'vodori/util/NotParsed', 'vodori/util/SerializableMixin'
], function (
    module, provide,
    lang,
    dom, domAttr, domClass, domConstruct,
    parser, query,
    _Widget,
    NotParsed, _SerializableMixin) {
    return provide(module.id, [_Widget, _SerializableMixin], {
        // A CSS selector targetting which node(s) to place in the placeholder
        include: '',

        // We'll store the selected node(s) here
        _nodeList: [],

        create: function () {
            this.inherited(arguments);

            domClass.add(this.domNode, 'vodori-placeholder');

            this._nodeList = query(this.include);

            if (this._nodeList.length < 1) {
                console.warn('Placeholder: no nodes matching "' + this.include + '" found.');
                return;
            }

            this._nodeList.forEach(function (node) {
                var newNode = this.makeCopy(node);
                domConstruct.place(newNode, this.domNode);

                // Cloned widgets don't work, so make sure we parse them after they've been placed
                parser.parse(newNode, {template:false});
            }, this);
        },

        makeCopy: function (node) {
            var newNode = lang.clone(node);

            var nodesWithId = query('[id]', newNode);

            // Add the new node to the list of nodes with ID for processing
            if (newNode.id) {
                nodesWithId.push(newNode);
            }

            nodesWithId.forEach(function (nodeWithId) {
                // Make a unique ID
                var newIdBase = nodeWithId.id + '_copy_';
                var copyNumber = 1;

                var newId = newIdBase + copyNumber;
                while (dom.byId(newId)) {
                    copyNumber++;
                    newId = newIdBase + copyNumber;
                }

                // Update labels to point to the correct ID
                var forNodes = query('label[for=' + nodeWithId.id + ']', newNode);
                forNodes.attr('for', newId);

                nodeWithId.id = newId;
            });

            domClass.add(newNode, 'vodori-placeholder-placed');

            // Remove the title so it doesn't show on hover
            domAttr.remove(newNode, 'title');

            return newNode;
        }
    });
});

},
'vodori/util/NotParsed':function(){
define([
    'module', 'vodori/provide',
    'dojo/dom-attr', 'dojo/query',
    'dijit/_Widget'
], function (module, provide,
             domAttr, query,
             _Widget) {
    return provide(module.id, [_Widget], {
        childWidgets: null,

        create: function () {
            this.inherited(arguments);

            // Disguise the dojoType attributes as potentialDojoType attributes
            this.childWidgets = query('[data-dojo-type]', this.srcNodeRef);
            this.childWidgets.forEach(function (node) {
                domAttr.set(
                    node,
                    'data-potential-dojo-type',
                    domAttr.get(node, 'data-dojo-type')
                );
                domAttr.remove(node, 'data-dojo-type');
            });
        },

        startup: function () {
            this.inherited(arguments);

            // The parser is done. Switch the attributes back to their original states.
            this.childWidgets.forEach(function (node) {
                domAttr.set(
                    node,
                    'data-dojo-type',
                    domAttr.get(node, 'data-potential-dojo-type')
                );
                domAttr.remove(node, 'data-potential-dojo-type');
            });
        }
    });
});

},
'vodori/tinymce/PreventLineBreaks':function(){
// Keeps the editor from having multiple lines. P and BR tags removed.
define([
    'vodori/provide', 'module',
    'dojo/_base/lang', 'dojo/_base/sniff',
    'dojo/dom-construct',
    'vodori/amd/tinymce',
    'vodori/tinymce/util/getPluginName'
], function (provide, module, lang, sniff, domConstruct, tinymce, getPluginName) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, null, {
        init: function (activeEditor) {

            // Capture Enter Key and Prevent it
            // For Firefox
            activeEditor.onKeyPress.add(function (activeEditor, event) {
                if (event.keyCode === 13) {
                    event.preventDefault();
                    event.stopPropagation();
                    return false;
                }
            });

            // For everything else (Yes! Even IE6!)
            activeEditor.onKeyDown.add(function (activeEditor, event) {
                if (event.keyCode === 13) {
                    event.preventDefault();
                    event.stopPropagation();
                    return false;
                }
            });

            // Just in case
            activeEditor.onKeyUp.add(function (activeEditor, event) {
                if (event.keyCode === 13) {
                    event.preventDefault();
                    event.stopPropagation();
                    return false;
                }
            });

            // Capture Paste event and cleanup line breaks. Timeout to wait for paste to happen before cleanup.
            activeEditor.onPaste.add(function (activeEditor) {
                setTimeout(lang.hitch(this, function () {

                    // Place a space before each P and BR tag, then remove the tag,
                    // leaving its inner contents untouched.
                    tinymce.each(activeEditor.dom.select("P, BR"), function (tagFound) {
                        activeEditor.dom.doc.body.insertBefore(activeEditor.dom.doc.createTextNode(" "), tagFound);
                        activeEditor.dom.remove(tagFound, true);
                    });

                    // If not IE, create a span at the end of the editor content so we can later move the cursor there.
                    if (!sniff.isIE) {
                        var span = domConstruct.create("span");
                        activeEditor.dom.doc.body.appendChild(span);
                    }

                    // We move the cursor to the span, then remove the span, leaving the cursor in its place.
                    setTimeout(function () {
                        if (!sniff.isIE) {
                            activeEditor.selection.select(span);
                            activeEditor.dom.remove(span, true);
                        }
                    }, 150);
                }), 1);
            });
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'vodori/tinymce/RandomImage':function(){
define([
    '../amd/tinymce',
    'vodori/provide',
    'module',
    'vodori/tinymce/util/getPluginName',
    'vodori/tinymce/util/getResourceUrl'
], function (tinymce, provide, module, getPluginName, getResourceUrl) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, null, {
        init: function (ed) {
            var url = this.url = getResourceUrl(module);

            // Register commands
            ed.addCommand('mce' + pluginName, function () {
                // Internal image object like a flash placeholder
                if (ed.dom.getAttrib(ed.selection.getNode(), 'class').indexOf('mceItem') !== -1) {
                    return;
                }

                ed.windowManager.open({
                    file: url + '/image.htm',
                    width: 480 + parseInt(ed.getLang('advimage.delta_width', 0), 10),
                    height: 485 + parseInt(ed.getLang('advimage.delta_height', 0), 10),
                    inline: 1
                }, {
                    /* jshint -W106 */
                    plugin_url: url
                    /* jshint +W106 */
                });
            });

            function isRandomImageElm(n) {
                return (/^(randomimage)$/).test(n.className);
            }


            // Register buttons
            ed.addButton(pluginName, {
                title: 'Random Images',
                cmd: 'mce' + pluginName
            });

            ed.onNodeChange.add(function (ed, cm, n) {
                cm.setActive(pluginName, n.nodeName === 'IMG' && isRandomImageElm(n));
            });
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});
},
'vodori/tinymce/RegEx':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'vodori/amd/tinymce',
    'vodori/tinymce/util/getPluginName',
    'vodori/tinymce/util/getResourceUrl'
], function (provide, module,
             _,
             tinymce,
             getPluginName,
             getResourceUrl) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, null, {

        /* jshint -W106 */
        regex_config_key: 'regex_config',
        /* jshint +W106 */

        init: function (ed) {
            this.url = getResourceUrl(module);

            // If this is being called via inheritance, then we'll just be
            // getting an array of arguments in the first place.
            if (_.isArray(ed)) {
                ed = ed[0];
            }

            var t = this;

            t.editor = ed;

            ed.onBeforeSetContent.add(function (ed, o) {
                if (o.set) {
                    o.content = t._doReplacement(ed, o);
                }
            });

            ed.onPostProcess.add(function (ed, o) {
                if (o.get) {
                    o.content = t._doReplacement(ed, o);
                }
            });

            if (this.inherited) {
                this.inherited("init", arguments);
            }

        },

        _doReplacement: function (ed, o) {

            var h = o.content;

            /* jshint -W106 */
            var regexConfig = this.regex_config; // Allow the config to be specified internally
            if (!regexConfig) {
                regexConfig = ed.getParam(this.regex_config_key);
            }
            /* jshint +W106 */


            if (!regexConfig) {
                return h;
            } // Don't replace anything if we're not configured to do so

            h = h.replace(/\r|\n|\r\n/g, "");

            var direction =     (o.get) ?   "fromTinyIntoPage"
                            :   (o.set) ?   "fromPageIntoTiny"
                            :               null;
            if(!direction) {
                console.warn("Why is neither o.set or o.get true for the Tiny regex plugin?");
                return;
            }

            _.forOwn(regexConfig, function(config) {
                if (!config[direction]) {
                    return; // Skips to next value
                }

                var search = config[direction].search;
                var replace = config[direction].replace;

                var regex = new RegExp(search, "gi");
                h = h.replace(regex, replace);
            });

            return h;
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'vodori/tinymce/RemoveForcedRoots':function(){
// This plugin should read a no_forced_root list in the config (say, 'img')
// and remove the forced_root_element (usually a <p>)from matching nodes.
// Sadly, it doesn't quite work. Maybe one day it will.
// I think something weird happens with onInit.
define([
    'vodori/provide', 'module',
    'dojo/_base/lang',
    'vodori/amd/tinymce',
    'vodori/tinymce/util/getPluginName'
], function (provide, module, lang, tinymce, getPluginName) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, null, {
        init: function (ed) {
            this.editor = ed;

            this.forcedRoot = ed.getParam('forced_root_block', '');
            this.noForcedRoot = ed.getParam('no_forced_root', '').replace(/\s/g, '').split(',');

            // Don't bother making any connections
            if (!this.noForcedRoot[0]) {
                return;
            }

            // These are events on which forceRoots seems to fire
            // forceRoots is really hard to get to. It'd be nice to override it.
            var when = [
                'onInit', 'onSetContent', 'onBeforeGetContent',
                'onBeforeExecCommand', 'onKeyUp', 'onPreProcess'
            ];

            tinymce.each(when, function (now) {
                ed[now].add(this.removeForcedRoots, this);
            }, this);

            ed.addCommand('mce_remove_forced_root', this.removeForcedRoots, this);
        },

        removeForcedRoots: function () {
            setTimeout(lang.hitch(this, '_removeForcedRoots'), 1);
        },

        _removeForcedRoots: function () {
            if (!this.forcedRoot) {
                return;
            }

            var ed = this.editor,
                body = ed.getBody(),
                removeParent = function (n) {
                    ed.dom.remove(n.parentNode, true);
                    console.log(body.innerHTML);
                };

            var i = 0, selectorsCount = this.noForcedRoot.length, selector = '';
            for (i = 0; i < selectorsCount; i++) {
                selector = this.noForcedRoot[i];

                var rooted = ed.dom.select(this.forcedRoot + '>' + selector, body);
                tinymce.each(rooted, removeParent);
            }
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'vodori/tinymce/RemoveMarkup':function(){
/**
 * Remove Markup in a field
 */
define([
    '../amd/tinymce',
    'vodori/provide',
    'module',
    'vodori/tinymce/util/getPluginName'
], function (tinymce, provide, module, getPluginName) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, null, {
        init: function (ed) {
            var t = this;

            t.editor = ed;

            ed.onKeyDown.add(function (ed, e) {
                if ((ed.getBody().innerHTML === '<br mce_bogus="1">') ||
                    (ed.getBody().innerHTML === '<P>&nbsp;</P>') ||
                    (ed.getBody().innerHTML.length === 0)
                   ){
                    ed.getBody().innerHTML = ' ';
                }
            });

        },

        getInfo: function () {
            return {
                longname: 'Remove Markup',
                author: 'Nathan Kurtyka',
                authorurl: 'http://www.vodori.com',
                infourl: 'http://www.vodori.com',
                version: tinymce.majorVersion + "." + tinymce.minorVersion
            };
        }

    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});
},
'vodori/tinymce/RemoveSingleForcedRoot':function(){
// If there's a single root node, and it's forced,
// don't include it as part of the content when saving.
define([
    '../amd/tinymce',
    'vodori/provide',
    'module',
    'vodori/tinymce/util/getPluginName'
], function (tinymce, provide, module, getPluginName) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, null, {
        init: function (ed) {
            ed.onPreProcess.add(function (ed, o) {
                var dom = ed.dom;
                var body = o.node;

                // Is there only one node in the content?
                if (body.children.length !== 1) {
                    return;
                }
                var root = body.children[0];

                // Is that node a forced root?
                if (root.nodeName.toLowerCase() !== ed.getParam('forced_root_block', '').toLowerCase()) {
                    return;
                }

                // Does that node have no attributes?
                if (dom.getAttribs(root).length !== 0) {
                    return;
                }

                // Then get rid of it, but keep its contents
                dom.remove(root, true);
            }, this);
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});
},
'vodori/tinymce/LiveStyling':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'vodori/amd/tinymce',
    'vodori/tinymce/util/getPluginName', 'vodori/util/string/startsWith', 'vodori/enums/cssRulesEnum',
    'vodori/util/node/getCssClasses'
], function (provide, module, _, lang, tinymce, getPluginName, startsWith, cssRulesEnum, getCssClasses) {
    'use strict';

    var LIVE_STYLES_ATTR = 'data-vodori-live-styling';
    var EDITOR_CONTAINER_SELECTOR = '.mceEditor';

    /**
     * This module transports styles from the containing document into a tinymce.Editor for which it's
     * enabled.
     *
     * To disable any sheet, set data-vodori-live-styling="false" on the link or style block. (This
     * works for LESS sheets as well as normal CSS.)
     */
    var Plugin = provide(module.id, null, {
        /**
         * @type {tinymce.Editor}
         */
        ed: null,

        /**
         * The frame that contains the editor.
         *
         * @type {Window}
         */
        frame: null,

        /**
         * The sheet we'll hang our styles from.
         *
         * @type {CSSStyleSheet}
         */
        sheet: null,

        /**
         * Matching selectors will be removed when testing for a match against the editor.
         *
         * It matches things like :hover, :first-child, :not([controls]), :nth-child(2), and ::-moz-focus-inner
         *
         * @type {RegExp}
         * @const
         */
        IGNORED_SELECTOR_COMPONENTS: /:+[^\s]+/ig,

        /**
         * Wait for frame to finish rendering, then begin transporting styles into it.
         *
         * @param {tinymce.Editor} ed
         */
        init: function (ed) {
            this.ed = ed;

            this.cachingEnabled = !ed.getParam('disable_live_styling_cache');

            ed.onPostRender.add(function () {
                this.loadStyles();
            }, this);
        },

        loadStyles: function () {
            this.frame = this.ed.getWin().frameElement;
            this._container = this.ed.getContainer();
            this._processFrame();
        },

        /**
         * Transports all the styles from the parent frame into the editor.
         *
         * @private
         */
        _processFrame: function () {
            var dom = this.ed.dom;
            var head = dom.doc.head;

            var styleNode = dom.add(head, 'style', {
                title: 'injectedCss',
                type: 'text/css',
                // Prevent the browser from rendering our sheet, until we've processed all the rules.
                disabled: true
            }, '/* Injected CSS */');
            this.sheet = styleNode.sheet;

            var cachedStyleSheet = this.cachingEnabled && this._getCachedStylesIfAny();

            if(cachedStyleSheet) {
                console.info('Using cached StyleSheet');

                _.forEach(cachedStyleSheet.cssRules, function(rule) {
                    this.sheet.insertRule(rule.cssText, this.sheet.cssRules.length);
                }, this);

            } else {
                // Process each stylesheet and compile them into the new one
                _.forEach(document.styleSheets, this._processSheet, this);

                if (this.cachingEnabled) {
                    this._setCachedStyles(this.sheet);
                }
            }

            styleNode.removeAttribute('disabled');

            this._undoTinymceStyling();
        },

        _getCachedStylesIfAny: function() {
            return Plugin.styleSheetCache[this._getCacheKey()];
        },

        _setCachedStyles: function(objectToCache) {
            Plugin.styleSheetCache[this._getCacheKey()] = objectToCache;
        },

        _getCacheKey: function() {
            var wysiwygLocation = this._container.parentElement;
            wysiwygLocation = wysiwygLocation && wysiwygLocation.parentElement;

            return this._buildCssSelectorCacheKeyForNode(wysiwygLocation);
        },

        _buildCssSelectorCacheKeyForNode: function(node) {
            var selectors = [];
            while (node && node.nodeName.toLowerCase() !== 'body') {
                var selector = node.nodeName.toLowerCase();
                _.forEach(_.sortBy(getCssClasses(node)), function(className) {
                    selector += "." + className;
                }); // jshint ignore:line
                selectors.unshift(selector);

                node = node.parentNode;
            }

            return selectors.join(' ');
        },

        /**
         * @param {CSSStyleSheet} sheet
         * @private
         */
        _processSheet: function (sheet) {
            // Don't parse disabled sheets.
            if (sheet.disabled || !this._isLiveStylingEnabled(sheet)) {
                return;
            }

            // Process each rule and append it to the new stylesheet
            try {
                // If there are no cssRules, then assume that it is just a <link> tag that needs to be injected.
                // This is needed for links such as Google API fonts.
                if (!sheet.cssRules) {
                    this._injectLinkTag(sheet);
                } else {
                    _.forEach(sheet.cssRules, function (rule) {
                        var newRule = this._processRule(rule);
                        _.forEach(newRule, function (rule) {
                            // It didn't match the editor.
                            if (rule === '') {
                                return;
                            }

                            // Another try catch block to let us ignore bad selectors
                            // that're part of a comma delimited set.
                            try {
                                this.sheet.insertRule(rule, this.sheet.cssRules.length);
                            } catch (e) {
                                console.warn(e, 'couldn\'t handle rule:', rule);
                            }
                        }, this);
                    }, this);
                }
            } catch (e) {
                // Firefox doesn't like us checking if(!sheet.cssRules) and throws a security exception.
                // We catch it here and inject the link tag anyway.
                if (e.name === 'SecurityError') {
                    try {
                        this._injectLinkTag(sheet);
                    } catch (ex) {
                        console.warn(ex, 'Unable to inject link tag', sheet);
                    }
                } else {
                    console.warn(e, 'probably tried to access cross domain styles while loading', sheet);
                }
            }
        },

        /**
         * Figure out the type of a rule and add to the frame as best we can.
         *
         * @param {CSSRule} rule
         * @return {Array.<string>}
         */
        _processRule: function (rule) {
            var ruleResult = [''],
                ruleType = rule.type;

            switch (ruleType) {

                /**
                 * Process a {CSSStyleRule}
                 */
                case cssRulesEnum.STYLE_RULE:
                    ruleResult = this._processStyleRule(rule);
                    break;

                /**
                 * Process a {CSSImportRule}
                 */
                case cssRulesEnum.IMPORT_RULE:
                    if (this.ed.dom.create('a', {href: rule.href}).hostname !== location.hostname) {
                        console.warn('Can\'t inject a stylesheet from another domain', rule);
                    } else {
                        this._processSheet(rule.styleSheet);
                    }
                    break;

                /**
                 * Process a {CSSMediaRule}
                 */
                case cssRulesEnum.MEDIA_RULE:
                    ruleResult = this._processMediaRule(rule);
                    break;

                /**
                 * Process a {CSSFontFaceRule}
                 */
                case cssRulesEnum.FONT_FACE_RULE:
                    ruleResult = [rule.cssText];
                    break;

                /**
                 * Ignore any other type of {CSSRule}
                 */
                default:
                    console.warn('Ignoring rule: ', rule);
            }

            return ruleResult;
        },

        /**
         * Handle transforming a CSSMediaRule into a collection of stringified CSS rules with reduced selectors.
         * Loop through each of the CSSMediaRule's CSSRules and call the original _processRule. Wrap each of those
         *  processed rules in the original media query and return as an array.
         *
         * @param {CSSMediaRule} rule
         * @returns {Array.<string>}
         * @private
         */
        _processMediaRule: function(rule) {
            var mediaRules = [],
                originalMediaQuery = rule.media.mediaText;

            // Don't bother adding print-only styles to the region
            if (rule.media.length == 1 && rule.media[0] == 'print') {
                return mediaRules;
            }

            // Loop through and process each rule in this media query
            var rulesWithin = rule.cssRules;
            _.forEach(rulesWithin, function(ruleWithin) {
                var processedRules = this._processRule(ruleWithin);

                // Wrap each processed rule into the original media query
                _.forEach(processedRules, function(processedRule) {
                    mediaRules.push('@media ' + originalMediaQuery + ' { ' + processedRule  + ' }');
                }, this);

            }, this);

            return mediaRules;
        },

        /**
         * Handles transforming a CSSStyleRule into a collection of stringified CSS rules with
         * reduced selectors.
         *
         * @param {CSSStyleRule} rule
         * @return {Array.<string>}
         * @private
         */
        _processStyleRule: function (rule) {
            // Ignore empty rules
            if (!rule.style.cssText) {
                return [''];
            }

            var selectors = rule.selectorText.split(',');

            var reducedSelector = '';
            for (var i = 0; i < selectors.length; i++) {
                selectors[i] = lang.trim(selectors[i]);

                reducedSelector = this._reduceSelector(selectors[i]);

                // Reduction was successful.
                if (reducedSelector && reducedSelector !== selectors[i]) {
                    // Add in the version with the leading components removed.
                    selectors.splice(i + 1, 0, reducedSelector);
                    i += 1;
                }
            }

            return _.map(selectors, function (selector) {
                if (selector.length > 0) {
                    return selector + ' {' + rule.style.cssText + '}';
                } else {
                    return '';
                }
            });
        },

        /**
         * Attempt to match against the editor, breaking off leading components of the selector that
         * match.
         *
         * @param {string} selector
         * @return {(string|boolean)}
         * @private
         */
        _reduceSelector: function (selector) {
            var parts = selector.split(' ');
            var selectorHead = '';

            // Test the selector from left to right, removing this container's ancestry.
            for (var i = 0; i < parts.length; i++) {
                selectorHead = parts.slice(0, i + 1).concat([
                    EDITOR_CONTAINER_SELECTOR
                ]).join(' ');

                try {
                    if (!this.ed.dom.is(this._container, selectorHead.replace(this.IGNORED_SELECTOR_COMPONENTS, ''))) {
                        return parts.slice(i).join(' ');
                    }
                } catch (e) {
                    // Catch the error here so that we can continue processing other rules in this stylesheet
                    console.warn("tinymce.dom.DOMUtils::is() was unable to parse the selector: " +
                        selectorHead.replace(this.IGNORED_SELECTOR_COMPONENTS, ''));
                }
            }

            return false;
        },

        /**
         * Injects a link tag directly into the iframe's <head> tag. Assumes the link tag is a
         * stylesheet, but tries to scrape what other info it can out of the sheet. Direct injection
         * of a link tag is needed for links like Google API fonts.
         * @param sheet The stylesheet that is being added manually as a <link> tag
         * @private
         */
        _injectLinkTag: function (sheet) {
            var dom = this.ed.dom;
            var head = dom.doc.head;

            dom.add(head, 'link', {
                title: sheet.title,
                type: sheet.type,
                rel: 'stylesheet',
                href: sheet.href
            });
        },

        /**
         * Undoing some of tinymce's styles to prevent their stepping on those we've transported
         * from the parent frame.
         *
         * @private
         */
        _undoTinymceStyling: function () {
            var dom = this.ed.dom;
            dom.setStyles(this.ed.getBody(), {
                background: 'transparent',
                margin: '0px',
                padding: '0px'
            });
            dom.setStyle(this.frame, 'background', 'transparent');
            dom.setStyle(dom.select('> table', this.ed.getContainer())[0], 'background', 'transparent');
        },

        /**
         * Tests if live styling has been disabled for a given style sheet. Includes a back track
         * for LESS rules.
         *
         * @param {CSSStyleSheet} sheet
         * @return {boolean}
         * @protected
         */
        _isLiveStylingEnabled: function (sheet) {
            var dom = tinymce.DOM;
            var ownerNode = sheet.ownerNode;
            var id = ownerNode && ownerNode.id;
            var possiblePath = null;
            if (!!id && startsWith(id, 'less:')) {
                // Backtrack the less files
                possiblePath = id.replace('less:', '').split('-').join('/') + '.less';

                return !dom.select([
                    '[', LIVE_STYLES_ATTR, '="false"]',
                    '[href$="', possiblePath, '"],',
                    '[', LIVE_STYLES_ATTR, '="false"]',
                    '[title="', id, '"]'
                ].join('')).length;
            }


            return dom.getAttrib(ownerNode, LIVE_STYLES_ATTR) !== 'false';
        }
    });

    Plugin.styleSheetCache = {};

    tinymce.PluginManager.add(getPluginName(module), Plugin);

    return Plugin;
});

},
'vodori/enums/cssRulesEnum':function(){
/* global CSSStyleRule: false  */
define(['../util/Enum'], function (Enum) {
    'use strict';

    /**
     * Transports CSSStyleRule enumerables into our Enum container, giving us some helper methods.
     */
    var ruleTypes = new Enum();
    var styleRulePrototype = CSSStyleRule.prototype;
    for (var type in styleRulePrototype) {
        // I want the rule types from the prototype of CSSStyleRule. IE has some other junk keys in
        // there that we want to ignore.
        //noinspection JSUnfilteredForInLoop
        if (/RULE$/.test(type)) {
            //noinspection JSUnfilteredForInLoop
            ruleTypes[type] = styleRulePrototype[type];
        }
    }

    return ruleTypes;
});
},
'vodori/util/node/getCssClasses':function(){
define(['lodash'], function (_) {

    /**
     * Returns a list of CSS classes specified on an HTML node.
     *
     * @param {HTMLElement} node (if null or has no classes, an empty array is returned)
     * @return {Array.<String>} array of classes in the order specified in the HTML
     */
    return function (node) {
        if (!node || !node.className) {
            return [];
        }
        var classes = node.className.split(/\s+/);
        return _.filter(classes);
    };
});

},
'vodori/tinymce/Stamp':function(){
define([
    'dojo/dom-attr',
    '../amd/tinymce',
    'vodori/provide', 'module',
    './util/getResourceUrl', 'vodori/tinymce/_Selection'
], function (domAttr, tinymce, provide, module, getResourceUrl, _Selection) {
    var plugin = provide(module.id, [_Selection], {
        /**
         * @type {tinymce.Editor}
         */
        editor: null,

        /**
         * Path to resources.
         *
         * @type {string}
         */
        url: '',

        /**
         * Collection of stamp configurations. See init for example stamps.
         *
         * @type {Object}
         */
        stamps: null,

        /**
         * @param {tinymce.Editor} ed
         * @return {void}
         */
        init: function (ed) {
            this.editor = ed;
            this.url = getResourceUrl(module);

            // IE doesn't include the slash
            if (this.url.charAt(0) !== '/') {
                this.url = '/' + this.url;
            }

            // Read in stamps from our config.
            // NOTE: Stamp templates must contain exactly one root element.
            // Defaults to the example stamps here.
            this.stamps = ed.getParam('stamps', {
                paragraph: {
                    label: 'P',
                    template: '_tests/paragraph.htm',
                    /* jshint -W106 */
                    lorem_ipsum: 'Hey, this is some paragraphical placeholder text'
                    /* jshint +W106 */
                },

                linky: {
                    label: 'a',
                    template: '_tests/link.htm',
                    /* jshint -W106 */
                    lorem_ipsum: 'Link'
                    /* jshint +W106 */
                },

                divAwesome: {
                    label: 'div.awesome',
                    template: '_tests/divAwesome.htm',
                    /* jshint -W106 */
                    forbidden_ancestors: ['div.awesome'] // Too awesome to nest
                    /* jshint +W106 */
                },

                ulGreat: {
                    label: 'ul.great',
                    template: '_tests/ulGreat.htm',
                    container: 'ul.great' // A node in the template
                },

                tabley: {
                    label: 'table',
                    template: '_tests/table.htm'
                },

                special: {
                    label: 'special',
                    template: '_tests/forbiddenContainer.htm',
                    /* jshint -W106 */
                    forbidden_ancestors: ['div.special'],
                    /* jshint +W106 */
                    container: 'div.special'
                },

                inline: {
                    label: 'inline',
                    templateString: '<p>My template is defined inline{|}</p>'
                }
            });

            // Add a reusable stamp command.
            ed.addCommand('mce_stamp', this.stampContent, this);
            this.addButtons(ed);

            this.rules = ed.getParam('stamp_rules', {
                /* jshint -W106 */
                div: {forbidden_ancestors: ['p']},
                p: {forbidden_ancestors: ['p']},
                ul: {forbidden_ancestors: ['p'], container: 'ul'},
                ol: {forbidden_ancestors: ['p'], container: 'ol'},
                table: {forbidden_ancestors: ['p'], container: 'table > tbody'},
                dl: {forbidden_ancestors: ['p']},
                a: {forbidden_ancestors: ['a']},
                label: {forbidden_ancestors: ['label']}
                /* jshint +W106 */
            });

            // Self-closing tags are forbidden ancestors of every node 
            this.selfClosers = ['br', 'hr', 'img'];
        },

        // Make a button available for each stamp in the "stamps" config object.
        addButtons: function (ed) {
            tinymce.each(this.stamps, function (stamp, name) {
                if (!stamp.templateString) {
                    // If the stamp has a template, figure out if it's absolute
                    // or relative to the templates dir.
                    if (stamp.template.charAt(0) !== '/') {
                        // It's not an absolute path, so go from the standard templates dir.
                        stamp.template = this.url + '/templates/' + stamp.template;
                    }

                    tinymce.util.XHR.send({
                        url: stamp.template,
                        async: false,
                        success: function (result) {
                            stamp.templateString = result;
                        },
                        error: function (err) {
                            console.error('Error getting file ' + stamp.template, err);
                        }
                    });
                }

                ed.addButton(name, {
                    label: stamp.label || false,
                    image: stamp.image || false,
                    title: stamp.title || false,
                    onclick: function (e) {
                        /* jshint -W106 */
                        ed.execCommand('mce_stamp', false, {
                            template: stamp.templateString,
                            forbiddenAncestors: stamp.forbidden_ancestors,
                            container: stamp.container,
                            loremIpsum: stamp.lorem_ipsum,
                            ignoreContainers: e.shiftKey && !e.altKey,
                            appendToBody: e.shiftKey && e.altKey,
                            breakOutOfContainer: !e.shiftKey && e.altKey
                        });
                        /* jshint +W106 */
                    },
                    scope: this
                });
            }, this);
        },

        _insertAfterNode: function (ed, nodeToPlace, afterNode) {
            ed.dom.insertAfter(nodeToPlace, afterNode);

            // In the case of a single <br /> child, remove it.
            if (afterNode.children.length === 1 && afterNode.children[0].nodeName.toUpperCase() === "BR") {
                ed.dom.remove(afterNode.children[0]);
            }

            // Set this variable based on if the browser supports textContent or innerText
            var innerText = (afterNode.textContent !== undefined) ? afterNode.textContent : afterNode.innerText;

            // Delete the ancestor if it's empty
            if (afterNode && afterNode.children.length === 0 && !(innerText).replace(/\s/g, '')) {
                ed.dom.remove(afterNode);
            }
        },

        _processTemplate: function (template, selected) {
            // Replace {selection} in the template with our currently selected content
            // and move the selection to {|} or {|text to select|}.
            template = template.split('{selection}').join(selected.content);
            template = template.split('{|}').join('{||}'); // One pipe is a shortcut for an empty pair
            template = template.split('{|').join('<span class="_vodoriStampCursor">').split('|}').join('</span>');
            return template;
        },

        _removeCursorNodes: function (ed) {
            // Find all the cursor placehohlder nodes (there should really only be one)
            var cursors = ed.dom.select('span._vodoriStampCursor');
            if (cursors.length) {
                // Select the last one
                ed.selection.select(cursors[cursors.length - 1]);
                // Remove the nodes, but leave their content
                ed.dom.remove(cursors, true);
            }
        },

        _cleanUpNode: function (ed) {
            // Find the node we just placed in the editor
            var nodeToPlace = ed.dom.select('[nodetoplace]')[0];

            // If the stamp has a data-dojo-type on it, parse it.
            if (nodeToPlace && domAttr.get(nodeToPlace, 'data-dojo-type')) {
                ed.getWin().dojo.parser.instantiate([nodeToPlace]);
            }

            if (nodeToPlace) {
                // Remove the attribute
                ed.dom.setAttrib(nodeToPlace, 'nodetoplace', '');
            }
            return nodeToPlace;
        },

        _chooseTargetNode: function (selected, insertOptions) {
            var target = {};
            tinymce.each(selected.parents, function (parent) {
                if (target.containerNode) {
                    return;
                }

                // The shift key will ignore any containers,
                // nesting things that are normally not nested
                if (!insertOptions.ignoreContainers && insertOptions.container) {
                    if (this.nodeMatchesSelector(parent, insertOptions.container)) {
                        target.containerNode = parent;
                        return; // In case the container is also a forbidden ancestor
                    }
                }

                for (var i = 0, forbidLen = insertOptions.forbiddenAncestors.length; i < forbidLen; i++) {
                    if (this.nodeMatchesSelector(parent, insertOptions.forbiddenAncestors[i])) {
                        target.afterNode = parent;
                    }
                }
            }, this);

            // If the shift and alt keys are held down, append a child to the body
            if (insertOptions.appendToBody) {
                target.afterNode = selected.parents.reverse()[2];
            }

            // If the alt key is held down, break out of the nearest container node
            if (insertOptions.breakOutOfContainer && target.containerNode) {
                target.afterNode = target.containerNode;

                // Inserting after a tbody would be dumb
                if (target.afterNode.nodeName.toLowerCase() === 'tbody') {
                    target.afterNode = target.afterNode.parentNode;
                }
            }

            return target;
        },


        _processInsertionRules: function (insertOptions, rules) {
            insertOptions.container = insertOptions.container || (rules && rules.container) || undefined;

            // Build a list of forbidden ancestors
            /* jshint -W106 */
            if (rules && rules.forbidden_ancestors) {
                insertOptions.forbiddenAncestors = insertOptions.forbiddenAncestors.concat(rules.forbidden_ancestors);
            }
            /* jshint +W106 */

            insertOptions.forbiddenAncestors = insertOptions.forbiddenAncestors.concat(this.selfClosers);
        },

        stampContent: function (ui, value) {
            if (this._bookmark) {
                this.restoreSelection();
            }

            var ed = this.editor,
                loremIpsum = value.loremIpsum,

                insertOptions = {
                    container: value.container,
                    ignoreContainers: value.ignoreContainers,
                    appendToBody: value.appendToBody,
                    breakOutOfContainer: value.breakOutOfContainer,
                    forbiddenAncestors: value.forbiddenAncestors || []
                },

                // We'll store some selection-related things in here.
                selected = {
                    content: ed.selection.getContent() || loremIpsum || 'Lorem ipsum dolor sit amet',
                    node:    ed.selection.getNode(),
                    parents: ed.dom.getParents(ed.selection.getNode())
                },

                // The template is a string, not a path, so make sure
                // you figure that out before you execute this command.
                template = this._processTemplate(value.template, selected),

                /**
                 * {
                 *      afterNode:      If this is set to something, we'll insert after this node.
                 *      containerNode:  If this is set, we'll insert at the end of this node.
                 * }
                 */
                target,

                // Let's see what's in our template.
                holderDiv = ed.dom.create('div', {id: '_vodoriStampHolder'}, template),
                nodeToPlace = holderDiv.children[0],
                rules = this.rules[nodeToPlace.nodeName.toLowerCase()];

            if (holderDiv.children.length !== 1) {
                console.error('Your stamp needs a single root node');
                return;
            }

            // Add an attribute to the node so we can retrieve it once it has been added to the editor.
            ed.dom.setAttrib(nodeToPlace, 'nodetoplace', 'true');

            this._processInsertionRules(insertOptions, rules);

            // Walk through all the parents, looking for containers and forbidden ancestors
            // This ensures that afterNode is the top-most forbidden ancestor,
            // or the last child in a container
            target = this._chooseTargetNode(selected, insertOptions);

            // Insert the content
            if (target.containerNode) {
                // A container node was found, so append the template to that
                nodeToPlace = ed.dom.select(insertOptions.container, holderDiv)[0];
                if (nodeToPlace.children.length === 1) {
                    // There's only one contained child; insert if after the current child of the container
                    ed.dom.insertAfter(nodeToPlace.children[0],
                                       selected.parents[tinymce.inArray(selected.parents, target.containerNode) - 1]);
                } else {
                    // There are many contained children; append them all to the end
                    while (nodeToPlace.children.length) {
                        ed.dom.add(target.containerNode, nodeToPlace.children[0]);
                    }
                }
            } else if (target.afterNode) {
                this._insertAfterNode(ed, nodeToPlace, target.afterNode);
            } else {
                // No forbidden parent or container found, just replace the selected content.
                ed.selection.setNode(nodeToPlace);
            }

            this._removeCursorNodes(ed);

            this._cleanUpNode(ed);
        },

        // Like Element.prototype.matchesSelector
        nodeMatchesSelector: function (node, selector, root) {
            root = root || this.editor.getBody();

            var selection = tinymce.DOM.select(selector, root);
            var matches = false;

            tinymce.each(selection, function (n) {
                if (n === node) {
                    matches = true;
                }
            });

            return matches;
        }
    });

    tinymce.PluginManager.add('stamp', plugin);

    return plugin;
});

},
'vodori/tinymce/_Selection':function(){
define(['module', 'vodori/provide'], function (module, provide) {
    'use strict';

    return provide(module.id, null, {
        /**
         * @type {tinymce.Editor}
         */
        editor: null,

        /**
         * @type {{id: string}}
         */
        _bookmark: null,

        /**
         * Cache the position of the selection.
         *
         * @return {{id: string}}
         */
        saveSelection: function () {
            this._bookmark = this.editor.selection.getBookmark();
            return this._bookmark;
        },

        /**
         * Return to the previous position.
         *
         * @return {tinymce.Selection}
         */
        restoreSelection: function () {
            var selection = this.editor.selection;

            if (!!this._bookmark) {
                selection.moveToBookmark(this._bookmark);
            }

            selection.getNode().focus();

            return selection;
        }
    });

});

},
'vodori/tinymce/StampValidator':function(){
/**
 * A plugin to enforce the markup of a stamp during editing. This will allow the stamp developer to make
 * sure certain element's won't deleted by the content author.
 *
 * USAGE:
 * To make use of this validator, the attribute data-stamp-validator will need to be added to the stamp.
 * The values of this attribute are:
 *
 *      wrapper:  [REQUIRED] This will define the outer most element of the stamp.
 *                           By default this makes everything inside of it not editable.
 *      editable: [OPTIONAL] This will define that the element this attribute is on and all the content
 *                           inside of it will be editable.
 *      force:    [OPTIONAL] This will make the content within the element this attribute is on editable,
 *                           but the element itself will not be removable.
 *
 * EXAMPLE:
 *      <div data-stamp-validator="wrapper">
 *          <div>This will not be editable</div>
 *          <h1 data-stamp-validator="force">The content of this H1 will be editable, but the H1 can not be removed</h1>
 *          <a href="#" data-stamp-validator="editable">This link will be editable and it can be removed</a>
 *      </div>
 *
 * NOTES:
 *      -Nesting attributes is not supported
 *          (The wrapper is the only exception as all other attributes will need to be within it)
 *      -Additional stamp actions are available in the right click menu. (eg. Delete stamp)
 *
 */
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'dojo/dom-attr', 'dojo/dom-class', 'dojo/dom-construct',
    'dojo/query',
    'vodori/amd/tinymce',
    'vodori/tinymce/util/getPluginName',
    'vodori/tinymce/util/getResourceUrl'
], function (provide, module, _, lang, domAttr, domClass, domConstruct, query, tinymce, getPluginName, getResourceUrl) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, null, {
            ed: null, // Set in init
            url: '',
            pluginName: pluginName,
            isInsideStamp: false,

            init: function (ed) {
                this.ed = ed;
                this.url = getResourceUrl(module);

                ed.onKeyUp.add(this._onKeyUp, this);

                ed.onKeyDown.add(this._onKeyDown, this);

                ed.onMouseUp.add(this._onMouseUp, this);

                ed.onNodeChange.add(this.updateIsInsideStamp, this);

                ed.onExecCommand.add(function (ed, action) {
                    // When a stamp is added to the editor run parseTemplates
                    if (action === "mce_stamp") {
                        this.parseTemplates();
                    }
                }, this);

                // Delete template stamp command for context menu
                ed.addCommand('mceDeleteTemplateStamp', function () {
                    domConstruct.destroy(this.getTemplateWrapper());
                }, this);

                // Toggle stamp border command for context menu
                ed.addCommand('mceToggleTemplateStampBorder', function () {
                    domClass.toggle(this.getTemplateWrapper(), 'mceItemTemplateStampBorder');
                }, this);

                ed.onInit.add(function (ed) {
                    // Add attribute filter to remove certain attributes from the markup
                    ed.serializer.addAttributeFilter('data-stamp-validator-markup,data-stamp-validator-active',
                        function (nodes, name) {
                            for (var i = 0; i < nodes.length; i++) {
                                nodes[i].attr(name, null);
                            }
                        }
                    );

                    // Add content menu logic
                    this.addContextMenuItems();

                    // Parse all the templates on editor initialization
                    this.parseTemplates();

                    // Load css file that will contain our validation indicators
                    ed.dom.loadCSS(this.url + '/css/' + this.pluginName + '.css');
                }, this);

            },

            _onKeyUp: function (ed, event) {
                if (this.isInsideStamp) {
                    this.undoIfInvalid(ed);
                    ed.undoManager.add();
                }
            },

            _onKeyDown: function (ed, event) {
                if (this.isInsideStamp) {
                    var selNode = ed.selection.getNode();
                    var parent = ed.dom.getParent(selNode);

                    // If the direct parent has a data-stamp-validator attribute don't allow enter to be
                    // pressed as it will duplicate the element we are currently
                    // and the attribute as well which will change how the template gets validated.
                    // (Unless accompanied with shift as this will only add a br)
                    if (parent.getAttribute('data-stamp-validator')) {
                        if (event.keyCode === 13 && !event.shiftKey) {
                            console.log("Stamp Validator: Stopping 'enter' key press");
                            event.preventDefault();
                            event.stopPropagation();
                            return false;
                        }
                    }
                }
            },

            /**
             * This function attempts to capture selections made across multiple validated regions and then modify
             * the selection to only one of the regions.
             * Example: User triple clicks in a region and the selection spans across 2 validated regions.
             * If the user were to start typing they would probably
             * invalidate one of the regions and the content would revert back.
             * Instead we try to make an intelligent guess on which region they want selected by examining the
             * event.target property, which is where the mouse click originated from.
             *
             * Known issue: Firefox and IE return different start and end selection nodes when a full selection
             * (eg. triple click) occurs, which causes this logic to do nothing because the selection start and
             * end points are the parent node and not the nodes that are actually part of the selection.
             *
             * @param ed Editor
             * @param e Event
             */
            _onMouseUp: function (ed, e) {
                if (this.isInsideStamp) {
                    var selNode = e.target;
                    var selStart = ed.selection.getStart();
                    var selEnd = ed.selection.getEnd();

                    var node1 = this.getTemplateFromNode(selStart);
                    var node2 = this.getTemplateFromNode(selEnd);
                    var cursorNode = this.getTemplateFromNode(selNode);

                    if (node1 && node2) {

                        var isNode1Wrapper = domAttr.get(node1, 'data-stamp-validator') === 'wrapper';
                        var isNode2Wrapper = domAttr.get(node2, 'data-stamp-validator') === 'wrapper';

                        if (!node1.isEqualNode(node2)) {
                            if (node1.isEqualNode(cursorNode)) {
                                if (isNode1Wrapper) {
                                    ed.selection.select(ed.dom.select('[data-stamp-validator]', node1)[0], true);
                                } else {
                                    ed.selection.select(node1, true);
                                }
                            } else if (node2.isEqualNode(cursorNode)) {
                                if (isNode2Wrapper) {
                                    ed.selection.select(ed.dom.select('[data-stamp-validator]', node2)[0], true);
                                } else {
                                    ed.selection.select(node2, true);
                                }
                            }
                        }
                    }
                }
            },

            /**
             * Updates the isInsideStamp variable to indicated if the current selection is inside a stamp template.
             * This will also add an attribute to the active editor so we can query for it.
             *
             * @param ed Editor
             */
            updateIsInsideStamp: function (ed) {
                var i;
                var selNode = ed.selection.getNode();
                var parents = ed.dom.getParents(selNode);
                var allActiveTemplates = ed.dom.select('[data-stamp-validator-active=true]');

                for (i = 0; i < allActiveTemplates.length; i++) {
                    domAttr.remove(allActiveTemplates[i], 'data-stamp-validator-active');
                }

                for (i = 0; i < parents.length; i++) {
                    if (domAttr.get(parents[i], 'data-stamp-validator') === "wrapper") {
                        this.isInsideStamp = true;
                        domAttr.set(parents[i], 'data-stamp-validator-active', 'true');
                        return;
                    }
                }
                this.isInsideStamp = false;
            },

            /**
             * Checks if the active template is invalid and if so calls undo. This will continue to call undo until
             * the template is valid.
             *
             * @param ed Editor
             */
            undoIfInvalid: function (ed) {
                for (var i = 0; i < 1000; i++) {
                    var activeTemplate = ed.dom.select('[data-stamp-validator-active=true]');
                    if (!activeTemplate || activeTemplate.length === 0) {
                        console.error("Stamp Validator: No active template could be found");
                        return;
                    } else if (activeTemplate.length > 1) {
                        console.error("Stamp Validator: More then 1 active template was found");
                        return;
                    } else {
                        activeTemplate = activeTemplate[0];
                        var templateMarkup = domAttr.get(activeTemplate, 'data-stamp-validator-markup');

                        if (!templateMarkup) {
                            console.error("Stamp Validator: Could not find the 'data-stamp-validator-markup' " +
                                "attribute on the active template.");
                            return;
                        }

                        if (!this.isTemplateValid(activeTemplate, templateMarkup)) {
                            this.ed.undoManager.undo();
                        } else {
                            return;
                        }
                    }
                }
                console.error("Stamp Validator: A valid template state was not found within 1000 iterations.");
            },

            /**
             * Add template stamps options to the right click menu if our mouse is within a template area.
             */
            addContextMenuItems: function () {
                if (this.ed && this.ed.plugins && this.ed.plugins.contextmenu) {
                    this.ed.plugins.contextmenu.onContextMenu.add(function (th, m, e) {

                        if (this.isInsideStamp) {
                            m.addSeparator();

                            var am = m.addMenu({
                                title: 'Stamp'
                            });

                            am.add({
                                title: 'Delete Stamp',
                                cmd: 'mceDeleteTemplateStamp'
                            });

                            am.add({
                                title: 'Toggle Borders',
                                cmd: 'mceToggleTemplateStampBorder'
                            });

                            am.remove(am.id);

                            m.addSeparator();
                        }
                    }, this);
                }
            },

            /**
             * Loop through all the stamp templates within the editor and add a new attribute
             * to each that will hold the templateString. The templateString will be used to test if the template is
             * valid or not when the author makes content changes to it.
             */
            parseTemplates: function () {
                var templates = query('[data-stamp-validator=\'wrapper\']', this.ed.getDoc());

                for (var i = 0; i < templates.length; i++) {
                    domAttr.set(templates[i], 'data-stamp-validator-markup', this.getTemplateString(templates[i]));
                }
            },

            /**
             * Function that will parse a domNode and remove elements that we don't wish to include when trying to
             * validate a template with it's templateString.

             * @param template A domNode
             * @return string
             */
            getTemplateString: function (template) {
                var i;
                template = lang.clone(template);

                // EDITABLE - This is a node that can be edited at will or can be deleted
                var matches = query('[data-stamp-validator=\'editable\']', template);
                for (i = 0; i < matches.length; i++) {
                    domConstruct.destroy(matches[i]);
                }

                // FORCE - This is a node that can be edited at will but it CAN NOT be deleted
                matches = query('[data-stamp-validator=\'force\']', template);
                for (i = 0; i < matches.length; i++) {
                    domConstruct.empty(matches[i]);
                }

                return this.ed.dom.getOuterHTML(template);
            },

            /**
             * A convenience function to get the node that has the attribute 'data-stamp-validator=wrapper'
             * on it in relation to where the cursor is currently.
             *
             * @return domNode The wrapper node for the template stamp the cursor is currently in.
             */
            getTemplateWrapper: function () {
                return this.getTemplateFromNode(this.ed.selection.getNode(), "wrapper");
            },

            /**
             * Loops though all the parents of the node that is passed in until one is found with the
             * attribute 'data-stamp-validator'. If value is specified, the attribute value is first compared the value
             * passed in, and that node will only be returned if a mach occurs.
             * If value is not specified, the first node that has the 'data-stamp-validator' attribute
             * with any value will returned.
             *
             * @param node The node to start searching for the data-stamp-validator attribute.
             * @param value An optional string that will test the value of the attribute for.
             * @return domNode
             */
            getTemplateFromNode: function (node, value) {
                var parents = this.ed.dom.getParents(node);

                for (var i = 0; i < parents.length; i++) {
                    var template = domAttr.get(parents[i], 'data-stamp-validator');
                    if (template) {
                        if (value) {
                            if (value === template) {
                                return parents[i];
                            }
                        } else {
                            return parents[i];
                        }
                    }
                }
            },

            /**
             * Helper function to determine if a dom node representation of a template stamp is equal to a string.
             *
             * @param node A dom node of a single template stamp.
             * This node will be run through the template string parser to get the html that we want to compare.
             * @param templateString A string representation of a template stamp that was generated when the stamp was
             * initially added to the editor.
             * @return boolean Does the node match the templateString
             */
            isTemplateValid: function (node, templateString) {
                return this.isEqualNode(this.getTemplateString(node), templateString);
            },


            _normalizeNode: function (node) {
                var normalizedNode = [];
                for (var i = 0; i < node.childNodes.length; i++) {
                    if (node.childNodes[i].nodeType === 1 ||
                        (node.childNodes[i].nodeType === 3 && lang.trim(node.childNodes[i].nodeValue) !== "")) {

                        normalizedNode[normalizedNode.length] = node.childNodes[i];
                    }
                }
                return normalizedNode;
            },

            /**
             * Compares two nodes and checks if they are equal.
             * Some custom rules have been added which may exclude certain attributes.
             *
             * @param n1 {string|domNode} The source node to compare.
             *                            Note if a string is passed in it will be converted to a dom node.
             * @param n2 {string|domNode} The target node to compare the source to.
             *                            Note if a string is passed in it will be converted to a dom node.
             */
            isEqualNode: function (n1, n2) {
                var i;

                // Convert to a node if param is a string
                if (typeof n1 === "string") {
                    n1 = domConstruct.create('div', {innerHTML: n1});
                }

                if (typeof n2 === "string") {
                    n2 = domConstruct.create('div', {innerHTML: n2});
                }

                // Check that node properties match
                var props = ['nodeType', 'nodeName'];
                var propMatch = _.all(props, function(prop) {
                    return (n1[prop] === n2[prop]);
                });
                if(!propMatch) {
                    return false;
                }


                // Check that attributes match
                if (n1.nodeType === 1) {
                    var excludeAttrs = ['data-mce-href', 'data-stamp-validator-active', 'data-stamp-validator-markup',
                        'class', 'style']; //Don't check these

                    for (i = 0; i < n1.attributes.length; i++) {
                        if (_.indexOf(excludeAttrs, n1.attributes[i].name) === -1) {
                            if (n1.attributes[i].value !== n2.getAttribute(n1.attributes[i].name)) {
                                return false;
                            }
                        }
                    }
                } else if (n1.nodeType === 3) { // Check that text match
                    if (lang.trim(n1.nodeValue) !== lang.trim(n2.nodeValue)) {
                        return false;
                    }
                }

                // Normalize the childNodes. This is to eliminate problems like having an empty text node
                var normalizedN1 = this._normalizeNode(n1),
                    normalizedN2 = this._normalizeNode(n2);

                return _.isEqual(normalizedN1, normalizedN2);

            }
        }

    );


    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'vodori/tinymce/SubPageDropDown':function(){
define([
    'vodori/provide', 'module',
    'dojo/json',
    'dojo/dom-attr', 'dojo/dom-construct',
    'vodori/amd/tinymce',
    'vodori/ui/SubMenuSelect',
    'vodori/tinymce/util/getPluginName',
    'vodori/tinymce/util/getResourceUrl'
], function (provide, module, JSON, domAttr, domConstruct, tinymce, SubMenuSelect, getPluginName, getResourceUrl) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, null, {

        dijitDeclaredClass: SubMenuSelect.prototype.declaredClass,

        dijitDeclaredClassCSS: SubMenuSelect.prototype.declaredClass.replace(/\./g, '_'),

        init: function (ed) {
            var t = this;
            t.editor = ed;
            var url = t.url = getResourceUrl(module);


            // We only have 1 command -- insert the dropdown
            ed.addCommand('mceInsertSubPageDropdown', function (ui, val) {
                var ed = t.editor,
                    attributeMap = {'data-dojo-type': this.dijitDeclaredClass },
                    content = '<img ' +
                        '       class="' + t.dijitDeclaredClassCSS +'" ' +
                        '       data-dojo-props="' +
                                    ed.dom.encode(JSON.stringify(attributeMap)).replace(/^{|}$/g, '') +'"' +
                        '       src="' + url +'/img/trans2.gif" />';

                ed.execCommand('mceInsertContent', false, content);
                ed.addVisual();
            }, this);

            // Register buttons
            ed.addButton('subpagedropdown', {title: 'Insert sub-page dropdown', cmd: 'mceInsertSubPageDropdown' });

            ed.onPreProcess.add(function (ed, o) {
                if (o.get) {

                    var widgets = ed.dom.select("img." + t.dijitDeclaredClassCSS, o.node);

                    for (var i = 0; i < widgets.length; ++i) {
                        var widgetWannabe = widgets[i];

                        var widget = domConstruct.create("div", {
                            'data-dojo-type': this.dijitDeclaredClass,
                            'data-dojo-props': domAttr.get(widgetWannabe, 'data-dojo-props')
                        });

                        ed.dom.replace(widget, widgetWannabe);
                    }

                }
            }, this);

            ed.onSetContent.add(function (ed, o) {
                if (o.set) {

                    // Get all of our widgets out
                    var widgets = ed.dom.select("[data-dojo-type=" + t.dijitDeclaredClass + "]", ed.getBody());
                    for (var i = 0; i < widgets.length; ++i) {
                        var widget = widgets[i];

                        var wannabeWidget = domConstruct.create("img", {
                            'data-dojo-props': domAttr.get(widget, 'data-dojo-props'),
                            'class': t.dijitDeclaredClassCSS,
                            'src': url + '/img/trans2.gif'
                        });

                        ed.dom.replace(wannabeWidget, widget);

                    }
                }
            }, this);
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});


},
'vodori/ui/SubMenuSelect':function(){
/**
 * USAGE:
 * Standard usage below.  Also takes a cssQuery parameter, as well as a default label
 * <select data-dojo-type="vodori/ui/SubMenuSelect" data-dojo-props="value:''" ></select>
 *
 */
define([
    'module', 'vodori/provide',
    'dojo/query',
    'dojo/dom-attr',
    'vodori/ui/_DropDownLinkSelect',
    'dojox/data/KeyValueStore'
], function (module, provide, query, domAttr, _DropDownLinkSelect, KeyValueStore) {
    return provide(module.id, [_DropDownLinkSelect], {

        label: 'Select a page...',

        // Configuration parameters
        cssQuery: '#main-navigation ul.selected > li.parentActive > a:first-child',
        baseClass: 'dijitDropDownButton subPageSelectorWidget',

        /**
         * The function to override to create the data structure that gets returned.
         * Returns a KeyValueStore with label/URL pairs
         */
        getDropdownData: function () {

            var selectedNav = query(this.cssQuery);

            var data = []; // Prepopulate the array of data we need

            // If this is totally empty, add a blank entry
            if (selectedNav.length === 0) {
                data.push({'': ''});
            }

            for (var i = 0; i < selectedNav.length; ++i) {

                var a = selectedNav[i];
                var label = a.innerHTML;
                var url = domAttr.get(a, 'href');

                var dataPair = {};
                dataPair[url] = label;

                data.push(dataPair);
            }

            return new KeyValueStore({data: data});
        }
    });
});

},
'vodori/ui/_DropDownLinkSelect':function(){
/**
 * USAGE:
 * Standard usage below.  Also takes a cssQuery parameter, as well as a default label
 * <select data-dojo-type='vodori/ui/SubMenuSelect' data-dojo-props='value:'Foo'' ></select>
 *
 */
define([
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'dijit/form/DropDownButton',
    'dijit/Menu',
    'dijit/MenuItem',
    'vodori/util/SerializableMixin'
], function (module, provide, lang, DropDownButton, Menu, MenuItem, _SerializableMixin) {
    return provide(module.id, [DropDownButton, _SerializableMixin], {

        postMixInProperties: function () {

            this.inherited(arguments);

            // Grab all of the relevant options.  Note that we need to do it here, because super::postMixInProps
            // will test for the presence of this.store and create a store if it's not present
            this.dropDown = this._createDropdown();

        },

        itemSelected: function (url) {
            if (url) {
                window.location.href = url;
            }
        },

        /**
         * The main function of this widget
         */
        _createDropdown: function () {

            var menu = new Menu({});
            menu.addChild(new MenuItem({label: this.label, url: ''}));

            var dropDownDataStore = this.getDropdownData();
            if (dropDownDataStore) {
                var _this = this;
                dropDownDataStore.fetch({
                    onComplete: function (items, req) {

                        for (var i = 0; i < items.length; ++i) {
                            var key = items[i].key;
                            var value = items[i].value;
                            menu.addChild(new MenuItem({
                                label: value,
                                url: key,
                                onClick: lang.hitch(_this, 'itemSelected', key)
                            }));
                        }

                    }
                });
            }

            return menu;
        },

        /**
         * The function to override to create the data structure that gets returned.
         * Returns a KeyValueStore with label/URL pairs
         */
        getDropdownData: function () {

            console.error('The _DropDownLinkSelect subclass must implement getDropdownData');
        }
    });
});

},
'dojox/data/KeyValueStore':function(){
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/xhr", "dojo/_base/kernel",
		"dojo/data/util/simpleFetch", "dojo/data/util/filter"], 
  function(declare, lang, xhr, kernel, simpleFetch, filterUtil) {

var KeyValueStore = declare("dojox.data.KeyValueStore", null, {
	// summary:
	//		This is a dojo.data store implementation.  It can take in either a Javascript
	//		array, JSON string, or URL as the data source.  Data is expected to be in the
	//		following format:
	// |	[
	// |		{ "key1": "value1" },
	// |		{ "key2": "value2" }
	// |	]
	//		This is to mimic the Java Properties file format.  Each 'item' from this store
	//		is a JS object representing a key-value pair.  If an item in the above array has
	//		more than one key/value pair, only the first will be used/accessed.
	constructor: function(/* Object */ keywordParameters){
		// summary:
		//		constructor
		// keywordParameters:
		//		- {url: String}
		//		- {data: string}
		//		- {dataVar: jsonObject}
		if(keywordParameters.url){
			this.url = keywordParameters.url;
		}
		this._keyValueString = keywordParameters.data;
		this._keyValueVar = keywordParameters.dataVar;
		this._keyAttribute = "key";
		this._valueAttribute = "value";
		this._storeProp = "_keyValueStore";
		this._features = {
			'dojo.data.api.Read': true,
			'dojo.data.api.Identity': true
		};
		this._loadInProgress = false;	//Got to track the initial load to prevent duelling loads of the dataset.
		this._queuedFetches = [];
		if(keywordParameters && "urlPreventCache" in keywordParameters){
			this.urlPreventCache = keywordParameters.urlPreventCache?true:false;
		}
	},
	
	url: "",
	data: "",

	// urlPreventCache: boolean
	//		Controls if urlPreventCache should be used with underlying xhrGet.
	urlPreventCache: false,
	
	_assertIsItem: function(/* item */ item){
		// summary:
		//		This function tests whether the item passed in is indeed an item in the store.
		// item:
		//		The item to test for being contained by the store.
		if(!this.isItem(item)){
			throw new Error("dojox.data.KeyValueStore: a function was passed an item argument that was not an item");
		}
	},
	
	_assertIsAttribute: function(/* item */ item, /* String */ attribute){
		// summary:
		//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
		// attribute:
		//		The attribute to test for being contained by the store.
		if(!lang.isString(attribute)){
			throw new Error("dojox.data.KeyValueStore: a function was passed an attribute argument that was not an attribute object nor an attribute name string");
		}
	},

/***************************************
     dojo/data/api/Read API
***************************************/
	getValue: function(	/* item */ item,
						/* attribute-name-string */ attribute,
						/* value? */ defaultValue){
		// summary:
		//		See dojo/data/api/Read.getValue()
		this._assertIsItem(item);
		this._assertIsAttribute(item, attribute);
		var value;
		if(attribute == this._keyAttribute){ // Looking for key
			value = item[this._keyAttribute];
		}else{
			value = item[this._valueAttribute]; // Otherwise, attribute == ('value' || the actual key )
		}
		if(value === undefined){
			value = defaultValue;
		}
		return value;
	},

	getValues: function(/* item */ item,
						/* attribute-name-string */ attribute){
		// summary:
		//		See dojo/data/api/Read.getValues()
		//		Key/Value syntax does not support multi-valued attributes, so this is just a
		//		wrapper function for getValue().
		var value = this.getValue(item, attribute);
		return (value ? [value] : []); //Array
	},

	getAttributes: function(/* item */ item){
		// summary:
		//		See dojo/data/api/Read.getAttributes()
		return [this._keyAttribute, this._valueAttribute, item[this._keyAttribute]];
	},

	hasAttribute: function(	/* item */ item,
							/* attribute-name-string */ attribute){
		// summary:
		//		See dojo/data/api/Read.hasAttribute()
		this._assertIsItem(item);
		this._assertIsAttribute(item, attribute);
		return (attribute == this._keyAttribute || attribute == this._valueAttribute || attribute == item[this._keyAttribute]);
	},

	containsValue: function(/* item */ item,
							/* attribute-name-string */ attribute,
							/* anything */ value){
		// summary:
		//		See dojo/data/api/Read.containsValue()
		var regexp = undefined;
		if(typeof value === "string"){
			regexp = filterUtil.patternToRegExp(value, false);
		}
		return this._containsValue(item, attribute, value, regexp); //boolean.
	},

	_containsValue: function(	/* item */ item,
								/* attribute|attribute-name-string */ attribute,
								/* anything */ value,
								/* RegExp?*/ regexp){
		// summary:
		//		Internal function for looking at the values contained by the item.
		// description:
		//		Internal function for looking at the values contained by the item.  This
		//		function allows for denoting if the comparison should be case sensitive for
		//		strings or not (for handling filtering cases where string case should not matter)
		// item:
		//		The data item to examine for attribute values.
		// attribute:
		//		The attribute to inspect.
		// value:
		//		The value to match.
		// regexp:
		//		Optional regular expression generated off value if value was of string type to handle wildcarding.
		//		If present and attribute values are string, then it can be used for comparison instead of 'value'
		var values = this.getValues(item, attribute);
		for(var i = 0; i < values.length; ++i){
			var possibleValue = values[i];
			if(typeof possibleValue === "string" && regexp){
				return (possibleValue.match(regexp) !== null);
			}else{
				//Non-string matching.
				if(value === possibleValue){
					return true; // Boolean
				}
			}
		}
		return false; // Boolean
	},

	isItem: function(/* anything */ something){
		// summary:
		//		See dojo/data/api/Read.isItem()
		if(something && something[this._storeProp] === this){
			return true; //Boolean
		}
		return false; //Boolean
	},

	isItemLoaded: function(/* anything */ something){
		// summary:
		//		See dojo/data/api/Read.isItemLoaded()
		//		The KeyValueStore always loads all items, so if it's an item, then it's loaded.
		return this.isItem(something); //Boolean
	},

	loadItem: function(/* object */ keywordArgs){
		// summary:
		//		See dojo/data/api/Read.loadItem()
		// description:
		//		The KeyValueStore always loads all items, so if it's an item, then it's loaded.
		//
		//		From the dojo/data/api/Read.loadItem docs:
		//
		//			If a call to isItemLoaded() returns true before loadItem() is even called,
		//			then loadItem() need not do any work at all and will not even invoke
		//			the callback handlers.
	},

	getFeatures: function(){
		// summary:
		//		See dojo/data/api/Read.getFeatures()
		return this._features; //Object
	},

	close: function(/*dojo/data/api/Request|Object?*/ request){
		// summary:
		//		See dojo/data/api/Read.close()
	},

	getLabel: function(/* item */ item){
		// summary:
		//		See dojo/data/api/Read.getLabel()
		return item[this._keyAttribute];
	},

	getLabelAttributes: function(/* item */ item){
		// summary:
		//		See dojo/data/api/Read.getLabelAttributes()
		return [this._keyAttribute];
	},
	
	// The dojo/data/api/Read.fetch() function is implemented as
	// a mixin from dojo.data.util.simpleFetch.
	// That mixin requires us to define _fetchItems().
	_fetchItems: function(	/* Object */ keywordArgs,
							/* Function */ findCallback,
							/* Function */ errorCallback){
		// summary:
		//		See dojo.data.util.simpleFetch.fetch()
		
		var self = this;

		var filter = function(requestArgs, arrayOfAllItems){
			var items = null;
			if(requestArgs.query){
				items = [];
				var ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false;

				//See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the
				//same value for each item examined.  Much more efficient.
				var regexpList = {};
				for(var key in requestArgs.query){
					var value = requestArgs.query[key];
					if(typeof value === "string"){
						regexpList[key] = filterUtil.patternToRegExp(value, ignoreCase);
					}
				}

				for(var i = 0; i < arrayOfAllItems.length; ++i){
					var match = true;
					var candidateItem = arrayOfAllItems[i];
					for(var key in requestArgs.query){
						var value = requestArgs.query[key];
						if(!self._containsValue(candidateItem, key, value, regexpList[key])){
							match = false;
						}
					}
					if(match){
						items.push(candidateItem);
					}
				}
			}else if(requestArgs.identity){
				items = [];
				var item;
				for(var key in arrayOfAllItems){
					item = arrayOfAllItems[key];
					if(item[self._keyAttribute] == requestArgs.identity){
						items.push(item);
						break;
					}
				}
			}else{
				// We want a copy to pass back in case the parent wishes to sort the array.  We shouldn't allow resort
				// of the internal list so that multiple callers can get lists and sort without affecting each other.
				if(arrayOfAllItems.length> 0){
					items = arrayOfAllItems.slice(0,arrayOfAllItems.length);
				}
			}
			findCallback(items, requestArgs);
		};

		if(this._loadFinished){
			filter(keywordArgs, this._arrayOfAllItems);
		}else{
			if(this.url !== ""){
				//If fetches come in before the loading has finished, but while
				//a load is in progress, we have to defer the fetching to be
				//invoked in the callback.
				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs, filter: filter});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self.url,
							handleAs: "json-comment-filtered",
							preventCache: this.urlPreventCache
						};
					var getHandler = xhr.get(getArgs);
					getHandler.addCallback(function(data){
						self._processData(data);
						filter(keywordArgs, self._arrayOfAllItems);
						self._handleQueuedFetches();
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						throw error;
					});
				}
			}else if(this._keyValueString){
				this._processData(eval(this._keyValueString));
				this._keyValueString = null;
				filter(keywordArgs, this._arrayOfAllItems);
			}else if(this._keyValueVar){
				this._processData(this._keyValueVar);
				this._keyValueVar = null;
				filter(keywordArgs, this._arrayOfAllItems);
			}else{
				throw new Error("dojox.data.KeyValueStore: No source data was provided as either URL, String, or Javascript variable data input.");
			}
		}
		
	},

	_handleQueuedFetches: function(){
		// summary:
		//		Internal function to execute delayed request in the store.
		
		//Execute any deferred fetches now.
		if(this._queuedFetches.length > 0){
			for(var i = 0; i < this._queuedFetches.length; i++){
				var fData = this._queuedFetches[i];
				var delayedFilter = fData.filter;
				var delayedQuery = fData.args;
				if(delayedFilter){
					delayedFilter(delayedQuery, this._arrayOfAllItems);
				}else{
					this.fetchItemByIdentity(fData.args);
				}
			}
			this._queuedFetches = [];
		}
	},
	
	_processData: function(/* Array */ data){
		this._arrayOfAllItems = [];
		for(var i=0; i<data.length; i++){
			this._arrayOfAllItems.push(this._createItem(data[i]));
		}
		this._loadFinished = true;
		this._loadInProgress = false;
	},
	
	_createItem: function(/* Object */ something){
		var item = {};
		item[this._storeProp] = this;
		for(var i in something){
			item[this._keyAttribute] = i;
			item[this._valueAttribute] = something[i];
			break;
		}
		return item; //Object
	},

/***************************************
     dojo/data/api/Identity API
***************************************/
	getIdentity: function(/* item */ item){
		// summary:
		//		See dojo/data/api/Identity.getIdentity()
		if(this.isItem(item)){
			return item[this._keyAttribute]; //String
		}
		return null; //null
	},

	getIdentityAttributes: function(/* item */ item){
		// summary:
		//		See dojo/data/api/Identity.getIdentifierAttributes()
		return [this._keyAttribute];
	},

	fetchItemByIdentity: function(/* object */ keywordArgs){
		// summary:
		//		See dojo/data/api/Identity.fetchItemByIdentity()
		keywordArgs.oldOnItem = keywordArgs.onItem;
		keywordArgs.onItem = null;
		keywordArgs.onComplete = this._finishFetchItemByIdentity ;
		this.fetch(keywordArgs);
	},
	
	_finishFetchItemByIdentity: function(/* Array */ items, /* object */ request){
		var scope = request.scope || kernel.global;
		if(items.length){
			request.oldOnItem.call(scope, items[0]);
		}else{
			request.oldOnItem.call(scope, null);
		}
	}
});
//Mix in the simple fetch implementation to this class.
lang.extend(KeyValueStore,simpleFetch);
return KeyValueStore;
});

},
'dojo/data/util/simpleFetch':function(){
define(["../../_base/lang", "../../_base/kernel", "./sorter"],
  function(lang, kernel, sorter){
	// module:
	//		dojo/data/util/simpleFetch
	// summary:
	//		The simpleFetch mixin is designed to serve as a set of function(s) that can
	//		be mixed into other datastore implementations to accelerate their development.

var simpleFetch = {};
lang.setObject("dojo.data.util.simpleFetch", simpleFetch);

simpleFetch.errorHandler = function(/*Object*/ errorData, /*Object*/ requestObject){
	// summary:
	//		The error handler when there is an error fetching items.  This function should not be called
	//		directly and is used by simpleFetch.fetch().
	if(requestObject.onError){
		var scope = requestObject.scope || kernel.global;
		requestObject.onError.call(scope, errorData, requestObject);
	}
};

simpleFetch.fetchHandler = function(/*Array*/ items, /*Object*/ requestObject){
	// summary:
	//		The handler when items are successfully fetched.  This function should not be called directly
	//		and is used by simpleFetch.fetch().
	var oldAbortFunction = requestObject.abort || null,
		aborted = false,

		startIndex = requestObject.start?requestObject.start: 0,
		endIndex = (requestObject.count && (requestObject.count !== Infinity))?(startIndex + requestObject.count):items.length;

	requestObject.abort = function(){
		aborted = true;
		if(oldAbortFunction){
			oldAbortFunction.call(requestObject);
		}
	};

	var scope = requestObject.scope || kernel.global;
	if(!requestObject.store){
		requestObject.store = this;
	}
	if(requestObject.onBegin){
		requestObject.onBegin.call(scope, items.length, requestObject);
	}
	if(requestObject.sort){
		items.sort(sorter.createSortFunction(requestObject.sort, this));
	}
	if(requestObject.onItem){
		for(var i = startIndex; (i < items.length) && (i < endIndex); ++i){
			var item = items[i];
			if(!aborted){
				requestObject.onItem.call(scope, item, requestObject);
			}
		}
	}
	if(requestObject.onComplete && !aborted){
		var subset = null;
		if(!requestObject.onItem){
			subset = items.slice(startIndex, endIndex);
		}
		requestObject.onComplete.call(scope, subset, requestObject);
	}
};

simpleFetch.fetch = function(/* Object? */ request){
	// summary:
	//		The simpleFetch mixin is designed to serve as a set of function(s) that can
	//		be mixed into other datastore implementations to accelerate their development.
	// description:
	//		The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems()
	//		call by returning an array of all the found items that matched the query.  The simpleFetch mixin
	//		is not designed to work for datastores that respond to a fetch() call by incrementally
	//		loading items, or sequentially loading partial batches of the result
	//		set.  For datastores that mixin simpleFetch, simpleFetch
	//		implements a fetch method that automatically handles eight of the fetch()
	//		arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
	//		The class mixing in simpleFetch should not implement fetch(),
	//		but should instead implement a _fetchItems() method.  The _fetchItems()
	//		method takes three arguments, the keywordArgs object that was passed
	//		to fetch(), a callback function to be called when the result array is
	//		available, and an error callback to be called if something goes wrong.
	//		The _fetchItems() method should ignore any keywordArgs parameters for
	//		start, count, onBegin, onItem, onComplete, onError, sort, and scope.
	//		The _fetchItems() method needs to correctly handle any other keywordArgs
	//		parameters, including the query parameter and any optional parameters
	//		(such as includeChildren).  The _fetchItems() method should create an array of
	//		result items and pass it to the fetchHandler along with the original request object --
	//		or, the _fetchItems() method may, if it wants to, create an new request object
	//		with other specifics about the request that are specific to the datastore and pass
	//		that as the request object to the handler.
	//
	//		For more information on this specific function, see dojo/data/api/Read.fetch()
	//
	// request:
	//		The keywordArgs parameter may either be an instance of
	//		conforming to dojo/data/api/Request or may be a simple anonymous object
	//		that may contain any of the following:
	// |	{
	// |		query: query-object or query-string,
	// |		queryOptions: object,
	// |		onBegin: Function,
	// |		onItem: Function,
	// |		onComplete: Function,
	// |		onError: Function,
	// |		scope: object,
	// |		start: int
	// |		count: int
	// |		sort: array
	// |	}
	//		All implementations should accept keywordArgs objects with any of
	//		the 9 standard properties: query, onBegin, onItem, onComplete, onError
	//		scope, sort, start, and count.  Some implementations may accept additional
	//		properties in the keywordArgs object as valid parameters, such as
	//		{includeOutliers:true}.
	//
	//		####The *query* parameter
	//
	//		The query may be optional in some data store implementations.
	//		The dojo/data/api/Read API does not specify the syntax or semantics
	//		of the query itself -- each different data store implementation
	//		may have its own notion of what a query should look like.
	//		However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data
	//		and dojox.data support an object structure query, where the object is a set of
	//		name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the
	//		dijit widgets, such as ComboBox assume this to be the case when working with a datastore
	//		when they dynamically update the query.  Therefore, for maximum compatibility with dijit
	//		widgets the recommended query parameter is a key/value object.  That does not mean that the
	//		the datastore may not take alternative query forms, such as a simple string, a Date, a number,
	//		or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the query
	//		format.
	//
	//		Further note:  In general for query objects that accept strings as attribute
	//		value matches, the store should also support basic filtering capability, such as *
	//		(match any character) and ? (match single character).  An example query that is a query object
	//		would be like: { attrFoo: "value*"}.  Which generally means match all items where they have
	//		an attribute named attrFoo, with a value that starts with 'value'.
	//
	//		####The *queryOptions* parameter
	//
	//		The queryOptions parameter is an optional parameter used to specify options that may modify
	//		the query in some fashion, such as doing a case insensitive search, or doing a deep search
	//		where all items in a hierarchical representation of data are scanned instead of just the root
	//		items.  It currently defines two options that all datastores should attempt to honor if possible:
	// |	{
	// |		ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.
	// |		deep: boolean	// Whether or not a fetch should do a deep search of items and all child
	// |						// items instead of just root-level items in a datastore.  Default is false.
	// |	}
	//
	//		####The *onBegin* parameter.
	//
	//		function(size, request);
	//		If an onBegin callback function is provided, the callback function
	//		will be called just once, before the first onItem callback is called.
	//		The onBegin callback function will be passed two arguments, the
	//		the total number of items identified and the Request object.  If the total number is
	//		unknown, then size will be -1.  Note that size is not necessarily the size of the
	//		collection of items returned from the query, as the request may have specified to return only a
	//		subset of the total set of items through the use of the start and count parameters.
	//
	//		####The *onItem* parameter.
	//
	//		function(item, request);
	//
	//		If an onItem callback function is provided, the callback function
	//		will be called as each item in the result is received. The callback
	//		function will be passed two arguments: the item itself, and the
	//		Request object.
	//
	//		####The *onComplete* parameter.
	//
	//		function(items, request);
	//
	//		If an onComplete callback function is provided, the callback function
	//		will be called just once, after the last onItem callback is called.
	//		Note that if the onItem callback is not present, then onComplete will be passed
	//		an array containing all items which matched the query and the request object.
	//		If the onItem callback is present, then onComplete is called as:
	//		onComplete(null, request).
	//
	//		####The *onError* parameter.
	//
	//		function(errorData, request);
	//
	//		If an onError callback function is provided, the callback function
	//		will be called if there is any sort of error while attempting to
	//		execute the query.
	//		The onError callback function will be passed two arguments:
	//		an Error object and the Request object.
	//
	//		####The *scope* parameter.
	//
	//		If a scope object is provided, all of the callback functions (onItem,
	//		onComplete, onError, etc) will be invoked in the context of the scope
	//		object.  In the body of the callback function, the value of the "this"
	//		keyword will be the scope object.   If no scope object is provided,
	//		the callback functions will be called in the context of dojo.global().
	//		For example, onItem.call(scope, item, request) vs.
	//		onItem.call(dojo.global(), item, request)
	//
	//		####The *start* parameter.
	//
	//		If a start parameter is specified, this is a indication to the datastore to
	//		only start returning items once the start number of items have been located and
	//		skipped.  When this parameter is paired with 'count', the store should be able
	//		to page across queries with millions of hits by only returning subsets of the
	//		hits for each query
	//
	//		####The *count* parameter.
	//
	//		If a count parameter is specified, this is a indication to the datastore to
	//		only return up to that many items.  This allows a fetch call that may have
	//		millions of item matches to be paired down to something reasonable.
	//
	//		####The *sort* parameter.
	//
	//		If a sort parameter is specified, this is a indication to the datastore to
	//		sort the items in some manner before returning the items.  The array is an array of
	//		javascript objects that must conform to the following format to be applied to the
	//		fetching of items:
	// |	{
	// |		attribute: attribute || attribute-name-string,
	// |		descending: true|false;   // Optional.  Default is false.
	// |	}
	//		Note that when comparing attributes, if an item contains no value for the attribute
	//		(undefined), then it the default ascending sort logic should push it to the bottom
	//		of the list.  In the descending order case, it such items should appear at the top of the list.

	request = request || {};
	if(!request.store){
		request.store = this;
	}

	this._fetchItems(request, lang.hitch(this, "fetchHandler"), lang.hitch(this, "errorHandler"));
	return request;	// Object
};

return simpleFetch;
});

},
'dojo/data/util/filter':function(){
define(["../../_base/lang"], function(lang){
	// module:
	//		dojo/data/util/filter
	// summary:
	//		TODOC

var filter = {};
lang.setObject("dojo.data.util.filter", filter);

filter.patternToRegExp = function(/*String*/pattern, /*boolean?*/ ignoreCase){
	// summary:
	//		Helper function to convert a simple pattern to a regular expression for matching.
	// description:
	//		Returns a regular expression object that conforms to the defined conversion rules.
	//		For example:
	//
	//		- ca*   -> /^ca.*$/
	//		- *ca*  -> /^.*ca.*$/
	//		- *c\*a*  -> /^.*c\*a.*$/
	//		- *c\*a?*  -> /^.*c\*a..*$/
	//
	//		and so on.
	// pattern: string
	//		A simple matching pattern to convert that follows basic rules:
	//
	//		- * Means match anything, so ca* means match anything starting with ca
	//		- ? Means match single character.  So, b?b will match to bob and bab, and so on.
	//		- \ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	//
	//		To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
	//		represented by \\ to be treated as an ordinary \ character instead of an escape.
	// ignoreCase:
	//		An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	//		By default, it is assumed case sensitive.

	var rxp = "^";
	var c = null;
	for(var i = 0; i < pattern.length; i++){
		c = pattern.charAt(i);
		switch(c){
			case '\\':
				rxp += c;
				i++;
				rxp += pattern.charAt(i);
				break;
			case '*':
				rxp += ".*"; break;
			case '?':
				rxp += "."; break;
			case '$':
			case '^':
			case '/':
			case '+':
			case '.':
			case '|':
			case '(':
			case ')':
			case '{':
			case '}':
			case '[':
			case ']':
				rxp += "\\"; //fallthrough
			default:
				rxp += c;
		}
	}
	rxp += "$";
	if(ignoreCase){
		return new RegExp(rxp,"mi"); //RegExp
	}else{
		return new RegExp(rxp,"m"); //RegExp
	}

};

return filter;
});

},
'vodori/tinymce/TableControls':function(){
/*
 These are some buttons and commands for working with table columns.
 */
define([
    '../amd/tinymce',
    'vodori/provide', 'module',
    './util/getPluginName', './util/getResourceUrl'
], function (tinymce, provide, module, getPluginName, getResourceUrl) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, null, {
        init: function (ed) {
            this.inherited(arguments);

            this.ed = ed;
            this.url = getResourceUrl(module);

            ed.addCommand('mce_insert_column_before', function () {
                this.insertColumn('before');
            }, this);
            ed.addCommand('mce_insert_column_after', function () {
                this.insertColumn('after');
            }, this);
            ed.addCommand('mce_shift_column_left', function () {
                this.shiftColumn('left');
            }, this);
            ed.addCommand('mce_shift_column_right', function () {
                this.shiftColumn('right');
            }, this);
            ed.addCommand('mce_delete_column', function () {
                this.deleteColumn();
            }, this);

            ed.addButton('insertcolumnbefore', {
                cmd: 'mce_insert_column_before',
                image: false, // this.url + '/addTab.png',
                label: 'Insert before',
                title: 'Insert a new tab before the current one'
            });

            ed.addButton('insertcolumnafter', {
                cmd: 'mce_insert_column_after',
                image: false, // this.url + '/addTab.png',
                label: 'Insert after',
                title: 'Insert a new tab after the current one'
            });

            ed.addButton('shiftcolumnleft', {
                cmd: 'mce_shift_column_left',
                image: false, // this.url + '/addTab.png',
                label: 'Shift left',
                title: 'Shift this tab to the left'
            });

            ed.addButton('shiftcolumnright', {
                cmd: 'mce_shift_column_right',
                image: false, // this.url + '/addTab.png',
                label: 'Shift right',
                title: 'Shift this tab to the right'
            });

            ed.addButton('deletecolumn', {
                cmd: 'mce_delete_column',
                image: false, // this.url + '/addTab.png',
                label: 'Delete',
                title: 'Delete the current tab'
            });

            ed.onNodeChange.add(function (ed, cm, n) {
                var selected = this.getSelectionInfo();
                var irrelevant = !selected;

                cm.setDisabled('insertcolumnbefore', irrelevant);
                cm.setDisabled('insertcolumnafter', irrelevant);

                cm.setDisabled('shiftcolumnleft', irrelevant || selected.column === 0);
                cm.setDisabled('shiftcolumnright', irrelevant || selected.column === selected.row.cells.length - 1);

                cm.setDisabled('deletecolumn', irrelevant || selected.row.cells.length === 1);
            }, this);
        },

        // This function just returns some things we need sometimes
        getSelectionInfo: function () {
            var ed = this.ed;

            // The node the cursor is currently in
            var selNode = ed.selection.getNode();

            var selTable = ed.dom.getParents(selNode, function (n) {
                return n.nodeName.toLowerCase() === 'table';
            })[0];

            var selRow = ed.dom.getParents(selNode, function (n) {
                return n.nodeName.toLowerCase() === 'tr';
            })[0];

            var selCell = ed.dom.getParents(selNode, function (n) {
                return n.nodeName.toLowerCase() === 'td';
            })[0];

            if (!selTable || !selRow || !selCell) {
                return false;
            }

            var selColIndex = selCell.cellIndex;

            return {
                node: selNode,
                cell: selCell,
                row: selRow,
                column: selColIndex,
                table: selTable
            };
        },

        insertColumn: function (position) {
            var selected = this.getSelectionInfo();

            var idx = selected.column;
            if (position === 'after') {
                idx += 1;
            }

            var newCells = [];
            tinymce.each(selected.table.rows, function (row) {
                var newCell = row.insertCell(idx);
                newCell.innerHTML = 'X';

                newCells.push(newCell);
            });

            newCells[selected.row.rowIndex].scrollIntoView();
            this.ed.selection.select(newCells[selected.row.rowIndex], true);
        },

        shiftColumn: function (direction) {
            var selected = this.getSelectionInfo();

            var idx = selected.column;
            if (direction === 'left')  {
                idx -= 1;
            }
            if (direction === 'right') {
                idx += 2;
            }

            // We're already at the start or end
            if (idx === -1 || idx > selected.row.cells.length) {
                return;
            }

            var newCells = [];
            tinymce.each(selected.table.rows, function (row) {
                var oldCell = row.cells[selected.column];
                var newCell = row.insertCell(idx);

                newCell.innerHTML = oldCell.innerHTML;

                row.deleteCell(oldCell.cellIndex);

                newCells.push(newCell);
            });

            newCells[selected.row.rowIndex].scrollIntoView();
            this.ed.selection.select(newCells[selected.row.rowIndex], true);
        },

        // Delete a table column representing a tab
        deleteColumn: function () {
            var selected = this.getSelectionInfo();

            // Don't delete the last column (because then what would we do?)
            if (selected.row.cells.length === 1) {
                return;
            }

            tinymce.each(selected.table.rows, function (r) {
                r.deleteCell(selected.column);
            });

            var newlySelected = selected.table.rows[selected.row.rowIndex].cells[Math.max(selected.column - 1, 0)];

            newlySelected.scrollIntoView();
            this.ed.selection.select(newlySelected, true);
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});


},
'vodori/tinymce/Twitter':function(){
define([
    'module', 'vodori/provide',
    'dojo/dom-form',
    'vodori/amd/tinymce',
    'vodori/tinymce/ConfigurableTransformer',
    'vodori/ui/Twitter',
    'vodori/tinymce/util/getPluginName'
], function (module, provide, domForm, tinymce, ConfigurableTransformer, TwitterWidget, getPluginName) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, [ConfigurableTransformer], {
        dijitDeclaredClass: TwitterWidget.prototype.declaredClass,

        // Set up a button
        button: {
            title: "Insert a twitter widget",
            image: '',
            label: 'Twitter',
            changeStates: {
                highlight: [pluginName],
                enable: [],
                disable: []
            }
        },

        // Configuration popup window dimensions
        popupWidth: 390,
        popupHeight: 330,

        wrapperNode: 'span',
        loremIpsum: 'I have a tooltip',

        // Define all possible attributes of the widget's dom node
        // and their desired default values
        defaultAttrs: {
            imgSrc: '',
            label: 'Hello, world!',
            showDelay: 500,
            animDuration: 100,
            position: 'after'
        },

        styleSheet: false,


        buttonOnClick: function (ui, val) {
            var ed = this.editor,
                url = this.url;

            ed.windowManager.open({
                file: url + '/twitter.htm',
                width: 730 + parseInt(ed.getLang('media.delta_width', 0), 10),
                height: 470 + parseInt(ed.getLang('media.delta_height', 0), 10),
                inline: 1
            }, {
                /* jshint -W106 */
                plugin_url: url,
                plugin: this
                /* jshint +W106 */
            });
        },

        convertPopupFormIntoConfiguration: function (form) {
            var formData = domForm.formToObject(form),
                i,
                config = {},
                query ='';

            if (formData.mode === 'single_user') {
                config.mode = formData.mode;
                config.query = "from:" + formData.name;

            } else if (formData.mode === 'multi_user') {
                config.mode = formData.mode;

                if (formData.namesHashtags !== '') {
                    var list = formData.namesHashtags.toString().split(" ");

                    for (i = 0; i < list.length; i++) {
                        if (query !== '') {
                            query += " OR ";
                        }

                        if (list[i].indexOf('#') === 0) {
                            query += list[i];
                        } else {
                            query += "from:" + list[i];
                        }
                    }
                }

                config.query = query;
            }

            return config;
        },

        prepopulatePopupForm: function (form) {

            var config = this.widgetPlaceholderToJson();

            // Check the right radio button
            tinymce.DOM.setAttrib(tinymce.DOM.select('input[name="mode"]', form), 'checked', null);
            tinymce.DOM.setAttrib(tinymce.DOM.select('input[name="mode"][value=' + config.mode + ']', form),
                                  'checked',
                                  'checked');


            if (config.mode === 'single_user') {
                form.name.value = config.query.substr(5) || "";
            } else if (config.mode === 'multi_user') {
                var list = config.query.split(" OR "),
                    query = "",
                    i;

                for (i = 0; i < list.length; i++) {
                    if (query !== '') {
                        query += " ";
                    }

                    if (list[i].indexOf("from:") === 0) {
                        query += list[i].substr(5);
                    } else if (list[i].indexOf('#') === 0) {
                        query += list[i];
                    }
                }

                form.namesHashtags.value = query;
            }

            if (config.mode === 'single_user') {
                tinymce.DOM.setStyles(tinymce.DOM.select('#singleUserOptions', form), {'display': 'block'});
            } else if (config.mode === 'multi_user') {
                tinymce.DOM.setStyles(tinymce.DOM.select('#multiUserOptions', form), {'display': 'block'});
            }

        }
    });

    tinymce.PluginManager.add(pluginName, plugin);
});

},
'vodori/ui/Twitter':function(){
/*
 Copyright (c) 2004-2009, The Dojo Foundation All Rights Reserved.
 Available via Academic Free License >= 2.1 OR the modified BSD license.
 see: http://dojotoolkit.org/license for details
 */
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/dom-construct',
    'dojo/date', 'dojo/date/locale',
    'dijit/_Widget',
    'dijit/_Templated',
    'vodori/data/TwitterStore',
    'vodori/util/SerializableMixin',
    'dojo/text!./templates/Twitter.html'
], function (module, provide,
             _,
             lang,
             domConstruct,
             date, dateLocale,
             _Widget,
             _Templated,
             TwitterStore,
             _SerilizableMixin,
             twitterTemplate) {
    return provide(module.id, [_Widget, _Templated, _SerilizableMixin], {
        templateString: twitterTemplate,

        store: {},
        maxResults: 0,
        query: '',
        mode: '',

        attributeMap: lang.delegate(_Widget.prototype.attributeMap, {
            title: [
                { node: 'twitterHeader', type: 'innerHTML' }
            ]
        }),

        //	summary:
        //		The post create to connect a dojo data object.
        //
        //
        postCreate: function () {

            if (this.store) {
                this.store = lang.getObject(this.store);
            }
            else {
                this.store = new TwitterStore();
            }

            var request = {
                query: this.query,
                maxResults: this.maxResults,

                onItem: lang.hitch(this, '_addItem'),
                onComplete: lang.hitch(this, function () {
                    this._applyFormatting.apply(this, arguments);
                }),
                onError: lang.hitch(this, '_error')
            };

            //Only run _singleUserSetup if the mode is 'single_user'
            if (this.mode === 'single_user') {
                request.onBegin = lang.hitch(this, '_singleUserSetup');
            }

            this.store.fetch(request);
            this.inherited(arguments);
        },


        //	summary:
        //		This function is specific to the single user mode and
        //		sets up the header, which includes the user profile image
        //      and the user name. This way we do not show the image and
        //      user name for each tweet.
        _singleUserSetup: function (count, args) {

            var results = args.results;

            if (results.length > 0) {
                var profileImageUrl = this.store.getValue(results[0], 'profile_image_url');
                var fromUser = this.store.getValue(results[0], 'from_user');
                var twitterOpenTag = '<a href="http://www.twitter.com/' + fromUser + '" target="_new">';

                this.userThumbnailNode.innerHTML = twitterOpenTag +
                                                     '<img height="48px" width="48px" src="' + profileImageUrl + '"/>' +
                                                   '</a>';
                this.usernameNode.innerHTML = twitterOpenTag + fromUser + '</a>';
            }
        },

        _error: function (error, request) {
            console.debug('Error: ' + error);
        },

        _applyFormatting: function () {

        },


        _activateHashTags: function (text) {
            //Find twitter hashtags and add wrap them in html to make them clickable
            var newText = '',
                list,
                hashTagList,
                i;
            if (text.indexOf('#') >= 0) {
                //REGEX = any string starting with # and goes to first space (Flags= global, case insensitive)
                list = text.split(/#\S+/gi);
                hashTagList = text.match(/#\S+/gi);

                for (i = 0; i < list.length; i++) {

                    newText += list[i];

                    if (hashTagList[i] !== null) {
                        var tag = hashTagList[i].substring(1),
                            searchURL = 'http://twitter.com/search?q=%23' + tag;

                        newText += '<a href="' + searchURL + '" target="_new">' + hashTagList[i] + '</a>';
                    }
                }

                text = newText;
            }
            return text;
        },

        _activateTwitterHandles: function (text) {
            var newText = '',
                list,
                atList,
                i;
            //Find twitter user names and add wrap them in html to make them clickable
            if (text.indexOf('@') >= 0) {
                //REGEX = any string starting with @ and including any letters, numbers, and underscores which are the
                // only valid characters in a twitter user name (Flags= global, case insensitive)
                list = text.split(/@\w+/gi);
                atList = text.match(/@\w+/gi);

                for (i = 0; i < list.length; i++) {

                    newText += list[i];

                    if (atList[i] !== null) {
                        var atText = atList[i].toString().substr(1);
                        newText += '@<a href="http://twitter.com/' + atText + '" target="_new">' + atText + '</a>';
                    }
                }

                text = newText;
            }
            return text;
        },

        _activateLinks: function (text) {
            //Find links and add wrap them in html to make them clickable
            var newText = '',
                list,
                linkList,
                i;
            if (text.indexOf('http') >= 0) {
                //REGEX = any string starting with http and goes to first space (Flags= global, case insensitive)
                list = text.split(/http\S+/gi);
                linkList = text.match(/http\S+/gi);

                for (i = 0; i < list.length; i++) {
                    newText += list[i];

                    if (linkList[i] !== null) {
                        newText += '<a href="' + linkList[i] + '" target="_new">' + linkList[i] + '</a>';
                    }
                }

                text = newText;
            }
            return text;
        },


        /*
         * summary:
         *      This function is called when an item is added to the dojo data object.
         */
        _addItem: function (item) {

            var profileImageUrl = this.store.getValue(item, 'profile_image_url'),
                createdAt = this.store.getValue(item, 'created_at'),
                fromUser = this.store.getValue(item, 'from_user'),
                text = this.store.getValue(item, 'text');


            text = this._activateLinks(text);
            text = this._activateHashTags(text);
            text = this._activateTwitterHandles(text);

            //Convert created at date to a format that we want to use
            createdAt = this._getTweetDateString(createdAt);

            if (this.mode === 'single_user') {
                this._singleUserLayoutInsertTweet(text, createdAt);
            } else if (this.mode === 'multi_user') {
                this._multiUserLayoutInsertTweet(profileImageUrl, fromUser, text, createdAt);
            }

        },

        _getItemsFromLoadedData: function (/* Object */ dataObject) {

        },

        _singleUserLayoutInsertTweet: function (text, createdAt) {

            var node = this.singleUserTweetList;

            domConstruct.create('div', {
                'class': 'singleUserTweet',
                innerHTML: '<span class="tweetText">' + text + '</span>' +
                    '<span class="createdAt">' + createdAt + '</span>'
            }, node);

        },

        _multiUserLayoutInsertTweet: function (profileImageUrl, fromUser, text, createdAt) {

            var node = this.multiUserTweetList,
                twitterURL = 'http://www.twitter.com/' + fromUser;

            domConstruct.create('div', {
                'class': 'multiUserTweet',
                innerHTML: '<span class="userThumbnailImg">' + '<a href="'+ twitterURL + '" target="_new">' +
                                '<img height="48px" width="48px" src="' + profileImageUrl + '"/></a>' +
                            '</span> ' +
                            '<span class="userName">' +
                                '<a href="'+ twitterURL + '" target="_new">' + fromUser + '</a>' +
                            '</span> ' +
                            '<span class="tweetText">' + text + '</span> ' +
                            '<span class="createdAt">' + createdAt + '</span> '
            }, node);

        },

        _getTweetDateString: function (createDate) {

            // Sample date from twitter: Tue, 12 Jan 2010 02:19:25 +0000

            var dateString;
            var currentDate = (new Date())();
            var tweetDate = dateLocale.parse(createDate.substr(5), {
                datePattern: 'dd MMM yyyy HH:mm:ss ZZ',
                selector: 'date'
            });
            tweetDate = (new Date())(tweetDate.getTime() - (currentDate.getTimezoneOffset() * 60000));

            var dateDiff = date.difference(tweetDate, currentDate, 'second');

            //Date less then 1 hour ago
            if (dateDiff < 3600) {
                dateString = Math.round(dateDiff / 60) + ' minutes ago';
            }
            //Date less then 1 day ago
            else if (dateDiff < 86400) {
                dateString = Math.round(dateDiff / 60 / 60) + ' hours ago';
            }
            //Else show full date
            else {
                dateString = dateLocale.format(tweetDate, {
                    datePattern: 'hh:mma MMM dd, yyyy',
                    selector: 'date'
                });
            }

            return dateString;
        }
    });
});

},
'dijit/_Templated':function(){
define([
	"./_WidgetBase",
	"./_TemplatedMixin",
	"./_WidgetsInTemplateMixin",
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.extend lang.isArray
	"dojo/_base/kernel" // kernel.deprecated
], function(_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, array, declare, lang, kernel){

	// module:
	//		dijit/_Templated

	// These arguments can be specified for widgets which are used in templates.
	// Since any widget can be specified as sub widgets in template, mix it
	// into the base widget class.  (This is a hack, but it's effective.)
	// Remove for 2.0.   Also, hide from API doc parser.
	lang.extend(_WidgetBase, /*===== {} || =====*/ {
		waiRole: "",
		waiState:""
	});

	return declare("dijit._Templated", [_TemplatedMixin, _WidgetsInTemplateMixin], {
		// summary:
		//		Deprecated mixin for widgets that are instantiated from a template.
		//		Widgets should use _TemplatedMixin plus if necessary _WidgetsInTemplateMixin instead.

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  False by default.
		widgetsInTemplate: false,

		constructor: function(){
			kernel.deprecated(this.declaredClass + ": dijit._Templated deprecated, use dijit._TemplatedMixin and if necessary dijit._WidgetsInTemplateMixin", "", "2.0");
		},

		_processNode: function(baseNode, getAttrFunc){
			var ret = this.inherited(arguments);

			// Do deprecated waiRole and waiState
			var role = getAttrFunc(baseNode, "waiRole");
			if(role){
				baseNode.setAttribute("role", role);
			}
			var values = getAttrFunc(baseNode, "waiState");
			if(values){
				array.forEach(values.split(/\s*,\s*/), function(stateValue){
					if(stateValue.indexOf('-') != -1){
						var pair = stateValue.split('-');
						baseNode.setAttribute("aria-"+pair[0], pair[1]);
					}
				});
			}

			return ret;
		}
	});
});

},
'vodori/data/TwitterStore':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojox/rpc/Service',
    'dojox/data/ServiceStore'
], function (module, provide,
             _,
             Service, ServiceStore) {

    return provide(module.id, [ServiceStore],
        /**
         * @lends vodori/data/TwitterStore
         */
        {

            /**
             * @constructs
             * @extends dojox/data/ServiceStore
             */
            constructor: function () {
                var mu = require.toUrl('vodori/rpc/smd/twitter.smd');
                var svc = new Service(mu);

                this.service = svc.query;

                this.idAttribute = this.labelAttribute = 'id';

            },

            // this should return an object with the items as an array and the total count of
            // items (maybe more than currently in the result set).
            // for example:
            //  | {totalCount:10,[{id:1},{id:2}]}

            // index the results, assigning ids as necessary
            _processResults: function (results, def) {
                if (results && typeof results === 'object') {
                    if (results.results && typeof results.results === 'object') {
                        results = results.results;
                    }
                }

                // HACK: If this came from a widget, and that widget has a maxResults set, use it.
                var maxResults;
                if (this.widget && this.widget.maxResults) {
                    maxResults = this.widget.maxResults;
                    if (results.length > maxResults) {
                        results = results.slice(0, maxResults);
                    }
                }

                return {totalCount: results.length, items: results};
            }
        }
    );
});

},
'dojox/rpc/Service':function(){
define("dojox/rpc/Service", ["dojo", "dojox", "dojo/AdapterRegistry", "dojo/_base/url"], function(dojo, dojox) {

dojo.declare("dojox.rpc.Service", null, {
	constructor: function(smd, options){
		// summary:
		//		Take a string as a url to retrieve an smd or an object that is an smd or partial smd to use
		//		as a definition for the service
		// description:
		//		dojox.rpc.Service must be loaded prior to any plugin services like dojox.rpc.Rest
		//		dojox.rpc.JsonRpc in order for them to register themselves, otherwise you get
		//		a "No match found" error.
		// smd: object
		//		Takes a number of properties as kwArgs for defining the service.  It also
		//		accepts a string.  When passed a string, it is treated as a url from
		//		which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
		//		object.  It accepts serviceUrl, to manually define a url for the rpc service
		//		allowing the rpc system to be used without an smd definition. strictArgChecks
		//		forces the system to verify that the # of arguments provided in a call
		//		matches those defined in the smd.  smdString allows a developer to pass
		//		a jsonString directly, which will be converted into an object or alternatively
		//		smdObject is accepts an smdObject directly.

		var url;
		var self = this;
		function processSmd(smd){
			smd._baseUrl = new dojo._Url((dojo.isBrowser ? location.href : dojo.config.baseUrl) ,url || '.') + '';
			self._smd = smd;

			//generate the methods
 			for(var serviceName in self._smd.services){
				var pieces = serviceName.split("."); // handle "namespaced" services by breaking apart by .
				var current = self;
				for(var i=0; i< pieces.length-1; i++){
					// create or reuse each object as we go down the chain
					current = current[pieces[i]] || (current[pieces[i]] = {});
				}
				current[pieces[pieces.length-1]]=	self._generateService(serviceName, self._smd.services[serviceName]);
 			}
		}
		if(smd){
			//ifthe arg is a string, we assume it is a url to retrieve an smd definition from
			if( (dojo.isString(smd)) || (smd instanceof dojo._Url)){
				if(smd instanceof dojo._Url){
					url = smd + "";
				}else{
					url = smd;
				}

				var text = dojo._getText(url);
				if(!text){
					throw new Error("Unable to load SMD from " + smd);
				}else{
					processSmd(dojo.fromJson(text));
				}
			}else{
				processSmd(smd);
			}
		}

		this._options = (options ? options : {});
		this._requestId = 0;
	},

	_generateService: function(serviceName, method){
		if(this[method]){
			throw new Error("WARNING: "+ serviceName+ " already exists for service. Unable to generate function");
		}
		method.name = serviceName;
		var func = dojo.hitch(this, "_executeMethod",method);
		var transport = dojox.rpc.transportRegistry.match(method.transport || this._smd.transport);
		if(transport.getExecutor){
			func = transport.getExecutor(func,method,this);
		}
		var schema = method.returns || (method._schema = {}); // define the schema
		var servicePath = '/' + serviceName +'/';
		// schemas are minimally used to track the id prefixes for the different services
		schema._service = func;
		func.servicePath = servicePath;
		func._schema = schema;
		func.id = dojox.rpc.Service._nextId++;
		return func;
	},
	_getRequest: function(method,args){
		var smd = this._smd;
		var envDef = dojox.rpc.envelopeRegistry.match(method.envelope || smd.envelope || "NONE");
		var parameters = (method.parameters || []).concat(smd.parameters || []);
		if(envDef.namedParams){
			// the serializer is expecting named params
			if((args.length==1) && dojo.isObject(args[0])){
				// looks like we have what we want
				args = args[0];
			}else{
				// they provided ordered, must convert
				var data={};
				for(var i=0;i<method.parameters.length;i++){
					if(typeof args[i] != "undefined" || !method.parameters[i].optional){
						data[method.parameters[i].name]=args[i];
					}
				}
				args = data;
			}
			if(method.strictParameters||smd.strictParameters){
				//remove any properties that were not defined
				for(i in args){
					var found=false;
					for(var j=0; j<parameters.length;j++){
						if(parameters[j].name==i){ found=true; }
					}
					if(!found){
						delete args[i];
					}
				}

			}
			// setting default values
			for(i=0; i< parameters.length; i++){
				var param = parameters[i];
				if(!param.optional && param.name && !args[param.name]){
					if(param["default"]){
						args[param.name] = param["default"];
					}else if(!(param.name in args)){
						throw new Error("Required parameter " + param.name + " was omitted");
					}
				}
			}
		}else if(parameters && parameters[0] && parameters[0].name && (args.length==1) && dojo.isObject(args[0])){
			// looks like named params, we will convert
			if(envDef.namedParams === false){
				// the serializer is expecting ordered params, must be ordered
				args = dojox.rpc.toOrdered(parameters, args);
			}else{
				// named is ok
				args = args[0];
			}
		}

		if(dojo.isObject(this._options)){
			args = dojo.mixin(args, this._options);
		}

		var schema = method._schema || method.returns; // serialize with the right schema for the context;
		var request = envDef.serialize.apply(this, [smd, method, args]);
		request._envDef = envDef;// save this for executeMethod
		var contentType = (method.contentType || smd.contentType || request.contentType);

		// this allows to mandate synchronous behavior from elsewhere when necessary, this may need to be changed to be one-shot in FF3 new sync handling model
		return dojo.mixin(request, {
			sync: dojox.rpc._sync,
			contentType: contentType,
			headers: method.headers || smd.headers || request.headers || {},
			target: request.target || dojox.rpc.getTarget(smd, method),
			transport: method.transport || smd.transport || request.transport,
			envelope: method.envelope || smd.envelope || request.envelope,
			timeout: method.timeout || smd.timeout,
			callbackParamName: method.callbackParamName || smd.callbackParamName,
			rpcObjectParamName: method.rpcObjectParamName || smd.rpcObjectParamName,
			schema: schema,
			handleAs: request.handleAs || "auto",
			preventCache: method.preventCache || smd.preventCache,
			frameDoc: this._options.frameDoc || undefined
		});
	},
	_executeMethod: function(method){
		var args = [];
		var i;
		for(i=1; i< arguments.length; i++){
			args.push(arguments[i]);
		}
		var request = this._getRequest(method,args);
		var deferred = dojox.rpc.transportRegistry.match(request.transport).fire(request);

		deferred.addBoth(function(results){
			return request._envDef.deserialize.call(this,results);
		});
		return deferred;
	}
});

dojox.rpc.getTarget = function(smd, method){
	var dest=smd._baseUrl;
	if(smd.target){
		dest = new dojo._Url(dest,smd.target) + '';
	}
	if(method.target){
		dest = new dojo._Url(dest,method.target) + '';
	}
	return dest;
};

dojox.rpc.toOrdered=function(parameters, args){
	if(dojo.isArray(args)){ return args; }
	var data=[];
	for(var i=0;i<parameters.length;i++){
		data.push(args[parameters[i].name]);
	}
	return data;
};

dojox.rpc.transportRegistry = new dojo.AdapterRegistry(true);
dojox.rpc.envelopeRegistry = new dojo.AdapterRegistry(true);
//Built In Envelopes

dojox.rpc.envelopeRegistry.register(
	"URL",
	function(str){ return str == "URL"; },
	{
		serialize:function(smd, method, data ){
			var d = dojo.objectToQuery(data);
			return {
				data: d,
				transport:"POST"
			};
		},
		deserialize:function(results){
			return results;
		},
		namedParams: true
	}
);

dojox.rpc.envelopeRegistry.register(
	"JSON",
	function(str){ return str == "JSON"; },
	{
		serialize: function(smd, method, data){
			var d = dojo.toJson(data);

			return {
				data: d,
				handleAs: 'json',
				contentType : 'application/json'
			};
		},
		deserialize: function(results){
			return results;
		}
	}
);
dojox.rpc.envelopeRegistry.register(
	"PATH",
	function(str){ return str == "PATH"; },
	{
		serialize:function(smd, method, data){
			var i;
			var target = dojox.rpc.getTarget(smd, method);
			if(dojo.isArray(data)){
				for(i = 0; i < data.length;i++){
					target += '/' + data[i];
				}
			}else{
				for(i in data){
					target += '/' + i + '/' + data[i];
				}
			}

			return {
				data:'',
				target: target
			};
		},
		deserialize:function(results){
			return results;
		}
	}
);



//post is registered first because it is the default;
dojox.rpc.transportRegistry.register(
	"POST",
	function(str){ return str == "POST"; },
	{
		fire:function(r){
			r.url = r.target;
			r.postData = r.data;
			return dojo.rawXhrPost(r);
		}
	}
);

dojox.rpc.transportRegistry.register(
	"GET",
	function(str){ return str == "GET"; },
	{
		fire: function(r){
			r.url=  r.target + (r.data ? '?' + ((r.rpcObjectParamName) ? r.rpcObjectParamName + '=' : '') + r.data : '');
			return dojo.xhrGet(r);
		}
	}
);


//only works ifyou include dojo.io.script
dojox.rpc.transportRegistry.register(
	"JSONP",
	function(str){ return str == "JSONP"; },
	{
		fire: function(r){
			r.url = r.target + ((r.target.indexOf("?") == -1) ? '?' : '&') + ((r.rpcObjectParamName) ? r.rpcObjectParamName + '=' : '') + r.data;
			r.callbackParamName = r.callbackParamName || "callback";
			return dojo.io.script.get(r);
		}
	}
);
dojox.rpc.Service._nextId = 1;

dojo._contentHandlers.auto = function(xhr){
	// automatically choose the right handler based on the returned content type
	var handlers = dojo._contentHandlers;
	var retContentType = xhr.getResponseHeader("Content-Type");
	var results = !retContentType ? handlers.text(xhr) :
		retContentType.match(/\/.*json/) ? handlers.json(xhr) :
		retContentType.match(/\/javascript/) ? handlers.javascript(xhr) :
		retContentType.match(/\/xml/) ? handlers.xml(xhr) : handlers.text(xhr);
	return results;
};

return dojox.rpc.Service;

});

},
'dojox/data/ServiceStore':function(){
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array"], function(declare, lang, array) {
return declare("dojox.data.ServiceStore",
	// ClientFilter is intentionally not required, ServiceStore does not need it, and is more
	// lightweight without it, but if it is provided, the ServiceStore will use it.
	lang.getObject("dojox.data.ClientFilter", 0)||null,{
		// summary:
		//		note that dojox.rpc.Service is not required, you can create your own services
		//		A ServiceStore is a readonly data store that provides a data.data interface to an RPC service.
		//		|		var myServices = new dojox.rpc.Service(dojo.moduleUrl("dojox.rpc.tests.resources", "test.smd"));
		//		|		var serviceStore = new dojox.data.ServiceStore({service:myServices.ServiceStore});
		//
		//		The ServiceStore also supports lazy loading. References can be made to objects that have not been loaded.
		//		For example if a service returned:
		//		|		{"name":"Example","lazyLoadedObject":{"$ref":"obj2"}}
		//
		//		And this object has accessed using the dojo.data API:
		//		|		var obj = serviceStore.getValue(myObject,"lazyLoadedObject");
		//		The object would automatically be requested from the server (with an object id of "obj2").
	
	
		// service: Object
		//	This is the service object that is used to retrieve lazy data and save results
		//	The function should be directly callable with a single parameter of an object id to be loaded
		service: null,
		
		constructor: function(options){
			// summary:
			//		ServiceStore constructor, instantiate a new ServiceStore
			//		A ServiceStore can be configured from a JSON Schema. Queries are just
			//		passed through to the underlying services
			// options:
			//		Keyword arguments
			//
			//		####The *schema* parameter
			//
			//		This is a schema object for this store. This should be JSON Schema format.
			//
			//		####The *service* parameter
			//
			//		This is the service object that is used to retrieve lazy data and save results
			//		The function should be directly callable with a single parameter of an object id to be loaded
			//
			//		####The *idAttribute* parameter
			//
			//		Defaults to 'id'. The name of the attribute that holds an objects id.
			//		This can be a preexisting id provided by the server.
			//		If an ID isn't already provided when an object
			//		is fetched or added to the store, the autoIdentity system
			//		will generate an id for it and add it to the index.
			//
			//		####The *estimateCountFactor* parameter
			//
			//		This parameter is used by the ServiceStore to estimate the total count. When
			//		paging is indicated in a fetch and the response includes the full number of items
			//		requested by the fetch's count parameter, then the total count will be estimated
			//		to be estimateCountFactor multiplied by the provided count. If this is 1, then it is assumed that the server
			//		does not support paging, and the response is the full set of items, where the
			//		total count is equal to the number of items returned. If the server does support
			//		paging, an estimateCountFactor of 2 is a good value for estimating the total count
			//		It is also possible to override _processResults if the server can provide an exact
			//		total count.
			//
			//		####The *syncMode* parameter
			//
			//		Setting this to true will set the store to using synchronous calls by default.
			//		Sync calls return their data immediately from the calling function, so
			//		callbacks are unnecessary. This will only work with a synchronous capable service.
			//
			// description:
			//		ServiceStore can do client side caching and result set updating if
			//		dojox.data.ClientFilter is loaded. Do this add:
			//	|	dojo.require("dojox.data.ClientFilter")
			//		prior to loading the ServiceStore (ClientFilter must be loaded before ServiceStore).
			//		To utilize client side filtering with a subclass, you can break queries into
			//		client side and server side components by putting client side actions in
			//		clientFilter property in fetch calls. For example you could override fetch:
			//	|	fetch: function(args){
			//	|		// do the sorting and paging on the client side
			//	|		args.clientFilter = {start:args.start, count: args.count, sort: args.sort};
			//	|		// args.query will be passed to the service object for the server side handling
			//	|		return this.inherited(arguments);
			//	|	}
			//		When extending this class, if you would like to create lazy objects, you can follow
			//		the example from dojox.data.tests.stores.ServiceStore:
			// |	var lazyItem = {
			// |		_loadObject: function(callback){
			// |			this.name="loaded";
			// |			delete this._loadObject;
			// |			callback(this);
			// |		}
			// |	};

			//setup a byId alias to the api call
			this.byId=this.fetchItemByIdentity;
			this._index = {};
			// if the advanced json parser is enabled, we can pass through object updates as onSet events
			if(options){
				lang.mixin(this,options);
			}
			// We supply a default idAttribute for parser driven construction, but if no id attribute
			//	is supplied, it should be null so that auto identification takes place properly
			this.idAttribute = (options && options.idAttribute) || (this.schema && this.schema._idAttr);
		},
		
		// schema: 
		//		This is a schema object for this store. This should be JSON Schema format.
		schema: null,
		
		// idAttribute: String
		//		Defaults to 'id'. The name of the attribute that holds an objects id.
		//		This can be a preexisting id provided by the server.
		//		If an ID isn't already provided when an object
		//		is fetched or added to the store, the autoIdentity system
		//		will generate an id for it and add it to the index.

		idAttribute: "id",
		labelAttribute: "label",
		
		// syncMode: Boolean
		//		Setting this to true will set the store to using synchronous calls by default.
		//		Sync calls return their data immediately from the calling function, so
		//		callbacks are unnecessary. This will only work with a synchronous capable service.
		syncMode: false,
		
		// estimateCountFactor:
		//		This parameter is used by the ServiceStore to estimate the total count. When
		//		paging is indicated in a fetch and the response includes the full number of items
		//		requested by the fetch's count parameter, then the total count will be estimated
		//		to be estimateCountFactor multiplied by the provided count. If this is 1, then it is assumed that the server
		//		does not support paging, and the response is the full set of items, where the
		//		total count is equal to the numer of items returned. If the server does support
		//		paging, an estimateCountFactor of 2 is a good value for estimating the total count
		//		It is also possible to override _processResults if the server can provide an exact
		//		total count.	
		estimateCountFactor: 1,
		
		getSchema: function(){
			// summary:
			//		Returns a reference to the JSON Schema
			// returns: Object
			return this.schema;
		},

		loadLazyValues:true,

		getValue: function(/*Object*/ item, /*String*/property, /*value?*/defaultValue){
			// summary:
			//		Gets the value of an item's 'property'
			// item:
			//		The item to get the value from
			// property:
			//		property to look up value for
			// defaultValue:
			//		the default value

			var value = item[property];
			return value || // return the plain value since it was found;
						(property in item ? // a truthy value was not found, see if we actually have it
							value : // we do, so we can return it
							item._loadObject ? // property was not found, maybe because the item is not loaded, we will try to load it synchronously so we can get the property
								(dojox.rpc._sync = true) && arguments.callee.call(this,dojox.data.ServiceStore.prototype.loadItem({item:item}) || {}, property, defaultValue) : // load the item and run getValue again
								defaultValue);// not in item -> return default value
		},
		getValues: function(item, property){
			// summary:
			//		Gets the value of an item's 'property' and returns
			//		it.	If this value is an array it is just returned,
			//		if not, the value is added to an array and that is returned.
			// item: Object
			// property: String
			//		property to look up value for

			var val = this.getValue(item,property);
			return val instanceof Array ? val : val === undefined ? [] : [val];
		},

		getAttributes: function(item){
			// summary:
			//		Gets the available attributes of an item's 'property' and returns
			//		it as an array.
			// item: Object

			var res = [];
			for(var i in item){
				if(item.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_')){
					res.push(i);
				}
			}
			return res;
		},

		hasAttribute: function(item,attribute){
			// summary:
			//		Checks to see if item has attribute
			// item: Object
			// attribute: String
			return attribute in item;
		},

		containsValue: function(item, attribute, value){
			// summary:
			//		Checks to see if 'item' has 'value' at 'attribute'
			// item: Object
			// attribute: String
			// value: Anything
			return array.indexOf(this.getValues(item,attribute),value) > -1;
		},


		isItem: function(item){
			// summary:
			//		Checks to see if the argument is an item
			// item: Object

			// we have no way of determining if it belongs, we just have object returned from
			// service queries
			return (typeof item == 'object') && item && !(item instanceof Date);
		},

		isItemLoaded: function(/* object */ item){
			// summary:
			//		Checks to see if the item is loaded.

			return item && !item._loadObject;
		},

		loadItem: function(args){
			// summary:
			//		Loads an item and calls the callback handler. Note, that this will call the callback
			//		handler even if the item is loaded. Consequently, you can use loadItem to ensure
			//		that an item is loaded is situations when the item may or may not be loaded yet.
			//		If you access a value directly through property access, you can use this to load
			//		a lazy value as well (doesn't need to be an item).
			// example:
			//	|	store.loadItem({
			//	|		item: item, // this item may or may not be loaded
			//	|		onItem: function(item){
			//	|			// do something with the item
			//	|		}
			//	|	});

			var item;
			if(args.item._loadObject){
				args.item._loadObject(function(result){
					item = result; // in synchronous mode this can allow loadItem to return the value
					delete item._loadObject;
					var func = result instanceof Error ? args.onError : args.onItem;
					if(func){
						func.call(args.scope, result);
					}
				});
			}else if(args.onItem){
				// even if it is already loaded, we will use call the callback, this makes it easier to
				// use when it is not known if the item is loaded (you can always safely call loadItem).
				args.onItem.call(args.scope, args.item);
			}
			return item;
		},
		_currentId : 0,
		_processResults : function(results, deferred){
			// this should return an object with the items as an array and the total count of
			// items (maybe more than currently in the result set).
			// for example:
			//	| {totalCount:10, items: [{id:1},{id:2}]}

			// index the results, assigning ids as necessary

			if(results && typeof results == 'object'){
				var id = results.__id;
				if(!id){// if it hasn't been assigned yet
					if(this.idAttribute){
						// use the defined id if available
						id = results[this.idAttribute];
					}else{
						id = this._currentId++;
					}
					if(id !== undefined){
						var existingObj = this._index[id];
						if(existingObj){
							for(var j in existingObj){
								delete existingObj[j]; // clear it so we can mixin
							}
							results = lang.mixin(existingObj,results);
						}
						results.__id = id;
						this._index[id] = results;
					}
				}
				for(var i in results){
					results[i] = this._processResults(results[i], deferred).items;
				}
				var count = results.length;
			}
			return {totalCount: deferred.request.count == count ? (deferred.request.start || 0) + count * this.estimateCountFactor : count, items: results};
		},
		close: function(request){
			return request && request.abort && request.abort();
		},
		fetch: function(args){
			// summary:
			//		See dojo/data/api/Read.fetch
			// args:
			//		####The *queryOptions.cache* parameter
			//
			//		If true, indicates that the query result should be cached for future use. This is only available
			//		if dojox.data.ClientFilter has been loaded before the ServiceStore
			//
			//		####The *syncMode* parameter
			//
			//		Indicates that the call should be fetch synchronously if possible (this is not always possible)
			//
			//		####The *clientFetch* parameter
			//
			//		This is a fetch keyword argument for explicitly doing client side filtering, querying, and paging

			args = args || {};

			if("syncMode" in args ? args.syncMode : this.syncMode){
				dojox.rpc._sync = true;
			}
			var self = this;

			var scope = args.scope || self;
			var defResult = this.cachingFetch ? this.cachingFetch(args) : this._doQuery(args);
			defResult.request = args;
			defResult.addCallback(function(results){
				if(args.clientFetch){
					results = self.clientSideFetch({query:args.clientFetch,sort:args.sort,start:args.start,count:args.count},results);
				}
				var resultSet = self._processResults(results, defResult);
				results = args.results = resultSet.items;
				if(args.onBegin){
					args.onBegin.call(scope, resultSet.totalCount, args);
				}
				if(args.onItem){
					for(var i=0; i<results.length;i++){
						args.onItem.call(scope, results[i], args);
					}
				}
				if(args.onComplete){
					args.onComplete.call(scope, args.onItem ? null : results, args);
				}
				return results;
			});
			defResult.addErrback(args.onError && function(err){
				return args.onError.call(scope, err, args);
			});
			args.abort = function(){
				// abort the request
				defResult.cancel();
			};
			args.store = this;
			return args;
		},
		_doQuery: function(args){
			var query= typeof args.queryStr == 'string' ? args.queryStr : args.query;
			return this.service(query);
		},
		getFeatures: function(){
			// summary:
			//		return the store feature set

			return {
				"dojo.data.api.Read": true,
				"dojo.data.api.Identity": true,
				"dojo.data.api.Schema": this.schema
			};
		},

		getLabel: function(item){
			// summary:
			//		returns the label for an item. Just gets the "label" attribute.

			return this.getValue(item,this.labelAttribute);
		},

		getLabelAttributes: function(item){
			// summary:
			//		returns an array of attributes that are used to create the label of an item
			return [this.labelAttribute];
		},

		//Identity API Support


		getIdentity: function(item){
			return item.__id;
		},

		getIdentityAttributes: function(item){
			// summary:
			//		returns the attributes which are used to make up the
			//		identity of an item.	Basically returns this.idAttribute

			return [this.idAttribute];
		},

		fetchItemByIdentity: function(args){
			// summary:
			//		fetch an item by its identity, by looking in our index of what we have loaded
			var item = this._index[(args._prefix || '') + args.identity];
			if(item){
				// the item exists in the index
				if(item._loadObject){
					// we have a handle on the item, but it isn't loaded yet, so we need to load it
					args.item = item;
					return this.loadItem(args);
				}else if(args.onItem){
					// it's already loaded, so we can immediately callback
					args.onItem.call(args.scope, item);
				}
			}else{
				// convert the different spellings
				return this.fetch({
						query: args.identity,
						onComplete: args.onItem,
						onError: args.onError,
						scope: args.scope
					}).results;
			}
			return item;
		}

	}
);
});

},
'vodori/tinymce/Validation':function(){
/**
 * A plugin to support validation inside of a TinyMCE box.
 *
 * USAGE:
 * Below is an example to require that the contents of the editor have at least 10 characters.
 * If that validation fails, and alert dialog is displayed with the regex_failure_message
 *
 validation_config: {
                    regex: "[a-zA-Z0-9]{10}", // A regex for a minimum of 10 characters
                    regex_failure_message: "This field is required to have at least 10 characters"
                }


 * NOTES
 * Note that this adds an editor.validation namespace to any editors it's applied to.

 */
define([
    '../amd/tinymce',
    'vodori/provide',
    'module',
    'vodori/tinymce/util/getPluginName'
], function (tinymce, provide, module, getPluginName) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, null, {

        _validationConfig: null,

        init: function (ed) {

            var t = this;

            t.editor = ed;

            // Pull out our table configuration and register our buttons
            if (!t._validationConfig) {
                t._validationConfig = t.editor.getParam('validation_config');
            }


            // Add a validation namespace and validation function if the namespace hasn't been created and
            // a config is present
            if (!ed.validation && t._validationConfig) {
                ed.validation = {

                    validate: function () {

                        // Have we already created and cached our RegExp?
                        if (!t.editor.validation._regex) {
                            t.editor.validation._regex = new RegExp(t._validationConfig.regex, "gim");
                        }

                        // Get and validate the contents against the regex
                        var content = t.editor.getContent();
                        return t.editor.validation._regex.test(content);
                    }
                };
            }

        }

    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'vodori/tinymce/VodoriImage':function(){
define([
    '../amd/tinymce',
    'vodori/provide',
    'module',
    'vodori/tinymce/util/getPluginName',
    'vodori/tinymce/util/getResourceUrl'
], function (tinymce, provide, module, getPluginName, getResourceUrl) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, null, {
        init: function (ed) {
            var url = this.url = getResourceUrl(module);

            // Register commands
            ed.addCommand('mceVodoriImage', function () {
                // Internal image object like a flash placeholder
                if (ed.dom.getAttrib(ed.selection.getNode(), 'class').indexOf('mceItem') !== -1){
                    return;
                }

                ed.windowManager.open({
                    file: url + '/image.htm',
                    width: 480 + parseInt(ed.getLang('vodoriimage.delta_width', 0), 10),
                    height: 385 + parseInt(ed.getLang('vodoriimage.delta_height', 0), 10),
                    inline: 1
                }, {
                    /* jshint -W106 */
                    plugin_url: url
                    /* jshint +W106 */
                });
            });

            // Register buttons
            ed.addButton('image', {
                title: 'vodoriimage.image_desc',
                cmd: 'mceVodoriImage'
            });
        },

        getInfo: function () {
            return {
                longname: 'Vodori image',
                author: 'Vodori Inc.',
                authorurl: 'http://www.vodori.com',
                infourl: 'http://www.vodori.com',
                version: tinymce.majorVersion + '.' + tinymce.minorVersion
            };
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'pepper/library/filter/LibraryFilters':function(){
define([
    './ui/ContentType',
    './ui/LockOwner',
    './ui/StateVersion',
    './ui/TimeEvent',
    './ui/Directory',
    './ui/Category',
    './ui/Tag',
    './ui/Workflow'
],
    function () {
        'use strict';
        return {};
    }
);

},
'pepper/library/filter/ui/ContentType':function(){
define([
    'module',
    'vodori/provide',
    'pepper/library/filter/ui/_LibraryBaseFilterUI',
    'dojo/text!./templates/ContentType.html',
    // Template deps
    'pepper/library/filter/model/OnlyMyStuff'
],
    function (module, provide, _LibraryBaseFilterUI, contenttypeTemplate) {
        /**
         *
         * @class
         */
        var ContentType = {
            title: 'Content Type',
            templateString: contenttypeTemplate
        };

        return provide(module, [_LibraryBaseFilterUI], ContentType);
    }
);

},
'pepper/library/filter/ui/_LibraryBaseFilterUI':function(){
define([
    'module', 'vodori/provide',
    'lodash', 'dojo/_base/lang',
    'dojo/json', 'dojo/dom-class', 'dojo/when',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'vodori/renderTemplate', 'vodori/util/getDijitDescendantsByClass',
    'vodori/filter/FilterUIBox'
],
    function (module, provide,
              _, lang,
              json, domClass, when,
              _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
              renderTemplate, getDijitDescendantsByClass,
              FilterUIBox) {
        /**
         *
         * @class
         */
        var _LibraryBaseFilterUI = {

           /**
            * @property {boolean} Indicate that this filter will include
            *                     ui components used to edit its own values
            */
            readOnly: false,

            /**
             * CSS class to apply when this filter is disabled
             */
            disabledClass: 'filter-disabled',

           /**
            * _WidgetBase Lifecycle method
            */
            postMixInProperties:function () {
                this.inherited(arguments);
                var templateVariables = {
                    title: this.title
                };
                if(this.filterData) {
                    templateVariables.filterData = this.doNotStringifyFilterData ? this.filterData
                                                                                : json.stringify(this.filterData);
                }

                this.templateString = renderTemplate(this.templateString, templateVariables);
            },

            postCreate: function () {
                this.inherited(arguments);
                var filterBoxes = getDijitDescendantsByClass(this.domNode, FilterUIBox);
                var numBoxes = filterBoxes.length;
                if (numBoxes !== 1) {
                    console.error('Too %s FilterUIBoxes (%d) found for %s',
                                    (numBoxes ? 'many' : 'few'),
                                    numBoxes,
                                    this.declaredClass);
                }
                this.filterSource = filterBoxes[0];
                this.applyDisabledClass();
                this.listenForDisabledChange();
            },

            applyDisabledClass: function() {
                this._withFilters(function(filters) {
                    var disabled = filters && filters.length && _.every(filters, function(filter) {
                        return filter.get('disabled') === true;
                    });
                    domClass.toggle(this.domNode, this.disabledClass, disabled);
                });
            },

            listenForDisabledChange: function() {
                this._withFilters(function(filters) {
                    _.forEach(filters, function(filter) {
                        this.own(filter.watch('disabled', lang.hitch(this, 'applyDisabledClass')));
                    }, this);
                });
            },

            /**
             * Call the given function, passing in the list of filters. The context will be this.
             * @param fn function to call
             * @private
             */
            _withFilters: function(fn) {
                if (this.filterSource) {
                    when(this.filterSource.get('filters'), lang.hitch(this, fn));
                }
            }
        };

        return provide(module.id, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], _LibraryBaseFilterUI);
    }
);

},
'vodori/filter/FilterUIBox':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'dojo/_base/lang',
    'dojo/Deferred', 'dojo/promise/all', 'dojo/when',
    'dojo/dom-construct', 'dojo/dom-style', 'dojo/dom-class',
    'dojo/on',
    'vodori/util/node/renderNode',
    'vodori/filter/model/_FilterBase', 'vodori/filter/model/_CompositeFilter',
    'dojo/text!./templates/FilterUIBox.html', 'dojo/text!./templates/summaryPane.html',

    /* Unreferenced MIDs */
    'dijit/TitlePane', 'vodori/ui/Button', 'vodori/input/GroupedSelect'

], function (module, provide,
             _,
             _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
             lang,
             Deferred, all, when,
             domConstruct, domStyle, domClass,
             on,
             renderNode,
             _FilterBase, CompositeFilter,
             template, summaryPaneTemplate) {

    /**
     *
     * @class
     */
    var _FilterUIBox = {

        /**
         * If true the box exposes only a single composite filter that pulls together the other filters. (Defaults to
         * false)
         */
        asComposite: false,
        /**
         * If true automatically detect and add filter widgets within this box. (Defaults to true)
         */
        scanChildWidgetsForFilters: true,

        templateString: template,

        manualBuild: false,

        showSummaryWhenOpen: false,

        paneOpen: true,

        paddingOption: 'use-padding',

        /*
         * Necessary to prevent the internal widgets of this module from being instantiated, whenever *this*
         * module is created via declarative instantiation.
         */
        stopParser: true,

        constructor: function () {
            this._filtersDeferred = new Deferred();
            this._filterList = [];
            this.clearButtonIsVisible = false;
        },

        /**
         * @param {Array.<filterModel>} value
         */
        _setFiltersAttr: function(value) {
            if (this._started) {
                throw new Error('filters cannot be set after startup.');
            } else {
                this._filterList = value;
            }
        },

        _getFiltersAttr: function() {
            return this._filtersDeferred.promise;
        },

        /**
         * _WidgetBase Lifecycle method
         */
        buildRendering: function () {
            this.inherited(arguments);

            /*
             * Add the appropriate class to the summary pane to keep it open at all times
             * if the user has requested it
             */
            domClass.toggle(this.summaryPane, 'alwaysShowSummary', this.showSummaryWhenOpen);

            if (this.titlePane && this.clearBtn) {
                // Move the clear button into the TitlePane's title so we can clear collapsed filters.
                this.clearBtn.placeAt(this.titlePane.focusNode);
                this.own(on(this.clearBtn, 'click', lang.hitch(this, function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    this.clearAll();
                })));
            }
        },

        /**
         * _WidgetBase Lifecycle method
         */
        startup: function () {
            if (!this._started) {
                var _composite;
                if (this.asComposite) {
                    _composite = new CompositeFilter({
                        autoUpdate: this.autoUpdate
                    });
                    this._filterList.push(_composite);
                }
                if (this.scanChildWidgetsForFilters) {
                    this._scanChildWidgetsForFilters(_composite);
                } else {
                    this._filtersDeferred.resolve(this._filterList);
                }

                this.get('filters').then(lang.hitch(this, function (filters) {
                    _.forEach(filters, function (filter) {
                        this.own(filter.watch('query', lang.hitch(this, '_updateUIBox')));
                    }, this);
                }));

                this.own(this.titlePane.watch('open', lang.hitch(this, function (attr, oldValue, newValue) {
                    domClass.toggle(this.summaryPane, 'parentPaneClosed', !newValue);
                })));
            }
            this.inherited(arguments);
        },

        _scanChildWidgetsForFilters: function(compositeFilter) {
            var childWidgets = this.titlePane.getChildren();
            var promises = [];
            _.forEach(childWidgets, lang.hitch(this,
                function (widget) {
                    var widgetFilter = widget.get('filter');
                    var p = when(widgetFilter, lang.hitch(this, function (filter) {
                        if (filter && filter.isInstanceOf && filter.isInstanceOf(_FilterBase)) {
                            if (compositeFilter) {
                                compositeFilter.addFilter(filter);
                            } else {
                                this._filterList.push(filter);
                            }
                        }
                    }));
                    if (p) {
                        promises.push(p);
                    }
                }));
            var promiseList = all(promises);
            promiseList.then(lang.hitch(this, function () {
                this._filtersDeferred.resolve(this._filterList);
            }));
        },

        _toggleClearButton: function (enabled) {
            var clearBtn = this.clearBtn;
            this.set('clearButtonIsVisible', enabled);
            clearBtn.set('disabled', !enabled);
            domStyle.set(clearBtn.domNode, 'display', enabled ? '' : 'none');
        },

        _updateUIBox: function () {
            var summary = {
                defaultSelections: true,
                summaryTexts: []
            };

            this._performForAllFilters(lang.hitch(this, 'summarizer', summary))
                .then(lang.hitch(this, function () {
                    this._toggleClearButton(!summary.defaultSelections);
                    var summaryPane = this.summaryPane;
                    domConstruct.empty(summaryPane);
                    domClass.toggle(summaryPane, 'containsSummary', summary.summaryTexts.length > 0);

                    _.forEach(summary.summaryTexts, function (summaryText) {
                        var summaryNode = renderNode(summaryPaneTemplate, summaryText);
                        this.own(on(summaryNode, '.summary-delete-handle:click', function (e) {
                            summaryText.deselector(e.target.getAttribute('data-filter-deselect-target'));
                        }));

                        domConstruct.place(summaryNode, summaryPane);
                    }, this);
                }));
        },

        summarizer: function (summary, filter) {
            var summaryText = filter.get('summaryText');
            if (summaryText) {
                summary.summaryTexts.push({
                    deselector: lang.hitch(filter, 'deselect'),
                    title: filter.get('title') || '',
                    summaries: summaryText
                });
            }
            summary.defaultSelections = summary.defaultSelections && filter.isDefaultSelected();
        },

        /**
         * Clear all of the filters in this FilterUIBox
         */
        clearAll: function () {
            this._performForAllFilters(function (filter) {
                filter.reset();
            });
        },

        _performForAllFilters: function (fn) {
            return when(this._filtersDeferred, lang.hitch(this, function (filters) {
                _.forEach(filters, fn);
            }));
        },

        _setPaneOpenAttr: function (isOpen) {
            this.paneOpen = isOpen;

            this.titlePane.set('open', isOpen);
        }
    };

    return provide(module.id, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], _FilterUIBox);
});

},
'vodori/util/node/renderNode':function(){
define([
    './htmlToElement',
    'vodori/renderTemplate'
], function (htmlToElement, renderTemplate) {
    /**
     * Provides a domNode from an HTML template, which may or may not be parsed.
     * @name vodori.util.node.renderNode
     * @function
     * @param {String} template
     * @param {Object} view
     * @param {boolean} parse
     * @param {Object.<string>} partials
     * @param {Function} streamOutput
     * @returns {Node}
     */
    return function (template, view, parse, partials, streamOutput) {
        // Let mustache do its thing.
        var html = renderTemplate(template, view, partials, streamOutput);

        return htmlToElement(html, parse);
    };
});

},
'vodori/filter/model/_FilterBase':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/Deferred', 'dojo/Evented',
    'dojo/json', 'dojo/Stateful',
    'vodori/util/collections/mapAndFilter', 'vodori/util/collections/equivalent',
    'vodori/util/debug/console',
    './FilterType'
], function (module, provide,
             _,
             lang,
             Deferred, Evented,
             json, Stateful,
             mapAndFilter, equivalent,
             console,
             FilterType) {

    'use strict';
    /* jshint -W030 */
    /* jshint -W024 */

    var NULL_SELECTION = '__NULL_SELECTION__';

    /**
     * The base mixin for all filter models
     *
     * A filter model represents a filter or search query that can be applied to a data set. It's a complete
     * abstraction and is not tied to the actual search mechanism. It merely represents some 'key' and the 'values'
     * that can be associated with that key.
     *
     * A filter model <b>does not</b> contain any UI information.
     *
     * All properties of a filter model should be accessed using the dojo/Stateful paradigm of
     * <code>
     *     #get('propertyName')
     *     #set('propertyName', propertyValue)
     * </code>
     *
     * In addition, all public properties can be watched using
     * <code>
     *     #watch("propertyValue")
     * </code>
     *
     * Details of the get/set/watch paradigm can be found in the documentation for dojo/Stateful.
     *
     * The filter defines a <i>key</i>, which is, essentially, a property that is being filtered.
     * In addition, a series of <i>label</i>s and <i>value</i>s are also defined. A value is something that can
     * be assigned to the key according to the <i>filterType</i>.
     *
     * @mixin
     */
    var _FilterBase = {
        /**
         * @property {vodori/filter/model/FilterType} The type of filter
         */
        filterType: FilterType.UNKNOWN,

        /**
         * @property {string} Text that summarizes the current filter state
         */
        summaryText: '',

        /**
         * @property {string} Provides means to associate text w/ a filter model.
         */
        title: '',

        /**
         * @property {string} The key of the filter query
         */
        key: '',

        /**
         * @property {boolean} Indicate that this model will include the dummy entry
         *                     used to create new real model entries
         */
        notNull: true,

        /**
         * @property {boolean} Indicate that this filter will allow
         *                     for editing its own values
         */
        readOnly: false,

        /**
         * @property {boolean} If true, this filter will be ignored by the filter manager (defaults to false)
         */
        disabled: false,

        /**
         * The configuration for this filter model
         *
         * A series of labels
         *
         * @property {Object} The configuration of this filter.
         * {
         *   label: {
         *           value:   {string|Function},
         *           order:   {integer},
         *           isDefault: {boolean},
         *           summaryText: {string|Function|undefined}
         *       },
         *   ...
         * }
         *
         */
        //filterConfig: {},

        /**
         *
         * @property {Array.<string>} The currently selected labels
         */
        selectedLabels: null,

        /**
         * @property {Array.<string>} The default labels
         * Note: Any labels with isDefault=true will be appended to this list.
         */
        defaultLabels: null,

        /**
         * Used to keep track of the initial value of defaultLabels. This is needed again if/when the config is updated
         * and the defaultLabels need to be recalculated.
         * @private
         */
        _originalDefaultLabels: null,

        /**
         * Used to indicate that the filter is being reset (so that the query should be updated, no matter what
         */
        _resetting: false,

        /**
         * Used to indicate that the filter can potentially emit events.library.filters.requiresRebuild
         */
        emitsRebuild: false,

        /**
         * NOTE: the filter selection is reset during the _processConfig
         *
         * @param payload
         * @param readOnly
         */
        constructor: function (payload, readOnly) {
            this.readOnly = readOnly;
            this._defaultIsSelected = false;
            this._processingComplete = new Deferred();
            this.query = {};
            this._analyzeQuery = true;
            this.selectedLabels = this.selectedLabels ? _.clone(this.selectedLabels) : [];
            this.filterConfig = this.filterConfig ? _.clone(this.filterConfig) : {};

            /*
             * In order to support external calls to set('query',...), we need to be able to detect mapped
             * labels, i.e. labels which map to something other than their literal value.
             */
            this._valueMapper = {};

            this._processPayload(payload);
            this._originalDefaultLabels = this.defaultLabels;

            this._processConfig();
            this._processingComplete.resolve(true);
        },

        /*
         * Filters can take in arbitrary payloads (such as data from an external source).
         * By overriding this method, they can convert the payload to a valid filterConfig
         */
        _processPayload: function (payload) {
            if (payload) {
                console.warn('Received payload %o, but have no method to handle it', payload);
            }
        },

        /**
         * Called after a filter has been rebuilt, override if post rebuild logic is required
         */
        afterRebuild: function() {
        },

        /*
         * By supplying a label mapping function, a filter can support different input labels and map
         * them on to any number of internal labels.
         */
        _labelMapper: function (label) {
            return label;
        },

        /*

         */
        _processConfig: function () {
            this.defaultLabels = this._originalDefaultLabels ? _.clone(this._originalDefaultLabels) : [];
            var sortable = [];

            _.forOwn(this.filterConfig, function(label, labelName) {
                var order = label.order;
                if (typeof order === 'undefined') {
                    order = Number.MAX_VALUE;
                }
                sortable.push([labelName, order]);

                if (label.isDefault) {
                    this.defaultLabels.push(labelName);
                }
            }, this);
            sortable.sort(function (a, b) {
                return a[1] - b[1];
            });

            this.labels = mapAndFilter(sortable, function (item) {
                return item[0];
            });
            _.forEach(this.labels, lang.hitch(this, function (label) {
                var val = this._getValueForLabel(label);
                if (!lang.isArray(val)) {
                    val = [val];
                } else {
                    val.sort();
                }
                this._valueMapper[json.stringify(val)] = label;
            }));

            this.reset();
        },

        /*
         * Builds a query object, based on the currently selected labels and the filter type.
         *
         * NB: THIS METHOD AND ANY THAT OVERRIDE IT SHOULD **NEVER** MODIFY THE FILTER STATE!
         */
        _buildQuery: function () {
            var query = {};
            var filterType = this.filterType;
            var firstSelection = lang.isArray(this.selectedLabels) ? this.selectedLabels[0] : this.selectedLabels;
            var value = null;

            if (filterType === FilterType.BINARY) {
                query[this.key] = !!firstSelection;
            } else if (filterType === FilterType.ONE_OF_MANY) {
                value = this._getValueForLabel(firstSelection);
                if (value === null && this.notNull) {
                    value = [];
                }
                if (this.asString) {
                    value = lang.isArray(value) ? value.join(',') : value;
                } else {
                    value = lang.isArray(value) ? value : [value];
                }
                query[this.key] = value;
            } else if (filterType === FilterType.MANY_OF_MANY) {
                // Return a copy of the selectedLabels to avoid modification
                query[this.key] = _.map(this.selectedLabels, lang.hitch(this, '_getValueForLabel'));
            } else if (filterType === FilterType.FREEFORM) {
                query[this.key] = (typeof firstSelection !== 'undefined') ? firstSelection : this.defaultValue;
            } else {
                console.error('Unknown Filter Type: %s', this.filterType);
                return undefined;
            }
            return query;
        },

        _processingCompleteGetter: function () {
            return this._processingComplete.promise;
        },

        /**
         * @private
         */
        _labelsSetter: function () {
            console.error('Do not call set("labels") directly');
        },

        /**
         * @private
         */
        _labelsGetter: function () {
            return this.labels.slice(0);
        },

        _configSetter: function (config) {
            this.filterConfig = config;
            this._processConfig();
        },

        /**
         * @param {string} label
         * @return {(string|number)}
         *
         * @private
         */
        _getValueForLabel: function (label) {
            if (typeof label === 'undefined' || label === NULL_SELECTION) {
                return null;
            }

            var config = this.filterConfig[label];

            // If the config is a string, then it's also the value.
            if (typeof config === 'string') {
                return config;
            }
            // If it's a function, then it's a value getter.
            else if (typeof config.value === 'function') {
                return config.value.call(this, label);
            }
            // The non-lazy case; maybe this should be first, but easier to read in last position.
            else {
                return config.value;
            }
        },

        /**
         * Given a query value, maps it back to the appropriate label, suitable for a call to select();
         *
         * If a falsy value is given, the default labels of the filter is returned.
         *
         * @param {*} val A query value or array of query values.
         * @return {Array.<string>} The appropriate label or labels, such that .select(<returned value>), followed by
         *         .get('query') will return 'val'
         * @private
         */
        _getLabelsForValues: function (val) {

            // null values on the query are equivalent to the default values.
            if (!val) {
                return this.defaultLabels;
            }

            if (this.filterType !== FilterType.ONE_OF_MANY && this.filterType !== FilterType.MANY_OF_MANY) {
                return val;
            }

            if (!_.isArray(val)) {
                val = [val];
            }

            var labels = _.map(val, function(value) {
                return _.findKey(this.filterConfig, function(labelConfig) {
                    return labelConfig.value === value;
                });
            }, this);
            return _.filter(labels);
        },

        /**
         * @private
         */
        _getSummaryTextForLabel: function (label) {
            var configElement = this.filterConfig[label];
            if (typeof configElement === 'undefined') {
                return;
            }
            if (!configElement.hasOwnProperty('summaryText')) {
                return label;
            }
            var rawText = configElement.summaryText;
            if (typeof rawText === 'function') {
                return rawText.call(this, label);
            } else {
                return rawText;
            }
        },

        /**
         *
         * @param labels
         * @returns {Array}
         * @private
         */
        _normalizeLabels: function (labels) {
            if (labels && ((!(labels instanceof Array) && labels === NULL_SELECTION) ||
                (labels.length === 1 && labels[0] === NULL_SELECTION))) {
                this.selectedLabels = [];
                labels = [];
            }
            /*
             * This is to detect whether the user has requested a set of labels in a One Of Many filter that
             * corresponds to an actual single selection that, itself, maps onto multiple choices.
             * An example:
             *   If the choices where Any, Foo, Bar & Baz, where 'Any' mapped on to ['Foo', 'Bar', 'Baz'], then
             *   calling filter.select(['Foo', 'Bar', 'Baz']) should be aliased on to a call to
             *   filter.select('Any')
             *
             */
            var selectedLabelCount;
            if (typeof labels === 'undefined') {
                selectedLabelCount = 0;
            } else if (labels instanceof Array) {
                selectedLabelCount = labels.length;
            } else {
                selectedLabelCount = 1;
            }
            if (this.filterType === FilterType.ONE_OF_MANY) {
                if ((selectedLabelCount > 1)) {
                    labels = _.map(labels.sort(), lang.hitch(this, '_getValueForLabel'));
                    var valString = json.stringify(labels);
                    if (valString in this._valueMapper) {
                        labels = this._valueMapper[valString];
                    } else {
                        console.error('Multiple labels selected for a One Of Many Filter: %o', labels);
                        throw 'Invalid selection for one-of-many filter';
                    }
                }
            }

            /*
             * Guarantee that the rest of the code in this method is dealing with an array
             */
            if (!(labels instanceof Array)) {
                labels = [labels];
            }
            return labels;
        },

        /**
         *
         * @param selection
         */
        select: function (selection) {
            var labels = this._normalizeLabels(selection);

            _.forEach(labels, lang.hitch(this, function (label) {
                label = this._labelMapper(label);
                if (this.filterType !== FilterType.FREEFORM) {
                    if (_.indexOf(this.labels, label) === -1) {
                        console.error('Selected value "%s" is not recognised', label);
                        return;
                    }
                }

                if (this.filterType === FilterType.MANY_OF_MANY) {
                    if (_.indexOf(this.selectedLabels, label) === -1) {
                        this.selectedLabels.push(label);
                    }
                } else {
                    this.selectedLabels = [label];
                }
            }));

            this._updateDefaultIsSelected();
            var newQuery = this._buildQuery();
            if (!_.isEqual(newQuery, this.get('query')) || this._resetting) {
                this._setQueryInternally(newQuery);
            }
        },

        /**
         * @private
         */
        _selectedLabelsSetter: function (newSelection) {
            if (!newSelection) {
                newSelection = [];
            }
            this.selectedLabels = [];
            this.select(newSelection);
        },

        /**
         * Implementation of #get("selectedLabels")
         *
         * Makes sure that we return a <i>copy</i> of the selectedLabels list, and not the <i>actual</i> list
         *
         * @private
         */
        _selectedLabelsGetter: function () {
            return this.selectedLabels.slice(0);
        },

        _disabledSetter: function(value) {
            this.disabled = value;

            if(value) {
                this.reset();
            }
        },

        _querySetter: function (query) {
            if (!(this.key in query)) {
                console.warn('This query (%o) contains nothing that matches this filter\'s key: %s ', query, this.key);
                return;
            }
            this.query = query;
            if (this._analyzeQuery) {
                var newValue = query[this.key];
                this.set('selectedLabels', this._getLabelsForValues(newValue));
            }
            this._analyzeQuery = true;
        },

        _setQueryInternally: function (query) {
            this._analyzeQuery = false;
            this.set('query', query);
        },

        _updateDefaultIsSelected: function () {
            this._defaultIsSelected = equivalent(this.selectedLabels, this.defaultLabels);
        }, /**
         *
         * @param label
         */
        deselect: function (label) {
            label = this._labelMapper(label);
            var labelIndex = _.indexOf(this.selectedLabels, label);
            if (labelIndex < 0) {
                console.warn('The value "%s" was not selected, so deselect did nothing', label);
            } else {
                this.selectedLabels.splice(labelIndex, 1);
                this.selectedLabels = _.filter(this.selectedLabels, function (item) {
                    return typeof item !== 'undefined';
                });
                if (this.filterType === FilterType.ONE_OF_MANY) {
                    if (this.selectedLabels.length === 0) {
                        this.selectedLabels = this.defaultLabels.slice(0);
                    }
                }
                this._updateDefaultIsSelected();
                this._setQueryInternally(this._buildQuery());
            }
        },

        /**
         * Resets the filter selection to the default.
         *
         * NB: This will result a setting of the query, regardless of whether the query, ultimately, changes
         */
        reset: function () {
            this._resetting = true;
            this.set('selectedLabels', this.defaultLabels);
            this._resetting = false;
            this.emit('reset', {});
        },

        /**
         * Clears the selection so that *nothing* is selected.
         *
         * This is different to resetting the Filter, since that sets the selection to the default
         */
        clearSelection: function() {
            this.set('selectedLabels', []);
        },

        /**
         *
         * @return {boolean} true if the current selection is the default selection
         */
        isDefaultSelected: function () {
            return this._defaultIsSelected;
        },

        /**
         * Implementation of #get("summaryText")
         *
         * @private
         */
        _summaryTextGetter: function () {
            var summaries = mapAndFilter(
                this.selectedLabels,
                lang.hitch(this, function (label) {
                    var summary = this._getSummaryTextForLabel(label);
                    if (summary) {
                        return {
                            text: summary,
                            label: label
                        };
                    } else {
                        return undefined;
                    }
                }),
                function (summary) {
                    return typeof summary !== 'undefined';
                }
            );

            if (summaries.length === 0) {
                return undefined;
            } else {
                return summaries;
            }
        },

        /**
         * Returns a list of all of the values that this filter represents, except for the first.
         * Generally, this would be used for generic 'Any' filter lables
         * @return {*}
         * @private
         */
        _getAllButFirstFilterValue: function () {
            return _.map(this.get('labels').slice(1), lang.hitch(this, '_getValueForLabel'));
        }

    };

    return provide(module.id, [Stateful, Evented], _FilterBase, {
        NULL_SELECTION: NULL_SELECTION
    });
});

},
'vodori/util/collections/equivalent':function(){
/**
 * @module vodori/util/collections/equivalent
 */
define([
    'lodash'
], function (_) {

    /**
     * Determines whether two arrays are equivalent, i.e. every item in one array is in the other array (and vice versa)
     *
     * @name vodori/util/collections/equivalent
     * @function
     * @param {Array} array1 A list
     * @param {Array} array2 A list
     * @return {boolean} True, if `array1` and `array2` contain the same items, regardless of order
     */
    return function (array1, array2) {
        var clone;
        if(!_.isArray(array1) || !_.isArray(array2)) {
            return false;
        }
        if(array1.length !== array2.length) {
            return false;
        }

        clone = array2.slice();
        return _.every(array1, function(item) {
            var location = _.indexOf(clone, item);
            if (location >= 0) {
                clone.splice(location, 1);
            }
            return (location >= 0);
        });
    };
});

},
'vodori/util/debug/console':function(){
define(['dojo/has', 'dojo/_base/lang', 'dojo/_base/window'], function (has, lang, win) {
    var global = win.global;

    has.add('console', function () {
        return !!global.console;
    });

    var _print = function (precedeWith) {
        return lang.partial(global.print, precedeWith);
    };

    return has('console') ? global.console : {
        log: _print('log:'),

        warn: _print('!warn:'),

        error: _print('!!!error:')
    };
});
},
'vodori/filter/model/FilterType':function(){
/**
 * @module vodori/filter/model/FilterType
 */
define(['vodori/util/Enum'], function (Enum) {
    'use strict';

    /**
     * @alias module:vodori/filter/model/FilterType
     * @readonly
     * @enum {number}
     *
     * The various types of filter that can exist:
     * - UNKNOWN        - An unknown FilterType.
     *    This means that none of the supporting code will know what to do with it
     * - BINARY         - A filter that can be in one of two states.
     *    Generally true/false, checked/unchecked, selected/unselected
     * - ONE_OF_MANY    - A filter that allows the selection of a single item from a list
     * - MANY_OF_MANY   - A filter that allows the selection of zero or more items from a list
     * - FREEFORM       - A filter that allows the selection of some arbitrary value from a list
     */
    var FilterType = new Enum('UNKNOWN', 'BINARY', 'ONE_OF_MANY', 'MANY_OF_MANY', 'FREEFORM');
    return FilterType;
});
},
'vodori/filter/model/_CompositeFilter':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    './_FilterBase'
],
    function (module, provide, _, lang, _FilterBase) {
        'use strict';

        /**
         * @mixin
         */
        var _CompositeFilter = {

            filters: [],

            autoUpdate: false,

            constructor: function () {
                this.query = {};
                this._defaultIsSelected = true;

            },

            _buildQuery: function () {
                var query = {};
                var defaultIsSelected = true;
                _.forEach(this.filters, lang.hitch(this, function (filter) {
                    lang.mixin(query, filter.get('query'));
                    defaultIsSelected = defaultIsSelected && filter.isDefaultSelected();
                }));

                this._defaultIsSelected = defaultIsSelected;

                return query;
            },

            _queryGetter: function () {
                if (this.autoUpdate) {
                    this.query = this._buildQuery();
                }
                return this.query;
            },

            _querySetter: function (query) {
                this.query = query;
                if (this._analyzeQuery) {
                    _.forEach(this.filters, lang.hitch(this, function (filter) {
                        filter.set('query', query);
                    }));
                    this.query = this._buildQuery();
                }
                this._analyzeQuery = true;
            },

            addFilter: function (filter) {
                this.filters.push(filter);
                this.query[filter.get('key')] = undefined;
            },

            reset: function () {
                _.forEach(this.filters, lang.hitch(this, function (filter) {
                    filter.reset();
                }));
                this._setQueryInternally(this._buildQuery());
            },

            update: function () {
                this._setQueryInternally(this._buildQuery());
            }
        };

        return provide(module.id, [_FilterBase], _CompositeFilter);
    }
);

},
'pepper/library/filter/model/OnlyMyStuff':function(){
define([
    'dojo/_base/declare',
    'dojo/_base/lang',
    'vodori/filter/model/_FilterBase', 'vodori/filter/model/FilterType'

],
    function (declare, lang, _FilterBase, FilterType) {
        'use strict';

        var OnlyMyStuff = {

            title: '',

            filterType: FilterType.BINARY,

            key: 'mine',

            filterConfig: {
                'Only show my stuff': {
                    value: 'myStuff',
                    order: 0
                }
            }
        };

        return declare([_FilterBase], OnlyMyStuff);
    }
);

},
'pepper/library/filter/ui/LockOwner':function(){
define([
    'module',
    'vodori/provide',
    'pepper/library/filter/ui/_LibraryBaseFilterUI',
    'dojo/text!./templates/LockOwner.html'
],
    function (module, provide, _LibraryBaseFilterUI, lockownerTemplate) {
        /**
         *
         * @class
         */
        var LockOwner = {
            title: 'Lock Owner',
            templateString: lockownerTemplate
        };

        return provide(module.id, [_LibraryBaseFilterUI], LockOwner);
    }
);

},
'pepper/library/filter/ui/StateVersion':function(){
define([
    'module',
    'vodori/provide',
    'dojo/_base/lang',
    'pepper/library/filter/ui/_LibraryBaseFilterUI',
    'dojo/text!./templates/StateVersion.html'
],
    function (module, provide, lang, _LibraryBaseFilterUI, StateVersionTemplate) {
        /**
         *
         * @class
         */
        var StateVersion = {
            /* attach points */
            allVersionFilter: null,
            stateFilter: null,
            stateFilterTargetType: null,

            title: 'State/Version',
            templateString: StateVersionTemplate,

            postCreate: function() {
                this.allVersionFilter.on('select', lang.hitch(this, '_handleAllVersionToggle'));

                this.inherited(arguments);
            },

            _handleAllVersionToggle: function(event) {
                var value = event.value;

                if(this.stateFilter.filterWidget) {
                    this.stateFilter.filterWidget.set('disabled', value.allVersions === true);
                }

                if(this.stateFilterTargetType.filterWidget){
                    this.stateFilterTargetType.filterWidget.set('disabled', value.allVersions === true);
                }
            }
        };

        return provide(module.id, [_LibraryBaseFilterUI], StateVersion);
    }
);

},
'pepper/library/filter/ui/TimeEvent':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/Deferred', 'dojo/_base/lang',
    'dojo/on', 'dojo/DeferredList',
    'vodori/util/collections/mapAndFilter',
    'pepper/library/filter/ui/_LibraryBaseFilterUI', 'pepper/ui/handleNotification',
    'dojo/text!./templates/TimeEvent.html'
],
    function (module, provide,
              _,
              Deferred, lang,
              on, DeferredList,
              mapAndFilter,
              _LibraryBaseFilterUI, handleNotification,
              timeeventTemplate) {
        /**
         *
         * @class
         */
        var TimeEvent = {
            templateString: timeeventTemplate,

            constructor: function () {
                this._deferredFilters = new Deferred();

                this._deferredFilters.then(lang.hitch(this, function (filters) {
                    var filterBox = this.filterBox;

                    this.filterBox.set('summarizer', function (summary) {
                        console.log('Event Summary');
                        summary.defaultSelections = _.every(filters, function (filter) {
                            return filter.isDefaultSelected();
                        });
                        if (!summary.defaultSelections) {
                            var texts = mapAndFilter(filters,
                                function (filter) {
                                    var f = filter.get('summaryText');
                                    return f ? f[0].text : undefined;
                                },
                                function (filter) {
                                    return typeof filter !== 'undefined';
                                });
                            if (texts.length === 3) {
                                var summaryText = texts[0] + ' ' + texts[2] + ' ' + texts[1];
                                summary.summaryTexts.push(
                                    {
                                        deselector: lang.hitch(filterBox, 'clearAll'),
                                        title: 'time & event',
                                        summaries: [
                                            {text: summaryText, label: summaryText}
                                        ]
                                    }
                                );
                            }
                        }
                    });
                }));
            },

            /**
             * _WidgetBase Lifecycle method
             */
            startup: function () {
                this.inherited(arguments);

                var deferredFilterList = new DeferredList(
                    [
                        this.eventType.get('filter'),
                        this.eventDate.get('filter'),
                        this.eventOccurrence.get('filter')
                    ]
                );

                deferredFilterList.then(lang.hitch(this, function (filters) {
                    this._deferredFilters.resolve(
                        _.map(filters, function (filterInfo) {
                            return filterInfo[1];
                        })
                    );
                }));

                this.applyButton.set('disabled', true);
                on(this.applyButton, 'click', lang.hitch(this, function () {

                    this._deferredFilters.then(lang.hitch(this, function (filters) {
                        var allSet = _.every(filters, function (filter) {
                            return filter.get('query')[filter.get('key')];
                        });
                        if (allSet) {
                            this.composite.update();
                        } else {
                            handleNotification(
                                {
                                    title: 'Unable to apply filter',
                                    message: 'Please select all options in the Time & Event filter to continue',
                                    expireAfter: 6000
                                }
                            );
                        }
                    }));

                }));

                this.filterBox.get('filters').then(lang.hitch(this, function (filters) {
                    if (filters.length !== 1) {
                        console.error('Unexpected number of filters in TimeEvent FitlerUIBox: %d', filters.length);
                        return;
                    }
                    this.composite = filters[0];
                    this.applyButton.set('disabled', false);
                }));
            }


        };

        return provide(module.id, [_LibraryBaseFilterUI], TimeEvent);
    }
);

},
'pepper/library/filter/ui/Directory':function(){
define([
    'module',
    'vodori/provide',
    'pepper/library/filter/ui/_LibraryTreeFilterUI',
    'dojo/text!./templates/Directory.html'
],
    function (
        module,
        provide,
        _LibraryTreeFilterUI,
        directoryTemplate) {

        /**
         * @class pepper/library/filter/ui/Directory
         * @extends pepper/library/filter/ui/_LibraryTreeFilterUI
         */
        return provide(module.id, [_LibraryTreeFilterUI],
            /**
             * @lends pepper/library/filter/ui/Directory.prototype
             */
            {

                title: 'URL Path',
                templateString: directoryTemplate,
                folderType: 'uri',
                folderName: 'URI',
                createCommand: 'showCreateURI',
                dndName: 'directory',
                menuItems: ['GET_INFO', 'EXPAND_FOLDER', '|', 'CREATE', 'IMPORT', '|', 'CREATE_FOLDER', 'DELETE'],

                postMixInProperties:function () {
                    this.filterData = { channelId: this.channelId };

                    this.inherited(arguments);
                }

            });
    }
);

},
'pepper/library/filter/ui/_LibraryTreeFilterUI':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/topic',
    'pepper/commands', 'pepper/events',
    'pepper/library/filter/ui/_LibraryBaseFilterUI',
    'pepper/library/filter/menu/TreeFilterMenu',
    './gridMixins/TreeSelectionFactory'
],
    function (module, provide,
              _,
              lang,
              topic,
              commands, events,
              _LibraryBaseFilterUI,
              TreeFilterMenu,
              TreeSelectionFactory) {
        /**
         *
         * @class
         */
        var _LibraryTreeFilterUI = {
            title: '',
            templateString: '',
            /* jshint -W106 */
            folder_type: '',
            /* jshint +W106 */
            MenuConstructor: TreeFilterMenu,

            buildRendering: function () {
                this.inherited(arguments);

                this.treeWidget.readOnly = this.readOnly;
            },

            postCreate: function () {
                this.inherited(arguments);
                var contextMenu = new this.MenuConstructor(
                    {
                        treeWidget: this.treeWidget,
                        items: this.menuItems,
                        itemsConfig: {
                            folderType: this.folderType,
                            folderName: this.folderName,
                            createCommand: this.createCommand
                        }
                    }
                );
                var folderEvents = events.folders[this.folderType];
                topic.subscribe(folderEvents.created, lang.hitch(this, '_refreshTree'));
                topic.subscribe(folderEvents.changed, lang.hitch(this, '_refreshTree'));
                topic.subscribe(folderEvents.deleted, lang.hitch(this, '_refreshTree'));
                this.treeWidget.set('contextMenu', contextMenu);
                this.treeWidget.set('dndName', this.dndName);

                var createDialog = commands.dialogs[this.createCommand];
                if (!_.isUndefined(createDialog)) {
                    this.treeWidget.mixins.push(TreeSelectionFactory.build(createDialog));
                }
            },

            startup: function () {
                this.inherited(arguments);

                this.treeWidget.addSelectHandler(lang.hitch(this, function (filter, event) {
                    var selected = _.keys(_.omit(event.grid.selection, 'undefined')).shift();
                    if (!!selected) {
                        filter.select(selected);
                    }
                    else {
                        filter.reset();
                    }
                }));

                this.treeWidget.addFilterQueryWatcher(lang.hitch(this, function (filter, query, oldValue, newValue) {
                    var objId = filter.get('selectedLabels')[0];

                    // only set the selection if it has changed.
                    if (!_.isEqual(oldValue, newValue)) {
                        if (objId) {
                            this.treeWidget.tree.set('selectedItems', [
                                {objectId: objId}
                            ]);
                        } else {
                            this.treeWidget.tree.clearSelection();
                        }
                    }
                }));
            },

            _refreshTree: function () {
                this.treeWidget.tree.refresh();
            }
        };

        return provide(module, [_LibraryBaseFilterUI], _LibraryTreeFilterUI);
    }
);

},
'pepper/library/filter/menu/TreeFilterMenu':function(){
/**
 * Defines the menu that is available for an item in a _TreeFilterBase
 */
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/topic',
    'vodori/util/collections/deepMixin',
    'pepper/commands', 'pepper/events',
    'pepper/ui/_PepperServiceMenu'
], function (module, provide, _, lang, topic, deepMixin, commands, events, _PepperServiceMenu) {

    var BASE_ITEMS = {
        GET_INFO: {
            label: 'Info',
            commandName: 'GET_INFO',
            command: commands.dialogs.showFolderInfo,
            concatDefaultArgs: true,
            args: undefined // defined in postMixInProperties
        },
        EXPAND_FOLDER: {
            label: 'Expand',
            commandName: 'EXPAND_FOLDER',
            command: undefined, // defined in postMixInProperties
            args: []
        },
        CREATE: {
            label: 'Create',
            commandName: 'CREATE',
            command: commands.dialogs.showCreate,
            args: []
        },
        IMPORT: {
            label: 'Import',
            commandName: 'IMPORT',
            command: commands.dialogs.showImportPepperDoc,
            args: []
        },
        CREATE_FOLDER: {
            label: 'New',
            commandName: 'CREATE_FOLDER',
            command: undefined, // gets defined in postMixInProperties
            args: []
        },
        DELETE: {
            label: 'Delete',
            commandName: 'DELETE',
            command: commands.actions.deleteFolder,
            concatDefaultArgs: true,
            args: undefined // gets defined in postMixInProperties
        },
        '|': {}
    };

    /**
     * @class pepper/library/filter/menu/TreeFilterMenu
     * @mixes pepper/ui/_PepperServiceMenu
     */
    return provide(module.id, [ _PepperServiceMenu ],
        /**
         * @lends pepper/library/filter/menu/TreeFilterMenu#
         */
        {

            // These 3 properties are required in order for the menu to work properly
            items: [],                              // the menu items
            itemsConfig: {},                        // configuration info for menu items
            object: null,                           // the object for the row this menu is attached to
            treeWidget: null,                       // reference to the filter's treeWidget

            _deleteEvent: null,                     // the event to publish after choosing to delete a folder

            postMixInProperties: function () {
                /*
                 * Process this.items for references to BASE_ITEMS
                 */
                this._deleteEvent = events.folders[this.itemsConfig.folderType].deleted;

                var _BASE_ITEMS_COPY = deepMixin({}, BASE_ITEMS, {
                    GET_INFO: {
                        args: [ this.itemsConfig.folderName ]
                    },
                    EXPAND_FOLDER: {
                        command: lang.hitch(this, 'expandRow')
                    },
                    CREATE_FOLDER: {
                        command: commands.dialogs[this.itemsConfig.createCommand]
                    },
                    DELETE: {
                        args: [ lang.hitch(this, '_deleteCallback') ]
                    }
                });

                this.items = _.map(this.items, function (item) {
                    if (lang.isObject(item)) {
                        return item;
                    } else if (lang.isString(item)) {
                        if (_BASE_ITEMS_COPY[item]) {
                            return _BASE_ITEMS_COPY[item];
                        } else {
                            console.error('Unknown item: %s requested for TreeFilterMenu', item);
                        }
                    } else if (lang.isFunction(item)) {
                        return item.apply(this);
                    }
                });
            },

            /**
             * Menu callback to expand the selected tree row
             */
            expandRow: function () {
                this.treeWidget.expandRowByObjectId(this.object.objectId);
            },

            /**
             * Overridden to save a reference to the object
             */
            updateCommandAvailability: function (/* Object */ object) {
                // Only run this if the menu is opened on a different selection
                if (object !== this.object) {
                    this.object = object;

                    this.inherited(arguments);
                }
            },

            _deleteCallback: function () {
                var parent = this.object._parent;
                if (parent) { // this really should never be null, only the root node doesn't have a parent
                    parent = parent.objectId;
                }
                topic.publish(this._deleteEvent, parent);
                topic.publish(events.library.refresh);
            }
        });
});

},
'vodori/util/collections/deepMixin':function(){
/**
 * @module vodori/util/collections/deepMixin
 * @deprecated
 */
define([
    'lodash',
    'dojo/_base/lang',
    'dojo/has'
], function (_, lang, has) {
        'use strict';
        /**
         * Performs mixin, like dojo/_base/lang.mixin, except it does it recursively
         *
         * @name vodori/util/collections/deepMixin
         * @function
         *
         * @param {Object} dest Destination object - gets mutated
         * @param {...Object} sources Objects to get mixed in to `dest`
         * @return {Object} Mixedin object of `dest` and all `sources`
         */

        /*
         * See dojo/_base/mixin 1.7.2 for details of how this mixin generally works
         */
        var _extraNames = has('bug-for-in-skips-shadowed') ? ['hasOwnProperty', 'valueOf',
            'isPrototypeOf',
            'propertyIsEnumerable',
            'toLocaleString', 'toString',
            'constructor']
            : [];

        var _mixin = function (dest, source) {
            var s, d, empty = {};
            var keys = _.keys(source).concat(_extraNames);

            _.forEach(keys, function (name) {
                s = source[name];
                d = dest[name];
                if (!(name in dest) ||
                    (dest[name] !== s &&
                        (!(name in empty) || empty[name] !== s))
                    ) {
                    if (lang.isObject(d) && lang.isObject(s)) {
                        s = lang.mixin({}, d, s);
                    }
                    dest[name] = s;
                }
            });

            return dest; // Object
        };

        return function (dest, sources) {
            if (!dest) {
                dest = {};
            }
            for (var i = 1, l = arguments.length; i < l; i++) {
                _mixin(dest, arguments[i]);
            }
            return dest; // Object
        };
    }
);
},
'pepper/library/filter/ui/gridMixins/TreeSelectionFactory':function(){
define([
    'lodash',
    'dojo/_base/declare', 'dojo/_base/lang',
    'dojo/on',
    'dgrid/Selection'
],
    function (
        _,
        declare, lang,
        on,
        Selection) {

        /**
         * @lends pepper/library/filter/ui/gridMixins/TreeSelectionFactory
         */
        var TreeSelectionFactory = {
            /**
             * Create a custom dgrid/Selection instance that prevents disabled nodes from being selected and, instead,
             * calls the rootNodeClickHandler for that row
             *
             * @param rootNodeClickHandler Click handler for the root node. Should take a dgrid row as its parameter
             * @return {*}
             *
             */
            build: function (rootNodeClickHandler) {
                if (!_.isFunction(rootNodeClickHandler)) {
                    throw new Error('Non-function passed to TreeSelectionFactory');
                }
                else {
                    return declare([Selection], {
                        postCreate: function () {
                            this.inherited(arguments);
                            this.own(on(this.domNode, 'click', lang.hitch(this, function (e) {
                                var rowData = this.row(e.target).data;
                                if (rowData.disabled) {
                                    rootNodeClickHandler(rowData);
                                }
                            })));
                        },

                        allowSelect: function (row) {
                            var rowData = this.row(row).data;
                            return rowData && !rowData.disabled;
                        }
                    });
                }
            }
        };

        /**
         * @class pepper/library/filter/ui/gridMixins/TreeSelectionFactory
         */
        return TreeSelectionFactory;
    }
);

},
'pepper/library/filter/ui/Category':function(){
define([
    'module',
    'vodori/provide',
    'pepper/library/filter/ui/_LibraryTreeFilterUI',
    'dojo/text!./templates/Category.html'
],
    function (module, provide, _LibraryTreeFilterUI, categoryTemplate) {
        /**
         *
         * @class
         */
        var Category = {
            title: 'Category',
            templateString: categoryTemplate,
            folderType: 'category',
            folderName: 'CATEGORY',
            createCommand: 'showCreateCategory',
            dndName: 'category',
            menuItems: ['GET_INFO', 'EXPAND_FOLDER', '|', 'CREATE_FOLDER', 'DELETE']
        };

        return provide(module.id, [_LibraryTreeFilterUI], Category);
    }
);

},
'pepper/library/filter/ui/Tag':function(){
define([
    'module',
    'vodori/provide',
    'pepper/library/filter/ui/_LibraryTreeFilterUI',
    'dojo/text!./templates/Tag.html'
],
    function (module, provide, _LibraryTreeFilterUI, tagTemplate) {
        /**
         *
         * @class
         */
        var Tag = {
            title: 'Tag',
            templateString: tagTemplate,
            folderType: 'personalTag',
            folderName: 'PERSONAL_TAG',
            createCommand: 'showCreateTag',
            dndName: 'tag',
            menuItems: ['GET_INFO', 'EXPAND_FOLDER', '|', 'CREATE_FOLDER', 'DELETE']
        };

        return provide(module.id, [_LibraryTreeFilterUI], Tag);
    }
);

},
'pepper/library/filter/ui/Workflow':function(){
define([
    'module',
    'vodori/provide',
    'dojo/json',
    'pepper/library/filter/ui/_LibraryBaseFilterUI',
    'dojo/text!./templates/Workflow.html'
],
    function (module, provide, json, _LibraryBaseFilterUI, workflowTemplate) {
        /**
         *
         * @class
         */
        var Workflow = {
            title: 'Workflow',
            templateString: workflowTemplate,

            postMixInProperties: function () {
                this.filterData.workflowDefinitions = json.stringify(this.filterData.workflowDefinitions);
                this.doNotStringifyFilterData = true;

                this.inherited(arguments);
            }
        };


        return provide(module.id, [_LibraryBaseFilterUI], Workflow);
    }
);

},
'vodori/filter/model/Search':function(){
define([
    'dojo/_base/declare',
    './SimpleStringFilter'
],
    function (declare, SimpleStringFilter) {

        return declare([SimpleStringFilter], { key: 'search' });
    }
);

},
'vodori/filter/model/SimpleStringFilter':function(){
define([
    'dojo/_base/declare',
    './_FilterBase',
    'vodori/filter/model/FilterType'

],
    function (declare, _FilterBase, FilterType) {
        /**
         * A simple filter that takes a simple string value
         */
        var SimpleStringFilter = {

            filterType: FilterType.FREEFORM,

            key: '',

            title: '',

            filterConfig: {},

            _buildQuery: function () {
                var query = this.inherited(arguments);

                // Trim leading whitespace
                var value = query[this.key] || '';
                value = value.replace(/^\s\s*/, '');

                if (value.length) {
                    query[this.key] = value;
                } else {
                    query[this.key] = undefined;
                }

                return query;
            }
        };

        return declare([_FilterBase], SimpleStringFilter);
    }
);

},
'vodori/input/Wysiwyg':function(){
define([
    'module', 'vodori/provide',
    'dijit/_WidgetBase', 'vodori/input/_Activatable', 'vodori/input/_LazyInitializable',
    'dojo/query', 'dojo/on', 'dojo/dom-construct', 'dojo/dom-style', 'dojo/dom-class', 'dojo/aspect',
    'dojo/_base/lang', 'dojo/Deferred', 'dojo/topic',
    'vodori/util/debounce', 'vodori/util/node/descendsFrom', 'vodori/util/node/createFragmentedElement',
    'vodori/amd/tinymce',
    /* Template MIDs */
    'dojo/NodeList-manipulate', 'dojo/NodeList-traverse',
    'vodori/tinymce/EditorLoaded' // We're adding this to the config
], function (
    module, provide,
    _WidgetBase, _Activatable, _LazyInitializable,
    query, on, domConstruct, domStyle, domClass, aspect,
    lang, Deferred, topic,
    debounce, descendsFrom, createFragmentedElement,
    tinymce) {

    var CLASS_CONSTANTS = {
        INIT_EVENT: 'editor/tinymce/init'
    };

    // Use with pepper.content.PropertyWrapper if you want it to store content
    // If you need to move its node, make sure you call topic.publish('editors/redraw', [newParentNode])
    // TinyMCE instantiation can be delayed by setting property 'delayInitialization' to true

    // Usage: <textarea data-dojo-type="vodori/input/Wysiwyg"
    //                  data-dojo-props="value: 'Content here', delayInitialization: true"></textarea>

    return provide(module.id, [_WidgetBase, _Activatable, _LazyInitializable], {
        baseClass: 'Wysiwyg',
        configuration: {
            theme: 'advanced',
            mode: 'exact',
            width: '100%',
            /*
             * CAYENNE-561: Need to set autosize_min_height and height to
             *              ensure that box height is consistent on FF and Chrome
             */
            /* jshint -W106 */
            autoresize_min_height: '180px',
            height: '175px',
            autoresize_on_init: true
            /* jshint +W106 */
        },

        /**
         * Extends configuration with only the keys provided. This prevents the need for using dojo.mixin to extend
         * editor configs on the fly, which is not appropriate requirements for JSP editors.
         *
         * W/o this prop we'd need
         *     <div data-dojo-type="module/id"
         *          data-dojo-props="configuration: dojo.mixin(some.config.base, {foo: 'bar'})"></div>
         *
         * just to override the one property, foo, in a JSP. Instead we have:
         *     <div data-dojo-type="module/id"
         *          data-dojo-props="configuration: some.config.base, configurationExtension: {foo: 'bar'}"></div>
         *
         * @type {Object.<*>}
         */
        configurationExtension: null,

        persistsAcrossRefresh: false, // Normal form elements do this, but this thing probably shouldn't

        value: '',

        hasToolbars: true,

        /**
         * Prevent user interaction while the Editor is loading.
         *
         * @type {boolean}
         */
        blockWhileLoading: true,

        EDITOR_LOADING_CLASS: 'editorLoading',

        delayedContent: undefined,

        /**
         * true only while in the process of initializing
         */
        _initializing: false,

        constructor: function () {
            this.deferredEditor = new Deferred();
            this.markClean();
            this.configurationExtension = {};
        },

        postMixInProperties: function () {
            this.inherited(arguments);

            // Reset the <textarea> from scratch
            if (!this.persistsAcrossRefresh) {
                this.srcNodeRef.value = this.srcNodeRef.defaultValue;
            }

            // Make sure we've got a config
            if (this.configuration === this.constructor.prototype.configuration) {
                console.warn('No configuration specified', this);
            }
        },

        postCreate: function () {
            this.inherited(arguments);

            // If the configuration is a WysiwygConfig instance,
            // get its TinyMCE-usable config object
            if ('toConfig' in this.configuration) {
                this.configuration = this.configuration.toConfig();
            }

            // Mix the defaults and the overrides into a new object
            this.configuration = lang.mixin({}, this.constructor.prototype.configuration, this.configuration, {
                elements: this.id,
                /* jshint -W106 */
                init_instance_callback: lang.hitch(this, this.deferredEditor.resolve)
                /* jshint +W106 */
            }, this.configurationExtension);

            if (this.blockWhileLoading) {
                // Need the plugin in the config for this to work.
                this.configuration.plugins += ', editorloaded';
                // Setting the loading class here for timing reasons.
                domClass.add(this.domNode.parentNode, this.EDITOR_LOADING_CLASS);
            }

        },

        startup: function () {
            this.inherited(arguments);
            this.initializeEditorWhenReady();
            this.subscribe('editors/redraw', 'redraw');
        },

        /**
         * @inheritDoc
         */
        initializeNow: function () {
            if (!this._initializing && !this._isInitialized()) {
                this.initializeEditorNow();
            }
        },

        _isInitialized: function () {
            return domClass.contains(this.domNode, 'initialized');
        },

        // Associate an editor with the widget
        // Instantiation can now be delayed until shouldInitialize is true
        initializeEditorWhenReady: function () {

            this.deferredEditor.then(lang.hitch(this, function (editor) {
                var politeOnChange = debounce(function () {
                    this.onChange();
                }, 250, [], this);

                var normalizeContent = function(){
                    /*
                     * Put this in a closure to cache it without making it
                     * available for other people's use.
                     */
                    var frag = createFragmentedElement();
                    /**
                     * @param {string=} originalContent HTML to normalize
                     * @return {string} normalized HTML
                     */
                    return function(originalContent) {
                        frag.innerHTML = originalContent;
                        query('[data-mce-bogus]:only-child', frag).remove();
                        query('p:empty', frag).remove();
                        query('[mce_bogus]:only-child', frag).parent().remove();
                        return lang.trim(frag.innerHTML);
                    };
                }();

                editor.undoManager.onBeforeAdd.add(function(undoManager, level) {
                    level.content = normalizeContent(level.content);
                });
                editor.onPostProcess.add(function(ed, o) {
                    o.content = normalizeContent(o.content);
                });
                editor.setContent(normalizeContent(editor.getContent({format : 'raw'})));

                editor.onExecCommand.add(politeOnChange, this);
                /*
                 * By default, the TAB key moves the focus out of a Wysiwyg.
                 * Replace this functionality with Indent (and Outdent on Shift+TAB)
                 */
                editor.onKeyDown.add(function (ed, e) {
                    var keyCode;
                    if (e.keyCode) {
                        keyCode = e.keyCode;
                    }
                    else if (e.which) {
                        keyCode = e.which;
                    }
                    if (keyCode === 9) {
                        if (e.shiftKey) {
                            ed.execCommand('Outdent');
                        }
                        else {
                            ed.execCommand('Indent');
                        }
                        if (e.preventDefault) {
                            e.preventDefault();
                        }
                        return false;
                    }
                });
                editor.onKeyUp.add(politeOnChange, this);
                editor.onSaveContent.add(politeOnChange, this);
                editor.onDeactivate.add(politeOnChange, this);
                editor.onSetContent.add(politeOnChange, this);
                editor.onClick.add(lang.hitch(this, function () {
                    /*
                     * Clicking on a Wysiwyg editor means clicking inside an iFrame
                     * As a result, the click event is not in the main page.
                     * Thus, we create a new click event and bubble it up, so that main page can capture clicks to the
                     * Wysiwyg
                     */
                    //noinspection JSPotentiallyInvalidUsageOfThis,JSPotentiallyInvalidUsageOfThis
                    on.emit(this.domNode.parentNode, 'click',
                        {
                            bubbles: true,
                            cancelable: true
                        }
                    );
                }));

                // Add initialized class to the Wysiwyg element once the
                // editor is ready. Currently this is used in Selenium
                // tests to know when it is safe to start working with the
                // editor.
                domClass.add(this.domNode, 'initialized');

                editor.setContent(this.get('value'));
                // Because on change is fired, do not want to initialize into edit mode in a dirty state
                debounce(lang.hitch(this, 'markClean'), 260)();
                topic.publish(CLASS_CONSTANTS.INIT_EVENT, [this]);

                // Prevent bugs in autoresize.
                var doc = editor.getWin().document;
                domStyle.set(doc.documentElement, 'height', 'auto');
                domStyle.set(doc.body, 'height', 'auto');
            }));

            // If the page is loaded in edit mode, initialize TinyMCE right away
            if (!this.delayInitialization) {
                this.initializeEditorNow();
            }
        },

        initializeEditorNow: function () {
            this._inizializing = true;
            this.deferredEditor.then(lang.hitch(this, function () {
                this._inizializing = false;
            }));

            /* see http://stackoverflow.com/questions/13341087/tiny-mce-cant-be-inited-when-load-js-dynamically */
            tinymce.dom.Event.domLoaded = true;
            tinymce.init(this.configuration);
        },

        isDirty: function () {
            return this.dirty;
        },

        markDirty: function () {
            this.dirty = true;
        },

        markClean: function () {
            this.dirty = false;
        },

        // Check to see if an ancestor has changed dramatically enough to warrant resetting the editor
        redraw: function (root) {
            this.deferredEditor.then(lang.hitch(this, function (editor) {
                var inRefreshPath = descendsFrom(this.domNode, root);
                var editorIsOrphaned = !editor.contentWindow.frameElement;
                var hasNoHeight = editorIsOrphaned || !domStyle.get(editor.contentWindow.frameElement, 'height');

                if ((inRefreshPath && editorIsOrphaned) || hasNoHeight) {
                    this.resetEditor();
                }
            }));
        },

        // If this widget moves, its editor will break and must be recreated
        resetEditor: function () {
            this.deferredEditor.then(lang.hitch(this, function (editor) {
                console.log('Resetting editor', editor);

                // this.editor.destroy doesn't remove its nodes
                var container = editor.getContainer();
                editor.destroy();
                domConstruct.destroy(container);

                this.deferredEditor.cancel();
                this.deferredEditor = new Deferred();

                // Show the <textarea> or else the new editor will adopt its {display: none;}
                domStyle.set(this.domNode, 'display', '');

                this.initializeEditorWhenReady();
            }));
        },

        // This should fire when the editor's content changes
        onChange: function () {
            this.markDirty();
        },

        uninitialize: function () {
            this.deferredEditor.then(lang.hitch(this, function (editor) {
                editor.remove();
                this.deferredEditor.cancel();
            }));

            this.inherited(arguments);
        },

        // Make sure the editor stays with its widget
        placeAt: function (destination, position) {
            this.inherited(arguments);
            this.deferredEditor.then(lang.hitch(this, function (editor) {
                domConstruct.place(editor.getContainer(), this.domNode, 'after');
            }));

            // It might be reasonable to call this.resetEditor here,
            // but whatever moves the node should really be responsible
            // for publishing a "editors/redraw" message for it
        },

        generateToolbars: function (options) {
            return this.deferredEditor.then(lang.hitch(this, function (editor) {
                if (editor.getParam('use_pepper_toolbar') && 'fixedtoolbar' in editor.plugins) {
                    // Set its toolbarContainer and move its toolbar.
                    editor.plugins.fixedtoolbar.toolbarContainer = options.container;
                    editor.plugins.fixedtoolbar.moveToolbar(editor);

                    // Disable automatic showing and hiding. We'll handle it here.
                    editor.plugins.fixedtoolbar.changeDisplay = false;

                    this.own(aspect.after(this.getParent(), 'activate', lang.hitch(this, function () {
                        editor.plugins.fixedtoolbar.showToolbar(editor);
                        options.onActivate(this, this.toolbarTabs);
                    })));
                    this.own(aspect.after(this.getParent(), 'deactivate', lang.hitch(this, function () {
                        editor.plugins.fixedtoolbar.hideToolbar(editor);
                        options.onDeactivate(this, this.toolbarTabs);
                    })));

                    // Get a list of the toolbars.
                    editor.toolbars = query('.mceToolbar', editor.plugins.fixedtoolbar.toolbarHolder);

                    this.toolbarTabs = ['Home', 'Insert', 'Develop'];

                    return this.toolbarTabs;
                }
            }));
        },

        getToolbarHolder: function () {
            return this.deferredEditor.then(lang.hitch(this, function (editor) {
                return editor.plugins.fixedtoolbar.toolbarHolder;
            }));
        },

        getToolbars: function () {
            return this.deferredEditor.then(lang.hitch(this, function (editor) {
                return editor.toolbars;
            }));
        },

        getEditor: function () {
            return this.deferredEditor.then(function (editor) {
                return editor;
            });
        },

        /**
         * Wrapper for getValueWithArgs, for a common case.
         *
         * @return {string}
         */
        getRawValue: function () {
            return this.getValueWithArgs(true, true);
        },

        /**
         * This is the same as get('value') except it takes arguments, which dojo's Stateful doesn't for some
         * inexplicable reason.
         *
         * @param {(boolean|Object)} withEvents Whether to fire tinymce events.
         *     Optionally, pass along a tinymce `content` object
         *     @see: tinymce getContent
         * @param {boolean} asRaw
         * @return {(string|Element)}
         */
        getValueWithArgs: function (withEvents, asRaw) {
            // Expose the underlying tinymce options, just in case.
            // var settings = lang.isObject(refreshEditor) ? refreshEditor : {};
            // Sometimes tinymce return HTML other times a string.
            var settings = lang.isObject(withEvents) ? withEvents : {
                format: asRaw ? 'raw' : 'html',
                /* jshint -W106 */
                no_events: withEvents === false
                /* jshint +W106 */
            };
            this.deferredEditor.then(lang.hitch(this, function (editor) {
                this.delayedContent = editor.getContent(settings);
            }));

            // Use the domNode's value if there's no content from the editor
            if (typeof this.delayedContent === 'undefined') {
                return this.value;
            }
            else {
                return this.delayedContent;
            }
        },

        /**
         * @return {(string|Element)}
         */
        _getValueAttr: function () {
            this.deferredEditor.then(lang.hitch(this, function (editor) {
                this.delayedContent = editor.getContent();
            }));

            // Use the domNode's value if there's no content from the editor
            if (typeof this.delayedContent === 'undefined') {
                return this.value;
            }
            else {
                return this.delayedContent;
            }
        },

        _setValueAttr: function (value, refreshEditor) {
            // Expose the underlying tinymce options, just in case.
            // var settings = lang.isObject(refreshEditor) ? refreshEditor : {};
            // Sometimes tinymce return HTML other times a string.

            this.deferredEditor.then(lang.hitch(this, function (editor) {
                // We'll set the content again if the editor isn't around.
                if (!!editor && refreshEditor !== false) {
                    editor.setContent(value);
                }

                this.domNode.value = this._stringifyHTML(value);

                this.value = value;


                return this;
            }));
        },

        _stringifyHTML: function (html) {
            var container = createFragmentedElement();

            if (lang.isString(html)) {
                container.innerHTML = html;
            } else {
                domConstruct.place(html, container);
            }

            var stringified = container.innerHTML;
            domConstruct.destroy(container);

            return stringified;
        }

    }, CLASS_CONSTANTS);
});

},
'vodori/input/FilteringCheckedSelect':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'dojo/on', 'dojo/aspect',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'dijit/form/_FormValueWidget', 'dijit/form/TextBox',
    'vodori/input/CheckedSelect',
    'dojo/text!./templates/FilteringCheckedSelect.html'
], function (
    provide, module,
    _,
    lang, on, aspect,
    _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
    _FormValueWidget, TextBox,
    CheckedSelect,
    template
) {
    var aSlice = Array.prototype.slice;

    /**
     * A CheckedSelect w/ a TextBox that reduces the list of choices.
     */
    return provide(module.id, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, _FormValueWidget], {
        /**
         * Whether to allow selection of multiple values.
         *
         * @type {boolean}
         */
        multiple: true,

        /**
         * Which property on the options to filter by.
         *
         * @type {Array.<string>}
         */
        searchProperties: ['label'],

        /**
         * Whether the filtering should be case sensitive.
         *
         * @type {boolean}
         */
        caseSensitive: false,

        /**
         * The text the shows in the filter box when nothing has been entered.
         *
         * @type {string}
         */
        placeholder: 'Enter search here',

        /**
         * The values of the selected checkboxes.
         *
         * @type {Array.<string>}
         */
        value: [],

        /**
         * @type {string}
         */
        templateString: template,

        /**
         * @type {vodori.input.CheckedSelect}
         */
        _checkedSelect: null,

        /**
         * @type {Element}
         */
        _checkedSelectNode: null,

        /**
         * @type {dijit.form.TextBox}
         */
        _textBox: null,

        postCreate: function () {
            this.inherited(arguments);

            // Initialize the textbox late, so that we can use it as the focusNode.
            this.own(this._textBox = new TextBox({
                id: this.id + '_textBox',
                intermediateChanges: true
            }, this.focusNode));

            // Waiting for containerNode to be populated w/ <option>s.
            this.own(this._checkedSelect = new CheckedSelect({
                multiple: this.multiple
            }, this._checkedSelectNode));

            this.own(this._checkedSelect.on('change', lang.hitch(this, 'onChange')));

            this.own(this._textBox.on('change', lang.hitch(this, '_handleFiltering')));
        },

        // Events
        onChange: function () {
        },

        /**
         * Manage the CheckedSelect based on changes to _textBox.
         *
         * @param {string} value
         * @private
         */
        _handleFiltering: function (value) {
            var re = null;
            value = lang.trim(value);

            if (!!value) {
                re = new RegExp(value, this.caseSensitive ? '' : 'i');
                this._checkedSelect.filter(lang.hitch(this, function (option) {
                    return _.some(this.searchProperties, function (propName) {
                        return re.test(option[propName]);
                    });
                }));
            }
            else {
                // Show all options.
                this._checkedSelect.filter();
            }
        },

        /**
         * A fancy way to hand a set call over to the CheckedSelect.
         *
         * @param {string} prop
         * @return {*}
         * @private
         */
        _delegateSet: function (prop /*, args*/) {
            var args = aSlice.call(arguments[1], 0);
            this[prop] = args[1];
            args.unshift(prop);
            if (this._checkedSelect) {
                return this._checkedSelect.set.apply(this._checkedSelect, args);
            }
            else {
                this[prop] = args[1];
                return this[prop];
            }
        },

        _getValueAttr: function () {
            return this._checkedSelect ? this._checkedSelect.get('value') : this.value;
        },

        _setValueAttr: function (value) {
            return this._delegateSet('value', arguments);
        }
    });
});

},
'vodori/input/FormBasedEditor':function(){
/**
 *
 * @module vodori/input/FormBasedEditor
 *
 * @description
 * Provides an HTML form as an editing user interface for a section of markup.
 * The conversion between the form and the resulting markup is accomplished using templates
 * and special "data-parse" attributes for gleaning data from the form.
 *
 * Example 1:
 * ```html
 * <div data-dojo-type="vodori/input/formBasedEditor">
 *     <div data-dojo-attach-point="formTemplate">
 *         Source: <input data-parse="source" value="{{source}}"/><br/>
 *         Alt Text: <input data-parse="altText" value="{{altText}}"/>
 *     </div>
 *     <div data-dojo-attach-point="valueTemplate">
 *         <img data-parse="source:src, altText:alt" src="{{source}}" alt="{{altText}}" />
 *     </div>
 *     <div data-dojo-attach-point="value">
 *         <img data-parse="source:src, altText:alt" src="/images/example.png" alt="Example Image" />
 *     </div>
 * </div>
 * ```
 *
 * The data-parse attributes are used to glean data from the DOM nodes. In this case, the
 * data produced by both sections would be `{ source: ..., value: ... }`. In the value
 * template, the data-parse "source:src" tells the parser to use the value of the "src"
 * attribute for the "source" property. The form template is using the default attribute for
 * the source property (which for inputs is the value and for other nodes is innerHTML).
 *
 * The `{{...}}` notations are used when rendering the template from data. Simply use the
 * standard syntax from the templating engine being used.
 *
 * Here an initial value is also specified in a third div. On initialization, this value
 * will be parsed and used to render the initial form via the form template.
 *
 * Example 2:
 * ```html
 * <div data-dojo-type="vodori/input/formBasedEditor">
 *     <div data-dojo-attach-point="formTemplate">
 *         <ol>
 *         {{#fruits}}
 *             <li data-parse="fruits:[]">
 *                 <input data-parse="fruits.name" value="{{name}}"/>
 *                 <input data-parse="fruits.quantity" value="{{quantity}}"/>
 *             </li>
 *         {{/fruits}}
 *         </ol>
 *     </div>
 *     <div data-dojo-attach-point="valueTemplate">
 *         <ol>
 *         {{#fruits}}
 *             <li data-parse="fruits:[]">
 *                 <span data-parse="fruits.name">{{name}}</span>
 *                 <span data-parse="fruits.quantity">{{quantity}}</span>
 *             </li>
 *         {{/fruits}}
 *         </ol>
 *     </div>
 * </div>
 * ```
 *
 * This example would produce data looking like `{ fruits: [ { name: ..., quantity: ... }, ... ] }`.
 * The path to nested properties is specified via "."s as in "fruits.name". This works with
 * arrays as well as objects. For arrays, the special data-parse ending with ":[]", as in
 * "fruits:[]" is used to indicate each new array element. This tells the parser that when
 * it next comes upon "fruits.name" and "fruits.quantity" these should be set on an object
 * that is an element of the fruits array rather than set as properties on a "fruits" object.
 *
 * For more examples see DomDataParser.html in the unit test suite.
 *
 * @tutorial FormBasedEditor
 */
define([
    'module',
    'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/topic', 'dojo/on', 'dojo/json', 'dojo/query',
    'dojo/dom-style', 'dojo/dom-construct', 'dojo/dom-attr',
    'dojo/has', 'dojo/parser',
    'dijit/_WidgetBase',
    'vodori/util/cleanup', 'vodori/util/string/isBlank', 'vodori/util/string/endsWith',
    'vodori/util/node/isDomNode', 'vodori/renderTemplate',
    'vodori/input/formBasedEditor/DomDataParser'
],
    function (
        module, provide,
        _,
        lang, topic, on, json, query,
        domStyle, domConstruct, domAttr,
        has, parser,
        _WidgetBase,
        cleanup, isBlank, endsWith,
        isDomNode, renderTemplate,
        DomDataParser) {

        return provide(module.id, [_WidgetBase],
            /**
             *
             * @lends module:vodori/input/FormBasedEditor#
             */
            {
                /**
                 * Template used to generate the form that is displayed for editing the value.
                 * @note this can be specified in a nested node with data-dojo-attach-point="formTemplate"
                 * if an HTMLElement is specified, the innerHTML will be used
                 * @type {String|HTMLElement}
                 */
                formTemplate: '',

                /**
                 * Template used to the value of this widget (i.e. widget.get('value')).
                 * @note this can be specified in a nested node with data-dojo-attach-point="valueTemplate"
                 * if an HTMLElement is specified, the innerHTML will be used
                 * @type {String|HTMLElement}
                 */
                valueTemplate: '',

                /**
                 * The value of this input widget. Use get/set to access this value. If valueAsJson is
                 * true, this must be a valid JSON string. Otherwise, it must be valid HTML.
                 * @note the initial value can be specified in a nested node with data-dojo-attach-point="value"
                 * if set with an HTMLElement, the innerHTML will be used
                 * @type {String}
                 * @private
                 */
                value: '',

                /**
                 * Engine for rendering templates. Currently, options are `mustache` and `lodash`.
                 *
                 * The default is `mustache`.
                 * @type {String}
                 */
                templateEngine: 'mustache',

                /**
                 * If true, the value will be returned as a JSON string rather than using the
                 * outputTemplate to render the value.
                 * @type {boolean}
                 */
                valueAsJson: false,

                /**
                 * Parser used to glean the data from the form or the set value.
                 * @note initialized in constructor
                 * @type {module:vodori/input/formBasedEditor/DomDataParser}
                 */
                dataParser: null,

                /**
                 * The node within which the form is rendered. Defaults to this.domNode.
                 * @type {HTMLElement}
                 */
                formNode: null,

                /**
                 * Set this to true in order to log additional debugging information.
                 */
                verbose: false,

                /**
                 * false until after postCreate.
                 * @private
                 */
                _isReady: false,

                /**
                 * Aspect or override this method to modify the data before rendering the form template.
                 * @param {*} data the original data
                 * @result {*} the modified data with which to render the template (optional -- unless
                 *         you are replacing the data object, there is no need to return it.)
                 */
                prepareDataForForm: function (data) {
                    return data;
                },

                /**
                 * Aspect or override this method to modify the data before rendering the value template
                 * or converting to JSON.
                 * @param {*} data the original data
                 * @result {*} the modified data with which to render the template or render JSON
                 *         (optional -- unless you are replacing the data object, there is no need to
                 *         return it.)
                 */
                prepareDataForValue: function (data) {
                    return data;
                },

                constructor: function () {
                    this.dataParser = new DomDataParser();
                },

                postCreate: function () {
                    if (this.verbose) {
                        console.group(this.id + ' postCreate');
                    }
                    this.inherited(arguments);

                    this.formNode = this.formNode || this.domNode;

                    this._assignPropertiesFromAttachPoints();
                    domConstruct.empty(this.domNode);

                    // Set up the input and output templates
                    this.formTemplate = this._createTemplateFromTextOrNode(this.formTemplate);
                    this.valueTemplate = this._createTemplateFromTextOrNode(this.valueTemplate);

                    if (this.verbose) {
                        console.log('formTemplate:', this.formTemplate);
                        console.log('valueTemplate:', this.valueTemplate);
                        console.log('value:', this.value);
                        console.log('valueAsJson:', this.valueAsJson);
                    }

                    this._renderFormFromValue();

                    this._isReady = true;
                    if (this.verbose) {
                        console.groupEnd();
                    }
                },

                _assignPropertiesFromAttachPoints: function () {
                    _.forEach(['formTemplate', 'valueTemplate', 'value'], function(prop) {
                        this[prop] = this[prop] || query('[data-dojo-attach-point='+prop+']', this.domNode)[0];
                    }, this);

                    this._removeFromDomIfDomNode(this.formTemplate);
                    this._removeFromDomIfDomNode(this.valueTemplate);
                    this._removeFromDomIfDomNode(this.value);
                },

                _removeFromDomIfDomNode: function (node) {
                    if (isDomNode(node) && node.parentNode) {
                        node.parentNode.removeChild(node);
                    }
                },

                _createTemplateFromTextOrNode: function (textOrNode) {
                    var text;
                    if (isDomNode(textOrNode)) {
                        var node = textOrNode;
                        text = node.innerHTML;

                        if (has('ie')) {
                            // fix IE stripping of quotations when input is <tag attr="{{singleWord}}"/>
                            var UNQUOTED_ATTRIBUTES_REGEX = /(<[^>]+=){{(\S*)}}(.*?>)/g;
                            text = text.replace(UNQUOTED_ATTRIBUTES_REGEX, '$1"{{ $2 }}"$3');
                            if (text !== node.innerHTML) {
                                console.log('Replaced missing quotations in input:',
                                    node.innerHTML.match(UNQUOTED_ATTRIBUTES_REGEX));
                            }
                        }

                        // "{%", "{{", " ", "}}", and "%}" get encoded in "href" and "src" attributes
                        var templateChars = /(%7B%25|%7B%7B|%20|%7D%7D|%25%7D)/g;
                        text = text.replace(templateChars, decodeURI);

                        cleanup.destroy(textOrNode);
                    } else {
                        text = textOrNode;
                    }

                    text = text || ' '; // Can't be blank.

                    return text;
                },

                /**
                 * Parse the form and pass its data through the `valueTemplate` in order to determine
                 * the value. Or if `valueAsJson` is true, convert the form data to a JSON string for the
                 * value.
                 * @return {String}
                 */
                _getValueAttr: function () {
                    var data = this._parseForm();
                    data = this._callPrepareDataForValue(data);
                    if (this.valueAsJson) {
                        this.value = json.stringify(data);
                    } else {
                        this.value = this._renderTemplate(this.valueTemplate, data);
                    }
                    return this.value;
                },

                /**
                 * Parse the new value, pass its data through the form template and display the updated
                 * form. Or if `valueAsJson` is true, valid JSON must be passed in, which data will be
                 * passed through the form template to dispaly an updated form.
                 * @param value {String|HTMLElement} An HTML string or a node that represents the value
                 *        or a JSON string if `valueAsJson` is true
                 */
                _setValueAttr: function (value) {
                    this.value = value;
                    if (this._isReady) {
                        this._renderFormFromValue();
                    }
                },

                _parseForm: function () {
                    return this.dataParser.parse(this.domNode);
                },

                _renderTemplate: function (template, data) {
                    var engine = this.templateEngine;
                    var rendered = (engine === 'mustache') ? this._renderMustacheTemplate(template, data)
                                 : (engine === 'lodash')   ? this._renderLodashTemplate(template, data)
                                 :                           null;
                    if(rendered === null) {
                        throw 'Unrecognized template engine: ' + engine;
                    }
                    else {
                        return rendered;
                    }
                },

                _renderMustacheTemplate: function (template, data) {
                    if (_.isNull(data)) {
                        data = {};
                    }
                    return renderTemplate(template, data);
                },

                _renderLodashTemplate: function (template, data) {
                    return _.template(template, data, {
                        'escape': /{{([\s\S]+?)}}/g,
                        'interpolate': /{{{([\s\S]+?)}}}/g,
                        'evaluate': /{%([\s\S]+?)%}/g
                    });
                },

                _renderFormFromValue: function () {
                    var data = this._parseValue();
                    data = this._callPrepareDataForForm(data);
                    var formHtml = this._renderTemplate(this.formTemplate, data);

                    this._setFormHtml(this.formNode, formHtml);
                },

                _setFormHtml: function (formNode, html) {
                    cleanup.destroyChildWidgets(formNode);
                    formNode.innerHTML = html;
                    parser.parse(formNode, {template:false});
                },

                _parseValue: function () {
                    if (this.valueAsJson) {
                        return this._parseValueAsJson();
                    } else {
                        return this._parseValueAsHtml();
                    }
                },

                _parseValueAsJson: function () {
                    var jsonString;
                    if (isDomNode(this.value)) {
                        jsonString = this.value.textContent || this.value.innerText;
                    } else {
                        jsonString = this.value;
                    }

                    if (isBlank(jsonString)) {
                        return null;
                    } else {
                        return json.parse(jsonString);
                    }
                },

                _parseValueAsHtml: function () {
                    return this.dataParser.parse(this.value);
                },

                /**
                 * Call prepareDataForForm. Handle the optional return of the data object.
                 * @param data the raw data
                 * @returns {*} the modified data
                 * @private
                 */
                _callPrepareDataForForm: function (data) {
                    var result = this.prepareDataForForm(data);
                    // If nothing was returned, use the original data object.
                    return !_.isUndefined(result) ? result : data;
                },

                /**
                 * Call prepareDataForValue. Handle the optional return of the data object.
                 * @param data the raw data
                 * @returns {*} the modified data
                 * @private
                 */
                _callPrepareDataForValue: function (data) {
                    var result = this.prepareDataForValue(data);
                    // If nothing was returned, use the original data object.
                    return !_.isUndefined(result) ? result : data;
                }
            });
    }
);

},
'vodori/util/node/isDomNode':function(){
define(function () {
    /**
     * Return true if the given object is a dom node.
     *
     * @param {*} it
     * @return {boolean}
     */
    return function (it) {
        return it && it.nodeName && it.nodeType;
    };
});
},
'vodori/input/formBasedEditor/DomDataParser':function(){
/**
 * @module vodori/input/formBasedEditor/DomDataParser
 *
 * @description
 * Used by FormBasedEditor to glean data from HTML markup. Parsing is directed by data-parse
 * attributes on the DOM nodes.
 *
 * These are the valid values for the data-parse attribute:
 *
 *  - `path:attribute`
 *      Use the given attribute of this node for the value at the given path
 *  - `path`
 *      If no attribute is set, a default is used ("value" for form elements, "src" for
 *      img's, "href" for a's and "textContent" for all other elements). Also if a checkbox
 *      or radio is unchecked, no value will be set to the path.
 *  - `path:[]`
 *      This is a special syntax to indicate that path is an array and a new array element
 *      should be started here.
 *  - `path, another.path:attribute, ...`
 *      Multiple instructions can be included for one node, separated by commas.
 *
 * And here are some examples:
 *  - `<input data-parse="title" />`
 *      The value of the input would be assigned to title.
 *  - `<a data-parse="helpText:title" title="...">...</a>`
 *      The value of the title attribute would be assigned to helpText.
 *  - `<span data-parse="title" >...</span>`
 *      The textContent of the span would be assigned to title.
 *  - `<img data-parse="image.src, image.text:alt" ... />`
 *      The src of the img would be assigned to image.src and the value of the "alt"
 *      attribute would be assigned to image.text.
 *
 * @see module:vodori/input/FormBasedEditor
 *
 */
define([
    'module',
    'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/query', 'dojo/dom-construct', 'dojo/dom-attr',
    'vodori/util/node/isDomNode',
    './DataWrapper'
],
    function (module, provide, _, lang, query, domConstruct, domAttr, isDomNode, DataWrapper) {

        /**
         * @lends module:vodori/input/formBasedEditor/DomDataParser#
         */
        var DomDataParser =             {
            /**
             * Attribute used in markup to specify directions for parsing.
             */
            PARSE_INFO_ATTRIBUTE: 'data-parse',

            /**
             * Set this to true in order to log additional debugging information.
             */
            verbose: false,

            /**
             * Parse markup and return the data as an object.
             * @param domNodeOrHtmlString {HTMLElement|String} HTML string or Dom node to parse
             * @return {*}
             */
            parse: function (domNodeOrHtmlString) {
                if (isDomNode(domNodeOrHtmlString)) {
                    return this.parseDom(domNodeOrHtmlString);
                } else {
                    return this.parseHtmlString(domNodeOrHtmlString);
                }
            },

            /**
             * Parse markup and return the data as an object.
             * @param htmlString {String} valid HTML to parse
             * @return {*}
             */
            parseHtmlString: function (htmlString) {
                var node = domConstruct.toDom('<div>' + htmlString + '</div>');
                return this.parseDom(node);
            },

            /**
             * Parse markup and return the data as an object.
             * @param rootNode {HTMLElement} DOM node to parse
             * @return {*}
             */
            parseDom: function (rootNode) {
                if (this.verbose) {
                    console.group('DomDataParser.parseDom');
                }
                if (this.verbose) {
                    console.log('node', rootNode);
                }

                var data = new DataWrapper();

                // HERE BE DRAGONS
                query('[' + this.PARSE_INFO_ATTRIBUTE + ']', rootNode).forEach(lang.hitch(this, function (node) {
                    var directives = lang.trim(domAttr.get(node, this.PARSE_INFO_ATTRIBUTE)).split(/\s*,\s*/);
                    _.forEach(directives, lang.hitch(this, function (directive) {
                        directive = this._parseDirective(directive);
                        var path = directive.path;
                        var valueAttribute = directive.valueAttribute;
                        var newListItem = directive.newListItem;

                        if (newListItem) {
                            data.startNewArrayElement(path);
                        } else {
                            var value = this._getValueFromNode(node, valueAttribute);
                            if (value !== null) {
                                data.setItemAtPath(path, value);
                            }
                        }
                    }));
                }));

                if (this.verbose) {
                    console.log('data', data.data);
                }
                if (this.verbose) {
                    console.groupEnd();
                }
                return data.data;
            },

            _parseDirective: function (directive) {
                var directiveParts = directive.split(':');
                var path = directiveParts[0];
                var valueAttribute = directiveParts[1];

                var newListItem = false;
                if (valueAttribute === '[]') {
                    newListItem = true;
                    valueAttribute = null;
                }

                return {
                    path: path,
                    newListItem: newListItem,
                    valueAttribute: valueAttribute
                };
            },

            _getValueFromNode: function (node, valueAttribute) {
                var value;
                if (this._isUncheckedCheckboxOrRadio(node)) {
                    return null;
                }

                if (!valueAttribute) {
                    valueAttribute = this._getDefaultValueAttributeForNode(node);
                }

                value = this._getValueOfNodeAttribute(node, valueAttribute);
                value = this._convertValue(value);
                return value;
            },

            _isUncheckedCheckboxOrRadio: function (node) {
                if (node.nodeName === 'INPUT') {
                    var type = domAttr.get(node, 'type');
                    if (type && type.match(/checkbox|radio/i)) {
                        if (!node.checked) {
                            return true;
                        }
                    }
                }

                return false;
            },

            _getDefaultValueAttributeForNode: function (node) {
                if (node.nodeName === 'INPUT' || node.nodeName === 'TEXTAREA') {
                    return 'value';
                } else if (node.nodeName === 'IMG') {
                    return 'src';
                } else if (node.nodeName === 'A') {
                    return 'href';
                } else {
                    return 'textContent';
                }
            },

            _getValueOfNodeAttribute: function (node, attribute) {
                //NOTE: textContent is the standard, but it's not supported before IE9. innerText is
                // a similar, but somewhat different property that was originally IE specific.
                if (attribute === 'textContent') {
                    return ('textContent' in node) ? node.textContent : node.innerText;
                } else if (attribute === 'innerText') {
                    return ('innerText' in node) ? node.innerText : node.textContent;
                } else {
                    return  domAttr.get(node, attribute);
                }
            },

            _convertValue: function (value) {
                if (value === 'false') {
                    value = false;
                } else if (value === 'true') {
                    value = true;
                }
                return value;
            }
        };

        return provide(module.id, [], DomDataParser);
    }
);

},
'vodori/input/formBasedEditor/DataWrapper':function(){
define([
    'module',
    'vodori/provide',
    'lodash',
    'dojo/_base/lang'
],
    function (module, provide, _, lang) {

        /**
         * Wraps a data object with methods to access its contents by path. When accessing an array,
         * the last element of the array is always used.
         *
         * Used by DomDataParser to keep track of and build data while parsing the DOM.
         *
         * @see vodori/input/formBasedEditor/DomDataParser
         * @class vodori/input/formBasedEditor/DataWrapper
         */
        return provide(module.id, [],
            /**
             *
             * @lends vodori/input/formBasedEditor/DataWrapper.prototype
             */
            {
                /**
                 * The wrapped data object
                 */
                data: null,

                constructor: function (data) {
                    this.data = data || {};
                },

                /**
                 * Retrieve a value from the data.
                 * @note When accessing an array, the last element of the array is always used.
                 *
                 * @param {String} path dot (.) delimited path to a value within the data
                 * @param {boolean} [createIfNotExist=false] when this is true, if no value yet exists
                 *        at the given path, an empty object will be created there.
                 * @returns {*} the value found or created at the path
                 */
                getItemAtPath: function (path, createIfNotExist) {
                    var object = this.data;
                    if (path) {
                        _.forEach(path.split('.'), lang.hitch(this, function (segment) {
                            var child = this._getChild(object, segment);
                            if (!child && createIfNotExist) {
                                child = this._setChild(object, segment, {});
                            }
                            object = child;

                            if (_.isNull(object) || _.isUndefined(object)) {
                                return false; // exit loop
                            }
                        }));
                    }
                    return object;
                },

                /**
                 * Set a value in the data.
                 * @note When accessing an array, the last element of the array is always used.
                 *
                 * @param {String} path dot (.) delimited path to a value within the data
                 * @param {*} value value to set
                 */
                setItemAtPath: function (path, value) {
                    if (!path) {
                        if (_.isArray(this.data)) {
                            this.data[this.data.length - 1] = value;
                        } else {
                            this.data = value;
                        }
                    } else {
                        var currentItemAtPath = this.getItemAtPath(path, false);
                        if (_.isArray(currentItemAtPath)) {
                            currentItemAtPath[currentItemAtPath.length - 1] = value;
                        } else {
                            var parent = this.getItemAtPath(this._getParentPath(path), true);
                            var segment = this._getLastPathSegment(path);
                            this._setChild(parent, segment, value);
                        }
                    }
                },

                /**
                 * Create an array or append a new element at the given path. Subsequent references to
                 * this path will apply to this new element.
                 * {String} path dot (.) delimited path to a value within the data
                 */
                startNewArrayElement: function (path) {
                    var currentList = this.getItemAtPath(path);
                    if (_.isArray(currentList)) {
                        currentList.push(null);
                    } else {
                        this.setItemAtPath(path, [null]);
                    }
                },

                /**
                 * Get the value of the given property of the object, taking into account the special
                 * semantics of arrays.
                 * @param {Object|Array} object
                 * @param {String} child name of the property
                 * @returns {*}
                 * @private
                 */
                _getChild: function (object, child) {
                    if (_.isArray(object)) {
                        var lastElement = object[object.length - 1];
                        return lastElement ? lastElement[child] : null;
                    } else {
                        return object[child];
                    }
                },

                /**
                 * Set the value of the given property of the object, taking into account the special
                 * semantics of arrays.
                 * @param {Object|Array} object
                 * @param {String} child name of the property
                 * @param {*} value value to set
                 * @returns {*} the value that was set
                 * @private
                 */
                _setChild: function (object, child, value) {
                    if (_.isArray(object)) {
                        var lastElement = object[object.length - 1];
                        if (lastElement === null) {
                            lastElement = object[object.length - 1] = {};
                        }
                        lastElement[child] = value;
                    } else {
                        object[child] = value;
                    }
                    return value;
                },

                /**
                 * @param {String} path dot (.) delimited path to a value within the data
                 * @returns {String} dot (.) delimited path to a value within the data
                 * @private
                 */
                _getParentPath: function (path) {
                    var pos = path.lastIndexOf('.');
                    if (pos !== -1) {
                        return path.substring(0, pos);
                    } else {
                        return '';
                    }
                },

                /**
                 * @param {String} path dot (.) delimited path to a value within the data
                 * @returns {String}
                 * @private
                 */
                _getLastPathSegment: function (path) {
                    return path.split('.').pop();
                }
            });
    }
);

},
'dijit/form/MultiSelect':function(){
define([
	"dojo/_base/array", // indexOf, map, forEach
	"dojo/_base/declare", // declare
	"dojo/dom-geometry", // domGeometry.setMarginBox
	"dojo/sniff",	// has("android")
	"dojo/query", // query
	"./_FormValueWidget",
	"dojo/NodeList-dom"	// orphan()
], function(array, declare, domGeometry, has, query, _FormValueWidget){

	// module:
	//		dijit/form/MultiSelect

	var MultiSelect = declare("dijit.form.MultiSelect" + (has("dojo-bidi") ? "_NoBidi" : ""), _FormValueWidget, {
		// summary:
		//		Widget version of a `<select multiple=multiple>` element,
		//		for selecting multiple options.

		// size: Number
		//		Number of elements to display on a page
		//		NOTE: may be removed in version 2.0, since elements may have variable height;
		//		set the size via style="..." or CSS class names instead.
		size: 7,

		baseClass: "dijitMultiSelect",

		templateString: "<select multiple='multiple' ${!nameAttrSetting} data-dojo-attach-point='containerNode,focusNode' data-dojo-attach-event='onchange: _onChange'></select>",

		addSelected: function(/*dijit/form/MultiSelect*/ select){
			// summary:
			//		Move the selected nodes of a passed Select widget
			//		instance to this Select widget.
			//
			// example:
			// |	// move all the selected values from "bar" to "foo"
			// |	dijit.byId("foo").addSelected(dijit.byId("bar"));

			select.getSelected().forEach(function(n){
				this.containerNode.appendChild(n);
				// scroll to bottom to see item
				// cannot use scrollIntoView since <option> tags don't support all attributes
				// does not work on IE due to a bug where <select> always shows scrollTop = 0
				this.domNode.scrollTop = this.domNode.offsetHeight; // overshoot will be ignored
				// scrolling the source select is trickier esp. on safari who forgets to change the scrollbar size
				var oldscroll = select.domNode.scrollTop;
				select.domNode.scrollTop = 0;
				select.domNode.scrollTop = oldscroll;
			}, this);
			this._set('value', this.get('value'));
		},

		getSelected: function(){
			// summary:
			//		Access the NodeList of the selected options directly
			return query("option", this.containerNode).filter(function(n){
				return n.selected; // Boolean
			}); // dojo/NodeList
		},

		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works.
			// description:
			//		Returns an array of the selected options' values.

			// Don't call getSelect.map() because it doesn't return a real array,
			// and that messes up dojo.toJson() calls like in the Form.html test
			return array.map(this.getSelected(), function(n){
				return n.value;
			});
		},

		// Set multiple so parent form widget knows that I return multiple values.
		// Also adding a no-op custom setter; otherwise the multiple property is applied to the <select> node
		// which causes problem on Android < 4.4 with all but the first selected item being deselected.
		multiple: true,
		_setMultipleAttr: function(val){
		},

		_setValueAttr: function(/*String[]*/ values){
			// summary:
			//		Hook so set('value', values) works.
			// description:
			//		Set the value(s) of this Select based on passed values

			if(has("android")){
				// Workaround bizarre Android bug where deselecting one option selects another one.
				// See https://code.google.com/p/android/issues/detail?id=68285.
				// Could use this code path for all browsers but I worry about IE memory leaks.
				query("option", this.containerNode).orphan().forEach(function(n){
					var option = n.ownerDocument.createElement("option");
					option.value = n.value;
					option.selected = (array.indexOf(values, n.value) != -1);
					option.text = n.text;
					option.originalText = n.originalText;	// for bidi support, see has("dojo-bidi") block below
					this.containerNode.appendChild(option);
				}, this);
			}else {
				query("option", this.containerNode).forEach(function(n){
					n.selected = (array.indexOf(values, n.value) != -1);
				});
			}

			this.inherited(arguments);
		},

		invertSelection: function(/*Boolean?*/ onChange){
			// summary:
			//		Invert the selection
			// onChange: Boolean
			//		If false, onChange is not fired.
			var val = [];
			query("option", this.containerNode).forEach(function(n){
				if(!n.selected){
					val.push(n.value);
				}
			});
			this._setValueAttr(val, !(onChange === false || onChange == null));
		},

		_onChange: function(/*Event*/){
			this._handleOnChange(this.get('value'), true);
		},

		// for layout widgets:
		resize: function(/*Object*/ size){
			if(size){
				domGeometry.setMarginBox(this.domNode, size);
			}
		},

		postCreate: function(){
			this._set('value', this.get('value'));
			this.inherited(arguments);
		}
	});

	if(has("dojo-bidi")){
		MultiSelect = declare("dijit.form.MultiSelect", MultiSelect, {
			addSelected: function(/*dijit/form/MultiSelect*/ select){
				select.getSelected().forEach(function(n){
					n.text = this.enforceTextDirWithUcc(this.restoreOriginalText(n), n.text);
				}, this);
				this.inherited(arguments);
			},

			_setTextDirAttr: function(textDir){
				// to insure the code executed only when _BidiSupport loaded, and only
				// when there was a change in textDir
				if((this.textDir != textDir || !this._created) && this.enforceTextDirWithUcc){
					this._set("textDir", textDir);

					query("option", this.containerNode).forEach(function(option){
						// If the value wasn't defined explicitly, it the same object as
						// option.text. Since the option.text will be modified (by wrapping of UCC)
						// we want to save the original option.value for form submission.
						if(!this._created && option.value === option.text){
							option.value = option.text;
						}
						// apply the bidi support
						option.text = this.enforceTextDirWithUcc(option, option.originalText || option.text);
					}, this);
				}
			}
		});
	}

	return MultiSelect;
});

},
'abbott/editing/ui/formBasedEditor/orderingInformation/sortable/MolecularCatalogOrderingInformationFormBasedEditorSelect':function(){
/*jshint dojo:true devel:true strict:false*/
/*global define:true */
define([
    'module', 'vodori/provide', 'abbott/pandx/PanDxUtil',
    'abbott-shared/editing/ui/formBasedEditor/FormBasedEditorSelect'
], function (
    module, provide, PanDxUtil,
    FormBasedEditorSelect
) {

    var PRODUCTS_FOR_ORDER_NUMBER_ENDPOINT = '/ajax/product/getOrderingInformationForProductIdAndMarketId';

    /**
     * Extends the capabilities of the FormBasedEditorSelect to pull the contents for the select.
     *
     * Populates the Ordering Information dropdowns on MolecularCatalogWebpage.html with all available order numbers for the current market.
     *
     * Market is determined by the current channel prefix.
     */
    var MolecularCatalogOrderingInformationFormBasedEditorSelect = provide(module.id, [FormBasedEditorSelect], {


        /**
         * Array of options that will be set to be selectable in the widget. Should have a key and label values (used for
         * value and display text of option)
         *
         * {@type Object}
         */
        options: null,

        /**
         * Current market id, determined by the uri prefix in PanDxUtil
         */
        marketId: null,

        /**
         * Constructor for the widget. Resets the options field.
         */
        constructor: function() {
            this.inherited(arguments);
        },

        postCreate: function() {
            this.inherited(arguments);
            this.$domNode = this.domNode;
        },

        /**
         * In addition to the function of FormBasedEditorSelect, first populates the select with the ordering information
         */
        postMixInProperties: function() {
            this.inherited(arguments);
            this.options = [];
            this._loadOrderingInformation();
        },

        /**
         * Loads all ordering information for the current market into the widget's select field.
         */
        _loadOrderingInformation: function(){
            this._fetchOrderingInfo().success($.proxy(function(results) {
                // Add results into the widget
                $.each(results, $.proxy(function (index, orderInfos) {
                    this.options.push({
                        'key': orderInfos.orderInfoId,
                        'label': this._formatOptionString(orderInfos)
                    });
                }, this));

                if(this.options && this.options.length > 0) {
                    this._addOptionsToSelect();
                }
            }, this)).error(function (result){
                console.error("An error occurred retrieving ordering information. Result was: ", result);
                this.options = [];
            }, this);
        },

        /**
         * retrieves all ordering information for the given market. Market is determined by the current pages uri prefix
         * @returns {*}
         * @private
         */
        _fetchOrderingInfo: function() {
            return $.ajax(PRODUCTS_FOR_ORDER_NUMBER_ENDPOINT, {
                type: 'GET',
                data: {
                    marketId: PanDxUtil.getCurrentMarketId(),
                    orderNumber: ''
                },
                async:false
            })
        },

        /**
         * Builds the string to be used as the display value of the select option
         * @param orderingInformation
         * @returns {string}
         * @private
         */
        _formatOptionString: function(orderingInformation) {
            return orderingInformation.orderNumber + '  -  '  + this._getProductDisplayName(orderingInformation)+ ' (Regulatory Status: ' + orderingInformation.regulatoryStatus + ', GTIN: ' + orderingInformation.gtin + ')';
        },

        /**
         * Returns the value to use as the product name. Uses product display name if present, otherwise product name
         * @param orderingInformation
         * @returns {*}
         * @private
         */
        _getProductDisplayName: function(orderingInformation) {
            return orderingInformation.productDisplayName ? orderingInformation.productDisplayName : orderingInformation.productName;
        },

        /**
         * Adds all the current options to the select tag for this widget.
         */
        _addOptionsToSelect: function() {
            var $selectTag = $('select', this.srcNodeRef);

            var hiddenInputValue = this.hiddenInputValue;

            $.each(this.options, function(i, orderingInformationOption){
                $selectTag.append(
                    $("<option/>", {

                        value: orderingInformationOption.key,
                        html: orderingInformationOption.label,
                        selected: orderingInformationOption.key === hiddenInputValue
                    })
                );
            });
        }

    });

    return MolecularCatalogOrderingInformationFormBasedEditorSelect;
});
},
'abbott-shared/editing/ui/formBasedEditor/FormBasedEditorSelect':function(){
/*jshint dojo:true devel:true strict:false*/
/*global define:true */
define([
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'dojo/on', 'dojo/query',
    'dojo/dom-attr',
    'dijit/_WidgetBase'
], function (
    module, provide,
    lang,
    on, query,
    domAttr,
    _WidgetBase
) {

    /**
     * Extends the capabilities of the form based editor to work on HTML select elements. Select elements support
     * more than one value attribute, via the option elements. The standard FormBasedEditor expects a single value
     * attribute which really limits us to only input elements. This widget works by taking a hidden input and
     * select element. When an onchange event occurs on the select element, the selected value is set on the hidden
     * input, which can then be used by the standard FormBasedEditor.
     *
     * Example:
     *
     * <div data-dojo-type="abbott-shared/editing/ui/FormBasedEditorSelect">
     *      <input class="select-value" style="display: none !important;" data-parse="pastEvents.event_icon" type="text" />
     *      <select>
     *          <option value="ARTICLE">Article</option>
     *          <option value="ISSUE">Issue</option>
     *          <option value="PRESENTATION">Presentation</option>
     *          <option value="VIDEO">Video</option>
     *          <option value="WEBINAR">Webinar</option>
     *      </select>
     * </div>
     *
     * This widget should live inside of a FormBasedEditor as such:
     *
     * <div data-dojo-type="vodori.input.FormBasedEditor" ... >
     *     ...
     *
     *     <div data-dojo-type="abbott-shared/editing/ui/FormBasedEditorSelect">
     *         <input class="select-value" style="display: none !important;" data-parse="someValue.value" type="text" />
     *         <select>
     *             <option value="VALUE_1">Value 1</option>
     *             <option value="VALUE_2">Value 2</option>
     *             <option value="VALUE_3">Value 3</option>
     *         </select>
     *     </div>
     *
     *     ...
     * </div>
     *
     * The FormBasedEditorSelects hidden input MUST have a class of 'select-value' in order to be parsed correctly.
     * The hidden input should also provide the data-parse attribute data for the FormBasedEditor.
     */
    var FormBasedEditorSelect = provide(module.id, [_WidgetBase], {

        hiddenInput: null,
        hiddenInputValue: null,
        selectNode: null,

        /**
         * Set/Update any properties
         */
        postMixInProperties: function() {
            this.inherited(arguments);

            var defaultInput = query('option.select-default', this.srcNodeRef)[0];
            this.hiddenInput = query('input.select-value', this.srcNodeRef)[0];
            this.selectNode = query('select', this.srcNodeRef)[0];

            // If a select option has the class 'select-default' on it, and the hiddenInput value is not yet set, set it to the default
            if(this.hiddenInput.value === "" && defaultInput !== undefined) {
                this.hiddenInput.value = defaultInput.value;
            }

            // Set the selected element on the select node to the value on the hiddenInput
            this.hiddenInputValue = this.hiddenInput.value;
            this.selectNode.value = this.hiddenInputValue;
        },

        /**
         * Setup the widget
         */
        postCreate: function() {

            // make sure to set the input value to the default value of the select
            this._maintainHiddenInputValue();

            // watch for changes and update accordingly
            on(this.selectNode, 'change', lang.hitch(this, '_maintainHiddenInputValue'));
        },

        /**
         * Fired on widget startup & when the user selects a new item in the select widget.
         * This function handles setting the value on the hidden input element on this widget.
         *
         * If there are no selected options on the select, update the value of the hidden input to that
         * of the first select element (and make sure the first select element is appropriately shown)
         *
         * @private
         */
        _maintainHiddenInputValue: function() {

            // update the hidden input value to that of the selected option
            if (this.selectNode.selectedOptions[0]) {
                domAttr.set(this.hiddenInput, 'value', this.selectNode.selectedOptions[0].value);
            }

            // no selected options so update the value of the hidden input to that
            // of the first select element (and make sure the first select element is appropriately shown)
            else if (this.selectNode[0]) {
                domAttr.set(this.hiddenInput, 'value', this.selectNode[0].value);
                this.selectNode.value = this.selectNode[0].value;
            }
        }

    });

    return FormBasedEditorSelect;
});
},
'abbott/editing/ui/formBasedEditor/orderingInformation/sortable/MolecularCatalogOrderingInformationSingleRowRenderer':function(){
define([
    'module',
    'lodash',
    'vodori/provide', 'vodori/renderTemplate',
    'dijit/_WidgetBase', 'abbott/pandx/PanDxUtil',
    'dojo/parser',
    'dojo/text!abbott/editing/ui/block/formBased/orderingInformation/sortable/MolecularCatalogOrderingInformationSingleRowTemplate.html'
], function (
    module,
    _,
    provide, renderTemplate,
    _WidgetBase, PanDxUtil,
    parser,
    MolecularCatalogOrderingInformationSingleRowTemplate
) {

    var PRODUCTS_FOR_ORDER_NUMBER_ENDPOINT = '/ajax/product/getOrderingInformationForOrderNumberIdAndMarketId';

    /**
     * Renders a single row of the Sortable Ordering Information section of the MoelcularCatalogWebpage.html FBE
     */
    return provide(module.id, [_WidgetBase], {

        $domNode: null,

        /**
         * Order Info Ids selected via the Sortable Ordering Information section on the FBE
         */
        orderInfoId: null,

        postCreate: function () {
            this.inherited(arguments);
            this.$domNode = $(this.domNode);
            if (this.orderInfoId) {
                this._populateOrderingInfo();

            }
        },

        /**
         * Retrieves the ordering information for the given order number id and market. Information is then used to render the ordering information table on the Catalog FBE
         * @private
         */
        _populateOrderingInfo: function () {
            if (this.orderInfoId) {
                $.ajax(PRODUCTS_FOR_ORDER_NUMBER_ENDPOINT, {
                    type: 'GET',
                    data: {
                        orderNumberIds: this.orderInfoId,
                        marketId: PanDxUtil.getCurrentMarketId()
                    }
                }).success($.proxy(function (results) {
                    // if there is more than one result, this an indiciation of bad data.
                    // Just grab the first result so the ordering information table renders correctly
                    if(results && results.length >1) {
                        results = results[0];
                    }

                    this._renderOrderingInfoTemplate(results);
                }, this));
            }
        },

        /**
         * Renders the Ordering Information section of the Molecular Catalog FBe
         * @param orderingInformation - array of ProductCatalogBlockOrderingInfoDTO retrieved for the given order info ids and market id
         * @private
         */
        _renderOrderingInfoTemplate: function(orderingInformation) {
            this.$domNode.html(renderTemplate(MolecularCatalogOrderingInformationSingleRowTemplate, {
                orderingInformation: orderingInformation,
                orderingInformationHeader: this.orderingInformationHeader
            }));
        }
    });
});

},
'abbott/editing/ui/formBasedEditor/CertificateOfAnalysisBlock':function(){
define([
    'vodori/provide',
    'dijit/_WidgetBase',
    'module',
    'abbott-shared/ui/form/PandxValidatingForm',
    'abbott/pandx/PanDxUtil',
    'dojo/query'
], function (provide,
             _WidgetBase,
             module,
             PandxValidatingForm,
             PanDxUtil,
             query) {

    // Selectors
    var CLEAR_BUTTON = '.js--clear-button';
    var SEARCH_BUTTON_SELECTOR = '.js--search-button';
    var SEARCH_RESULTS_SELECTOR = '.js--search-results';
    var SEARCH_RESULTS_TABLE_SELECTOR = '.js--results-table';
    var NO_RESULTS_ERROR_SELECTOR = '.js--no-results-error';
    var SERVER_ERROR_SELECTOR = '.js--server-error';
    var ERROR_MESSAGE_SELECTOR = '.error-message';
    var FORM_SELECTOR = '.js--coa-form';
    var INPUT_SELECTOR = 'input';

    // Endpoints
    var GET_COA_DOCUMENTS = "/amd/ajax/technical-library/query-coa";

    // Misc
    var HIDDEN_CLASS = 'u-hide';
    var DISABLED_CLASS_AND_ATTRIBUTE = 'disabled';
    var ENTER_KEY_KEYCODE = 13;
    var DATA_FETCH_SUCCESS_CODE = 0;
    var DATA_FETCH_USER_ERROR_CODE = -2;

    return provide(module.id, [PandxValidatingForm], {

        /**
         * The root DOM node for this widget.
         *
         * {@type jQuery}
         */
        $domNode: null,

        postCreate: function() {
            this.inherited(arguments);
            this.$domNode = $(this.domNode);

            // Initialize our listeners
            this.initListeners();
        },

        /**
         * Initialize our DOM listeners.
         */
        initListeners: function() {
            // Reset our form when the clear button is clicked
            $(CLEAR_BUTTON, this.$domNode).on('click', $.proxy(function() {
                this.reset();
                this.resetCoaResults();
            }, this));

            $(SEARCH_BUTTON_SELECTOR, this.$domNode).on('click', $.proxy(function() {
                this.submitForm();
            }, this));

            $(FORM_SELECTOR).find(INPUT_SELECTOR).keypress($.proxy(function(e){
                if (e.which === ENTER_KEY_KEYCODE) {
                    this.submitForm();
                    return false;
                }
            }, this));
        },

        /**
         * Handles submitting of the form.
         */
        submitForm: function() {
            var isFormValid = this._validateForm();

            // Validate our form and submit it if it is valid
            if(isFormValid) {
                // Clear our front-end errors as they sometimes do not clear on submit
                this.clearFrontEndErrors();

                this.toggleSearchInProgress(true);

                // Extract our form data
                var formData = this.$domNode.serializeJSON();
                $.ajax(GET_COA_DOCUMENTS, {
                    type: 'POST',
                    data: JSON.stringify(formData),
                    headers: PanDxUtil.getPostHeaders()
                }).success($.proxy(function(results) {
                    if(this.isResults(results)) {
                        this.renderSearchResultTable(results);
                    } else if(this.isNoResults(results)) {
                        $(NO_RESULTS_ERROR_SELECTOR, this.$domNode).show();
                    } else {
                        $(SERVER_ERROR_SELECTOR, this.$domNode).show();
                    }

                    this.toggleSearchInProgress(false);

                }, this)).error($.proxy(function() {

                    $(SERVER_ERROR_SELECTOR, this.$domNode).show();

                    this.toggleSearchInProgress(false);

                }, this));

            }

            return false;
        },

        /**
         * Returns if there are results. This is true if a success code comes back and there are results sent back.
         *
         * @param results - the CoA result from the backend
         * @returns {boolean} - whether or not there are CoA results to display
         */
        isResults: function(results) {
            return results.code === DATA_FETCH_SUCCESS_CODE && results.details.length > 0;
        },

        /**
         * Returns if there are no results. This is true if there a user error code comes back
         * or there are no results sent back.
         *
         * @param results - the CoA results from the backend
         * @returns {boolean} - whether or not there aren't any CoA results to display
         */
        isNoResults: function(results) {
            return results.code === DATA_FETCH_USER_ERROR_CODE || results.details.length <= 0;
        },

        /**
         * Tasks to do when a search is in progress.
         * We disable the submit button and hide the search results header when the search is in progress.
         *
         * @param searchInProgress - whether the search is in progress is not
         */
        toggleSearchInProgress: function(searchInProgress) {
            if(!searchInProgress) {
                // Enable the submit button
                this.enableElement(SEARCH_BUTTON_SELECTOR);

            } else {
                // Disable the submit button
                this.disableElement(SEARCH_BUTTON_SELECTOR);

                // resets the CoA results (errors, search results table)
                this.resetCoaResults();
            }
        },

        /**
         * Renders the search results table. Takes the results and renders the correct table cells.
         *
         * @param results - the results to put into the table
         */
        renderSearchResultTable: function(result) {
            var fileSize = result.details[0].fileSize || window.coaTranslations.coaResultFileSizeEmpty
            var lotNumber = result.details[0].lotNumber || window.coaTranslations.coaResultLotNumberEmpty
            var reportName = result.details[0].reportName || window.coaTranslations.coaResultReportNameEmpty

            $(SEARCH_RESULTS_SELECTOR, this.$domNode)
                .append("<td><a href=\"/certificate-of-analysis-download.html?id=" + lotNumber + "\">" + reportName + "<i class=\"icon download\" style=\"margin-left: 7px\"></i></a></td>" +
                    "<td>" + fileSize + "</td>" +
                    "<td>" + lotNumber + "</td>")

            this.showElement(SEARCH_RESULTS_TABLE_SELECTOR);
        },

        /**
         * resets the CoA results (errors, search results table)
         */
        resetCoaResults: function() {
            // Hide the search results
            this.hideElement(SEARCH_RESULTS_TABLE_SELECTOR);

            // Clear our table while we generate a new one
            $(SEARCH_RESULTS_SELECTOR, this.$domNode).empty();

            // Hide our error message
            $(ERROR_MESSAGE_SELECTOR, this.$domNode).hide();
        },

        /**
         * Calls a function in the PanDxValidatingForm component that clears our front-end errors.
         */
        clearFrontEndErrors: function() {
            query(this.fieldEntry, this.domNode).forEach($.proxy(function(entry){
                this._removeFrontEndErrors(entry);
            }, this));
        },

        /**
         * Disables an element.
         * We add the disabled attribute to physically disable it, and then the disabled class to make it appear disabled.
         *
         * @param selector - the selector of the element to disable
         */
        disableElement: function(selector) {
            $(selector, this.$domNode).attr(DISABLED_CLASS_AND_ATTRIBUTE, true);
            $(selector, this.$domNode).addClass(DISABLED_CLASS_AND_ATTRIBUTE);
        },

        /**
         * Enables an element.
         * We remove the disabled attribute to physically enable it, and then remove the disabled class to make it appear enabled.
         *
         * @param selector - the selector of the element to enable
         */
        enableElement: function(selector) {
            $(selector, this.$domNode).removeAttr(DISABLED_CLASS_AND_ATTRIBUTE);
            $(selector, this.$domNode).removeClass(DISABLED_CLASS_AND_ATTRIBUTE);
        },

        /**
         * Hides an element.
         *
         * @param selector - the selector of the element to hide
         */
        hideElement: function(selector) {
            $(selector, this.$domNode).addClass(HIDDEN_CLASS);
        },

        /**
         * Shows an element.
         *
         * @param selector - the selector of the element to show
         */
        showElement: function(selector) {
            $(selector, this.$domNode).removeClass(HIDDEN_CLASS);
        }
    });
});
},
'abbott/editing/ui/formBasedEditor/InstructionsForUseBlock':function(){
define([
    'vodori/provide',
    'dijit/_WidgetBase',
    'module',
    'dojo/topic',
    'abbott/pandx/ifu/InstructionsForUseEvents',
    'abbott/pandx/PanDxUtil',
    'vodori/renderTemplate',
    'dojo/text!../block/formBased/instructionsForUse/InstructionsForUseBlockLanguageDropdownOptions.html',
    'dojo/text!../block/formBased/instructionsForUse/InstructionsForUseBlockSearchOptionsDropdownOptions.html',
    'dojo/text!../block/formBased/instructionsForUse/InstructionsForUseBlockProductGroupDropdownOptions.html'
], function (provide,
             _WidgetBase,
             module,
             topic,
             instructionsForUseEvents,
             PanDxUtil,
             renderTemplate,
             languageDropdownOptionsTemplate,
             searchOptionsDropdownOptionsTemplate,
             productGroupDropdownOptionsTemplate) {

    // Endpoints
    var GET_ALL_IFU_LANGUAGES_URI = "/ifu/languages";
    var GET_ALL_IFU_SEARCH_OPTIONS_URI = "/ifu/search-options";
    var GET_IFU_DOCUMENTS_URI = "/amd/ajax/technical-library/query-ifu";

    // Selectors
    var SEARCH_OPTION_ENTRY_SELECTOR = '.js--search-option-entry';
    var SEARCH_OPTION_DROPDOWN_SELECTOR = '.js--search-option-dropdown';
    var SEARCH_OPTION_INPUT_CONTAINER_SELECTOR = '.js--search-option-input-container';
    var SEARCH_OPTION_INPUT_SELECTOR = '.js--search-option-input';
    var SEARCH_OPTION_DROPDOWN_SELECTED_SELECTOR = '.js--search-option-dropdown :selected';
    var SEARCH_OPTION_LABEL_SELECTOR = '.js--search-option-label';
    var SEARCH_BUTTON_SELECTOR = '.js--search-button';
    var FORM_SELECTOR = '.js--ifu-form';
    var INPUT_SELECTOR = 'input';
    var SEARCH_RESULTS_SELECTOR = '.js--search-results';
    var SEARCH_RESULTS_TABLE_SELECTOR = '.js--results-table';
    var NO_RESULTS_ERROR_SELECTOR = '.js--no-results-error';
    var SERVER_ERROR_SELECTOR = '.js--server-error';
    var ERROR_MESSAGE_SELECTOR = '.error-message';

    var PRODUCT_GROUP_CONTAINER_SELECTOR = '.js--product-group-container';
    var PRODUCT_GROUP_DROPDOWN_SELECTOR = '.js--product-group-dropdown';
    var DOCUMENT_LANGUAGE_DROPDOWN_SELECTOR = '.js--language-dropdown';

    // Misc
    var HIDDEN_CLASS = 'u-hide';
    var DISABLED_CLASS_AND_ATTRIBUTE = 'disabled';
    var DEFAULT_LANGUAGE_CODE = "ENG";
    var DEFAULT_SEARCH_OPTION = "LOT_NUMBER";
    var PRODUCT_GROUP_SEARCH_OPTION = 'PRODUCT_GROUP';
    var ENTER_KEY_KEYCODE = 13;
    var DATA_FETCH_SUCCESS_CODE = 0;
    var DATA_FETCH_SUCCESS_WITH_EXPIRED_DOCS_CODE = 1;
    var DATA_FETCH_USER_ERROR_CODE = -2;

    return provide(module.id, [_WidgetBase], {

        /**
         * The root DOM node for this widget.
         *
         * {@type jQuery}
         */
        $domNode: null,

        postCreate: function() {
            this.inherited(arguments);
            this.$domNode = $(this.domNode);

            // Fetch all IFU search options and render them in the dropdown
            this.fetchAndRenderIfuSearchOptions();

            // Fetch all IFU languages and render them in the dropdown
            this.fetchAndRenderIfuLanguages();

            // Initialize our listeners
            this.initListeners();
        },

        /**
         * Fetches all IFU languages and then renders them in the dropdown.
         */
        fetchAndRenderIfuLanguages: function() {
            // Retrieve all IFU languages to render in our language dropdown
            $.get(GET_ALL_IFU_LANGUAGES_URI)
                .then($.proxy(function(data) {
                    // Set the English one to selected so that it is selected in our template by default
                    data.forEach(function(option) {
                       if(option.code === DEFAULT_LANGUAGE_CODE) {
                           option.selected = true;
                       }
                    });

                    // Generate our dropdown options markup
                    var dropdownOptionsMarkup = renderTemplate(languageDropdownOptionsTemplate, {
                        options: data
                    });

                    // Insert our markup into the dropdown
                    $(DOCUMENT_LANGUAGE_DROPDOWN_SELECTOR, this.$domNode).html(dropdownOptionsMarkup);
                }, this));
        },

        /**
         * Fetches all IFU search options and then renders them in the dropdown.
         */
        fetchAndRenderIfuSearchOptions: function() {
            $.get(GET_ALL_IFU_SEARCH_OPTIONS_URI)
                .then($.proxy(function(data) {
                    // Set the lot number to be the default search option
                    data.forEach(function(option) {
                        if(option.searchValue === DEFAULT_SEARCH_OPTION) {
                            option.selected = true;
                        }
                    });

                    // Generate our dropdown options markup
                    var dropdownOptionsMarkup = renderTemplate(searchOptionsDropdownOptionsTemplate, {
                        options: data
                    });

                    // Insert our markup into the dropdown
                    $(SEARCH_OPTION_DROPDOWN_SELECTOR, this.$domNode).html(dropdownOptionsMarkup);

                    // Extract the product group search option child options for our dropdown
                    var productGroupSearchOption = data.find(function(searchOption) {
                        return searchOption.searchValue === PRODUCT_GROUP_SEARCH_OPTION;
                    });
                    this.renderProductGroupOptions(productGroupSearchOption);

                    // Update the search option label after we fetch our data
                    this.updateSearchOptionLabel();
                }, this))
        },

        /**
         * Renders options in our product group dropdown based on the options passed in.
         *
         * @param productGroupSearchOption - the product group option to render in our dropdown
         */
        renderProductGroupOptions: function(productGroupSearchOption) {
            var options = [];
            var optionValues = productGroupSearchOption.childOptions;
            var optionsTranslated = productGroupSearchOption.childOptionsTranslations;

            // Merge our option values and translations into single array of objects
            optionValues.forEach(function(option, index) {
                options.push({
                    value: option,
                    displayValue: optionsTranslated[index]
                })
            });

            // Generate our dropdown options markup
            var dropdownOptionsMarkup = renderTemplate(productGroupDropdownOptionsTemplate, {
                options: options
            });

            // Insert our markup into the dropdown
            $(PRODUCT_GROUP_DROPDOWN_SELECTOR, this.$domNode).html(dropdownOptionsMarkup);
        },

        /**
         * Initialize our DOM listeners.
         */
        initListeners: function() {
            // Listener for when the form is submitted
            $(SEARCH_BUTTON_SELECTOR, this.$domNode).on('click', $.proxy(function() {
                this.submitForm();
            }, this));

            // Listener for pressing enter in an input, should submit the form and prevent the default form action (page reload)
            $(FORM_SELECTOR).find(INPUT_SELECTOR).keypress($.proxy(function(e){
                if (e.which === ENTER_KEY_KEYCODE) {
                    this.submitForm();
                    return false;
                }
            }, this));

            // Listener for when the existing probe name dropdown changes
            $(SEARCH_OPTION_DROPDOWN_SELECTOR, this.$domNode).change($.proxy(function() {
                this.activateCorrectSearchOptionInput();
            }, this));
        },

        /**
         * Handles submitting of the form when the user clicks search.
         */
        submitForm: function() {
            // Extract our form data
            var formData = $(FORM_SELECTOR, this.$domNode).serializeJSON();

            // Disable the submit button & search results header when our search kicks off
            this.toggleSearchInProgress(true);

            // Make a POST to get our documents back
            $.ajax(GET_IFU_DOCUMENTS_URI, {
                type: 'POST',
                data: JSON.stringify(formData),
                headers: PanDxUtil.getPostHeaders()
            }).success($.proxy(function(results) {
                if(this.isResults(results)) {
                    this.renderSearchResultsTable(results.details);
                } else if(this.isNoResults(results)) {
                    // Show our no results error message
                    $(NO_RESULTS_ERROR_SELECTOR, this.$domNode).show();
                } else {
                    // Show our server error message
                    $(SERVER_ERROR_SELECTOR, this.$domNode).show();
                }

                // Re-enable the submit button & search results header when our request returns
                this.toggleSearchInProgress(false);

                // Show our expired modal if there are expired docs
                if(this.resultsHaveExpiredDocs(results.code)) {
                    topic.publish(instructionsForUseEvents.events.showLotNumberExpiredModal);
                }
            }, this)).error($.proxy(function() {
                // Show our server error message
                $(SERVER_ERROR_SELECTOR, this.$domNode).show();

                // Re-enable the submit button & search results header when our request returns
                this.toggleSearchInProgress(false);
            }, this));
        },

        /**
         * Returns if there are expired docs in our results.
         *
         * @param responseCode - the response code sent from the backend
         * @returns {boolean} - true if there are expired docs, false otherwise
         */
        resultsHaveExpiredDocs: function(responseCode) {
            return responseCode === DATA_FETCH_SUCCESS_WITH_EXPIRED_DOCS_CODE;
        },

        /**
         * Returns if there are results. This is true if a success code comes back and there are results sent back.
         *
         * @param results - the IFU results from the backend
         * @returns {boolean} - whether or not there are IFU results to display
         */
        isResults: function(results) {
            return (results.code === DATA_FETCH_SUCCESS_CODE || this.resultsHaveExpiredDocs(results.code)) &&
                results.details.length > 0;
        },

        /**
         * Returns if there are no results. This is true if there a user error code comes back
         * or there are no results sent back.
         *
         * @param results - the IFU results from the backend
         * @returns {boolean} - whether or not there aren't any IFU results to display
         */
        isNoResults: function(results) {
            return results.code === DATA_FETCH_USER_ERROR_CODE ||
                results.details.length <= 0;
        },

        /**
         * Tasks to do when a search is in progress.
         * We disable the submit button and hide the search results header when the search is in progress.
         *
         * @param searchInProgress - whether the search is in progress is not
         */
        toggleSearchInProgress: function(searchInProgress) {
            if(!searchInProgress) {
                // Enable the submit button
                this.enableElement(SEARCH_BUTTON_SELECTOR);

                // Show the search results
                this.showElement(SEARCH_RESULTS_SELECTOR);
            } else {
                // Disable the submit button
                this.disableElement(SEARCH_BUTTON_SELECTOR);

                // Hide the search results
                this.hideElement(SEARCH_RESULTS_SELECTOR);

                // Clear our table while we generate a new one
                $(SEARCH_RESULTS_TABLE_SELECTOR, this.$domNode).empty();

                // Hide our error message
                $(ERROR_MESSAGE_SELECTOR, this.$domNode).hide();
            }
        },

        /**
         * Renders the search results table. Takes the results and renders the correct table cells.
         *
         * @param results - the results to put into the table
         */
        renderSearchResultsTable: function(results) {
            // Initialize the JS grid with the results data
            $(SEARCH_RESULTS_TABLE_SELECTOR, this.$domNode).jsGrid({
                width: "100%",
                sorting: true,
                data: results,
                fields: [
                    {
                        name: "productName",
                        type: "text",
                        title: window.ifuTranslations.tableHeaderProductName,
                        itemTemplate: function(value, item) {
                            return '<a target="_blank" href=' + item.downloadLink + '>' + item.productName + '<i class="icon download download-link"></i></a>';
                        }
                    },
                    {
                        name: "lotDetails",
                        type: "text",
                        title: window.ifuTranslations.tableHeaderLotDetails,
                        sorting: false,
                        itemTemplate: function(value, item) {
                            var lotExpirationDate = item.lotExpirationDate ? moment(item.lotExpirationDate).format('DD MMM YYYY') : 'N/A';
                            return "<div class='lot-number-container'><p><b>" + window.ifuTranslations.tableSubHeaderLotNumber + "</b></p><p>" + item.lotNumber + "</p></div><div><p><b>" + window.ifuTranslations.tableSubHeaderLotNumberExpiration + "</b></p><p>" + lotExpirationDate + "</p></div>"
                        }
                    },
                    { name: "productGroup", type: "text", title: window.ifuTranslations.tableHeaderProductGroup },
                    { name: "orderNumber", type: "text", title: window.ifuTranslations.tableHeaderOrderNumber },
                    { name: "insertNumber", type: "text", title: window.ifuTranslations.tableHeaderInsertNumber },
                    { name: "revision", type: "text", title: window.ifuTranslations.tableHeaderRevision }
                ]
            }).jsGrid("sort", "productName");   // Apply a sort by default
        },

        /**
         * Hides/disables all search option inputs and shows/enables the correct input based on the search option
         * selected in the dropdown.
         */
        activateCorrectSearchOptionInput: function() {
            // Clear the input field and hide all search options so we can show a new one
            this.hideElement(SEARCH_OPTION_ENTRY_SELECTOR);
            $(SEARCH_OPTION_INPUT_SELECTOR, this.$domNode).val('');

            // Based on which search option is chosen, show and enable the correct input
            var searchOption = $(SEARCH_OPTION_DROPDOWN_SELECTOR, this.$domNode).val();
            if(searchOption === PRODUCT_GROUP_SEARCH_OPTION) {
                this.showElement(PRODUCT_GROUP_CONTAINER_SELECTOR);
            } else {
                this.showElement(SEARCH_OPTION_INPUT_CONTAINER_SELECTOR);
            }

            // Update the search option label as the search option has changed
            this.updateSearchOptionLabel();
        },

        /**
         * Updates the search option label to be the text value currently selected in the search option dropdown.
         */
        updateSearchOptionLabel: function() {
            var searchOptionLabel = $(SEARCH_OPTION_DROPDOWN_SELECTED_SELECTOR, this.$domNode).text();
            $(SEARCH_OPTION_LABEL_SELECTOR, this.$domNode).text(searchOptionLabel);
        },

        /**
         * Disables an element.
         * We add the disabled attribute to physically disable it, and then the disabled class to make it appear disabled.
         *
         * @param selector - the selector of the element to disable
         */
        disableElement: function(selector) {
            $(selector, this.$domNode).attr(DISABLED_CLASS_AND_ATTRIBUTE, true);
            $(selector, this.$domNode).addClass(DISABLED_CLASS_AND_ATTRIBUTE);
        },

        /**
         * Enables an element.
         * We remove the disabled attribute to physically enable it, and then remove the disabled class to make it appear enabled.
         *
         * @param selector - the selector of the element to enable
         */
        enableElement: function(selector) {
            $(selector, this.$domNode).removeAttr(DISABLED_CLASS_AND_ATTRIBUTE);
            $(selector, this.$domNode).removeClass(DISABLED_CLASS_AND_ATTRIBUTE);
        },

        /**
         * Hides an element.
         *
         * @param selector - the selector of the element to hide
         */
        hideElement: function(selector) {
            $(selector, this.$domNode).addClass(HIDDEN_CLASS);
        },

        /**
         * Shows an element.
         *
         * @param selector - the selector of the element to show
         */
        showElement: function(selector) {
            $(selector, this.$domNode).removeClass(HIDDEN_CLASS);
        }
    });
});
},
'abbott/pandx/ifu/InstructionsForUseEvents':function(){
define({
    events: {
        // Fired when we should show the lot number expired modal
        showLotNumberExpiredModal: 'instructionsForUse/showLotNumberExpiredModal'
    }
});
},
'abbott/editing/ui/formBasedEditor/PanelBackgroundVideoWithImageOverlayBlock':function(){
define([
    'module',
    'vodori/provide',
    'dojo/_base/lang',
    'abbott-shared/util/linkTransformationUtil',
    'dojo/topic',
    'dojo/window',
    'dojo/ready',
    'abbott-shared/util/responsiveUtil',
    'abbott-shared/util/events',
    'dijit/_WidgetBase'
], function(module,
            provide,
            lang,
            linkTransformationUtil,
            topic,
            win,
            ready,
            responsiveUtil,
            events,
            _WidgetBase
) {
    var BREADCRUMBS_SELECTOR = '.breadcrumbs-container',
        VIDEO_CONTENT_SELECTOR = '.panel-video-content',
        VIDEO_CONTENT_BACKGROUND = '.panel-video-background',

        VIDEO_CONTENT_PADDING_HEIGHT = 40,
        MOBILE_IMAGE_HEIGHT = 150,
        BREAK_MOBILE = 480;

    return provide(module.id, [_WidgetBase], {

        /**
         * jQuery element containing outermost node of current PanelBackgroundVideo
         */
        $domNode: null,

        /**
         * jQuery element containing our breadcrumbs container to show if required
         */
        $breadcrumbsContainer: null,

        /**
         * jQuery element that we initialized Vide on (jQuery plugin used for the background video)
         */
        $videDiv: null,

        /**
         *  jQuery element containing the HTML video player for the background video.
         *  Used to pause and play the video
         */
        $backgroundVideoPlayer: null,

        /**
         * jQuery element containing the content that overlays the background video.
         * Used to calculate the heights of its inner elements so they can correctly display on mobile
         */
        $contentDiv: null,

        /**
         * Current maximum height among all divs within $contentDiv (for mobile viewport only)
         */
        maxHeight: null,

        /**
         * path to the background video.  Passed in as prop
         * The URI of the video is wrapped in "url(...)" so that Pepper creates a relationship, so it will need
         * to be unwrapped before use.
         */
        pathToVideo: null,

        /**
         * path to the poster image used when one mobile or tablet.  Passed in as prop
         * The URI of the image is wrapped in "url(...)" so that Pepper creates a relationship, so it will need
         * to be unwrapped before use.
         */
        pathToPosterImage: null,

        /**
         * file extension for poster image, ex ('jpg', 'png').  Used so Vide only makes 1 request for the poster image, instead of multiple.
         */
        posterImageFileExtension: null,


        postCreate: function() {

            // Exit early if jQuery doesn't exist on the page
            if (typeof $ != 'function') { return; }

            this.inherited(arguments);

            this.initDomNodes();
            this.extractLinkFromUrls();
            this.setPosterImageFileExtension();
            this.initBackgroundVideo();
            this.handleVideoPlayerEvents();
            this.showBreadcrumbs();
        },

        startup: function() {
            this.inherited(arguments);
            this.$contentDiv = $(VIDEO_CONTENT_SELECTOR, this.$domNode);
            this.getBackgroundVideoPlayer();
            this.handleMobileContentHeightAdjust();
        },

        /**
         * Initiates the background video
         */
        initBackgroundVideo: function () {
            this.$videDiv.vide({
                mp4: this.pathToVideo,
                poster: this.pathToPosterImage
            }, { posterType: this.posterImageFileExtension });
        },

        /**
         * Initialize our domNode elements
         */
        initDomNodes: function() {
            this.$domNode = $(this.domNode);
            this.$videDiv = $(VIDEO_CONTENT_BACKGROUND, this.$domNode);
            this.$breadcrumbsContainer = this.$domNode.find(BREADCRUMBS_SELECTOR);
        },

        /**
         * Extracts link from url(LINK) wrapper so the video or image can display correctly.
         * Links are originally wrapped in url to create pepper relationship
         */
        extractLinkFromUrls: function() {
            this.pathToVideo = linkTransformationUtil.getLinkFromUrlWrapper(this.pathToVideo);
            this.pathToPosterImage = linkTransformationUtil.getLinkFromUrlWrapper(this.pathToPosterImage);
        },

        /**
         * Sets the file extension for the poster image. Used so Vide only makes 1 request for the poster
         * Defaults to no poster image if no fileExtension exists
         */
        setPosterImageFileExtension: function() {
            var fileExtension = this.pathToPosterImage.split('.').pop();
            this.posterImageFileExtension = fileExtension || 'none';
        },

        /**
         * Gets HTML video player for background video
         */
        getBackgroundVideoPlayer: function () {
            var instance = this.$videDiv.data('vide');
            this.$backgroundVideoPlayer = instance.getVideoObject();
        },

        /**
         * Subscribes to events emitted by the video player (on open and close). When the video player is opened, we
         * pause the background video. When the video player is closed, we play the background video
         */
        handleVideoPlayerEvents: function() {
            // Listener for when a video is opened on the current page, used to stop pause the background video
            this.own(topic.subscribe(events.videoPlayer.videoOpen,  $.proxy(function() {
                this.pauseBackgroundVideo();
            }, this)));
            // Listener for when a video is closed on the current page, used to play the background video
            this.own(topic.subscribe(events.videoPlayer.videoClose,  $.proxy(function() {
                this.playBackgroundVideo();
            }, this)));
        },

        /**
         * Plays Background video
         */
        playBackgroundVideo: function() {
            this.$backgroundVideoPlayer.play();
        },

        /**
         * Pauses Background video
         */
        pauseBackgroundVideo: function() {
            this.$backgroundVideoPlayer.pause();
        },


        /**
         * shows the $breadcrumbsContainer
         */
        showBreadcrumbs: function() {
            this.$breadcrumbsContainer.show();
        },

        /**
         * Compute height of $contentDiv's children and stores the maxHeight
         */
        updateMobileContentMaxHeight: function() {
            var contentHeight = 0;
            // The $contentDiv is absolutely positioned, so it's height must be computed by adding up the outer
            // heights of it's children
            this.$contentDiv.children().each($.proxy(function(i, childElem) {
                contentHeight += $(childElem).outerHeight(true);
            }, this));

            this.maxHeight = contentHeight + VIDEO_CONTENT_PADDING_HEIGHT;
        },

        /**
         * When mobile breakpoint is passed, either adjust $contentDiv height or clear inline height
         */
        handleMobileContentHeightAdjust: function() {

            // On page load, adjust mobile $contentDiv height if mobile viewport
            ready(lang.hitch(this, function() {
                if (win.getBox().w < BREAK_MOBILE) {
                    this.matchMobileContentHeight();
                }
            }));

            this.own(topic.subscribe(events.breakpoints.mobile, lang.hitch(this, function(e) {
                ready(lang.hitch(this, function() {
                    if (e.exceeded) { // mobile -> desktop
                        this.returnToOriginalHeight();
                    }
                    else { // desktop -> mobile
                        this.matchMobileContentHeight();
                    }
                }));
            })));
        },

        /**
         * Add inline styling to make mobile content div conform to the max height. Fires on mobile view.
         */
        matchMobileContentHeight: function() {
            this.updateMobileContentMaxHeight();
            this.updateRotatorHeight(this.maxHeight, this.maxHeight + MOBILE_IMAGE_HEIGHT);
        },

        /**
         * Remove inline styling added to matchMobileContentHeight. Fires when transitioning from mobile to
         * non-mobile view.
         */
        returnToOriginalHeight: function() {
            this.updateRotatorHeight('', '');
        },

        /**
         * Apply max $contentDiv height to $contentDiv,
         *
         * @param contentHeight     Height of maximum content div
         * @param slideHeight       Total height of slide (contentHeight + MOBILE_IMAGE_HEIGHT)
         */
        updateRotatorHeight: function(contentHeight, slideHeight) {
            this.$contentDiv.css('height', contentHeight);
            this.$domNode.css('height', slideHeight);
        }
    });
});
},
'abbott/editing/ui/formBasedEditor/MolecularCatalogFBETabWrapper':function(){
define([
    'module',
    'vodori/provide',
    'dijit/WidgetSet',
    'dijit/registry',
    'dojo/_base/lang',
    'dojo/_base/array',
    'dojo/request',
    'dojo/query',
    'dojo/aspect',
    'dojo/topic',
    'dojo/ready',
    'dojo/parser',
    'abbott-shared/editing/ui/dynamicBlock/DynamicBlockUtil',
    'abbott-shared/util/responsiveUtil',
    'abbott-shared/util/ScrollTo',
    'dijit/_WidgetBase'
], function(module,
            provide,
            WidgetSet,
            registry,
            lang,
            array,
            request,
            query,
            aspect,
            topic,
            ready,
            parser,
            DynamicBlockUtil,
            responsiveUtil,
            ScrollTo,
            _WidgetBase) {
    var MOBILE_TABS_SELECTOR = '.js--molecular-catalog-tabs-mobile',
         DESKTOP_TABS_SELECTOR = '.js--molecular-catalog-tabs-tablet-desktop',
        TABS_CONTENT_SELECTOR = '.js--molecular-catalog-tabs-content',
        TAB_STAMP_SELECTOR = '.js--molecular-catalog-tab-stamp';

    /**
     * Wrapper for the Molecular Catalog Product FBE template tab section
     *
     * Functionality taken from TabsCominer.js
     */
    return provide(module.id, [_WidgetBase], {
        /**
         * root node of the widget
         */
        $domNode: null,
        // Array of labels for all except first tab in certain dynamic block
        tabLabels: null,

        // Array of tab content for all except first tab in certain dynamic block
        tabContents: null,

        // List of all tab blocks - updated for each template region
        tabBlockList: null,

        // First tab block in current template section
        $firstTabBlock: null,

        BREAK_TABLET_PORTRAIT: 767,

        postCreate: function() {
            this.inherited(arguments);

            // Exit early if jQuery doesn't exist on the page
            if (typeof $ != 'function') {
                return;
            }
            this.$domNode = $(this.domNode);

            this._initListeners();

        },

        /**
         * Each time tab changes are possible or detected, restart the widget
         *
         * @param templateSection
         */
        _initListeners: function() {
            this.handleDesktopTabSelection();
            this.handleMobileTabExpandCollapse();
        },

        /**
         * Since there are two entirely separate sets of buttons for desktop vs. mobile view,
         * the following two methods handle click events for (and maintain consistency between)
         * both button sets
         */
        handleDesktopTabSelection: function() {
            // Remove all existing click selectors if they exist
            $(DESKTOP_TABS_SELECTOR + ' ' + TAB_STAMP_SELECTOR, this.$domNode).off('click');

            // Toggle active tab on click
            $(DESKTOP_TABS_SELECTOR + ' ' + TAB_STAMP_SELECTOR, this.$domNode).on('click', lang.hitch(this, function(e) {
                var idx = $(e.target).index(),
                    $tabsContent = $(e.target).parent().siblings(TABS_CONTENT_SELECTOR);

                this.toggleActiveClass($(e.target).siblings(), $(e.target));
                this.showHideContent($tabsContent, idx);

                // Update mobile tabs' '.active' state
                var $mobileTabs = $(e.target).parent().siblings(MOBILE_TABS_SELECTOR);
                this.toggleActiveClass($mobileTabs, $mobileTabs.eq(idx));
            }));
        },

        /**
         * Handle mobile tabs being expanded/collapsed. If tab is initially inactive, expand; else collapse.
         * Expanding behavior is accordion-like. Note that the 'active' class on tab content is toggled upon
         * completion of the animation to maintain consistency with desktop tab versions.
         */
        handleMobileTabExpandCollapse: function() {
            var _this = this;
            // Remove all existing click selectors if they exist
            $(MOBILE_TABS_SELECTOR, this.$domNode).off('click');

            // Toggle active tab on click
            $(MOBILE_TABS_SELECTOR, this.$domNode).on('click', function() {
                var $mobileTabs = $(this).parent().children(MOBILE_TABS_SELECTOR),
                    idx = $mobileTabs.index($(this)),
                    $tabsContent = $(this).siblings(TABS_CONTENT_SELECTOR),
                    isInactive = $tabsContent.eq(idx).css('display') === 'none';

                // Animate accordion to open newly selected tab, then close all others
                if (isInactive) {
                    $tabsContent.eq(idx).slideDown({
                        duration: 'slow', queue: false,
                        complete: function() {
                            $(this).addClass('active');
                            ScrollTo.topOfElement($('.tabs-mobile.active', this.parentNode));;
                        }
                    });
                    $tabsContent.filter(function(index) {
                        return index !== idx
                    })
                        .slideUp({
                            duration: 'slow', queue: false,
                            complete: function() {
                                $(this).removeClass('active');
                            }
                        });

                    _this.toggleActiveClass($mobileTabs, $(this));
                    // Update desktop tabs' '.active' state to match mobile version
                    var $desktopTabs = $(this).parent().find(DESKTOP_TABS_SELECTOR + ' ' + TAB_STAMP_SELECTOR);
                    _this.toggleActiveClass($desktopTabs, $desktopTabs.eq(idx));
                } else {
                    $tabsContent.eq(idx).slideUp({
                        duration: 'slow', queue: false,
                        complete: function() {
                            $(this).removeClass('active');
                        }
                    });
                    $(this).removeClass('active');
                }
            });
        },

        /**
         * Show tab content at specified index, hide all other content
         *
         * @param $tabsContent
         * @param idx
         */
        showHideContent: function($tabsContent, idx) {
            $tabsContent.css('display', '');
            $tabsContent.removeClass('active');
            $tabsContent.eq(idx).addClass('active');
        },

        /**
         * Add or remove 'active' class for corresponding selectors
         *
         * @param $removeSelector
         * @param $addSelector
         */
        toggleActiveClass: function($removeSelector, $addSelector) {
            $removeSelector.removeClass('active');
            $addSelector.addClass('active');
        }
    });
});
},
'abbott/editing/ui/formBasedEditor/MolecularCatalogProductFormBasedEditor':function(){
/*jshint dojo:true devel:true strict:false*/
/*global define:true */
define([
    'module', 'vodori/provide', 'abbott/pandx/PanDxUtil',
    'vodori/input/FormBasedEditor'
], function (
    module, provide, PanDxUtil,
    FormBasedEditor
) {

    var ROH_NODE_REPEATER = '.js--roh-node-repeater-node',
        ROH_QUESTION_NAME = 'input[name=roh-required]',
        ROH_REQUIRED_CHECKED_STATE = ':checked',
        NORMAL_ROH_IMAGE_INDICATOR = 'normal',
        PROBE_MAP_IMAGES_ENDPOINT = '/ajax/product/probeMapImages',
        ROH_IMAGE_ENDPOINT = '/ajax/product/hybridizationImages',
        PRODUCT_NAME_ENDPOINT = '/ajax/product/getProductNameForProductId',
        PRODUCT_FAMILY_NAME_ENDPOINT = '/ajax/product/getProductFamilyNameForProductFamilyId';



    /**
     * Extends the capabilities of the FormBasedEditor so we can populate the form with data related to the product
     */
    var MolecularCatalogProductFormBasedEditor = provide(module.id, [FormBasedEditor], {


        /**
         * The root DOM node for this widget.
         *
         * {@type jQuery}
         */
        $domNode: null,

        /**
         * Product Id of the current Pepper Page
         */
        productId: null,

        /**
         * Product Family Id of the current Pepper Page
         */
        productFamilyId: null,

        constructor: function () {
            this.inherited(arguments);
            this._setProductInformation();
        },

        postCreate: function() {
            this.inherited(arguments);
            this.$domNode = this.domNode;
        },

        startup: function() {
            this.inherited(arguments);
          this._initROHSection();
        },

        /**
         * Called from startup. Sets the initial display value of the ROH images section and adds listener
         * for when the input changes
         * @private
         */
        _initROHSection: function () {
            this._setROHNodeRepeaterDisplay();

            $(ROH_QUESTION_NAME, this.$domNode).change($.proxy(function () {
                this._setROHNodeRepeaterDisplay()
            }, this))

        },

        /**
         * Show/hide ROH image section based on the value of the input[name=roh-required] input
         * @private
         */
        _setROHNodeRepeaterDisplay: function() {
            if (this._retrieveValueOfRequiredROHInput() === 'true') {
                this._showROHNodeRepeater();
            } else {
                this._hideROHNodeRepeater()
            }
        },

        /**
         * Retrieves the value of the :checked roh-required input
         * @private
         */
        _retrieveValueOfRequiredROHInput: function () {
            return $(ROH_QUESTION_NAME + ROH_REQUIRED_CHECKED_STATE, this.$domNode).val();
        },

        /**
         * Shows the ROH Node Repeater section
         * @private
         */
        _showROHNodeRepeater: function () {
            $(ROH_NODE_REPEATER, this.$domNode).show();
        },

        /**
         * Hides the ROH Node Repeater section
         * @private
         */
        _hideROHNodeRepeater: function() {
            $(ROH_NODE_REPEATER, this.$domNode).hide();
        },

        /**
         * Override the FormBasedEditor method in order to prepopulate fields on the FBE
         *
         * @result {*} the modified data with which to render the template (optional -- unless
         *         you are replacing the data object, there is no need to return it.)
         */
        prepareDataForForm: function (data) {
            if(!data.images) {
                data.images = this._fetchProbeMapImages(data.images);
            }

            if(!data.rohImages) {
                data.rohImages = this._fetchROHImages(data.rohImages);
            }

            // displayROHImages will only be undefined on initial fbe start up
            // if it is undefined set the value to true if there is at least one roh image found for the product
            if(data.displayROHImages === undefined) {
                data.displayROHImages = data.rohImages && data.rohImages.length >= 1;
            }

            if(!data.displayName) {
                data.displayName = this._fetchDisplayName();
            }

            return data;
        },

        /**
         * Retrieves product information from the meta tags on the page
         * @private
         */
        _setProductInformation: function () {
            this.productId = PanDxUtil.getCatalogProductId();
            this.productFamilyId = PanDxUtil.getCatalogProductFamilyId();
        },

        /**
         * retrieves list of probe map images from BE and adds them to the list of images to be rendered by the fbe
         *
         * if product images is not undefined, the fbe has previously been loaded with content and we do not want to fetch any additional images
         *
         * @returns {Array}
         * @private
         */
        _fetchProbeMapImages: function (productImages) {
            productImages = (productImages || []);

            if(this.productId || this.productFamilyId) {
                $.ajax(PROBE_MAP_IMAGES_ENDPOINT, {
                    type: 'GET',
                    data: {
                        productId: this.productId,
                        productFamilyId: this.productFamilyId
                    },
                    async: false

                }).done($.proxy(function (probeMapImages) {
                    // Add probe map images to the widget
                    $.each(probeMapImages, $.proxy(function (index, probeMapImage) {
                        this._addProbeMapImages(productImages, probeMapImage);
                    }, this));

                }, this)).fail(function (result) {
                    console.error("An error occurred retrieving the Probe Map Images. Result was: ", result);
                });
            }
            return productImages;
        },

        /**
         * retrieves list of result of hybridization images from BE and adds them to the list of images to be rendered by the fbe.
         *
         * if rohImages is not undefined, the fbe has previously been loaded with content and we do not want to fetch any additional images
         * @returns {Array}
         * @private
         */
        _fetchROHImages: function (rohImages) {
            rohImages = (rohImages || []);

            if(this.productFamilyId) {
                $.ajax(ROH_IMAGE_ENDPOINT, {
                    type: 'GET',
                    data: {
                        productFamilyId : this.productFamilyId
                    },
                    async: false
                }).done($.proxy(function (fetchedImages) {
                    $.each(fetchedImages, $.proxy(function(index, rohImage) {
                        this._addROHImages(rohImages, rohImage);
                    }, this));

                }, this)).fail(function(result) {
                    // shouldn't happen as we are checking productFamilyId before ever calling the endpoint
                    if(result.status === 400) {
                        console.log("No results found for the given product family id");
                        return rohImages;
                    } else {
                        console.error("An error occured retrieving roh images. the result was:", result);
                    }
                });
            }
            return rohImages;
        },

        /**
         * Fetches the product name to be displayed on the catalog page
         *
         * If product id is present then the display name will be the Product Display name for the given product id. If product display name is not present then product name will be used.
         *
         * If product id is not present, and product family id is present, then the product family name will be used as the display name
         *
         * @returns {string}
         * @private
         */
        _fetchDisplayName: function() {
            var displayName = '';
            if(this.productId) {
                $.ajax(PRODUCT_NAME_ENDPOINT, {
                    type: 'GET',
                    data: {
                        productId: this.productId
                    },
                    async:false
                }).done(function(productName) {
                    displayName = productName;
                }).fail(function(result) {
                    return '';
                })
            } else if(this.productFamilyId) {
                $.ajax(PRODUCT_FAMILY_NAME_ENDPOINT, {
                    type: 'GET',
                    data: {
                        productFamilyId: this.productFamilyId
                    },
                    async:false
                }).done(function(productFamilyName) {
                    displayName = productFamilyName;
                }).fail(function(result) {
                    return '';
                })
            }
          return displayName;
        },

        /**
         * Add ROH images retrieved from the backend to the FBE
         * @param currentListOfImages
         * @param image
         * @param isNormalROHType
         * @returns {*}
         * @private
         */
        _addROHImages: function (currentListOfImages, image) {
            var isNormalROHType = image.hybridizationType === NORMAL_ROH_IMAGE_INDICATOR;
                currentListOfImages.push({
                    'imagePath': image.url,
                    'isNormalROHType': isNormalROHType,
                    'imageCaption': '',
                    'imageAltText': ''
                });
            return currentListOfImages;
        },

        /**
         * Add probe map images retrieved from the backend to the FBE
         * @param currentListOfImages
         * @param image
         * @returns {*}
         * @private
         */
        _addProbeMapImages: function (currentListOfImages, image) {
            currentListOfImages.push({
                    'imagePath': image.url,
                    'ideogram': false,
                    'imageAltText': ''
                });
            return currentListOfImages;
        }
    });

    return MolecularCatalogProductFormBasedEditor;
});
},
'abbott/editing/ui/formBasedEditor/MolecularCatalogProductOrderingInformation':function(){
define([
    'module',
    'lodash',
    'vodori/provide', 'vodori/renderTemplate',
    'dijit/_WidgetBase', 'abbott/pandx/PanDxUtil',
    'dojo/parser',
    'dojo/text!abbott/editing/ui/block/formBased/MolecularCatalogOrderingInformationTemplate.html'
], function (
    module,
    _,
    provide, renderTemplate,
    _WidgetBase, PanDxUtil,
    parser,
    OrderingInformationTemplate
) {

    var PRODUCTS_FOR_ORDER_NUMBER_ENDPOINT = '/ajax/product/getOrderingInformationForOrderNumberIdAndMarketId';

    /**
     * Renders ordering information selected via the MolecularCatalogProductOrderingInformationMultiSelect.js widget.
     *
     * Per the logic on the MolecularCatalogWebpage FBE, This widget and its template will only render if "sortableOrderingInformation" is blank.
     *
     * sortableOrderingInformation is selected via the Sortable Ordering Information Nodes on the MolecularCatalogWebpage FBE
     *
     * Renders the ordering information section of the Molecular Catalog Webpage
     */
    return provide(module.id, [_WidgetBase], {

        $domNode: null,

        /**
         * Order Info Ids selected via the Form of the FBE
         */
        orderInfoIdsAsJson: null,

        /**
         * Array of the stored Order Info Ids after parsing from string to array
         */
        orderInfoAsArray: null,

        /**
         * Rendered as the header of the Ordering Information Section. Populated via the form of the FBE
         */
        orderingInformationHeader: null,

        postCreate: function () {
            this.inherited(arguments);
            this.$domNode = $(this.domNode);
            if (this.orderInfoIdsAsJson) {
                this._setOrderInfoAsArray();
                this._populateOrderingInfo();

            }
        },

        /**
         * Parses the JSON object of order info ids into a js object. joins them in to an array on ','
         * @returns {*|void|string}
         * @private
         */
        _setOrderInfoAsArray: function () {
            return this.orderInfoAsArray = JSON.parse(this.orderInfoIdsAsJson).join(',')
        },

        /**
         * Retrieves the ordering information for the given order number ids and market. Information is then used to render the ordering information table ont he Catalog FBE
         * @private
         */
        _populateOrderingInfo: function () {
            if (this.orderInfoAsArray.length > 0) {
                $.ajax(PRODUCTS_FOR_ORDER_NUMBER_ENDPOINT, {
                    type: 'GET',
                    data: {
                        orderNumberIds: this.orderInfoAsArray,
                        marketId: PanDxUtil.getCurrentMarketId()
                    }
                }).success($.proxy(function (results) {
                    this._renderOrderingInfoTemplate(results);
                }, this));
            }
        },

        /**
         * Renders the Ordering Information section of the Molecular Catalog FBe
         * @param orderingInformation - array of ProductCatalogBlockOrderingInfoDTO retrieved for the given order info ids and market id
         * @private
         */
        _renderOrderingInfoTemplate: function(orderingInformation) {
            this.$domNode.html(renderTemplate(OrderingInformationTemplate, {
                orderingInformation: orderingInformation,
                orderingInformationHeader: this.orderingInformationHeader
            }));
        }
    });
});
},
'abbott/editing/ui/formBasedEditor/MolecularCatalogProductOrderingInformationMultiSelect':function(){
/*jshint dojo:true devel:true strict:false*/
/*global define:true */
define([
    'module', 'vodori/provide',
    'dojo/_base/array',
    'dojo/dom-attr',
    'dojo/on', 'dojo/query', 'abbott/pandx/PanDxUtil',
    'abbott-shared/editing/ui/formBasedEditor/FormBasedEditorSelect'
], function (
    module, provide,
    array,
    domAttr,
    on, query, PanDxUtil,
    FormBasedEditorSelect
) {

    var PRODUCTS_FOR_ORDER_NUMBER_ENDPOINT = '/ajax/product/getOrderingInformationForProductIdAndMarketId';
    var ORDER_IDS_FOR_PRODUCT_FAMILY_ID_AND_MARKET_ENDPOINT = '/ajax/product/family/orderingInformationIds';

    /**
     * LEGACY WIDGET. THE MolecularCatalogOrderingInformationFormBasedEditorSelect.js WIDGET SHOULD BE USED TO SELECT ORDERING INFORMATION ON THE MolecularCatalgoWebpage.html FBE.
     *
     * THE WIDGET CANNOT BE REMOVED BECAUSE SOME EXISTING MOLECULAR CATALOG WEBPAGES REQUIRE THIS WIDGET.
     *
     * Extends the capabilities of the FormBasedEditorSelect.
     *
     * Populates the option list for the Molecular Catalog FBE Ordering Information multi-select.
     *
     * Persists selected Ordering Information Ids to a hidden input in order to render the Ordering Information section of the valueTemplate
     */
    return provide(module.id, [FormBasedEditorSelect], {

        /**
         * Array of options that will be set to be selectable in the widget. Should have a key and label values (used for
         * value and display text of option)
         *
         * @type Array
         */
        options: null,

        /**
         * Product
         */
        productId: null,

        orderIdsForProductFamily: null,

        /**
         * Constructor for the widget. Resets the options field.
         */
        constructor: function() {
            this.inherited(arguments);
            this.options = [];
            this._setProductInformation();
        },

        /**
         * In addition to the function of FormBasedEditorSelect, first populates the select with the categories.
         */
        postMixInProperties: function() {
            this.inherited(arguments);
            this.loadOrderingInformation();
        },

        /**
         * Most logic needs to go in the startup because this runs after the children widgets have been parsed
         */
        startup: function() {
            this.inherited(arguments);
            this._postParseMaintainHiddenInputValue(true);
        },

        _setProductInformation: function() {
            this.productId = PanDxUtil.getCatalogProductId();
            this.productFamilyId = PanDxUtil.getCatalogProductFamilyId();
            if(!this.productId && !!this.productFamilyId) {
                this._fetchOrderInfoIdsForProductFamilyId();
            }
        },

        /**
         * Retrieves all ordering information  ids for the given product family id and market id
         * @private
         */
        _fetchOrderInfoIdsForProductFamilyId: function() {
            $.ajax(ORDER_IDS_FOR_PRODUCT_FAMILY_ID_AND_MARKET_ENDPOINT, {
                type: 'GET',
                data: {
                    marketId: PanDxUtil.getCurrentMarketId(),
                    productFamilyId: this.productFamilyId
                },
                async: false
            }).success($.proxy(function(results) {
                this.orderIdsForProductFamily = results;
            }, this));
        },

        /**
         * Loads all aggregate IDs into the widget's select field.
         */
        loadOrderingInformation: function() {
            $.ajax(PRODUCTS_FOR_ORDER_NUMBER_ENDPOINT, {
                type: 'GET',
                data: {
                    marketId: PanDxUtil.getCurrentMarketId(),
                    orderNumber: ''
                },
                async: false
            }).success($.proxy(function(results) {
                // Add results into the widget
                $.each(results, $.proxy(function (index, orderingInformation) {
                    this._addOrderingInformation(orderingInformation);
                }, this));

                // Add options to the select tag
                this.addOptionsToSelect();
            }, this)).error(function (result){
                console.error("An error occurred retrieving ordering information. Result was: ", result);
            });
        },

        /**
         * Add Ajax results to list of options to display in the FBE
         * @param orderingInformation
         * @private
         */
        _addOrderingInformation: function(orderingInformation){
            // Add current productId
            this.options.push({
                'key': orderingInformation.orderInfoId,
                'label': this._formatOptionString(orderingInformation),
                'selected': !!this._determineIfOptionIsSelected(orderingInformation.productId, orderingInformation.orderInfoId)
            });
        },

        /**
         * Determins if an option should be auto selected in the multi-select
         *
         * Option should be auto-selected if:
         * 1. The given ordering information has been selected previously by checking the value of the hiddenInput
         * 2. HiddenInput is still an empty string, indicating this is the first time the FBE has been loaded.
         *
         * @param productId
         * @param orderInfoId
         * @returns {boolean|*}
         * @private
         */
        _determineIfOptionIsSelected: function(productId, orderInfoId) {
          return this._doesHiddenInputContainOrderInfoId(orderInfoId) ? true :  this._hiddenInputUnsetAndProductIdMatches(productId, orderInfoId);
        },

        /**
         * Checks if hiddenInputValue has been set and if the current orderInfoId is one of the contained in the hidden input
         *
         * If it has been set, parse the hiddenInputValue to determine if it contains the given orderInfoId
         * @param orderInfoId
         * @returns {boolean}
         * @private
         */
        _doesHiddenInputContainOrderInfoId: function (orderInfoId) {
            if(!!this.hiddenInputValue) {
                var hiddenInputAsArray = JSON.parse(this.hiddenInputValue);
                return hiddenInputAsArray.length !== 0 && $.inArray(orderInfoId, JSON.parse(this.hiddenInputValue)) !== -1;
            } else {
                return false;
            }
        },

        /**
         * Checks if the hidden input value has been set. If it has not been set (indicates first time the FBE has loaded), then check to see if the current ordering information product id matches the product id of the page.
         * If productId is not set, check to see if the current ordering information product family id matches the product family id of the page
         *
         * Hidden input value  will be "" on initial FBE load.
         *
         * Hidden input value will be an array, populated or empty, if the user has flipped to preview or live mode at all. If this is the case then we do not want auto select any options
         *
         * @param productId
         * @param orderInfoId
         * @returns {*}
         * @private
         */
        _hiddenInputUnsetAndProductIdMatches: function(productId, orderInfoId) {
            if(!this.hiddenInputValue ) {
                if(!!this.productId) {
                    return productId === this.productId;
                } else if(!!this.productFamilyId) {
                    return !!this.orderIdsForProductFamily && $.inArray(orderInfoId, this.orderIdsForProductFamily) !== -1;
                }
            } else {
                return false;
            }
        },

        /**
         * Builds the string to be used as the display value of the multi-select option
         * @param orderingInformation
         * @returns {string}
         * @private
         */
        _formatOptionString: function(orderingInformation) {
            return orderingInformation.orderNumber + '  -  '  + this._getProductDisplayName(orderingInformation)+ ' (Regulatory Status: ' + orderingInformation.regulatoryStatus + ', GTIN: ' + orderingInformation.gtin + ')';
        },

        _getProductDisplayName: function(orderingInformation) {
            return orderingInformation.productDisplayName ? orderingInformation.productDisplayName : orderingInformation.productName;
        },

        /**
         * Adds all the current options to the select tag for this widget.
         */
        addOptionsToSelect: function() {
            var $selectTag = $('select', this.srcNodeRef);
            $.each(this.options, function(i, option){
                $selectTag.append(
                    $("<option/>", {
                        value: option.key,
                        html: option.label,
                        selected: option.selected
                    })
                );
            });
        },

        /**
         * Sets the hiddenInputvalue to a stringified array of order info ids if any have been selected.
         *
         * If no order info ids have been selected, then set the value to a stringified empty array
         * @private
         */
        _maintainHiddenInputValue: function() {
            // Grab the selected values from the select.
            // Mozilla Developer Network is reporting no support in any IE version for
            // HTMLSelectElement.selectedOptions, but because this code is only being run for the FBE in Pepper
            // mode, we do not need to support IE
            var newSelectNode = $('select', this.domNode)[0];
            if (newSelectNode.selectedOptions.length > 0) {
                var valueArray = [];
                array.forEach(newSelectNode.selectedOptions, function(option) {
                    valueArray.push($(option).val());
                });
                var valueJSON = JSON.stringify(valueArray);
                domAttr.set(this.hiddenInput, 'value', valueJSON);
                this.hiddenInputValue = $(this.hiddenInput).val();
            } else {
                domAttr.set(this.hiddenInput, 'value', JSON.stringify([]));
                this.hiddenInputValue = $(this.hidenInput).val();
            }
        },

        /**
         * Fired when the user selects a new item in the select widget.
         * This function handles setting the value on the hidden input element on this widget.
         *
         * Copied from the ADD MultiSelectProductTestMenuFormBasedEditorSelect widget
         *
         * @param firstTime - boolean - is this the first time the block is being loaded?
         * @private
         */
        _postParseMaintainHiddenInputValue: function(firstTime) {

            // If this is the first time the block is loading
            if(firstTime) {
                // If there is already content in the hidden input, return immediately, and do not overwrite the
                // content with an empty array
                var hiddenInputValue = $(this.hiddenInput).val();
                if(hiddenInputValue !== "") {
                    return;
                }
            }

            // Grab the select node and its selected options
            // Mozilla Developer Network is reporting no support in any IE version for
            // HTMLSelectElement.selectedOptions, btu because this code is only being run for the FBE in Pepper
            // mode, we do not need to support IE
            var newSelectNode = $('select', this.domNode)[0];
            var valueArray = [];
            if (newSelectNode.selectedOptions.length > 0) {
                array.forEach(newSelectNode.selectedOptions, function(option) {
                    valueArray.push($(option).val());
                });
            }

            var valueJSON = JSON.stringify(valueArray);
            domAttr.set(this.hiddenInput, 'value', valueJSON);
            this.hiddenInputValue = $(this.hiddenInput).val();
        }
    });
});
},
'abbott/editing/ui/formBasedEditor/MolecularCatalogProducts':function(){
/*jshint dojo:true devel:true strict:false*/
/*global define:true */
define([
    'lodash',
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'dojo/on', 'dojo/query', 'dojo/dom-attr', 'dojo/request/xhr',
    'abbott-shared/ui/productFilter/Products'
], function (
    _,
    module, provide,
    lang,
    on, query, domAttr, xhr,
    Products
) {

    // Ajax endpoints
    var GET_MOLECULAR_CATALOG_PRODUCTS_AJAX_URI = "/ajax/product/productCatalog",
        GET_MOLECULAR_CATALOG_PRODUCTS_FOR_LETTER_AJAX_URI = "/ajax/product/productCatalog/letter";

    /**
     * Extension of the abbott-shared Products
     */
    return provide(module.id, [Products], {

        /**
         * Loads the filters for this filter list into the widget.
         */
        loadProducts: function(categoryId){
            // Fetch the product pages for the given category filter
            $.ajax(GET_MOLECULAR_CATALOG_PRODUCTS_AJAX_URI,{
                data: {
                    category: categoryId
                }
            }).success($.proxy(function(products) {
                this.processAJAXResults(products);
            }, this)).error(function (result){
                console.error("An error occurred retrieving the product detail pages. Result was: ", result);
            });
        },

        /**
         * Loads the filters for this filter list into the widget.
         *
         * This handles A-Z filters, which must include a letter in the query.
         */
        loadProductsAZ: function(categoryId, label){
            // Fetch the product pages for the given category filter
            $.ajax(GET_MOLECULAR_CATALOG_PRODUCTS_FOR_LETTER_AJAX_URI,{
                data: {
                    category: categoryId,
                    letter: label
                }
            }).success($.proxy(function(products) {
                this.processAJAXResults(products);
            }, this)).error(function (result){
                console.error("An error occurred retrieving the product detail pages. Result was: ", result);
            });
        }

    });
});
},
'abbott/editing/ui/formBasedEditor/ProbeInfoSelect':function(){
/**
 * Created by hank.spencer on 8/30/16.
 */
/*jshint dojo:true devel:true strict:false*/
/*global define:true */
define([
    'lodash',
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'dojo/on', 'dojo/query', 'dojo/dom-attr', 'dojo/request/xhr',
    'abbott-shared/editing/ui/formBasedEditor/FormBasedEditorSelect'
], function (
    _,
    module, provide,
    lang,
    on, query, domAttr, xhr,
    FormBasedEditorSelect
) {

    var ENDPOINT_GET_ALL_PRODUCTS = '/editing/ajax/getAllProductFamilies';

    /**
     * Extension of the abbott-shared FormBasedEditorSelect
     */
    return provide(module.id, [FormBasedEditorSelect], {

        selectNode: null,

        selectedProductId: null,
        selectedProductName: null,

        /**
         * Set/Update any properties
         */
        postMixInProperties: function() {
            this.inherited(arguments);

            this._populateDropdown();
        },

        /**
         * Populate's this FormBasedEditor's dropdowns with AMD products.
         *
         * @private
         */
        _populateDropdown: function() {
            var selectNode = query('select', this.srcNodeRef)[0];

            if (!selectNode) {
                return;
            }

            xhr(ENDPOINT_GET_ALL_PRODUCTS, {
                handleAs: 'json'
            }).then(
                lang.hitch(this, function(response) {
                    _.forEach(response, lang.hitch(this, function(product) {
                        var option = document.createElement('option');
                        option.value = product.id;
                        option.text = product.familyName;

                        selectNode.add(option);
                    }));

                    // Set the selected element on the select node to the value on the hiddenInput
                    this.hiddenInputValue = this.hiddenInput.value;
                    this.selectNode.value = this.hiddenInputValue;
                }),
                function(error) {

                },
                function(event) {

                }
            );
        }

    });
});
},
'abbott/editing/ui/formBasedEditor/ProductDiseaseStateFormBasedEditorSelect':function(){
/*jshint dojo:true devel:true strict:false*/
/*global define:true */
define([
    'module', 'vodori/provide', 'abbott/pandx/PanDxUtil',
    'abbott-shared/editing/ui/formBasedEditor/FormBasedEditorSelect'
], function (
    module, provide, PanDxUtil,
    FormBasedEditorSelect
) {

    var DISEASE_STATE_ENDPOINT = '/ajax/product/getDiseaseStatesForProductIdOrProductFamilyIdAndMarketId';

    /**
     * Extends the capabilities of the FormBasedEditorSelect to pull the contents for the select from the
     * disease state list.
     */
    var ProductDiseaseStateFormBasedEditorSelect = provide(module.id, [FormBasedEditorSelect], {

        /**
         * Array of options that will be set to be selectable in the widget. Should have a key and label values (used for
         * value and display text of option)
         *
         * {@type Object}
         */
        options: null,

        /**
         * Product Id of the current Pepper Page
         */
        productId: null,

        /**
         * Product Family Id of the current Pepper Page
         */
        productFamilyId: null,

        /**
         * Current market id, determined by the uri prefix in PanDxUtil
         */
        marketId: null,

        /**
         * Constructor for the widget. Resets the options field.
         */
        constructor: function() {
            this.inherited(arguments);
            this.options = [];
            this._setProductInformation();

        },

        /**
         * In addition to the function of FormBasedEditorSelect, first populates the select with the disease states
         */
        postMixInProperties: function() {
            this._loadDiseaseStates();
            this.inherited(arguments);
        },

        _setProductInformation: function () {
            this.productId = PanDxUtil.getCatalogProductId(),
            this.productFamilyId = PanDxUtil.getCatalogProductFamilyId(),
            this.marketId = PanDxUtil.getCurrentMarketId();
        },

        /**
         * Loads all disease states into the widget's select field.
         */
        _loadDiseaseStates: function(){
            $.ajax(DISEASE_STATE_ENDPOINT, {
                type: 'GET',
                data: {
                    productId: this.productId,
                    productFamilyId: this.productFamilyId,
                    marketId: this.marketId
                },
                aynch: false
            }).done($.proxy(function(diseaseStates) {
                // Add disease state options into the widget
                $.each(diseaseStates, $.proxy(function (index, diseaseState) {
                    this._addDiseaseStates(diseaseState.id, diseaseState.name);
                }, this));

                // Add productIds to the select tag
                this.addOptionsToSelect();
            }, this)).fail(function (result){
                console.error("An error occurred retrieving the Pepper productIds. Result was: ", result);
            });
        },

        /**
         * Adds a disese state to the widget's options. Note: Does not refresh the select object.
         *
         * @param diseaseStateId The disease state id
         * @param diseaseStateLabel The disease state name to add
         */
        _addDiseaseStates: function(diseaseStateId, diseaseStateLabel){
            // Add current productId
            this.options.push({
                'key': diseaseStateId,
                'label': diseaseStateLabel
            });
        },

        /**
         * Adds all the current options (and one 'No Disease State' option) to the select tag for this widget.
         */
        addOptionsToSelect: function() {
            var $selectTag = $('select', this.srcNodeRef);

            var hiddenInputValue = this.hiddenInputValue;

            // Note: Ability to disable applications (disease states) added in ADP-10055. If a product has a catalog
            // page created with a valid disease state selected and then all previously available applications for said
            // product are then disabled, the FBE dropdown will be correctly cleared of all disabled applications, but
            // disease state inputHiddenValue will maintain the previously selected disease state value because the dropdown
            // change event is never triggered to update the hidden value. Removing all applications for a product
            // without also removing the product catalog page is unlikely, so this is not a priority issue.
            // Bug documented and planned to fix in ADP-10138

            // add a 'No Disease State' option to the dropdown
            $selectTag.append(
                $("<option/>", {
                    value: '',
                    html: 'No Disease State',
                    selected: hiddenInputValue
                })
            );

            $.each(this.options, function(i, diseaseStateOption){
                $selectTag.append(
                    $("<option/>", {
                        value: diseaseStateOption.label,
                        html: diseaseStateOption.label + ' (' + diseaseStateOption.key + ')',
                        selected: diseaseStateOption.label === hiddenInputValue
                    })
                );
            });
        }

    });

    return ProductDiseaseStateFormBasedEditorSelect;
});
},
'abbott/editing/ui/formBasedEditor/ProductOrderingInfoSelect':function(){
/*jshint dojo:true devel:true strict:false*/
/*global define:true */
define([
    'lodash',
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'dojo/on', 'dojo/query', 'dojo/dom-attr', 'dojo/request/xhr',
    'abbott-shared/editing/ui/formBasedEditor/FormBasedEditorSelect'
], function (
    _,
    module, provide,
    lang,
    on, query, domAttr, xhr,
    FormBasedEditorSelect
) {

    var ENDPOINT_GET_ALL_PRODUCTS = '/editing/ajax/getAllProductFamilies';

    /**
     * Extension of the abbott-shared FormBasedEditorSelect
     */
    return provide(module.id, [FormBasedEditorSelect], {

        selectNode: null,

        selectedProductId: null,
        selectedProductName: null,

        /**
         * Set/Update any properties
         */
        postMixInProperties: function() {
            this.inherited(arguments);

            this._populateDropdown();
        },

        /**
         * Populate's this FormBasedEditor's dropdowns with AMD products.
         *
         * @private
         */
        _populateDropdown: function() {
            var selectNode = query('select', this.srcNodeRef)[0];

            if (!selectNode) {
                return;
            }

            xhr(ENDPOINT_GET_ALL_PRODUCTS, {
                handleAs: 'json'
            }).then(
                lang.hitch(this, function(response) {
                    _.forEach(response, lang.hitch(this, function(product) {
                        var option = document.createElement('option');
                        option.value = product.id;
                        option.text = product.familyName;

                        selectNode.add(option);
                    }));

                    // Set the selected element on the select node to the value on the hiddenInput
                    this.hiddenInputValue = this.hiddenInput.value;
                    this.selectNode.value = this.hiddenInputValue;
                }),
                function(error) {

                },
                function(event) {

                }
            );
        }

    });
});
},
'abbott/pandx/ifu/InstructionsForUseExpiredLotNumberModal':function(){
define([
    'module', 'vodori/provide',
    'dojo/topic',
    'abbott/pandx/ifu/InstructionsForUseEvents',
    'abbott-shared/ui/modal/_AbstractModal'
], function (
    module, provide,
    topic,
    instructionsForUseEvents,
    _AbstractModal
) {

    var MODAL_CONTENTS_SELECTOR = '.js--dialog-contents';

    return provide(module, [_AbstractModal], {

        /**
         * The modal contents DOM node.
         *
         * {@type jQuery}
         */
        _$dialogContents: null,

        /**
         * Runs on creation.
         */
        startup: function() {
            this.inherited(arguments);

            // Subscribe to the event that shows the modal
            topic.subscribe(instructionsForUseEvents.events.showLotNumberExpiredModal, $.proxy(function() {
                this.showModal();
            }, this));
        },

        /**
         * Shows our modal.
         */
        showModal: function() {
            this._$dialogContents = $(MODAL_CONTENTS_SELECTOR, this.domNode);
            this.showColorbox();
        }
    });
});
},
'abbott/editorConfigs/base':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'pepper/ui/defaultEditorConfig',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, defaultEditorConfig) {
    return provide(module.id, new WysiwygConfig(defaultEditorConfig, {

        /* Only differs from default by adding class and style to <a>. This may be obsolete with CAYENNE-3732 */
        extended_valid_elements: 'iframe[src|width|height|name|align|class|frameborder|scrolling],' +
                                 '+a[class|style|name|href|target|on*|data-*],td[*],table[*],p[*],div[*]',

        'style_formats': [
            {title: 'Header 1', block: 'h1'},
            {title: 'Header 2', block: 'h2'},
            {title: 'Header 3', block: 'h3'},
            {title: 'Header 4', block: 'h4'},
            {title: 'Header 5', block: 'h5'},
            {title: 'Header 6', block: 'h6'},
            {title: 'Blocks'},
            {title: 'Paragraph', block: 'p'},
            {title: 'Blockquote', block: 'blockquote'}
        ],

        '+stamperConfig': [ ],

        '+plugins': ['antenna', 'fixedtoolbar', 'pepperlink']
    }));
});

},
'vodori/input/WysiwygConfig':function(){
/* jshint -W106 */
define([
    'dojo/_base/lang',
    'vodori/provide',
    'module',
    'vodori/util/mixinAndModify',
    'vodori/tinymce/all'
], function (lang, provide, module, mixinAndModify) {
    // Set up the default config object.
    var defaults = {
        'schema': 'html5',
        'ie7_compat': false,
        'language': 'en',
        'plugins': [
            'adddojo',
            'addspace',
            'advhr',
            'antenna',
            'autolink',
            'autoresize',
            'autorotator',
            'buttongrouplabeler',
            'cleanbookmarks',
            'codemirror',
            'configurabletransformer',
            'contextmenu',
            'directionality',
            'editableconfigurabletransformer',
            'emotions',
            'fixedtoolbar',
            'fullscreen',
            'iespell',
            'iframe',
            'inlinepopups',
            'insertdatetime',
            'keyboardshortcuts',
            'layer',
            'limelightvideo',
            'nonbreaking',
            'noneditable',
            'overridecontextcommand',
            'pagebreak',
            'paste',
            'preview',
            'print',
            'save',
            'searchreplace',
            'livestyling',
            'spellchecker',
            'stampvalidator',
            'style',
            'tabcontainer',
            'table',
            'tablecontrols',
            'template',
            'visualblocks',
            'visualchars',
            'xhtmlxtras'
        ],

        'allow_nested_tabcontainer': false,

        'doctype': '<!DOCTYPE html>', // Required for editable widgets
        'object_resizing': false, // FireFox workaround
        'paste_auto_cleanup_on_paste': false,
        'overridden_commands': {},

        // Don't actually use the "styles" property.
        // Good docs for configuring these are 'here':
        // 'http'://www.tinymce.com/wiki.php/'Configuration':formats
        'style_formats': [],

        'label_groups': {
            'FONT': {'label': 'Font'},
            'PARAGRAPH': {'label': 'Paragraph'},
            'STYLE': {'label': 'Styles'},
            'LINKS': {'label': 'Links'},
            'MEDIA': {'label': 'Media'},
            'TABLES': {'label': 'Tables'},
            'WIDGETS': {'label': 'UI Widgets'},
            'CODE': {'label': 'Coding'}
        },

        'stamps': {},

        'theme_advanced_path': false,

        'theme_advanced_buttons1': [
            'FONT', '(', 'bold', 'italic', 'underline', ' |', 'strikethrough', 'sup', 'sub', 'charmap', 'advhr', ')',
            /* jshint -W015 */
            'PARAGRAPH', '(', 'bullist', 'numlist', '|',
                              'indent', 'outdent', '|',
                              'justifyleft', 'justifycenter', 'justifyright',
                          ')',
            /* jshint +W015 */
            'STYLE', '(', 'styleselect', 'removeformat', 'styleprops', ')'
        ],

        /*
         * 'NB': Be aware that 'link' can be overriden by using 'overridden_commands' and 'mceLink'
         *     Do a full tree search of these to see if this overriding is taking place
         */
        'theme_advanced_buttons2': [
            'LINKS', '(', 'link', 'unlink', 'anchor', ')',
            'MEDIA', '(', 'image', 'limelightvideo', 'iframe', ')',
            'TABLES', '(', 'table', '|', 'col_before', 'col_after', '|', 'row_before', 'row_after', ')',
            'WIDGETS', '(', 'autorotator', 'tabcontainer', ')'
        ],

        'theme_advanced_buttons3': [
            'CODE', '(', 'codemirror', 'visualblocks', ')'
        ],

        'content_css': '/static/js/vodori/tinymce/styles/content.css',
        'popup_css_add': '/static/js/vodori/tinymce/styles/popups.css',
        'relative_urls': false,
        'extended_valid_elements': 'iframe[src|width|height|name|align|class|frameborder|scrolling],' +
                                  'a[id|href|target|onclick|onmouseover|data-*],p[*],div[*]',
        'stamperConfig': [
        ],

        'disable_live_styling_cache': false
    };

    // Convert an array to a comma-delimited string for TinyMCE.
    function arrayToString(array) {
        return array.join(',');
    }

    // Convert our human-friendly toolbar buttons format
    // into TinyMCE's "theme_advanced_buttonsN" string.
    function buttonsToString(buttonArray) {
        return arrayToString(buttonArray);
    }

    return provide(module.id, null, {
        '_raw': null,    // Base config + overrides
        '_config': null, // Out to TinyMCE

        // Map properties that need processing to the function you want to process them
        'needsProcessing': {
            'plugins': arrayToString,
            'theme_advanced_buttons1': buttonsToString,
            'theme_advanced_buttons2': buttonsToString,
            'theme_advanced_buttons3': buttonsToString,
            'theme_advanced_buttons4': buttonsToString
        },

        // Instantiate with a base config and some overrides.
        'constructor': function(baseConfig, overrides) {
            // If no base config is passed in, adopt the defaults.
            if (arguments.length < 2) {
                overrides = baseConfig;
                baseConfig = {'_raw': defaults};
            }
            // Clone the base so this new instance doesn't modify it.
            this._raw = mixinAndModify(lang.clone(baseConfig._raw), overrides);
        },

        // Return a proper TinyMCE config object.
        'toConfig': function() {
            // Only process each configuration once.
            if (this._config) {
                return this._config;
            }

            this._config = {};

            for (var prop in this._raw) {
                if (prop in this.needsProcessing) {
                    // Process the properties that need processing.
                    // The function runs in the context of the instance.
                    this._config[prop] = this.needsProcessing[prop].call(this, this._raw[prop]);
                } else {
                    this._config[prop] = this._raw[prop];
                }
            }

            return this._config;
        }
    });
});

},
'pepper/ui/defaultEditorConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'pepper/tinymce/AdvBackground',
    'pepper/tinymce/AdvImage',
    'pepper/tinymce/PepperLink',
    'pepper/tinymce/Stamper',
    'pepper/tinymce/ThemeChanger',
    'pepper/tinymce/VodoriVideo'
], function (provide, module, WysiwygConfig) {
    return provide(module.id, new WysiwygConfig({
        '+plugins': ['advbackground', 'advimage', 'pepperlink', 'stamper', 'themechanger', 'vodorivideo'],

        '+overridden_commands': {
            mceLink: 'pepperLink',
            mceAdvLink: 'pepperLink'
        },

        '+style_formats': [

        ],

        '+stamps': {

        },

        '+theme_advanced_buttons2:9': ['vodorivideo'],

        '+theme_advanced_buttons2:12': ['advbackground'],

        /* jshint -W106 */
        '+theme_advanced_buttons2:26': ['stamper_dialog', 'pepperdemostamp', '|'],

        use_pepper_toolbar: true
        /* jshint +W106 */
    }));
});

},
'pepper/tinymce/AdvBackground':function(){
define([
    'vodori/amd/tinymce',
    'vodori/provide', 'module',
    'dojo/on', 'dojo/query', 'dojo/_base/lang',
    'vodori/tinymce/_GetInfoMixin',
    'vodori/tinymce/util/augmentWithLoader',
    'vodori/tinymce/util/getPluginName', 'vodori/tinymce/util/getResourceUrl',
    'pepper/library/LibraryDialog', 'pepper/library/FilterOverrideLibrary'
], function (
    tinymce,
    provide, module,
    on, query, lang,
    _GetInfoMixin,
    augmentWithLoader, getPluginName, getResourceUrl,
    LibraryDialog, FilterOverrideLibrary
    ) {
    var pluginName = getPluginName(module);

    var plugin = provide(module.id, [_GetInfoMixin], {
        editor: null,
        resourceUrl: getResourceUrl(module),

        pluginName: pluginName,

        menuItems: [],

        /**
         * @type {DOMWindow}
         */
        frameWindow: null,

        /**
         * @type {Object}
         */
        modal: null,

        init: function(ed, url) {
            this.editor = ed;

            ed.addCommand('mceEditBackground', function() {
                var ed = this.editor;

                var modal = this.modal = ed.windowManager.open({
                    file: this.resourceUrl + '/advbackground.htm',
                    width: 400 + ed.getLang('iframe.delta_width', 0),
                    height: 585 + ed.getLang('iframe.delta_height', 0),
                    inline: 1
                }, {
                    plugin: this
                });

                augmentWithLoader(modal);

                this.frameWindow = modal.iframeElement.get().contentWindow;

                this.connectBrowse();
            }, this);

            ed.addButton('advbackground', {
                image: this.resourceUrl + '/images/background.png',
                cmd: 'mceEditBackground',
                title: 'Add or change the background'
            });
        },

        /**
         * Connect to our browse button.
         */
        connectBrowse: function () {
            this.modal.require([
                'dojo/_base/lang', 'dojo/on', 'dojo/parser', 'dojo/query',
                'vodori/ui/Button', 'dojo/domReady!'
            ], lang.hitch(this, function (lang, on, parser, query) {
                parser.parse({template:false});

                var browseButton = query('.browse').pop();
                on(browseButton, 'click', lang.hitch(this, function () {
                    this.toggleModal(false);
                    this.browsePepper();
                }));
            }));
        },

        /**
         * Hide or show the tinymce modal associated with this plugin.
         *
         * @param {boolean?} show
         * @return {void}
         */
        toggleModal: function (show) {
            var blocker = query('#mceModalBlocker');
            if (this.modal.isHidden || show) {
                this.modal.element.show();
                blocker.style('display', 'block');
            } else {
                this.modal.element.hide();
                blocker.style('display', 'none');
            }
        },

        /**
         * Launch the browser and wait for a response.
         *
         * @return {void}
         */
        browsePepper: function () {
            var modal = new LibraryDialog({
                widget: new FilterOverrideLibrary({
                    readOnly: true,
                    resultsGridView: 'grid',
                    libraryFilterOverrides: [
                        {
                            'widget': 'pepper/library/filter/ui/ContentType',
                            'filterData': {
                                'default': 'Image'
                            }
                        },
                        {
                            'filterData': {
                                'exclude': ['Reception']
                            },
                            'widget': 'pepper/library/filter/ui/StateVersion'
                        }
                    ],
                    confirmHandler: lang.hitch(this, function(selection) {
                        this.setPepperObject(selection.pop() || {});
                    })
                }),
                onHide: lang.hitch(this, function() {
                    this.toggleModal(true);
                })
            });
            modal.startup();
            modal.show();
        },

        /**
         * @param {Object} pepperObject the first selection.
         * @return {void}
         */
        setPepperObject: function (pepperObject) {
            var forms = query('form', this.frameWindow.document.body);

            // Might as well support more than one form.
            forms.forEach(function (form) {
                form.image.value = pepperObject.pathInCurrentSubscription || '';
                form.image.onchange();
            }, this);
        }

    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});


},
'vodori/tinymce/util/augmentWithLoader':function(){
define([
    'vodori/tinymce/ScriptLoader'
], function (ScriptLoader) {
    'use strict';

    /**
     * Loans require and define to @param augmented, which is a remapping of augmented's
     * window.require/define, which will be added if they're not already defined.
     *
     * @param {(tinymce.Editor|{iframeElement: tinymce.dom.Element})} augmented An editor or a modal
     * @return {Object} Whatever you wanted to augment.
     */
    return function (augmented) {
        var scriptLoader = new ScriptLoader();

        if (!!augmented.iframeElement) {
            scriptLoader.addLoaderToModal(augmented);
        } else {
            scriptLoader.addLoaderToFrame(augmented.getWin(), this);
        }

        return augmented;
    };
});

},
'vodori/tinymce/ScriptLoader':function(){
define([
    'vodori/provide', 'module',
    'vodori/util/addLoaderToFrame',
    'dojo/query', 'dojo/_base/lang', 'dojo/Deferred'
], function (provide, module, addLoaderToFrameUtil, query, lang, Deferred) {
    'use strict';

    /**
     * Loans require and define to a given frame.
     */
    return provide(module.id, null, {

        /**
         * Blocking behind a Deferred, so calling require early has no negative side-effects.
         *
         * @type {dojo.Deferred}
         * @private
         */
        _loaderDeferred: null,

        /**
         * Prep deferred to hide require/define calls.
         */
        constructor: function (args) {
            this._loaderDeferred = new Deferred();
            // Let client override attributes upon construction.
            lang.mixin(this, args);
        },

        /**
         * @param {{iframeElement: tinymce.dom.Element}} modal
         * @protected
         */
        addLoaderToModal: function (modal) {
            var frameWin = query('iframe', modal.id).pop().contentWindow;

            modal.iframeElement.on('load', lang.hitch(this, function () {
                this.addLoaderToFrame(frameWin);
            }));

            // Must mixin the context separately, so we can call this.require immediately.
            lang.mixin(modal, this);
        },

        /**
         * Wrapper for addLoaderToFrame.
         *
         * @param {Window} frame
         * @param {Object} [context]
         */
        addLoaderToFrame: function (frame, context) {
            addLoaderToFrameUtil(frame).then(lang.hitch(this, function (req) {
                this._loaderDeferred.resolve(req, frame.define);
            }));

            if (!!context) {
                lang.mixin(context, this);
            }
        },

        /**
         * An implementation of the AMD spec's require see: https://github.com/amdjs/amdjs-api/wiki/AMD
         */
        require: function () {
            return this._delayedApply('require', arguments);
        },

        /**
         * An implementation of the AMD spec's define see: https://github.com/amdjs/amdjs-api/wiki/AMD
         */
        define: function () {
            return this._delayedApply('define', arguments);
        },

        /**
         * Call either define or require from the window when the loader is ready for them.
         *
         * @param {string} name
         * @param {ArrayLike} args
         * @protected
         */
        _delayedApply: function (name, args) {
            this._loaderDeferred.then(lang.hitch(this, function (require, define) {
                var method = name === 'define' ? define : require;
                method.apply(this, args);
            }));
        }
    });
});

},
'pepper/library/FilterOverrideLibrary':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
        'module', 'vodori/provide',
        'lodash',
        'pepper/library/LibraryNouveau'
    ],
    function (module, provide,
              _,
              LibraryNouveau
        ) {

        /**
         * A customized version of LibraryNouveau that allows you to override the default settings for specific filter
         * widgets instead of having to specify settings for all filters when any customization is required.
         *
         * Values to add or override for filter widgets need to be specified in the constructor using the
         * libraryFilterOverrides key.
         */
        return provide(module.id, [ LibraryNouveau ], {

            /**
             * Overrides the default values supplied to LibraryNouveau.libraryFilters. Each object in the given
             * array will be merged with the object in LibraryNouveau.libraryFilters that has the same 'widget' key
             * value. If an object with the same 'widget' value is not found, then the object from the given array is
             * pushed to LibraryNouveau.libraryFilters as an additional filter.
             *
             * The defaults for this.libraryFilters are supplied in the library.jsp file's
             * <pepper-data:json mids="pepper/library/LibraryBrowser/libraryFilters"> tag.
             */
            libraryFilterOverrides: [],

            /**
             * Use the same configuration as LibraryNouveau, otherwise _TemplatedData will not be able to find a
             * configuration MID specified for this widget and we won't be able to override LibraryNouveau's filters.
             */
            configurationMids: ['pepper/library/LibraryNouveau'],

            postCreate: function() {
                if (this.libraryFilterOverrides.length > 0) {
                    var libraryFilters = this.get('libraryFilters');

                    console.debug('libraryFilters BEFORE merge: ', libraryFilters);

                    _.forEach(this.libraryFilterOverrides, function(filterOverrideConfig) {
                        var widgetToOverride = filterOverrideConfig.widget;

                        // find the filter's default config in the libraryFilters array.
                        var defaultWidgetConfigIndex = _.findIndex(libraryFilters, {'widget': widgetToOverride});

                        if (defaultWidgetConfigIndex >= 0) {
                            libraryFilters[defaultWidgetConfigIndex] =
                                _.merge(libraryFilters[defaultWidgetConfigIndex], filterOverrideConfig);
                        } else {
                            libraryFilters.push(filterOverrideConfig);
                        }
                    });

                    console.debug('libraryFilters AFTER merge: ', libraryFilters);

                    this.set('libraryFilters', libraryFilters);
                } else {
                    console.info('No libraryFilterOverrides were specified.');
                }

                this.inherited(arguments);
            }

        });
    });

},
'pepper/library/LibraryNouveau':function(){
/*global define*/
define([
    'require', 'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/_base/declare',
    'dojo/on', 'dojo/topic', 'dojo/Deferred', 'dojo/when', 'dojo/promise/all',
    'dojo/dom-attr', 'dojo/dom-class', 'dojo/dom-geometry',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'vodori/renderTemplate',
    'vodori/ui/ButtonSet', 'vodori/util/string/camelToDashed', 'vodori/util/function/flip',
    'vodori/ui/StatefulDom',
    'vodori/layout/_Composable', 'vodori/layout/_Composing',
    'vodori/util/_TemplatedData',
    'vodori/filter/model/Search',
    'pepper/data/getCustomFilters',
    'pepper/ui/_QuarantineMixin',
    'pepper/library/Grid', 'pepper/library/_EditableGridMixin', 'pepper/library/filter/ui/ChannelSelector',
    'pepper/library/filter/ui/CustomFilter',
    'pepper/events', 'pepper/services', 'pepper/data/GetChannelsType',
    'dojo/text!./templates/Library.html',

    /* Unreferenced MIDs */
    'dijit/layout/ContentPane', 'dijit/layout/BorderContainer',
    'vodori/filter/FilterContainer', 'vodori/input/TextBox',
    'vodori/filter/FilterUIBox', 'vodori/filter/BasicFilterWidget', 'vodori/filter/DropdownFilterWidget',
    'vodori/filter/DateFilterWidget', 'vodori/filter/model/Search',
    'pepper/library/filter/ui/TreeFilterWidget', 'pepper/library/filter/LibraryFilters',
    'pepper/library/DetailsPane', 'pepper/library/ResultsHeader',
    'pepper/library/filter/ui/FacetedSearch'
], function (
    contextRequire, module, provide,
    _,
    lang, declare,
    on, topic, Deferred, when, all,
    domAttr, domClass, domGeom,
    _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
    renderTemplate,
    ButtonSet, camelToDashed, flip,
    StatefulDom,
    _Composable, _Composing,
    _TemplatedData,
    SearchFilter,
    getCustomFilters,
    _QuarantineMixin,
    Grid, _EditableGridMixin, ChannelSelector,
    CustomFilter,

    events, services, GetChannelsType,
    template
    ) {
    /**
     * @const
     * @type {string}
     */
    var RESULTS_GRID_ATTACH_POINT = '_resultsGrid';

    /**
     * Used to render the name of various choice grids.
     *
     * @const
     * @type {string}
     */
    var GRID_NAME_TEMPLATE = '_{{view}}Grid';

    /**
     * A centralized place to manage assets available to Pepper. This module composes the various
     * sub-components
     *
     * @class LibraryNouveau
     */
    var LibraryNouveau = provide(module, [
        // This must be "on top" of _WidgetBase, since I'm using Evented inside of it.
        StatefulDom, _TemplatedData,
        _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
        _Composable, _Composing, _QuarantineMixin
    ], {
        /* attach points */
        _categoriesGrid: null,
        _centerBorderContainer: null,
        _channelsGrid: null,
        _channelSelectorNode: null,
        _details: null,
        _footer: null,
        _primaryFilterContainer: null,
        _primaryViewer: null,
        _resultsGridNode: null,
        _resultsHeader: null,
        _searchBox: null,
        _subscriptionsGrid: null,
        _summarizer: null,
        _tagsGrid: null,
        _title: null,
        _viewSelectorButtons: null,
        _viewSelectorContainer: null,

        /**
         * See _Composable
         *
         * @type {Boolean}
         */
        shouldFillContainer: true,

        /**
         * @type {string}
         */
        templateString: template,

        /**
         * Determines whether or not any part of the library (grid items, filters, etc.)
         * can be edited.
         *
         * @type {Boolean}
         */
        readOnly: false,

        /**
         * Whether the library should display a button to download the results as CSV. This must be set before
         * postCreate().
         */
        csvDownloadEnabled: false,

        /**
         * StatefulDom configuration that calls the setters for which components should be visible.
         *
         * @type {Object.<*>}
         */
        states: {
            // NOTE: _details is a special case and only shows when there's a selection. It'll only
            // show when it's both enabled below and there's a selection
            base: {
                props: {
                    shown: [
                        RESULTS_GRID_ATTACH_POINT,
                        '_primaryFilterContainer',
                        '_details',
                        '_footer'
                    ]
                }
            },

            choose: {
                props: {
                    shown: [
                        GRID_NAME_TEMPLATE,
                        '_footer'
                    ]
                }
            },

            summarized: {
                props: {
                    shown: [
                        '_summarizer',
                        '_primaryFilterContainer',
                        RESULTS_GRID_ATTACH_POINT,
                        '_details',
                        '_footer'
                    ]
                }
            },

            summarizedChoice: {
                props: {
                    shown: [
                        '_summarizer',
                        '_primaryFilterContainer',
                        GRID_NAME_TEMPLATE,
                        RESULTS_GRID_ATTACH_POINT,
                        '_details',
                        '_footer'
                    ]
                }
            }
        },

        /**
         * Used to pass the query on to the Grid and FilterManager. Access via T::set and T::get
         *
         * @type {Object}
         */
        query: null,

        /**
         * Used to pass the view on to the Grid and Results Header (either 'list' or 'grid')
         *
         * @type {String}
         */
        resultsGridView: null,

        /**
         * @inheritDoc
         */
        events: ['.view-selector [name]:click'],

        /**
         * The current view.
         *
         * @type {string}
         */
        view: 'all',

        /**
         * Maps each possible view to a collection of named states. Usage
         * this.set('view', 'subscriptions', 1)
         *
         * @type {Object.<Array.<string>>}
         */
        viewMap: {
            all: [
                'base'
            ],
            channels: [
                'choose',
                'summarized'
            ],
            subscriptions: [
                'choose',
                'summarized'
            ],
            categories: [
                'choose',
                'summarizedChoice'
            ],
            tags: [
                'choose',
                'summarizedChoice'
            ]
        },

        /**
         * Turning off to reduce overhead.
         *
         * @inheritDoc
         */
        simulateBubbling: false,

        /**
         * @type {string}
         * @const
         */
        RESULTS_GRID_ATTACH_POINT: RESULTS_GRID_ATTACH_POINT,

        /**
         * @type {string}
         * @const
         */
        GRID_NAME_TEMPLATE: GRID_NAME_TEMPLATE,

        /**
         * HTML class applied to a choice grid's container pane when the pane is split view w/ the
         * results grid.
         *
         * @type {string}
         * @const
         */
        GRID_AS_TOP_HTML_CLASS: 'as-top',

        /**
         * Used to signal when the grid has a selection.
         *
         * @type {string}
         * @const
         */
        SELECTION_HTML_CLASS: 'is-selection',

        READ_ONLY_CSS_CLASS: 'read-only',

        /**
         * The panes that are sometimes hidden.
         *
         * @type {Array.<string>}
         */
        _conditionallyShown: [
            '_summarizer',
            '_primaryFilterContainer',
            RESULTS_GRID_ATTACH_POINT,
            '_channelsGrid',
            '_subscriptionsGrid',
            '_categoriesGrid',
            '_tagsGrid',
            '_results',
            '_details',
            '_footer'
        ],

        /**
         * @type {Object}
         */
        _viewSelectorConfig: {
            buttons: [
                {
                    name: 'all',
                    label: 'All',
                    attrs: {
                        'class': 'all',
                        title: 'View all types of content.'
                    }
                },
                {
                    name: 'channels',
                    label: 'Channels',
                    attrs: {
                        'class': 'channels',
                        title: 'View available channels.'
                    }
                },
                {
                    name: 'subscriptions',
                    label: 'Subscriptions',
                    attrs: {
                        'class': 'subscriptions',
                        title: 'View available subscriptions.'
                    }
                },
                {
                    name: 'categories',
                    label: 'Categories',
                    attrs: {
                        'class': 'categories',
                        title: 'View available categories.'
                    }
                },
                {
                    name: 'tags',
                    label: 'Tags',
                    attrs: {
                        'class': 'tags',
                        title: 'View available tags.'
                    }
                }
            ],
            states: {
                all: 1
            },
            state: 'all'
        },

        _pointToShowClass: null,

        _resultsGrid: null,
        _container: null,
        _searchFilter: null,
        _initialFilterSetLoadedDeferred: null,

        channelSelector: null,
        facetedSearch: null,

        constructor: function () {
            this._pointToShowClass = {};
            this.filters = [];
            this.query = {};
            this._initialFilterSetLoadedDeferred = new Deferred();

            // Protect ourselves from object sharing.
            this._viewSelectorConfig = _.clone(this._viewSelectorConfig, true);

            // Generate the show classes.
            _.forEach(this._conditionallyShown, function (name) {
                this._pointToShowClass[name] = 'is-' + camelToDashed(name).replace(/^_/, '');
            }, this);
        },

        buildRendering: function () {
            this.inherited(arguments);

            var ResultsGridCtor = this.readOnly ? Grid : declare([Grid, _EditableGridMixin]),
                gridOptions = {
                    'region': 'center'
                },
                resultsGridView = this.resultsGridView;

            if (resultsGridView) {
                gridOptions.view = resultsGridView;
            }

            this._resultsGrid = new ResultsGridCtor(gridOptions, this._resultsGridNode);

            this._viewSelectorButtons = new ButtonSet(
                this._viewSelectorConfig, // params
                this._viewSelectorButtons // sourceNodeRef
            );

            // default showChannels to "all" when library is in read/write mode
            // and "inCurrentSubscription" for read only mode
            if(!this.showChannels) {
                this.showChannels = this.readOnly ? GetChannelsType.inCurrentSubscription : GetChannelsType.all;
            }
        },

        postCreate: function () {
            this.inherited(arguments);

            var currentChannelId;

            var persistedChannelSelection = LibraryNouveau.readOnlyState.channelSelectionFor[this.showChannels];

            if(this.readOnly && persistedChannelSelection) {
                this.currentChannel = persistedChannelSelection;
            }

            if(this.currentChannel) {

                currentChannelId = this.currentChannel.id;

                // set the current channel for read only mode if it has not been set yet
                if(this.readOnly && !persistedChannelSelection) {
                    LibraryNouveau.readOnlyState.channelSelectionFor[this.showChannels] = this.currentChannel;
                }

                this._resultsHeader.set('currentChannel', this.currentChannel);
            }

            this.channelSelector = new ChannelSelector(
                { currentChannelId: currentChannelId, type: this.showChannels },
                this._channelSelectorNode
            );

            if(currentChannelId) {
                this.channelSelector.on('channeldata', lang.hitch(this, function(event) {
                    var channels = _.where(event.data, { id: currentChannelId.toString() });

                    if(channels.length === 1) {
                        var channel = channels[0];

                        this._initialFilterSetLoadedDeferred.then(
                            lang.hitch(this, '_adjustForCurrentSubscription', channel)
                        );
                    } else {
                        console.warn(
                            'current channel set as',
                            currentChannelId,
                            'but channel data from backend has',
                            channels.length,
                            'matching channels.'
                        );
                    }

                }));
            }

            when(this._primaryFilterContainer.get('filterManager'), lang.hitch(this, function (manager) {
                this.own(manager.watch('query', lang.hitch(this, function (__, ___, newValue) {
                    this.set('query', newValue, true);
                })));
                this._addFilters();
                this._addSearchFilter();
                this.own(manager.register(this._searchFilter));
                this.own(manager.register(this.channelSelector.filter));
                this.own(manager.register(this.facetedSearch.filter));
            }));

            this.own(
                on(this._resultsGrid, 'selectionChange', lang.hitch(this, '_handleSelectionChange')),

                // This subscription is for de-coupled refreshing
                topic.subscribe(events.library.refresh, lang.hitch(this, function() {
                    this._resultsGrid.refresh();
                })),

                this.channelSelector.on(
                    events.library.filters.channel.selectionChanged,
                    lang.hitch(this, '_handleChannelSelectorChange')
                ),

                // This subscription is for refreshing from the refresh button in the results header
                this._resultsHeader.on(events.library.refresh, lang.hitch(this, function() {
                    this._resultsGrid.refresh();
                })),
                this._resultsHeader.on(events.library.viewChange, lang.hitch(this, function(view) {
                    this._resultsGrid.set('view', view);
                })),
                this._resultsHeader.on('downloadCsv', lang.hitch(this, 'downloadCsv')),

                on(this._details, 'tag_removed', lang.hitch(this, '_handleTagOrCategoryRemoval', 'tag')),
                on(this._details, 'category_removed', lang.hitch(this, '_handleTagOrCategoryRemoval', 'category'))
            );

            this._resultsHeader.set('view', this._resultsGrid.get('view'));

            if (this.csvDownloadEnabled) {
                domClass.add(this.domNode, 'csvDownloadEnabled');
            }

            this.set('state', this.state);
        },

        startup: function () {
            this.inherited(arguments);

            var parentContainer = this.getParent();

            if (parentContainer) {
                domClass.toggle(parentContainer.domNode, this.READ_ONLY_CSS_CLASS, this.readOnly);
            }

            this._viewSelectorButtons.startup();
        },

        clearAllFilters: function () {
            this._primaryFilterContainer.get('filterManager').then(function (manager) {
                manager.resetAll();
            });
        },

        cancel: function() {
            this.fireCompose({
                methods : {
                    'hide' : {}
                }
            });
        },

        downloadCsv: function() {
            services.queryLibrary({
                params: {
                    state: 'DOWNLOAD',
                    query: this.query
                }
            });
        },

        /**
         * This method takes a channel id and updates the channel selector accordingly.
         *
         * @param channelId
         */
        selectCurrentChannel: function(channelId) {
            this.channelSelector.selectChannel(channelId);
        },

        /**
         * Perform any UI adjustments that correspond to a given channel.
         *
         * @param {Object} channel description of a channel
         */
        _adjustForCurrentSubscription: function(channel) {
            var disabledState = !channel.isInCurrentSubscription;

            if (disabledState) {
                this._resultsHeader.disableCreateButton();
            } else {
                this._resultsHeader.enableCreateButton();
            }

            when(this._primaryFilterContainer.get('filterManager'), lang.hitch(this, function (manager) {
                _.forEach(manager.get('filters'), function(filter) {
                    if(filter.disabledWhenChannelNotInSubscription) {
                        filter.set('disabled', disabledState);
                    }

                    if(filter.updateWithNewChannel) {
                        filter.updateWithNewChannel(channel.id);
                    }
                });
            }));

            this._resultsHeader.set('currentChannel', channel);
        },

        /**
         * Adjusts the custom filters based on a newly selected channel
         *
         * @param {Object} channel description of a channel
         */
        _adjustCustomFiltersForChannel: function(channel) {
            var allPromises = {
                customFilters: getCustomFilters(channel.id),
                filterManager: this._primaryFilterContainer.get('filterManager')
            };

            all(allPromises).then(lang.hitch(this, function (results) {
                var customFilterMap = {};

                _.forEach(results.customFilters, function(customFilter) {
                    customFilterMap[customFilter.key] = customFilter;
                });

                _.forEach(results.filterManager.get('filters'), function(filter) {
                    if(filter.isCustomFilter) {
                        var customFilter = customFilterMap[filter.key];

                        if(!customFilter) {
                            console.log('Custom filter not found -- should be disabled instead of being omitted.');
                            return;
                        }

                        filter.refreshPayload(customFilter);
                    }
                });
            }));

            this._resultsHeader.set('currentChannel', channel);
        },

        _handleChannelSelectorChange: function(event) {
            var channel = event.data;

            if(this.readOnly) {
                LibraryNouveau.readOnlyState.channelSelectionFor[this.showChannels] = channel;
            }

            this._adjustForCurrentSubscription(channel);
            this._adjustCustomFiltersForChannel(channel);
        },

        /**
         * @param taxonomyType One of either 'tag' or 'category'.
         * @param eventObj The event object which should contain the id of the taxonomy removed.
         * @private
         */
        _handleTagOrCategoryRemoval: function(taxonomyType, eventObj) {
            if(this.query[taxonomyType] === eventObj.id) {
                this._resultsGrid.refresh();
            }
        },

        _confirmHandler: function() {
            var confirmHandler = this.confirmHandler;

            if (confirmHandler && typeof confirmHandler === 'function') {
                confirmHandler(this._resultsGrid.get('selectedItems'));
            }

            this.cancel();
        },

        /**
         * @param {{target: Element}} event
         */
        '_.view-selector [name]:clickListener': function (event) {
            this.set('view', domAttr.get(event.target, 'name'));
        },

        _addFilters: function () {
            var filterModelDeferreds = [];

            // pause grid while adding filters
            this._resultsGrid.pauseRefreshing();

            _.forEach(this.libraryFilters, lang.partial(this._processFilterConfig, filterModelDeferreds), this);

            var channelsRetrievedDeferred;

            if(this._currentChannelIdSet()) {
                channelsRetrievedDeferred = getCustomFilters(this.currentChannel.id);
            } else {
                channelsRetrievedDeferred = new Deferred();
                channelsRetrievedDeferred.resolve();
            }

            channelsRetrievedDeferred.then(lang.hitch(this, function(customFilters) {
                _.forEach(customFilters, lang.hitch(this, '_addCustomFilter'));

                this._primaryFilterContainer.scrollToTop();

                all(filterModelDeferreds).then(lang.hitch(this, function() {
                    this._initialFilterSetLoadedDeferred.resolve();
                    this._resultsGrid.resumeRefreshing();
                }));

            }));
        },

        _processFilterConfig: function (filterModelDeferreds, config) {
            config = this._processConfig(config);

            var deferred;

            // widget
            if (config.widget) {
                // build filter
                // returns deferred for its models
                deferred = this._addFilterUI(config);
            }

            // model
            if (config.model) {
                // get model as deferred
                deferred = this._addFilterModel(config);
            }

            if(deferred) {
                filterModelDeferreds.push(deferred);
            }
        },

        _addCustomFilter: function(config) {
            var customFilter = new CustomFilter(config);
            customFilter.startup();
            this._primaryFilterContainer.add(customFilter);

            return customFilter.filterSource;
        },

        // Pass { model: 'path/to/filter/model' } to load a filter model
        // add other properties for configuration
        // set how to handle config in model _process_payload method
        _addFilterModel: function (config) {
            var modelDeferred = new Deferred();

            // include model so you can run queries with it
            require([config.model], function (model) {
                modelDeferred.resolve(model);
            });

            all([
                modelDeferred,
                this._primaryFilterContainer.get('filterManager')
            ]).then(function(results) {
                    var Model = results[0],
                        manager = results[1];

                    window.manager = manager;

                    manager.register(new Model(config));
                });

            return modelDeferred;
        },

        _currentChannelIdSet: function() {
            return this.currentChannel && this.currentChannel.id && this.currentChannel.id !== '';
        },

        _processConfig: function(config) {
            var cloned = false;

            if(this._currentChannelIdSet()) {
                config = _.clone(config);
                cloned = true;

                _.assign(config, { channelId: this.currentChannel.id });
            }

            // Pass the library readOnly flag to each filter,
            // while still allowing each filter to override individually
            if (!('readOnly' in config)) {
                if(!cloned) {
                    config = _.clone(config);
                }

                config.readOnly = this.readOnly;
            }

            return config;
        },

        _addFilterUI: function (config) {
            var FilterWidget = null,
                message = '';

            try {
                FilterWidget = contextRequire(config.widget);
            }
            catch (e) {
                message = 'Couldn\'t find widget for %o' + config;
                console.error(message);
                throw new Error(message);
            }

            var filterUI = new FilterWidget(config);
            filterUI.startup();
            this._primaryFilterContainer.add(filterUI);
            return ((filterUI.filterSource || filterUI).get('filters'));
        },

        _addSearchFilter: function () {
            var searchFilter = this._searchFilter = new SearchFilter();

            this._searchBox.on('change', lang.hitch(searchFilter, 'select'));

            this.own(searchFilter.watch('query', lang.hitch(this, function(_, __, searchQuery) {
                this._searchBox.set('value', searchQuery.search || '');
            })));
        },

        _handleSelectionChange: function () {
            var selections = this._resultsGrid.get('selectedItems');
            domClass.toggle(this.domNode, this.SELECTION_HTML_CLASS, !_.isEmpty(selections));

            // the details pane must be fully loaded before the border container can be resized
            var detailsPaneDeferred = this._details.setSelections(_.clone(selections));
            detailsPaneDeferred.then(lang.hitch(this._container, 'resize'));

            this._resultsHeader.set('selectedItems', selections);
        },

        /**
         * @param {string} view
         * @param {number} [index=0]
         * @return {T}
         * @private
         */
        _setViewAttr: function (view, index) {
            // Allow setting w/ an Array when using declarative syntax.
            if (_.isArray(view)) {
                index = view[1];
                view = view[0];
            }

            var viewMap = this.viewMap[view];

            if (!viewMap) {
                throw new Error('No viewMap found for ' + view);
            }

            this.view = view;

            this.set('state', viewMap[index || 0], true);

            return this;
        },

        /**
         * Passes the query along to the grid and FilterManager.
         *
         * @param {Object} query
         * @param {boolean} [internal=false]
         * @private
         */
        _setQueryAttr: function (query, internal) {
            when(this._primaryFilterContainer.get('filterManager'), lang.hitch(this, function (manager) {
                if (!internal) {
                    this._initialFilterSetLoadedDeferred.then(lang.hitch(this, function() {
                        manager.set('query', query);

                        this.query = manager.get('query');

                        this._resultsGrid.set('query', this.query);
                    }));
                } else {
                    // Let the manager mung the query however it wants.
                    this.query = manager.get('query');

                    this._resultsGrid.set('query', this.query);
                }
            }));

            return this;
        },

        /**
         * @param {Array.<string>} shown
         * @return {T}
         * @private
         */
        _setShownAttr: function (shown) {
            var dualGrid = _.contains(shown, this.GRID_NAME_TEMPLATE, this.RESULTS_GRID_ATTACH_POINT);
            shown = _.map(shown, lang.partial(flip(renderTemplate), {view: this.view}));

            var otherGridName = _.find(shown, function (point) {
                return point !== this.RESULTS_GRID_ATTACH_POINT && /Grid$/.test(point);
            }, this);

            var oGrid = this[otherGridName];
            if (oGrid) {
                oGrid.set('region', dualGrid ? 'top' : 'center');
                domClass.toggle(oGrid.domNode, this.GRID_AS_TOP_HTML_CLASS, dualGrid);
            }

            _.forEach(this._pointToShowClass, function (htmlClass, pointName) {
                if (_.contains(shown, pointName)) {
                    // Same here, adding an existing class is a no-op.
                    domClass.add(this.domNode, htmlClass);
                }
                else {
                    // Removing a class that's not there has no side-effect.
                    domClass.remove(this.domNode, htmlClass);
                }
            }, this);

            return this;
        },

        resize: function(dimensions) {
            this._container.resize(dimensions);
        },

        destroy: function () {
            if (!!this._primaryFilterContainer) {
                this._primaryFilterContainer.destroyRecursive();
            }

            this.inherited(arguments);
        }
    });

    LibraryNouveau.readOnlyState = {

        // stores the channel selected based on the showChannels constructor parameter
        channelSelectionFor: {}
    };

    return LibraryNouveau;
});

},
'vodori/util/string/camelToDashed':function(){
define(function () {
    /**
     * Converts a camelCased string to a dash-delimited string. Ex. fooBarBaz -> foo-bar-baz.
     *
     * @param {string} [str='']
     * @return {string}
     */
    return function (str) {
        return (str || '').replace(/([A-Z])/g, function (m) {
            return '-' + m.toLowerCase();
        });
    };
});
},
'vodori/util/_TemplatedData':function(){
/**
 * Safely mixin JSON configuration into a widget.
 *
 * This code expects inheriting widgets to declare a configurationMids array that point to the
 * configuration OR to pass their module object to vodori/provide at declaration time.
 *
 * For example if a widget vodori/Calculator extends this mixin and the page contains
 * ```
 * <script type="application/json" data-templated-data-for-modules="vodori/Calculator">
 * {
 *   operation: 'x',
 *   leftOperand: 2,
 *   rightOperand: 3
 * }
 * </script>
 * ```
 * then each instance of vodori/Calculator will be populated with the properties 'operation',
 * 'leftOperand' and 'rightOperand' with the values specified in the script tag.
 *
 * @module vodori/util/_TemplatedData
 */
define([
    'lodash',
    'dojo/_base/declare', 'dojo/_base/lang', 'dojo/json',
    'dojo/dom-attr', 'dojo/dom-construct', 'dojo/query'
], function (_, declare, lang, JSON, domAttr, domConstruct, query) {

    var _class = {
        /**
         * A list of MIDs (module IDs) that will be used to associate script tags w/ `this`.
         *
         * @type {Array.<string>}
         */
        configurationMids: [],

        /**
         * The attribute used to find the data containers
         *
         * @type {string}
         * @const
         */
        DATA_TRANSFER_ATTR: 'data-templated-data-for-modules',

        constructor: function () {

            // Create a copy of the configuration or an empty config if none specified.
            if (_.isArray(this.configurationMids)) {
                this.configurationMids = this.configurationMids.slice(0);
            }
            else {
                this.configurationMids = [];
            }

            var moduleIdFromConstructor = !!this.constructor ? this.constructor.module : null;

            // Error out if the user hasn't specified a configuration
            if (this.configurationMids.length === 0) {
                // IF the new style constructor is used, then read its mid automatically.
                if (moduleIdFromConstructor) {
                    this.configurationMids.push(moduleIdFromConstructor.id);
                }
                else {
                    throw new Error('You must specify at least 1 MID');
                }
            }

            // Loop through each of the MIDs that's been defined
            _.forEach(this.configurationMids, function (mid) {

                // Do a CSS select for the configuration node, and error out if it isn't found
                var configSelector = 'script[' + this.DATA_TRANSFER_ATTR + '*="' + mid + '"]';
                var configNode = query(configSelector);
                if (configNode.length === 0) {
                    console.warn(
                        'Unable to find data for the configuration mid: ' +
                        mid +
                        '.  There must be a node that matches the following selector: ' +
                        configSelector
                    );
                    return;
                }

                // Extract the contents of the config node, and convert to JSON
                var jsonRaw = configNode[0].innerHTML;
                if (!!jsonRaw) {

                    var jsonConfig = JSON.parse(jsonRaw);

                    // Mixin the config object to the current widget
                    lang.mixin(this, jsonConfig);
                }

            }, this);

        }

    };
    /**
     * @lends module:vodori/util/_TemplatedData#
     */
    return declare(null, _class);
});

},
'pepper/data/getCustomFilters':function(){
define([
    'dojo/Deferred',
    'pepper/services'
], function (Deferred, services) {
    /**
     * This command returns all custom filters for a specific channel.
     * @return {Promise} A promise that resolves to an array of custom filters. The format of each item in the array is
     * { key: string, title: string, helperText: string, enabled: boolean, values: [ {label: string, id: string} ] }
     */
    return function(channelId) {
        var deferred = new Deferred();

        var request = {params: { channelId: channelId }};

        services.getCustomFilters(request).then(function(result) {
            deferred.resolve(result.results);
        }, function(error) {
            var message = error && error.message;
            deferred.reject(message || 'FAILED');
        });

        return deferred.promise;
    };
});

},
'pepper/library/Grid':function(){
define([
    'module', 'vodori/provide',
    'dojo/dom-class', 'dojo/query',
    'dojo/topic',
    'vodori/ui/DndGrid',
    'pepper/events',
    'pepper/library/data/LibraryQueryStoreWrapper',
    'pepper/library/renderers',
    'pepper/library/IconViewCell',
    'pepper/ui/handleNotification'
], function(module, provide,
            domClass, query,
            topic,
            DndGrid,
            events,
            LibraryQueryStoreWrapper,
            renderers,
            IconViewCell,
            handleNotification) {

    var MAX_SELECTIONS  = -1;
    var MIN_ROWS        = 64;
    return provide(module.id, [DndGrid],
        /**
         * @lends pepper/library/Grid
         */
        {

            query: null,

            view: 'list',

            selectionLimit: MAX_SELECTIONS, // Limit number of Library selections
            noDataMessage: 'No results found.',
            minRowsPerPage: MIN_ROWS,       // Number of rows to get per page request

            store: null,

            /**
             * @constructs
             * @mixes vodori/ui/DndGrid
             */
            constructor: function() {
                this.query = {};

                this.columns = [
                    { label: 'Lock', field: 'lockOwner', renderCell: renderers.lockOwner },
                    { label: 'Sync', field: 'indicator', renderCell: renderers.indicator},
                    { label: 'Name', field: 'name', renderCell: renderers.name },
                    { label: 'Type', field: 'documentType', renderCell: renderers.type },
                    { label: 'State', field: 'sortableLifecycleState', renderCell: renderers.lifecycle },
                    { label: 'Version', field: 'sortableVersionLabel', renderCell: renderers.versionLabel },
                    { label: 'Language', field: 'locale' },
                    { label: 'Modified', field: 'pepperLastModifiedDate', renderCell: renderers.lastModified }
                ];

                this.store = new LibraryQueryStoreWrapper();
            },

            /**
             * @ignore
             */
            startup: function() {
                if (this._started) {  // prevent double-triggering
                    return;
                }

                this.inherited(arguments);
                this.set('sort', 'pepperLastModifiedDate', true);

                this.subscribe(events.library.menu.refreshCommandCompleted, function(){
                    topic.publish(events.library.refresh);
                });

                // Make sure the renderRow function is appropriately set.
                this._assignRenderRow(this.view);
            },

            /**
             * Handle the refreshing of a row
             *
             * @param {string} id
             * @private
             */
            _rowRefreshHandler: function(id) {
                console.log('Refreshing grid because of action performed on: ', id);

                this.refreshGrid();
            },

            _reportDisallowedSelection: handleNotification,

            /**
             * Refreshes the grid using the query supplied or the current query
             * @param {Object.<string,*>} [query]  the query to refresh the grid with
             */
            refresh: function(query) {
                this.clearSelections();

                if (query) {
                    console.log('Updating the grid with the following query:', query);
                    this.set('query', query);
                } else {
                    this.inherited(arguments);
                }

            },

            refreshGrid: function() {
                this.refresh();
            },

            /**
             * Clears the currently selected items
             */
            clearSelections: function() {
                this.clearSelection(true);
            },

            /**
             * Sets the view of this grid to be either list or grid
             * Must be `_setView` per dgrid requirements
             *
             * @param view the viewname
             * @private
             */
            _setView: function(view) {

                // prevent re-rending the grid if we aren't actually changing views.
                if (this.view === view) {
                    return;
                }

                // Setting the view seems to get rid of the sort arrow, so we need to get it here to set it after the
                // view change.
                var sort = this.get('sort');

                // To clarify: "list" means grid, "grid" means icons.
                this.view = view;

                this._assignRenderRow(view);

                this.set('showHeader', view === 'list');

                this.set('sort', sort);
                this.refresh();
            },

            _assignRenderRow: function(view) {
                if (view === 'list') {
                    domClass.replace(this.domNode, 'listView', 'iconView');
                    this.renderRow = this._renderRowList;
                } else { // grid/icon view
                    domClass.replace(this.domNode, 'iconView', 'listView');
                    this.renderRow = function(object, options) {
                        var cell = new IconViewCell({ data: object });
                        return cell.domNode;
                    };
                }
            }
        }
    );
});

},
'vodori/ui/DndGrid':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'vodori/provide', 'module',
    'lodash',
    'vodori/ui/grid/_BaseGrid',
    './grid/GridFactory!keyboard,selection,columnResizer,dnd',
    'dijit/_WidgetBase', 'dijit/layout/_ContentPaneResizeMixin'
], function (provide, module, _, _BaseGrid, GridModules, _WidgetBase, _ContentPaneResizeMixin) {

    /**
     * An extension of the vodori/ui/Grid to include dnd
     *
     * @class vodori/ui/DndGrid
     * @extends dijit/_WidgetBase
     * @extends dijit/layout/_ContentPaneResizeMixin
     *
     * @extends dgrid/Keyboard
     * @extends vodori/ui/grid/_Selection
     * @extends dgrid/ColumnResizer
     *
     * @extends vodori/ui/grid/_BaseGrid
     */
    return provide(module, _.flatten([_WidgetBase, _ContentPaneResizeMixin, GridModules, _BaseGrid]), {
    });
});

},
'pepper/library/data/LibraryQueryStoreWrapper':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'dojo/Deferred', 'dojo/store/util/QueryResults', 'dojo/topic',
    'lodash',
    'pepper/data/PostDescriptorStore', 'pepper/events'
], function (module, provide,
             lang,
             Deferred, QueryResults, topic,
             _,
             postDescriptorStore, events) {

    /**
     * Wrapper PostDescriptorStore for the library so the query happens correctly
     * and to make sure only the most recent request gets to return (and therefore render) results.
     */
    return provide(module.id, null, {
        _previousPendingQueries: null,
        identifier: 'objectId',
        idProperty: 'id',

        constructor: function () {
            this._previousPendingQueries = [];
        },

        getIdentity: postDescriptorStore.getIdentity,

        query: function(query, options) {
            query = this._formatQuery(query, options);

            if (query.start === 0) {
                this._cancelPreviousPendingQueries();
            }

            var resultDeferred = this._buildQueryResultsDeferred(postDescriptorStore.queryLibrary(query));

            if (query.start === 0) {
                this._addToPendingQueries(resultDeferred);
            }

            return new QueryResults(resultDeferred);
        },

        _buildQueryResultsDeferred: function (serviceResultDeferred) {
            var resultDeferred = new Deferred(function (reasonForCancel) {
                // pass on cancel to the service result deferred as well.
                serviceResultDeferred.cancel(reasonForCancel);
            });
            resultDeferred.total = new Deferred(); // Required by QueryResults.js

            // Clear total result count
            topic.publish(events.library.results.updateTotalResults, '---');

            serviceResultDeferred.then(
                lang.hitch(this, function (data) {
                    var results = this._formatResults(data.results);
                    var totalResults = data.totalResults || results.length;

                    topic.publish(events.library.results.updateTotalResults, totalResults);
                    resultDeferred.total.resolve(totalResults);
                    resultDeferred.resolve(results);
                }),
                function (error) {
                    if (serviceResultDeferred.isCanceled()) {
                        resultDeferred.total.cancel(error);
                        resultDeferred.cancel(error);
                    } else {
                        resultDeferred.total.reject(error);
                        resultDeferred.reject(error);
                    }
                }
            );

            return resultDeferred;
        },

        _formatQuery: function(query, options) {
            options = options || {};

            if (!_.isUndefined(options.sort)) {
                var sortOption = options.sort[0];

                query.sortOrder = {
                    field: sortOption.attribute,
                    order: (sortOption.descending) ? 'DESC' : 'ASC'
                };
            }

            if (!_.isUndefined(options.start)) {
                query.start = options.start;
            }

            if (!_.isUndefined(options.count)) {
                query.count = options.count;
            }

            return query;
        },

        _formatResults: function(results) {
            var idProperty = this.idProperty;
            var identifier = this.identifier;

            return _.map(results, function (result) {
                // Set custom id attribute
                if (identifier !== null && !(idProperty in result)) {
                    result[idProperty] = result[identifier];
                }

                return result;
            });
        },

        _cancelPreviousPendingQueries: function () {
            _.forEach(this._previousPendingQueries, function (queryResultDeferred) {
                if (!queryResultDeferred.isFulfilled()) {
                    queryResultDeferred.cancel('A more recent query overrode this one.');
                }
            });

            this._previousPendingQueries.length = 0;
        },

        _addToPendingQueries: function (queryResultDeferred) {
            this._previousPendingQueries.push(queryResultDeferred);
        }

    });
});

},
'pepper/library/renderers':function(){
define([
    'module', 'vodori/provide',
    'dojo/dom-construct', 'dojo/dom-class',
    'pepper/utilities/renderLocalDate',
    'pepper/ui/Wayfinder'
], function(
    module, provide,
    domConstruct, domClass,
    renderLocalDate,
    Wayfinder
) {
    /**
     * This module is for cell renderers used within the library's grid.
     */

    var renderers = {
        dragHandle: function (object, nothing, td) {
            domClass.add(td, 'dojoDndHandle');
            domConstruct.create('div', {
                innerHTML: '||'
            }, td);
        },

        lockOwner: function (object, lockOwner, td) {
            if (object.lockedByCurrentUser) {
                // You locked it.
                domConstruct.create('img', {
                    src: '/static/js/pepper/images/key.png',
                    title: 'Locked by you'
                }, td);
            } else if (lockOwner) {
                // Somebody else did.
                domConstruct.create('img', {
                    src: '/static/js/pepper/style/images/library/right-column/lower-top-bar/Locked.png',
                    title: 'Locked by ' + lockOwner
                }, td);
            }
        },

        indicator: function(object, indicator, td) {
            if(indicator) {
                var type = indicator.type || 'none';
                var message = indicator.message || '';

                domConstruct.create('img', {
                    src: '/static/js/pepper/style/images/library/indicator/' + type + '.png',
                    title: message
                }, td);
            }
        },

        name: function (object, filename, td) {
            domConstruct.create('div', {
                'class': 'filename',
                innerHTML: filename
            }, td);

            // Don't show the path if the item's in reception
            if (!object.lifecycle.inReception) {
                var path;
                if (object.uris && object.uris.length > 1) {
                    path = '<em>multiple</em>';
                } else {
                    /* If index of last '/' is 0 (at the beginning), then the path is the root and we should just
                     * display the first character, a '/'.  Otherwise display the folder path */
                    var lastSlashPosition = object.path.lastIndexOf('/');
                    path = lastSlashPosition <= 0 ? '/' : object.path.slice(0, lastSlashPosition);
                }

                domConstruct.create('div', {
                    'class': 'path',
                    innerHTML: path
                }, td);
            }
        },

        lifecycle: function (object, lifecycle, td) {
            return new Wayfinder({
                objectId: object.objectId,
                mini: true
            }, td);
        },

        lastModified: function(object, _lastModifiedDate, td) {
            var lastModifiedDate = renderLocalDate(object.lastModified, {selector: 'date'});
            var lastModifiedTime = renderLocalDate(object.lastModified, {selector: 'time'});

            // A check to see if we have a valid date object
            if (!lastModifiedDate || !lastModifiedTime) {
                return domConstruct.create('div', {
                    innerHTML: 'Invalid date!'
                });
            }

            domConstruct.create('div', {
                'class': 'date',
                innerHTML: lastModifiedDate
            }, td);

            domConstruct.create('div', {
                'class': 'time',
                innerHTML: lastModifiedTime
            }, td);
        },

        type: function (object, type, td) {
            td.innerHTML = object.type;
        },

        versionLabel: function (object, versionLabel, td) {
            td.innerHTML = object.versionLabel;
        }
    };

    return provide(module.id, renderers);
});

},
'pepper/library/IconViewCell':function(){
define([
    'module',
    'vodori/provide',
    'dijit/_Widget', 'dijit/_TemplatedMixin',
    'dojo/text!./templates/IconViewCell.html'
], function (module, provide, _Widget, _TemplatedMixin, template) {
    return provide(module.id, [ _Widget, _TemplatedMixin], {
        templateString: template,
        data: null,

        postMixInProperties: function () {
            if (!this.data.thumbnailURI) {
                this.data.thumbnailURI = '';
            }
        }
    });
});

},
'pepper/library/_EditableGridMixin':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/on',
    'pepper/library/renderers',
    'pepper/library/LibraryContextMenu'
], function(
    module, provide,
    _,
    lang,
    on,
    renderers,
    LibraryContextMenu) {

    /**
     * Provides editable functionality to the library grid.
     * Turns on dnd and context menus for rows.
     */
    return provide(module, null,
        {

            /**
             * The context menu used for right clicking on results within the Library's results grid.
             * @type {pepper/library/LibraryContextMenu}
             */
            resultsContextMenu: null,

            constructor: function() {
                _.assign(this.dndParams, {
                    dndSourceType: 'result',   // A string ID for the rows of this grid used for DnD
                    selfAccept: false,         // Whether you can drop items into items in the grid it was dragged from
                    withHandles: true
                });

                this.columns.unshift(
                    {
                        label: ' ',
                        field: 'dragHandle',
                        sortable: false,
                        renderCell: renderers.dragHandle
                    }
                ); // Add dnd row handle
            },

            /**
             * @ignore
             */
            postCreate: function() {
                this.inherited(arguments);

                // Add the Library's context menu.
                // JSHint doesn't understand the slashes in type annotations.
                //noinspection JSValidateTypes
                this.resultsContextMenu = new LibraryContextMenu({
                    targetNodeIds: [this.domNode],
                    selectedItems: this.get('selectedItems')
                });

                this.own(on(this, 'selectionChange', lang.hitch(this, function() {
                    this.resultsContextMenu.set('selectedItems', this.get('selectedItems'));
                })));

                this.resultsContextMenu.startup();
            },

            _setView: function(view) {
                if (view === 'list') {
                    this.dndSource.withHandles = this.withHandles;
                } else { // grid/icon view
                    this.dndSource.withHandles = false; // Never use handles in grid view
                }

                this.inherited(arguments);
            },

            destroy: function() {
                this.resultsContextMenu.destroyRecursive();
                this.inherited(arguments);
            }
        }
    );
});

},
'pepper/library/LibraryContextMenu':function(){
/**
 * The menu that gets created in the library to perform actions on items
 */
define([
    'vodori/provide', 'module',
    'lodash',
    'pepper/menu/_ActionMenu',
    'dojo/topic', 'pepper/events',
    'vodori/util/mixinAndModify'
], function (provide, module, _, _ActionMenu, topic, events, mixinAndModify) {

    return provide(module.id, [_ActionMenu],
        /**
         * @lends pepper/library/LibraryContextMenu#
         */
        {
            selectionChange: false,

            /**
             * @constructs
             * @mixes pepper/menu/_ActionMenu
             */
            constructor: function () {
                this.inherited(arguments);

                // Remove commands that should never appear in the LibraryContextMenu based on CommandName
                mixinAndModify(this, this.actionComparatorFactory, {
                    '-items': [
                        {commandName: 'OPEN_IN_LIBRARY'},
                        {commandName: 'NAV_MGR'},
                        {commandName: 'SAVE_AND_CHECK_IN'},
                        {commandName: 'PEEK'},
                        {commandName: 'SAVE'}
                    ]
                });
            },

            onCallbackItemCompletion: function () {
                topic.publish(events.library.menu.refreshCommandCompleted);
            },

            /**
             * Extended to prevent duplicate requests when selections and commands are identical.
             *
             * @inheritDoc
             */
            updateCommandAvailability: function (selectedItems) {
                // If the commands are the same and the objects are the same, then skip the service call.
                if (this.lastUsedCommands && _.isEqual(selectedItems, this.lastUsedSelectedItems)) {
                    return;
                }

                this.inherited(arguments);
            },

            /**
             * Overridden because this menu shouldn't be shown if there is no selection made
             */
            _openMyself: function () {
                if (!this.selectedItems || this.selectedItems.length === 0) {
                    return;
                }
                return this.inherited(arguments);
            },

            /**
             *
             * @param {Array} selectedItems
             * @return {T}
             * @protected
             */
            _setSelectedItemsAttr: function (selectedItems) {
                this.selectedItems = selectedItems;

                if (selectedItems.length > 0) {
                    this.updateCommandAvailability(selectedItems);
                }

                return this;
            }
        });
});

},
'pepper/library/filter/ui/ChannelSelector':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'dojo/dom-class',
    'vodori/renderTemplate', 'vodori/util/node/htmlToElement', 'pepper/utilities/channels',
    'vodori/ui/Button',
    'pepper/data/getChannels',
    'pepper/events',
    'pepper/library/filter/model/ChannelSelector',
    'dojo/text!pepper/library/filter/ui/templates/ChannelSelector.html',
    'dojo/text!pepper/library/filter/ui/templates/NetworksAndChannels.html',

    /* unreferenced MIDs */
    'dijit/TooltipDialog'
], function (provide, module,
             _,
             lang,
             _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
             domClass,
             renderTemplate, htmlToElement, channels,
             Button,
             getChannels,
             events,
             ChannelSelector,
             channelSelectorTemplate,
             networksAndChannelsTemplate) {

    /**
     * @class ChannelSelector
     */
    return provide(module, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin],
        {
            /**
             * @type {HTMLElement}
             */
            _dropdownButton: null,

            /**
             * @type {HTMLElement}
             */
            _dropdownDialog: null,

            /**
             * @type {string}
             */
            templateString: channelSelectorTemplate,

            /**
             * @typedef NetworkData
             * @type object
             * @property {string} name
             * @property {Array} channels
             */
            /**
             * @type {NetworkData[]}
             */
            networkChannelData: null,

            /**
             * @type {string}
             */
            currentChannelId: null,

            /**
             * @type {object}
             */
            filter: null,

            /**
             * @type {object}
             */
            _idToChannelMap: null,

            /**
             * @type {object}
             */
            _idToChannelButtonMap: null,

            /**
             * @constructor
             */
            constructor: function() {
                this._idToChannelMap = {};
                this._idToChannelButtonMap = {};
            },

            postMixInProperties: function() {
                getChannels(null, this.type).then(lang.hitch(this, '_handleChannelData'));

                // instantiate the filter model
                // NOTE: must be done in postMixInProperties since this.currentChannelId is provided to the constructor
                // NOTE: it is okay if this.currentChannelId is not set, the filter model will not complain
                this.filter = new ChannelSelector();
                this.filter.select(this.currentChannelId);
            },

            /**
             * Selects a channel on the channel selector by id and updates appropriately.
             * Since the library is also listening for the channelSelectorChanged event
             * it will update filters accordingly as well.
             *
             * @param {string} channelId The desired channel to switch to.
             */
            selectChannel: function(channelId){
                this._handleChannelSelection(channelId);
            },

            /**
             * Uses the channel data to fill out the channel selector dropdown
             *
             * @param {Array} data
             * @private
             */
            _handleChannelData: function(data) {
                this.emit('channeldata', { data: data });

                var currentChannelName = 'Select Channel...';

                this._buildChannelMap(data);

                if(this._idToChannelMap.hasOwnProperty(this.currentChannelId)){
                    this._idToChannelMap[this.currentChannelId].current = 'current';
                    currentChannelName = this._idToChannelMap[this.currentChannelId].name;
                }

                this.networkChannelData = channels.organizeByNetwork(data);

                var networksAndChannels = this._buildChannelButtonMap();
                this._dropdownDialog.set('content', networksAndChannels);
                this._setChannelSelectorLabel(currentChannelName);
            },

            /**
             * This builds the _idToChannelButtonMap and also returns the markup
             * that should be displayed in the channel selector drop down region.
             *
             * @returns {*}
             * @private
             */
            _buildChannelButtonMap: function(){
                var html = renderTemplate(networksAndChannelsTemplate, { networks: this.networkChannelData });
                // attach to the click event of each of the buttons instantiated by parser.parse
                return htmlToElement(html, true, lang.hitch(this, function(instances) {
                    _.forEach(instances, lang.hitch(this, function(channelSelection) {
                        if(channelSelection.isInstanceOf(Button)) {
                            channelSelection.on(
                                'click',
                                lang.hitch(this, '_handleChannelSelection', channelSelection.objectId)
                            );
                            this._idToChannelButtonMap[channelSelection.objectId] = channelSelection;
                        }
                    }));
                }));
            },

            /**
             * Builds the channel map from the ajax response.
             *
             * @param data
             * @returns {string} Returns the current channel name.
             * @private
             */
            _buildChannelMap: function(data){
                _.forEach(data, lang.hitch(this, function(channel) {
                    this._idToChannelMap[channel.id] = channel;
                }));
            },

            /**
             * Sets the display of the channel selector.
             *
             * @param {string} channelName The name to set on the selector.
             * @private
             */
            _setChannelSelectorLabel: function(channelName){
                this._dropdownButton.set('label', channelName);
            },

            /**
             * Sets whether a channel button is marked as the currently selected
             * button or not.
             *
             * @param {Button} button
             * @param {boolean} isCurrent
             * @private
             */
            _markButtonSelectedState: function(button, isCurrent){
                domClass.toggle(button, 'current', isCurrent);
            },

            /**
             * handles channel selection and deselection of the previous channel.
             *
             * @param {String} id
             * @private
             */
            _handleChannelSelection: function(id) {
                this._deselectChannel(this.currentChannelId);
                this._selectChannel(id);
            },

            /**
             * Applies the necessary styling to indicate that channel is not selected.
             *
             * @param {string} channelId The channel id for the channel to deselect
             * @private
             */
            _deselectChannel: function(channelId){
                if(this._idToChannelButtonMap.hasOwnProperty(channelId)){
                    var channelButton = this._idToChannelButtonMap[channelId];
                    this._markButtonSelectedState(channelButton.domNode, false);
                }
            },

            /**
             * Applies the necessary logic and styling to indicate a channel is selected.
             *
             * @param {string} channelId The channel id for the channel to select.
             * @private
             */
            _selectChannel: function(channelId){
                var channel = this._idToChannelMap[channelId];
                var channelButton = this._idToChannelButtonMap[channelId];

                if(!!channel && !!channelButton){
                    this._markButtonSelectedState(channelButton.domNode, true);
                    this.filter.select(channelId);
                    this._dropdownButton.closeDropDown();
                    this._setChannelSelectorLabel(channel.name);
                    this.currentChannelId = channelId;
                    this.emit(events.library.filters.channel.selectionChanged, {data: channel});
                }
            }

        }
    );
});
},
'pepper/library/filter/model/ChannelSelector':function(){
define([
        'dojo/_base/declare',
        'vodori/filter/model/_FilterBase', 'vodori/filter/model/FilterType'

    ],
    function (declare, _FilterBase, FilterType) {
        'use strict';
        return declare([_FilterBase], {

            filterType: FilterType.FREEFORM,

            key: 'channelId',

            title: '',

            filterConfig: {},

            reset: function() {
                // Never reset the channel selector.
            }
        });
    }
);


},
'pepper/library/filter/ui/CustomFilter':function(){
define([
        'module',
        'vodori/provide',
        'pepper/library/filter/ui/_LibraryBaseFilterUI',
        'dojo/text!./templates/CustomFilter.html'
    ],
    function (module, provide, _LibraryBaseFilterUI, template) {
        return provide(module.id, [_LibraryBaseFilterUI], {
            templateString: template,

            constructor: function(config) {
                this.filterData = config;

                this.inherited(arguments);
            }
        });
    }
);

},
'pepper/data/GetChannelsType':function(){
define({
    all: 'ALL',
    inCurrentSubscription: 'IN_CURRENT_SUBSCRIPTION'
});

},
'vodori/filter/FilterContainer':function(){
/* Disabling strict due to this.inherited calls */
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/Deferred', 'dojo/when', 'dojo/promise/all',
    'dojo/dom-construct', 'dojo/dom-geometry', 'dojo/dom-style',
    'dojo/query',
    'dijit/registry',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    './FilterManager',
    'dojo/text!./templates/FilterContainer.html',
    /* Unreferenced MIDs */
    'dojo/NodeList-traverse'
],
    function (module, provide,
              _,
              lang, Deferred, when, all,
              domConstruct, domGeometry, domStyle,
              query,
              registry,
              _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
              FilterManager, template) {
        return provide(module.id, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {

            templateString: template,

            /**
             * Prevent the page wide parser form parsing our filters, which would cause a wasteful double
             * instantiation. This must be on the prototype and cannot be overridden in the widget.
             *
             * @property {boolean}
             */
            stopParser: true,

            initialQuery: null,

            /*
             * I'd like to mixin FilterManager, but it uses a modified Stateful that conflicts with
             * _WidgetBase's use of dojo/Stateful.
             * Thus, I need to use composition instead :o(
             */
            postMixInProperties: function () {
                this.inherited(arguments);
                this._filterManager = new FilterManager();
                this._fmDeferred = new Deferred();
                this._enabledClearButtonCount = 0;
                this._filterRemovers = {};
            },

            _getFilterBoxFromWidget: function(filterWidget) {
                if (filterWidget && filterWidget.filterSource) {
                    return filterWidget.filterSource;
                } else {
                    return filterWidget;
                }
            },

            startup: function () {
                if (this._started) {
                    return;
                }
                this.inherited(arguments);

                // Find filters that we just parsed.
                var filterBoxes = query('>*', this.containerNode).map(lang.hitch(this, function (node) {
                    return this._getFilterBoxFromWidget(registry.byNode(node));
                })).filter(Boolean);


                var filterSetPromises = [];
                _.forEach(filterBoxes, lang.hitch(this, function (filterBox) {
                    this._addFilterBoxFilters(filterBox);
                    var filterSetPromise = filterBox.get('filters');
                    if (filterSetPromise) {
                        filterSetPromises.push(filterSetPromise);
                    }
                }));

                all(filterSetPromises).then(lang.hitch(this, function (filterSets) {
                    var filterPromises = [];
                    _.forEach(filterSets, function (filters) {
                        _.forEach(filters, function (filter) {
                            var processingComplete = filter.get('processingComplete');
                            if (processingComplete) {
                                filterPromises.push(processingComplete);
                            }
                        });
                    });
                    all(filterPromises).then(lang.hitch(this, function () {
                        this._fmDeferred.resolve(this._filterManager);
                    }));
                }));


                this.connectClearAllButton();
            },

            resize: function(dimensions) {
                var domSize     = domGeometry.getMarginBox(this.domNode),
                    headerSize  = domGeometry.getMarginBox(this.headerNode),
                    filtersHeight = domSize.h - headerSize.h,
                    explicitWidth = dimensions && dimensions.w;

                domGeometry.setMarginBox(this.containerNode, {'h': filtersHeight});

                if (_.isNumber(explicitWidth)) {
                    // If this filter has a splitter associated with it, we want to be careful to
                    // set the width to suit dimensions passed into `resize`. Otherwise, just
                    // perform old resizing.
                    this._resizeToWidth(explicitWidth);
                }

                this.inherited(arguments);
            },

            /*
             * Connects the Clear All button to the action of resetting the FilterManager
             */
            connectClearAllButton: function () {
                this.clearAllButton.on('click', lang.hitch(this, function () {
                    this._filterManager.resetAll();
                }));
            },

            add: function (filterBox) {
                domConstruct.place(filterBox.domNode, this.containerNode);
                this._addFilterBoxFilters(this._getFilterBoxFromWidget(filterBox));
            },

            remove: function (filterBox) {
                this._removeFilterBoxFilters(filterBox);
                domConstruct.destroy(filterBox, this.containerNode);

            },

            _getFilterManagerAttr: function () {
                return this._fmDeferred.promise;
            },

            /**
             *
             * Adds the filters from the provided vodori.filter.FilterUIBox
             * @param filterBox
             * @return {promise}
             * @private
             */
            _addFilterBoxFilters: function (filterBox) {
                var filterManager = this._filterManager;
                /*
                 * If we're adding a FilterUIBox, we need to monitor its clear button so that we
                 * know when to show 'clear all'
                 */
                this.own(filterBox.watch('clearButtonIsVisible', lang.hitch(this, '_handleClearButtonChange')));
                this._filterRemovers[filterBox.id] = when(filterBox.get('filters'), function (filters) {
                    return filterManager.registerAll(filters);
                });

                return this._filterRemovers[filterBox.id];
            },

            _removeFilterBoxFilters: function (filterBox) {
                /*
                 * If this FilterUIBox is currently displaying its 'clear' button, then we reduce the count of
                 * visible clear buttons by one (since this FilterUIBox is going away)
                 */
                if (filterBox.get('clearButtonIsVisible')) {
                    this._enabledClearButtonCount -= 1;
                    this._updateClearButton();
                }

                var removers = this._filterRemovers[filterBox.id];
                if (!removers) {
                    console.error('Tried to remove filters for filterBox %o, but couldn\'t find any removers in %o',
                        filterBox, this._filterRemovers);
                } else {
                    when(removers, function (removers) {
                        _.forEach(removers, function (remover) {
                            remover.remove();
                        });
                    });
                    delete this._filterRemovers[filterBox.id];
                }
            },

            _handleClearButtonChange: function (propName, oldValue, newValue) {
                if (typeof newValue === 'undefined') {
                    return;
                }

                if (newValue) {
                    this._enabledClearButtonCount += 1;
                } else {
                    this._enabledClearButtonCount -= 1;
                }

                if (this._enabledClearButtonCount < 0) {
                    console.error('The count of enabled clear buttons is less than 0');
                    this._enabledClearButtonCount = 0;
                }
                this._updateClearButton();
            },

            _updateClearButton: function () {
                var button = this.clearAllButton,
                    showClearButton = this._enabledClearButtonCount > 0;
                button.set('disabled', !showClearButton);
            },

            /**
             * Set widget width to an explicit height.
             *
             * @param {Number} width
             * @private
             */
            _resizeToWidth: function(width) {
                domStyle.set(this.domNode, 'width', width + 'px');
            },

            scrollToTop: function () {
                this.domNode.scrollTop = 0;
            }

        });
    }
);

},
'vodori/filter/FilterManager':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/Stateful', 'dojo/Deferred',
    'dijit/Destroyable'
], function (module, provide, _, lang, Stateful, Deferred, Destroyable) {
        /**
         *  Limits the number of queries to no more than one per 100ms
         * @type {Number}
         * @const
         */
        var DEFAULT_DEBOUNCE_PERIOD = 100;

        /**
         * @class Manages the Filters inside a DOM region
         */
        var FilterManager = {
            debouncePeriod: DEFAULT_DEBOUNCE_PERIOD,
            /**
             * Array of filter models
             * @type Array.<_FilterBase>
             */
            filters: null,
            _filterWatchers: null,
            /**
             * Each filter model has a chance to add to this object.
             * @type Object
             */
            query: null,

            constructor: function () {
                this.filters = [];
                this._filterWatchers = [];
                this.query = {};
            },

            getEnabledFilters: function() {
                return _.filter(this.filters, function(filter) {
                    return filter.get('disabled') !== true;
                });
            },

            /**
             * Registers a filter implementing _FilterBase with the FilterManager
             * @param {vodori.filter.model._FilterBase} filter The filter to register with the FilterManager
             * @return {{unregister : Function}} A handle - this can unregister the filter
             */
            register: function (filter) {
                var registrationHandle = this._register(filter);
                this._updateQueryFromCurrentFilters();
                return registrationHandle;
            },

            _register: function (filter) {
                if (this._isAlreadyRegistered(filter)) {
                    throw new Error('Cannot register filter with duplicate key: ' + filter.get('key'));
                }

                this.filters.push(filter);

                var queryWatcher = filter.watch('query', lang.hitch(this, '_setQueryToUpdateAfterDebouncePeriod'));
                var disabledWatcher = filter.watch('disabled',
                        lang.hitch(this,'_setQueryToUpdateAfterDebouncePeriod'));
                this._filterWatchers.push({
                    remove: function() {
                        queryWatcher.remove();
                        disabledWatcher.remove();
                    }
                });

                var unregisterFunction = lang.hitch(this, lang.partial(this.unregister, filter));
                return {
                    unregister: unregisterFunction,
                    remove: unregisterFunction // alias with 'remove' for use with Destroyable.own()
                };
            },

            _isAlreadyRegistered: function (filter) {
                return _.any(this.filters, function (existingFilter) {
                    return existingFilter.get('key') === filter.get('key');
                });
            },

            /**
             * Interrogate each of the registered filters and update the manager's internal query
             * based on the results.
             * @private
             */
            _updateQueryFromCurrentFilters: function () {
                var newQuery = this._buildQueryFromCurrentFilters();
                if (!_.isEqual(this.query, newQuery)) {
                    this._changeAttrValue('query', newQuery);
                }
            },

            /**
             * Interrogate each of the registered filters and generate a query based on the
             * results.
             * @private
             * @return the generated query
             */
            _buildQueryFromCurrentFilters: function () {
                var newQuery = {};
                _.forEach(this.getEnabledFilters(), function (filter) {
                    lang.mixin(newQuery, filter.get('query'));
                });
                return newQuery;
            },

            /**
             * Register several filters at once.
             * @param filters {Array.<_FilterBase>} filters to unregister.
             * @return {Array<{unregister: Function}>} A handle for each filter, which can unregister the filter
             */
            registerAll: function (filters) {
                var registrationHandles = _.map(filters, this._register, this);
                this._updateQueryFromCurrentFilters();
                return registrationHandles;
            },

            /**
             * Unregister a single filter from the manager.
             * @param filter {_FilterBase} filter to unregister
             */
            unregister: function (filter) {
                this._unregister(filter);
                this._updateQueryFromCurrentFilters();
            },

            _unregister: function (filter) {
                var filterIdx = this._findIndexOfFilterInFiltersArray(filter);
                if (filterIdx !== -1) {
                    this._filterWatchers[filterIdx].remove();

                    this.filters.splice(filterIdx, 1);
                    this._filterWatchers.splice(filterIdx, 1);
                }
            },

            _findIndexOfFilterInFiltersArray: function (soughtFilter) {
                var filterKey = soughtFilter.get('key'),
                    filterIndex = -1;

                if (soughtFilter) {
                    filterIndex = _.findIndex(this.filters, function (filter) {
                        return filterKey === filter.get('key');
                    });
                }
                return filterIndex;
            },

            /**
             * Unregister several filters at once.
             * @param filters {Array.<_FilterBase>} filters to unregister.
             */
            unregisterAll: function (filters) {
                _.forEach(filters, this._unregister, this);
                this._updateQueryFromCurrentFilters();
            },

            /*
             * Sets a timeout to update the query after this.debouncePeriod milliseconds
             */
            _setQueryToUpdateAfterDebouncePeriod: function () {
                if (typeof this._updateQueryTimeoutId !== 'undefined') {
                    clearTimeout(this._updateQueryTimeoutId);
                }
                var updateQueryFn = lang.hitch(this, function () {
                    this._updateQueryFromCurrentFilters();
                    this._updateQueryTimeoutId = undefined;
                });

                this._updateQueryTimeoutId = setTimeout(updateQueryFn, this.debouncePeriod);

            },

            _filtersSetter: function (newFilters) {
                // remove the previous filters one-by-one in reverse order
                for (var i = this.filters.length - 1; i >= 0; i--) {
                    this._unregister(this.filters[i]);
                }

                if (newFilters) {
                    _.forEach(newFilters, this._register, this);
                }

                this._updateQueryFromCurrentFilters();
            },

            _querySetter: function (query) {
                this._updateAllCurrentFiltersWithFromQuery(query);
                var newQuery = this._buildQueryFromCurrentFilters();

                if (!_.isEqual(this.query, newQuery)) {
                    this.query = newQuery;
                } else {
                    // Returning an unresolved deferred prevents Stateful from firing an onchange event.
                    var canceledDeferred = new Deferred();

                    // sick of seeing the error that is not an error in the console?
                    // notice the .cancel below...
                    // now we'll ignore the stupid thing
                    canceledDeferred.promise.otherwise(function(){ });

                    canceledDeferred.cancel('NO CHANGE');
                    return canceledDeferred;
                }
            },

            _updateAllCurrentFiltersWithFromQuery: function (query) {
                _.forEach(this.filters, function (filter) {
                    filter.set('query', query);
                });
            },

            /**
             * Reset all filters to their default values.
             */
            resetAll: function () {
                _.invoke(this.filters, 'reset');
                this._updateQueryFromCurrentFilters();
            },

            destroy: function() {
                _.forEach(this._filterWatchers, function(watcher) {
                    watcher.remove();
                });
            }
        };

        return provide(module, [Stateful, Destroyable], FilterManager);
    }
);

},
'vodori/filter/BasicFilterWidget':function(){
/**
 * @module vodori/filter/BasicFilterWidget
 */
define([
    'lodash',
    'module', 'require',
    'vodori/provide',
    'dojo/_base/lang', 'dojo/Deferred',
    'dojo/dom', 'dojo/dom-construct', 'dojo/dom-class',
    'dijit/_WidgetBase', 'dijit/registry',
    'vodori/util/getDijitAncestorByClass', 'vodori/util/cleanup',
    'vodori/filter/model/FilterType',
    'vodori/filter/widgetBuilder/_ManyOfManyFilter', 'vodori/filter/widgetBuilder/_OneOfManyFilter',
    'vodori/filter/widgetBuilder/_BinaryFilter',
    'vodori/filter/FilterManager',
    'pepper/events'
],
    function (_,
              module, require,
              provide,
              lang, Deferred,
              dom, domConstruct, domClass,
              _WidgetBase, registry,
              getDijitAncestorByClass, cleanup,
              FilterType,
              _ManyOfManyFilterBuilder, _OneOfManyFilterBuilder,
              _BinaryFilterBuilder,
              FilterManager,
              events) {

        var defaultFilterBuilder = {};
        defaultFilterBuilder[FilterType.BINARY]         = _BinaryFilterBuilder;
        defaultFilterBuilder[FilterType.ONE_OF_MANY]    = _OneOfManyFilterBuilder;
        defaultFilterBuilder[FilterType.MANY_OF_MANY]   = _ManyOfManyFilterBuilder;

        /**
         * Fired whenever this filter's `query` value changes
         *
         * @event module:vodori/filter/BasicFilterWidget#select
         * @type object
         * @property value {*} The new value of the filter's `query`
         */
        /**
         * @lends module:vodori/filter/BasicFilterWidget#
         */
        var BasicFilterWidget = {
            filterBuilder: defaultFilterBuilder,

            /**
             * The widget returned from the filter builder
             */
            filterWidget: null,
            filterNode: null,

            postMixInProperties: function() {
                this.inherited(arguments);

                if(!this.filter) {
                    console.error('No filter model assigned to BasicFilterWidget');
                }
                else {
                    this._filterDeferred = new Deferred();
                    require([this.filter], lang.hitch(this, function(Filter) {
                        this._filterDeferred.resolve(new Filter(this.filterData));
                    }));
                }
            },

            buildRendering: function() {
                this.inherited(arguments);
                this._filterDeferred.then(lang.hitch(this, '_buildFilterWidget'));
            },

            _buildFilterWidget: function(filter) {
                var filterBuilder = this.filterBuilder[filter.filterType];

                if(filterBuilder) {
                    var filterUI = filterBuilder(filter, this.separators);
                    filter.reset();
                    if(this.defaultLabels) {
                        filter.select(this.defaultLabels);
                    }

                    domClass.add(filterUI, 'basic-widget');
                    domConstruct.place(filterUI, this.domNode);

                    this.filterWidget = registry.byNode(filterUI);
                    this.filterNode = filterUI;

                    if(!this.filterWidget) {
                        // sometimes the node's child is the widget...

                        this.filterWidget = registry.byNode(filterUI.firstChild);
                    }

                    this.own(filter.watch('query', lang.hitch(this, '_handleQueryChange')));
                } else {
                    console.error('Do not know how to build for a filter of type: '+filter.filterType);
                }
            },

            _rebuild: function() {
                this._filterDeferred.then(lang.hitch(this, function(filter) {
                    cleanup.destroy(this.filterNode);

                    this._buildFilterWidget(filter);
                    if(filter.afterRebuild) {
                        filter.afterRebuild();
                    }
                }));
            },

            postCreate: function() {
                this.inherited(arguments);
                this._filterDeferred.then(lang.hitch(this, function(filter) {
                    if(!this.filterManager) {
                        this.filterManager = getDijitAncestorByClass(this.domNode, FilterManager);
                    } else if(typeof this.filterManager === 'string' ) {
                        this.filterManager = dom.byId(this.filterManager);
                    }
                    if(this.filterManager) {
                        this.own(this._filterHandle = this.filterManager.register(filter));
                    }

                    if(filter.emitsRebuild) {
                        this.own(
                            filter.on(
                                events.library.filters.requiresRebuild,
                                lang.hitch(this, '_rebuild')
                            )
                        );
                    }
                }));
            },

            startup: function() {
                if(this._started) {
                    return;
                }

                this._filterDeferred.then(function(filter) {
                    filter.reset();
                });

                this.inherited(arguments);
            },

            _getFilterAttr: function() {
                return this._filterDeferred.promise;
            },

            /**
             * @fires module:vodori/filter/BasicFilterWidget#select
             */
            _handleQueryChange: function(__, oldValue, newValue) {
                if(!_.isEqual(oldValue, newValue)) {
                    this.emit('select', { value: newValue });
                }
            }
        };

        return provide(module.id, [_WidgetBase], BasicFilterWidget);
    }
);

},
'vodori/filter/widgetBuilder/_ManyOfManyFilter':function(){
define([
    'lodash',
    'dojo/_base/lang',
    'dojo/on', 'dojo/string', 'dojo/when',
    'dojo/dom-construct', 'dojo/dom-class',
    'dijit/form/TextBox',

    /* Unreferenced MIDs */
    'vodori/input/GroupedSelect',
    'vodori/input/NestableGroupedSelect'
], function (_,
             lang,
             on, string, when,
             domConstruct, domClass,
             TextBox,
             GroupedSelect,
             NestableGroupedSelect) {
    'use strict';

    var builder = function (filter) {
        var container = domConstruct.create('div');
        domClass.add(container, 'multi-select-filter');

        var SelectType = GroupedSelect;

        if(_.any(filter.filterConfig, 'parent')) {
            SelectType = NestableGroupedSelect;
        }

        var selector = new SelectType({
            multiple: true,
            name: filter.key,
            labelTemplate: '<span class="dojoxMultiSelectItemText" title="${label}">${label}</span>'
        });

        when(filter.get('labels'), function (labels) {
            selector.set('options', _.map(labels, function (label) {
                var filterInfo = filter.filterConfig[label];

                var optionParameters = {
                    label: label,
                    value: label,
                    parent: filterInfo.parent
                };

                lang.mixin(optionParameters, filterInfo.searchData);
                return optionParameters;
            }));

            selector.own(on(selector, 'change', function (newLabel) {
                /*
                 * If newLabel is undefined, it means that change has been called due to the
                 * search textBox being updated - thus we ignore it.
                 */
                if (typeof newLabel !== 'undefined') {
                    filter.set('selectedLabels', newLabel);
                }
            }));
        });

        selector.own(filter.watch('query', function () {
            selector.set('value', filter.get('selectedLabels'));
        }));

        selector.own(filter.on('reset', function () {
            selector.set('disabled', false);
            selector.set('value', filter.get('defaultLabels'));
        }));

        var searchConfig = filter.searchConfig;
        var textBox;
        if (searchConfig) {
            textBox = new TextBox({
                intermediateChanges: true,
                includeDisabled: true,
                placeHolder: searchConfig.description || 'Enter search here'
            });
            selector.own(on(textBox, 'change', lang.hitch(this, function (value) {
                if (typeof value === 'string') {
                    value = string.trim(value);
                }

                if (value) {
                    var re = new RegExp(value, 'i');
                    selector.filter(function (item) {
                        return _.some(searchConfig.searchProperties, function (searchProperty) {
                            return re.test(item[searchProperty]);
                        });
                    });
                } else {
                    // Clear the filter.
                    selector.filter();
                }
            })));

            selector.own(filter.on('reset', lang.hitch(this, function () {
                textBox.reset();
            })));

            domConstruct.place(textBox.domNode, container);
            domConstruct.place(domConstruct.create('br'), container);
        }

        domConstruct.place(selector.domNode, container);
        return container;
    };

    return builder;
});

},
'vodori/input/NestableGroupedSelect':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/dom-class',
    './GroupedSelect'
], function (module, provide,
             _,
             lang,
             domClass,
             GroupedSelect) {
    return provide(module, [GroupedSelect], {
        _createGroupedSelectItem: function (option) {
            this.inherited(arguments);

            var groupedSelectItem = this._groupedSelectItemsByValue[option.value];

            groupedSelectItem.inputControl.on('change', lang.hitch(this, function () {
                // check to see if control has children, if so disable on uncheck
                var children = this.get('store').query({ parent: option.label });
                var selected = _.contains(this.get('value'), option.value);

                _.forEach(children, function(child) {
                    this._groupedSelectItemsByValue[child.value].set('disabled', !selected);
                }, this);
            }));

            if(option.parent) {
                domClass.add(groupedSelectItem.domNode, 'child');
            }
        }
    });
});

},
'vodori/filter/widgetBuilder/_OneOfManyFilter':function(){
define([
    'lodash',
    'dojo/_base/lang',
    'dojo/dom-construct',
    'dojo/on', 'dojo/query', 'dojo/when',
    'vodori/input/GroupedSelect', 'vodori/filter/model/_FilterBase',
    'dojo/NodeList-traverse'
], function (_,
             lang,
             domConstruct,
             on, query, when,
             GroupedSelect, _FilterBase) {
    'use strict';

    var builder = function (filter, separators) {
        separators = lang.mixin({
            before: [],
            after: []
        }, separators);

        var selector = new GroupedSelect({
            name: filter.key
        });

        selector.set('class', 'hidden-first-default');

        selector.addOption({
            label: undefined,
            value: _FilterBase.NULL_SELECTION
        });

        selector.startup();

        /*
         * A shorthand function for adding separators if necessary
         */
        var addNecessarySeparators = function (position, label) {
            if (_.indexOf(separators[position], label) > -1) {
                selector.addOption({
                    label: '-',
                    value: undefined
                });
            }
        };

        when(filter.get('labels'), function (labels) {
            _.forEach(labels, function (label) {
                addNecessarySeparators('before', label);
                selector.addOption({
                    label: label,
                    value: label
                });
                addNecessarySeparators('after', label);
            });

            selector.own(on(selector, 'change', function (newLabel) {
                filter.select(newLabel);
            }));
        });

        selector.own(filter.watch('query', function () {
            var labels = filter.get('selectedLabels')[0] || _FilterBase.NULL_SELECTION;
            selector.set('value', labels);
        }));

        // Wrap the children GroupedSelects in a form element to prevent bleed into other GroupedSelects
        var widgetChildren = query(selector.domNode).children();
        var formWrapper = domConstruct.create('form', null, selector.domNode);

        widgetChildren.forEach(function(node) {
            domConstruct.place(node, formWrapper, 'last');
        });

        return selector.domNode;
    };

    return builder;
});

},
'vodori/filter/widgetBuilder/_BinaryFilter':function(){
define([
    'lodash',
    'dojo/_base/lang', 'dojo/when',
    'dojo/on',
    'dojo/dom-construct',
    'dijit/form/CheckBox'
],
    function (_,
              lang, when,
              on,
              domConstruct,
              CheckBox) {
        'use strict';

        var builder = function (filter) {
            var container = domConstruct.create('div', {'class': 'binaryFilter'});

            when(filter.get('labels'), function (labels) {
                _.forEach(labels, function (label) {
                    var checkBox = new CheckBox();
                    checkBox.set('value', label);

                    checkBox.own(on(checkBox, 'change', lang.hitch(this, function (checked) {
                        if (checked) {
                            filter.select(label);
                        } else {
                            filter.set('selectedLabels', []);
                        }
                    })));

                    domConstruct.place(checkBox.domNode, container);

                    var boxLabel = domConstruct.create('div', {innerHTML: label, className: 'binaryFilterLabel' });
                    domConstruct.place(boxLabel, container);

                    checkBox.own(filter.watch('query', function () {
                        checkBox.set('value', (filter.get('selectedLabels').length > 0));
                    }));
                });
            });


            return container;
        };

        return builder;

    }
);

},
'vodori/filter/DropdownFilterWidget':function(){
define([
    'module',
    'vodori/provide',
    './BasicFilterWidget', './widgetBuilder/_OneOfManyDropdownFilter',
    'vodori/filter/model/FilterType'
],
    function (module, provide, BasicFilterWidget, _OneOfManyDropdownFilterBuilder, FilterType) {

        /**
         *
         * @class
         */
        var filterBuilder = {};
        filterBuilder[FilterType.ONE_OF_MANY] = _OneOfManyDropdownFilterBuilder;
        var DropdownFilterWidget = {
            filterBuilder: filterBuilder
        };

        return provide(module.id, [BasicFilterWidget], DropdownFilterWidget);
    }
);

},
'vodori/filter/widgetBuilder/_OneOfManyDropdownFilter':function(){
define([
    'lodash',
    'dojo/on', 'dojo/when',
    'vodori/input/Select', 'vodori/filter/model/_FilterBase'
],
    function (_,
              on, when,
              Select, _FilterBase) {
        'use strict';

        /**
         * A builder for a one-of-many dropdown filter.
         *
         * Note that this builder examines the filter for an optional `mustHaveAnOptionSelected` property.
         * If false or not present, the dropdown will be created with a default `null` selection whose
         * label ideally describes the purpose of the dropdown.
         *
         * If true, mustHaveAnOptionSelected will cause the builder to create a dropdown that shows no options
         * other than those listed in the filter options, and will respect the default select value indicated
         * in that filter.
         *
         * @param {vodori/filter/model/_FilterBase} filter A filter that implements _FilterBase
         * @returns {*}
         */
        var builder = function (filter) {

            var selector = new Select();
            var defaultOption;

            if (filter.mustHaveAnOptionSelected) {
                defaultOption = filter.defaultLabels[0];
                filter.select(defaultOption);
            } else {
                // Add handling for a do-nothing label "option" if the filter does not require
                // an active selection from its options
                defaultOption = _FilterBase.NULL_SELECTION;
                selector.addOption({ label: filter.description, value: defaultOption});
            }

            selector.own(filter.watch('query', function () {
                var selectedVals = filter.get('selectedLabels'),
                    valueToSet = selectedVals[0];

                // An empty selectedLabels prop on the filter means the dropdown needs to be reset
                if (_.isEmpty(selectedVals)) {
                    valueToSet = defaultOption;
                }

                selector.set('value', valueToSet);
            }));

            selector.own(on(selector, 'change', function (newLabel) {
                filter.select(newLabel);
            }));

            when(filter.get('labels'), function (labels) {
                _.forEach(labels, function (label) {
                    selector.addOption({ label: label, value: label });
                });
            });

            return selector.domNode;
        };

        return builder;

    }
);

},
'vodori/filter/DateFilterWidget':function(){
define([
    'module', 'require', 'vodori/provide',
    'dojo/_base/lang', 'dojo/Deferred',
    'dojo/dom', 'dojo/dom-construct',
    'dijit/_WidgetBase',
    'vodori/util/getDijitAncestorByClass',
    'vodori/filter/FilterManager',
    'vodori/input/DateTextBox'
],
    function (module, require, provide,
              lang, Deferred,
              dom, domConstruct,
              _WidgetBase,
              getDijitAncestorByClass,
              FilterManager,
              DateTextBox) {

        var DateFilterWidget = {

            postMixInProperties: function () {
                this.inherited(arguments);

                if (!this.filter) {
                    console.error('No filter model assigned to DateFilterWidget');
                }
                else {
                    this._filterDeferred = new Deferred();
                    require([this.filter], lang.hitch(this, function (Filter) {
                        this._filterDeferred.resolve(new Filter(this.filterData));
                    }));
                }
            },

            buildRendering: function () {
                this.inherited(arguments);
                var container = domConstruct.create('div', {'class': 'dateFilter'});
                this.date = new DateTextBox({});
                domConstruct.place(this.date.domNode, container);
                domConstruct.place(container, this.domNode);
            },

            postCreate: function () {
                this.inherited(arguments);
                this._filterDeferred.then(lang.hitch(this, function (filter) {
                    this.own(
                        this.date.watch('value', function (watch, oldValue, newValue) {
                            filter.select(newValue);
                        }),

                        filter.watch('query', lang.hitch(this, function () {
                            var date = filter.get('selectedLabels')[0];
                            if (date) {
                                this.date.set('value', date);
                            } else {
                                this.date.reset();
                            }
                        }))
                    );

                    if (!this.filterManager) {
                        this.filterManager = getDijitAncestorByClass(this.domNode, FilterManager);
                    } else if (typeof this.filterManager === 'string') {
                        this.filterManager = dom.byId(this.filterManager);
                    }
                    if (this.filterManager) {
                        this.own(this.filterManager.register(filter));
                    }
                }));
            },

            startup: function () {
                this._filterDeferred.then(function (filter) {
                    filter.reset();
                });
            },

            _getFilterAttr: function () {
                return this._filterDeferred.promise;
            }

        };

        return provide(module.id, [_WidgetBase], DateFilterWidget);
    }
);

},
'pepper/library/filter/ui/TreeFilterWidget':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/Deferred',
    'dojo/promise/all',
    'dojo/dom-construct', 'dojo/dom-class',
    'dojo/topic',
    'pepper/commands', 'pepper/events',
    'pepper/ui/DropDownButton', 'pepper/ui/handleNotification',
    'vodori/ui/grid/GridFactory',
    'dijit/_WidgetBase','dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'dojo/text!./templates/TreeFilterWidget.html'
],
    function (module, provide,
              _,
              lang, Deferred,
              all,
              domConstruct, domClass,
              topic,
              commands, events,
              DropDownButton, handleNotification,
              GridFactory,
              _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
              template) {
        /**
         *
         * @class
         */
        var TreeFilterWidget = {

            templateString: template,

            /**
             * dgrid mixins to be added to this tree
             *
             * @type {Array<*>}
             */
            mixins: null,

            _dropDownMenuButtons: null,

            readOnly: false,

            constructor: function () {
                this.mixins = [];
                this._dropDownMenuButtons = [];
                this._storeDeferred = new Deferred();
            },

            _getGridConstructor: function() {
                'use strict';
                return this._filterDeferred.then(lang.hitch(this, function(filter) {
                    var mixins = ['keyboard', 'selection', 'columnResizer']
                        .concat(this.mixins)
                        .concat(filter.get('treeMixins') || []);

                    if (!this.readOnly) {
                        mixins.push('dnd');
                    }

                    return GridFactory.getGrid(mixins);
                }));
            },

            createTree: function() {
                var readOnly = this.readOnly,
                    dragColumn = {
                        field: 'dragHandle',
                        renderCell: lang.hitch(this, function(object, nothing, td) {
                            // Hide the drag handle of dummy nodes
                            if (object.disabled) {
                                return;
                            }

                            domClass.add(td, 'dojoDndHandle');
                            domConstruct.create('div', {
                                innerHTML: '||'
                            }, td);
                        })
                    },
                    columns = [];

                if(!readOnly) {
                    columns.push(dragColumn);
                }

                columns.push({
                        field: 'label',
                        renderCell: function (object, label, td) {
                            domConstruct.create('div', {
                                innerHTML: label
                            }, td);
                        }
                    });

                if (!readOnly) {
                    columns.push({
                        field: 'menu',
                        renderCell: lang.hitch(this, function (object, nothing, td) {
                            // Hide the menu for dummy nodes
                            if (object.disabled) {
                                return;
                            }
                            var menuButton = new DropDownButton(
                                {
                                    label: '&#9660;',
                                    dropDown: this.contextMenu,
                                    commandAvailabilityParam: object
                                }
                            );

                            this._dropDownMenuButtons.push(menuButton);
                            menuButton.placeAt(td);
                            menuButton.startup();
                        })
                    });
                }

                return all({
                    store:      this._storeDeferred,
                    filter:     this._filterDeferred,
                    GridCtor:   this._getGridConstructor()
                }).then(lang.hitch(this, function(results) {
                        'use strict';
                        var grid = new results.GridCtor(
                            {
                                store: results.store,
                                columns: columns,
                                treeColumn: readOnly ? 0 : 1,
                                showHeader: false,
                                dndSourceType: this.dndName,
                                dndParams: {
                                    accept: ['result', this.dndName],
                                    selfAccept: true,
                                    allowNested: true,
                                    withHandles: true
                                },
                                multiSelect: false,
                                selectionMode: 'single',
                                query: results.filter.get('storeQuery'),
                                executeDropCommand: this._executeDropCommand
                            },
                            this.tree);

                        this.own(results.filter.watch('storeQuery', function(name, oldValue, value){
                            grid.set('query', value);
                        }));

                        return grid;
                    }));
            },

            /**
             * _WidgetBase Lifecycle method
             */
            postMixInProperties: function () {
                this.inherited(arguments);

                if (this.filter) {
                    this._filterDeferred = new Deferred();
                    require([this.filter], lang.hitch(this, function (filter) {
                        this._filterDeferred.resolve(filter(this.filterData, this.readOnly));
                    }));

                    this._filterDeferred.then(lang.hitch(this, function (filter) {
                        this._storeDeferred.resolve(filter.get('store'));
                    }));
                } else {
                    console.error('No filter model assigned to TreeFilterWidget');
                }
            },

            /**
             * _WidgetBase Lifecycle method
             */
            startup: function() {
                this._deferredTree = this.createTree();

                this._deferredTree.then(lang.hitch(this, function(tree) {
                    this.tree = tree;
                    this.contextMenu.startup();
                    this.tree.startup();
                }));

                this.inherited(arguments);
            },

            labelFormatter: function(label) { },

            addSelectHandler: function (fn) {
                return all({
                    tree: this._deferredTree,
                    filter: this._filterDeferred
                }).then(function (results) {
                        'use strict';
                        return results.tree.on('selectionChange', lang.partial(fn, results.filter));
                    });
            },

            addFilterQueryWatcher: function(fn) {
                this._filterDeferred.then( lang.hitch(this, function(filter) {
                    return this.own(filter.watch('query', lang.partial(fn, filter)));
                }));
            },

            _getFilterAttr: function () {
                return this._filterDeferred.promise;
            },

            /**
             * Expand the specified row in the tree
             * @param objectId the row is specified by the object in the store
             *        (ex: a Directory object) identified by this objectId.
             */
            expandRowByObjectId: function (objectId) {
                var row = this.tree.row(objectId);
                this.tree.expand(row, true);
            },

            /**
             * Handle dropping items into this grid. If the items are foreign, we want to use COPY_TO, since
             * it means we're dropping a result item into a filter. If the items are local, use MOVE_TO, since
             * we're dropping a folder into a folder.
             *
             * @param {Source} sourceSource      the Source the source objects were dragged from
             * @param {Array}  sourceObjectIds   array of object ids of the source items
             * @param {string} targetObjectId    the object id to drop into
             */
            _executeDropCommand: function (sourceSource, sourceObjectIds, targetObjectId) {
                var targetSource = this.dndSource;

                // Grab references to the source and target dgrids
                var sourceGrid = sourceSource.grid;
                var targetGrid = targetSource.grid;

                var dropDeferred; // The promise that is returned from executing one of the move commands

                // If the source and target are the same grid, we're dropping folders on folders, so use move,
                // otherwise use copy to add an object to a folder
                if (sourceSource === targetSource) {
                    // We need to supply the parent node's objectId, so the server knows
                    // which folder we were dragging from. Here is some very specific code
                    // To grab the parent objectId using the object store
                    // NOTE: okay, this will definitely break if we're dragging multiple rows.
                    // multirow dragging is disabled though, right... right?
                    var data = this.store.get(sourceObjectIds[0]);

                    // Disable DND of root nodes
                    // Once dgrid gets checkItemAcceptance,
                    // we can remove this and do it the right way
                    if (!data._parent) {
                        handleNotification({
                            type: 'modal',
                            title: 'Unable to perform action',
                            message: 'You cannot move that folder'
                        });
                        return;
                    }

                    var parentRowId = data._parent.objectId;

                    dropDeferred = commands.actions.moveTo(sourceObjectIds, targetObjectId, parentRowId);
                } else {
                    dropDeferred = commands.actions.copyTo(sourceObjectIds, targetObjectId, targetGrid.selection);
                }

                // Add a callback to refresh the tree only after the command has gone through
                dropDeferred.then(function () {
                    topic.publish(events.library.objectMoved, [dropDeferred, sourceGrid, targetGrid, targetObjectId]);
                    topic.publish(events.library.refresh);
                });
            },

            destroy: function () {
                if (this.contextMenu) {
                    this.contextMenu.destroyRecursive();
                }
                if (this._dropDownMenuButtons) {
                    _.invoke(this._dropDownMenuButtons, 'destroyRecursive');
                }
                this.inherited(arguments);
            }



        };

        return provide(module, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], TreeFilterWidget);
    }
);

},
'pepper/library/DetailsPane':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/when', 'dojo/Deferred', 'dojo/topic',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin',
    'vodori/renderTemplate', 'vodori/util/number/humanizeBytes',
    'vodori/layout/_LazyAttachPoints', 'pepper/utilities/renderLocalDate',
    'pepper/events', 'pepper/data/PostDescriptorStore',
    'dojo/text!./templates/DetailsPane.html',
    'dojo/text!./templates/detailsPane/single.html', 'dojo/text!./templates/detailsPane/bulk.html',
    'pepper/library/RemovableTagsOrCategoriesList',
    /* Unreferenced MIDs */
    'pepper/ui/Wayfinder',
    'vodori/ui/LoadingAwareImage'
], function (module, provide,
             _,
             lang, when, Deferred, topic,
             _WidgetBase, _TemplatedMixin,
             renderTemplate, humanizeBytes,
             _LazyAttachPoints, renderLocalDate,
             events, PostDescriptorStore,
             template,
             singleTemplate, bulkTemplate,
             RemovableTagsOrCategoriesList
    ) {
    /**
     * A generic widget to display metadata about a post.
     * Planned to be used anywhere information needs to be displayed (library details pane, post descriptor pop-up, etc)
     * To extend the metadata displayed, configure the backend service.
     * To tailor the display to each instance, use CSS.
     */
    return provide(module, [_WidgetBase, _TemplatedMixin, _LazyAttachPoints], {

        selections: null,

        lazyPanes: ['_fileDisplay', '_categorizationDisplay'],

        tagsWidget: null,
        categoriesWidget: null,
        tagsNode: null,
        categoriesNode: null,

        templateString: template,
        tagsName: 'Tags',

        categoriesName: 'Categories',

        /**
         * Defined in single.html via _LAP. Should reflect the current state of the selected object.
         *
         * @type {pepper/ui/Wayfinder}
         */
        _wayfinder: null,

        /**
         * Defined in single.html
         *
         * @type {vodori/ui/LoadingAwareImage}
         */
        _thumbnail: null,

        /**
         * Used to render metadata about the selected file (uses Mustache).
         * Set in the widget's template via attach-points.
         * @type {dijit/layout/ContentPane}
         */
        _fileDisplay: null,

        /**
         * Used to allow client sites to add metadata to the details pane.
         * This endpoint is meant to return HTML unique to the site.
         * This is set in the widget's template via attach-points.
         * @type {dijit/layout/ContentPane}
         */
        _supplementaryDisplay: null,

        _queryObserveHandle: null,

        /**
         * A mapping between folder types (e.g. segments, categories, etc.) and any published events that should
         * be registered with this widget so that it knows to clear the cache for any objects affected by published
         * changes.
         *
         * @typedef FolderEvents
         * @type {Object}
         */

        /**
         * @type {FolderEvents}
         * @private
         */
        _updateFolderForEvents: null,

        _appendFormattedDatesToSingleResult: function(data) {
            var detailsData = lang.getObject('lifecycle.details', false, data);
            if (detailsData) {
                data.createDateLocal = detailsData.createDate ? renderLocalDate(detailsData.createDate) : '';
                data.lockedDateLocal = detailsData.locked ? renderLocalDate(detailsData.locked) : '';
                data.modifiedDateLocal = detailsData.modified ? renderLocalDate(detailsData.modified) : '';
            }
        },

        _flattenSegments: function(segments) {
            if (!segments || segments.length === 0) {
                return [];
            } else {
                return _.map(segments, function (segment) {
                    if (segment.length === 0) {
                        return { label: '/' };
                    } else {
                        var path = _.reduceRight(segment, function (path, part) {
                            return path + '/' + part.label;
                        }, '');
                        return {
                            id: segment[0].id,
                            label: path
                        };
                    }
                });
            }
        },

        _flattenTaxonomy: function (taxonomyArray) {
            if (!taxonomyArray || taxonomyArray.length === 0) {
                return [];
            } else {
                return _.map(taxonomyArray, function (element) {
                    // the element array looks like this for a category:
                    // [
                    //   { label: "subcategory label", id: "workspace://SpacesStore/..." },
                    //   ...
                    //   { label: "category label", id: "workspace://SpacesStore/..." },
                    //   { label: "category", id: "workspace://SpacesStore/..." },
                    // ]

                    // the element array looks like this for a tag:
                    // [
                    //   { label: "tag label", id: "workspace://SpacesStore/..." },
                    //   { label: "username@email.com", id: "workspace://SpacesStore/..." },
                    //   { label: "personal", id: "workspace://SpacesStore/..." },
                    // ]
                    var elementLastIndex = element.length - 1;
                    if (element[elementLastIndex].label === 'category') {
                        // for categories, the element array has an item for each subcategory. in order to display
                        // them as "category / .. / subcategory" we will need to use all but the last item of
                        // the element array (which is an item distinguishing between tags and categories)
                        var modifiedElement = {};
                        var onlyCategories = element.slice(0, elementLastIndex).reverse();

                        var labels = _.map(onlyCategories, function (item) {
                            return item.label;
                        });

                        modifiedElement.label = labels.join(' / ');
                        modifiedElement.id = element[0].id;

                        return modifiedElement;
                    } else {
                        return element[0];
                    }
                });
            }
        },

        _getCachedObjects: function() {
            return PostDescriptorStore.query({}, {cacheOnly: true});
        },

        /**
         * Returns the collection of assets that have data matching the provided folder id and type.
         *
         * @param {String} folderId
         * @param {String} folderType
         * @returns {Array.<Object>} a collection of Pepper asset descriptors from the PostDescriptorStore
         * @private
         */
        _getCachedObjectsWithFolderId: function(folderId, folderType) {
            var objects = this._getCachedObjects();
            return _.filter(objects,
                function(o) { return _.some(_.flatten(o[folderType]), function(c) { return c.id === folderId; } ); });
        },

        /**
         * Returns a function that will be used to determine the collection of cached objects affected
         * by a change to a particular type of folder.
         *
         * @param {String}
         * @returns {Function}
         * @private
         */
        _updateForFolderChange: function(folderType) {
            return lang.hitch(this, function(changeInfo) {
                var folderId = changeInfo[1];
                if (folderId) {
                    var objects = this._getCachedObjectsWithFolderId(folderId, folderType);
                    PostDescriptorStore.refreshCachedObjects(objects);
                }
            });
        },

        _mergeSelections: function (selections) {

            var composite = _.reduce(selections, lang.hitch(this, function (composite, selection, i) {
                composite.contentStreamLength += selection.contentStreamLength || 0;

                if (i !== 0) {
                    // Only show lastModified if it's all the same person.
                    if (selection.lastModifier !== composite.lastModifier) {
                        composite.lastModifier = '';
                    }
                    composite.segments = this._removeUncommonTaxonomies(composite.segments, selection.segments);
                    composite.tags = this._removeUncommonTaxonomies(composite.tags, selection.tags);
                    composite.categories = this._removeUncommonTaxonomies(composite.categories, selection.categories);
                }

                return composite;
            }), {
                count: selections.length,
                contentStreamLength: 0,
                lastModifier: selections[0].lastModifier,
                segments: selections[0].segments,
                tags: selections[0].tags,
                categories: selections[0].categories
            });

            return composite;
        },

        _queryForSelections: function(selectedIds) {
            if (this._queryObserveHandle) {
                this._queryObserveHandle.remove();
            }
            if (selectedIds.length === 0) {
                return [];
            } else {
                var deferred = new Deferred();

                var result = PostDescriptorStore.query({
                    objectId: selectedIds
                });

                when(result, lang.hitch(this, function(storeResult) {
                    this._queryObserveHandle = storeResult.observe(lang.hitch(this, 'refresh'), true);
                    this.own(this._queryObserveHandle);
                    deferred.resolve(storeResult);
                }));

                return deferred.promise;
            }
        },

        _removeUncommonTaxonomies: function(originalList, list) {
            if (!originalList || originalList.length === 0) {
                return originalList;
            } else if (!list || list.length === 0) {
                return [];
            }

            return _.filter(originalList, function(originalItem) {
                var originalLeaf = originalItem[0];
                return _.some(list, function(item) {
                    var leaf = item[0];
                    return leaf.id === originalLeaf.id;
                });
            });
        },

        _renderSelections: function (selections) {
            var rendered = '',
                data = null,
                template = null;

            this._thumbnail = null;
            this._wayfinder = null;

            if (!_.isArray(selections)) {
                selections = [selections];
            }

            if (selections.length === 0) {
                this._fileDisplay.set('content', '');
                return;
            } else if (selections.length === 1) {
                data = lang.mixin({}, selections[0]);

                this._appendFormattedDatesToSingleResult(data);

                template = singleTemplate;

            } else {
                data = this._mergeSelections(selections);
                template = bulkTemplate;
            }

            data.contentStreamLength = humanizeBytes(data.contentStreamLength, 3);
            data.segments = this._flattenSegments(data.segments);

            data.pathLabels = _.flatten(data.segments, function(s) { return s.label; }).join(', ');

            rendered = renderTemplate(template, data);

            this._fileDisplay.set('content', rendered);

            // Update the supplementary display
            this._updateRemovableTagsAndCategoriesList('tags', selections, data.tags);
            this._updateRemovableTagsAndCategoriesList('categories', selections, data.categories);
        },

        _updateRemovableTagsAndCategoriesList: function(listType, selections, taxonomies) {
            var widgetName = listType+'Widget',
                listWidget = this[widgetName],
                singular = listType === 'categories'  ? 'category'
                         : listType === 'tags'        ? 'tag'
                         :                              '';

            if (!listWidget) {
                listWidget = this[widgetName] = new RemovableTagsOrCategoriesList({
                    objects: selections,
                    taxonomyType: listType,
                    taxonomies: this._flattenTaxonomy(taxonomies)
                }, this[listType+'Node']);


                this.own(listWidget.on('removed', lang.hitch(this, function (eventObj) {
                    this.emit(singular+'_removed', eventObj);
                })));

            } else {
                listWidget.set('objects', selections);
                listWidget.set('taxonomies', this._flattenTaxonomy(taxonomies));
            }
        },

        /**
         * Convenience method to allow DetailsPane.set('selections', blah), without support for
         * notification when the loading is complete.
         *
         * @param selections
         * @private
         */
        _setSelectionsAttr: function (selections) {
            this.setSelections(selections);
        },

        constructor: function() {
            // Call refresh only once at end of call stack. This comes into play when multiple items are selected.
            this.refresh = _.debounce(this.refresh, 0);

            var folderEvents = events.folders;

            this._updateFolderForEvents = {
                'categories': folderEvents.category.changed,
                'tags': folderEvents.personalTag.changed,
                'segments': folderEvents.uri.changed
            };
        },

        postCreate: function() {
            this.inherited(arguments);

            _.forOwn(this._updateFolderForEvents, function(event, folderType) {
                this.own(topic.subscribe(event, lang.hitch(this, '_updateForFolderChange')(folderType)));
            }, this);
        },

        refresh: function() {
            this.setSelections(this.selections);
        },

        /**
         * @param {string| Array.<{objectId: string}>} selections - This is either an objectId string,
         *                                                          or a PostDescriptor object
         * @return {*}
         * @private
         */
        setSelections: function (selections) {
            var deferred = new Deferred();
            if (this._destroyed) {
                deferred.resolve();
                return deferred;
            }

            if (!_.isArray(selections)) {
                selections = [selections];
            }

            // If any of the selections are just a string, they're an objectID.  Turn them into a proxy object.
            var selectedIds = _.map(selections, function (selection) {

                // If this is a string, it's an objectId
                if (_.isString(selection)) {

                    return selection;

                    // If this is an object, we should have everything we need
                } else if (_.isObject(selection)) {

                    return selection.objectId;

                    // Otherwise this is an error
                } else {
                    console.error('Attempting to fetch details for an invalid parameter:');
                    console.error(selection);
                    throw new Error('Attempting to fetch details for an invalid parameter.');
                }
            });

            when(this._queryForSelections(selectedIds), lang.hitch(this, function (selectedObjects) {
                // Clone because query results array is modified later by Observable, which we don't want to affect
                // our stored selections array.
                this.selections = _.clone(selectedObjects);

                this._renderSelections(selectedObjects);

                // the details pane hasn't fully loaded until the thumbnail is loaded
                if(this._thumbnail) {
                    this._thumbnail.promise.then(lang.hitch(deferred, 'resolve'));
                } else {
                    // if there is no thumbnail, then the details pane has finished loading
                    deferred.resolve();
                }
            }));

            return deferred.promise;
        }
    });
});

},
'pepper/library/RemovableTagsOrCategoriesList':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'dojo/dom-construct', 'dojo/Evented',
    'dijit/_WidgetBase',
    'vodori/ui/Button',
    'pepper/data/PostDescriptorStore'
], function(provide, module,
            _,
            lang,
            domConstruct, Evented,
            _WidgetBase,
            Button,
            PostDescriptorStore
    ) {

    /**
     * @class RemovableTagsOrCategoriesList
     * @mixes dijit/_WidgetBase
     *
     * Renders a list of tags or categories for a particular object or set of objects. It provides the ability for a
     * user to remove any of these taxonomies from the object(s).
     */
    return provide(module.id, [_WidgetBase, Evented], {
        /**
         * Object(s) from library to which these tags or categories apply. Used when removing taxonomy from these
         * objects.
         * @type Array.<Object>
         */
        objects: null,

        /**
         * Either 'tags' or 'categories'.
         * @type String
         */
        taxonomyType: '',

        /**
         * List of tags/categories to display
         * @type Array.<{id: String, label: String}>
         */
        taxonomies: null,

        _setTaxonomiesAttr: function(taxonomies) {
            this.taxonomies = taxonomies;
            this._render();
        },

        postCreate: function() {
            this.inherited(arguments);
            this._render();
        },

        _render: function() {
            if (!this.domNode) {
                return;
            }
            this.destroyDescendants();
            if (!this.taxonomies || this.taxonomies.length === 0) {
                if (this.objects && this.objects.length > 1) {
                    this.domNode.innerHTML = 'No common ' + this.taxonomyType + ' applied.';
                } else {
                    this.domNode.innerHTML = 'No ' + this.taxonomyType + ' applied.';
                }
                return;
            }

            domConstruct.empty(this.domNode);
            _.forEach(this.taxonomies, function(taxonomy) {
                var button = new Button({
                    label: taxonomy.label,
                    iconClass: 'xIcon',
                    onClick: lang.hitch(this, 'remove', taxonomy.id),
                    'class': 'standard action'
                });
                button.placeAt(this.domNode);
            }, this);
        },

        remove: function(taxonomyId) {
            var promise = PostDescriptorStore.unfile(this.objects, taxonomyId);

            promise.then(lang.hitch(this, function() {
                this.emit('removed', { id: taxonomyId });
            }));
        }
    });
});

},
'vodori/ui/LoadingAwareImage':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'module', '../provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/on', 'dojo/Deferred', 'dojo/dom-construct', 'dojo/dom-attr',
    'dijit/_WidgetBase'
], function (module, provide,
             _,
             lang,
             on, Deferred, domConstruct, domAttr,
             _WidgetBase
    ) {

    /**
     * A simple widget to allow images to be rendered and to resolve a deferred when loading completes
     *
     * NOTES:
     * - Do not specify the src attribute on the img tag, or the onload event will not work correctly.
     * - HTML element must be img, or an error will be thrown
     */
    return provide(module, [ _WidgetBase ], {
        src: null,
        promise: null,
        _deferred: null,

        constructor: function() {
            // rather than extending Evented, using a deferred allows implementing code to
            // receive deferred resolution even if the image has already loaded
            this._deferred = new Deferred();
            this.promise = this._deferred.promise;
        },

        buildRendering: function() {
            this.inherited(arguments);

            if(this.domNode) {
                if(this.domNode.tagName.toLowerCase() !== 'img') {
                    throw Error('LoadingAwareImage element type must be img.');
                }

                if(domAttr.get(this.domNode, 'src')) {
                    throw Error('LoadingAwareImage element type cannot have src attribute set.');
                }
            }

            // the ordering here is important: if the src attribute is set before
            // the event handler is connected then the event handler won't be called
            on(this.domNode, 'load', lang.hitch(this, function() {
                this._deferred.resolve();
            }));

            domAttr.set(this.domNode, 'src', this.src);
        }
    });
});
},
'pepper/library/ResultsHeader':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/topic',
    'dojo/dom-class', 'dojo/dom-style',
    'dojo/Evented',
    'dijit/layout/ContentPane',
    'vodori/_ContentAttachPoints',
    'pepper/events', 'pepper/services', 'pepper/utilities',
    'pepper/commands/dialogs/showCreate', 'pepper/commands/dialogs/showImportPepperDoc',
    'dojo/text!./templates/ResultsHeader-content.html',
    /* Unreference MIDs */
    'vodori/ui/Button',
    'pepper/ui/DropDownButton',
    'pepper/library/LibraryContextMenu',
    'vodori/input/GroupedSelect'
], function (provide, module,
             _,
             topic,
             domClass, domStyle,
             Evented,
             ContentPane,
             _ContentAttachPoints,
             events, services, utilities,
             showCreate, showImportPepperDoc,
             content) {
    /**
     * @class pepper/library/ResultsHeader
     */
    return provide(module, [ContentPane, _ContentAttachPoints, Evented],
        /**
         * @lends pepper/library/ResultsHeader.prototype
         */
        {
            content: content,
            contentFixed: true,
            contentAttachPoints: {
                '.createBtn': {name: 'createBtn', event: 'click', method: 'onCreateClick'},
                '.importBtn': {name: 'importBtn', event: 'click', method: 'onImportClick'},
                '.downloadBtn': {name: 'downloadBtn', event: 'click', method: 'onDownloadClick'},
                '.refreshBtn': {name: 'refreshBtn', event: 'click', method: 'onRefreshClick'},
                '.actionMenuBtn': 'actionMenuBtn',
                '.viewSelect': {name: 'viewSelect', event: 'change', method: '_onViewChange'},
                '.removeFolderButton': { name: 'removeFolderButton', event: 'click', method: 'onRemoveFolderClick' },
                '.removeTagButton': { name: 'removeTagButton', event: 'click', method: 'onRemoveTagClick' },
                '.removeCategoryButton': { name: 'removeCategoryButton',
                                           event: 'click',
                                           method: 'onRemoveCategoryClick'
                                         },
                '.totalResultsCount': {name: 'totalResultsCount'}
            },

            _selectedCategory: null,
            _selectedTag: null,
            _selectedFolder: null,
            _selections: null,

            currentChannel: null,

            postCreate: function() {
                this.inherited(arguments);

                this._toggleActionButton(false);

                this.own(
                    // Enable the action menu when there's a selection.
                    this.subscribe(events.library.filters.category.selectionChanged, this._categoryFilterChangeHandler),
                    this.subscribe(events.library.filters.tag.selectionChanged, this._tagFilterChangeHandler),
                    this.subscribe(
                        events.library.filters.directory.selectionChanged, this._directoryFilterChangeHandler),

                    this.subscribe(events.library.results.updateTotalResults, this._setTotalResultsCount)
                );
            },

            _allItemsMatchSelectedMetaDatum: function (selectedItems, metadataType, selectedMetaDatum) {
                if (selectedItems.length === 0) {
                    return false;
                }
                else {
                    return _.all(selectedItems, function (selectedItem) {
                        var metaData = selectedItem[metadataType][0];
                        if (metaData) {
                            return _.any(metaData, function (metaDatum) {
                                return metaDatum.id === selectedMetaDatum;
                            }, this);
                        } else {
                            return false;
                        }
                    }, this);
                }
            },

            _setSelectedItemsAttr: function(selectedItems) {
                var allTags, allCategories, allMultifiled;
                this._selections = selectedItems;
                this._toggleActionButton(selectedItems.length !== 0);

                if (selectedItems.length !== 0) {
                    this.actionMenuBtn.dropDown.set('selectedItems', selectedItems);
                }

                if (this._selectedCategory) {
                    allCategories = this._allItemsMatchSelectedMetaDatum(selectedItems, 'categories',
                                                                         this._selectedCategory);
                    domClass.toggle(this.domNode, 'hasCategory', allCategories);
                }

                if (this._selectedTag) {
                    allTags = this._allItemsMatchSelectedMetaDatum(selectedItems, 'tags', this._selectedTag);
                    domClass.toggle(this.domNode, 'hasTag', allTags);
                }

                if (this._selectedFolder) {
                    allMultifiled = _.all(selectedItems, function(selectedItem){
                        return selectedItem.uris && selectedItem.uris.length > 1;
                    });
                    domClass.toggle(this.domNode, 'hasFolder', allMultifiled);
                }
            },

            _categoryFilterChangeHandler: function (selectedItem) {
                this.set('_selectedCategory', selectedItem);
            },

            _tagFilterChangeHandler: function (selectedItem) {
                this.set('_selectedTag', selectedItem);
            },

            _directoryFilterChangeHandler: function (selectedItem) {
                this.set('_selectedFolder', selectedItem);
            },

            enableCreateButton: function() {
                this._toggleCreateButton(true);
            },

            disableCreateButton: function() {
                this._toggleCreateButton(false);
            },

            /**
             * Event handler for remove tag button
             */
            onRemoveTagClick: function () {
                this._removeHandler(this.get('_selectedTag'));
            },

            /**
             * Event handler for remove category button
             */
            onRemoveCategoryClick: function () {
                this._removeHandler(this.get('_selectedCategory'));
            },

            /**
             * Event handler for remove folder button
             */
            onRemoveFolderClick: function () {
                this._removeHandler(this.get('_selectedFolder'));
            },

            _removeHandler: function (parentFolderId) {
                var promise = services.unfile({
                    params: {
                        objects: utilities.createPayload(this._selections),
                        parentFolderId: parentFolderId
                    }
                });
                // Refresh the library after this is complete
                topic.publish(events.library.objectMoved, promise);
            },

            /**
             * Event handler for the Create button. Opens a create dialog
             */
            onCreateClick: function () {
                showCreate(null, this.currentChannel.id);
            },

            /**
             * Event handler for the Import button. Opens an import dialog
             */
            onImportClick: function () {
                showImportPepperDoc(null, this.currentChannel.id);
            },
            /**
             * Event handler for the Refresh button.
             */
            onRefreshClick: function () {
                this.emit(events.library.refresh);
            },

            /**
             * Event handler for the Download CSV button.  Executes the current QUERY_LIBRARY command
             * with a state of DOWNLOAD
             */
            onDownloadClick: function () {
                this.emit('downloadCsv');
            },

            /**
             * Called when the grid's view changes
             */
            _onViewChange: function (views) {
                var view = views[0];

                if (this.view !== view) {
                    this.view = view;
                    this.emit(events.library.viewChange, view);
                }
            },

            _setViewAttr: function (view) {
                this.viewSelect.set('value', view);
            },

            _toggleActionButton: function (enabled) {
                this.actionMenuBtn.set('disabled', !enabled);
                if (enabled) {
                    domStyle.set(this.actionMenuBtn.domNode, 'display', '');
                } else {
                    domStyle.set(this.actionMenuBtn.domNode, 'display', 'none');
                }
            },

            _toggleCreateButton: function(enabled) {
                  this.createBtn.set('disabled', !enabled);
            },

            _setTotalResultsCount: function (totalResults) {
                this.totalResultsCount.innerHTML = totalResults;
            }
        }
    );
});

},
'vodori/_ContentAttachPoints':function(){
/**
 * @module vodori/_ContentAttachPoints
 */
define([
    'dojo/_base/kernel', 'dojo/_base/lang',
    'dojo/query', 'dojo/on', 'dojo/aspect',
    './provide', 'module',
    'dijit/_base/manager',
    'vodori/util/string/capitalize',
    'dojo/NodeList-dom'
], function (kernel, lang, query, on, aspect, provide, module, manager, capitalize) {

    kernel.deprecated('vodori/_ContentAttachPoints',
        'Use vodori/layout/_LazyAttachPoints instead. ' +
            'This can be legitimately used in the Library and NavigationManager dialogs ' +
            '(until ComposingDialog is complete) but nowhere else',
        '3.5-release');

    /**
     * @lends module:vodori/_ContentAttachPoints#
     */
    var _ContentAttachPoints = {
        // Ignore content passed in with an instantiating DOM node?
        // This will force the content to be that of the constructor's prototype.
        contentFixed: false,

        // Which property actually determines the content?
        // Usually it's "content", but on a button it's "label".
        contentProperty: 'content',

        // Which node contains the content?
        // It's probably always "containerNode".
        contentNode: 'containerNode',

        // Set up a map of CSS selectors (in content) to property names.
        // You can also give it an event on the selection to connect to, and a widget method to fire.
        // If the selector matches a widget's DOM node, that widget will be used instead.
        contentAttachPoints: {
            /*
             '.someClass': 'propertyName',
             '.someClass .someDescendant': {name: 'propertyName', event: 'eventName', method: 'methodName'}
             */
        },

        _attachedContentNames: [],
        _attachedContentConnections: [],

        constructor: function () {
            this._attachedContentNames = [];
            this._attachedContentConnections = [];
        },

        postMixInProperties: function () {
            // We'll want to re-attach the points whenever we update the content property.
            this.own(aspect.after(this,
                '_set' + capitalize(this.contentProperty) + 'Attr',
                lang.hitch(this, '_attachContentPoints'), true));

            this.inherited(arguments);
        },

        _applyAttributes: function () {
            // If content is fixed, reset it to the default before we
            // apply the attributes from the instantiating DOM node.
            if (this.contentFixed) {
                this[this.contentProperty] = this.constructor.prototype[this.contentProperty];
            }

            this.inherited(arguments);
        },

        _attachContentPoints: function () {
            // Clear out the existing connections to old content.
            while (this._attachedContentConnections.length > 0) {
                this._attachedContentConnections.pop().remove();
            }

            // Clear out the existing references to old content.
            while (this._attachedContentNames.length > 0) {
                var key = this._attachedContentNames.pop();
                delete this[key]; //delete this.getObject(key, false, this);
            }

            for (var selector in this.contentAttachPoints) {
                var currentPoint = this.contentAttachPoints[selector],
                    normalizedPoint = {
                        name: currentPoint.name || currentPoint,
                        event: currentPoint.event || '',
                        method: currentPoint.method || '',
                        args: currentPoint.args || []
                    };

                // Select the right node or widget in the content node and attach to it.
                var selection = query(selector, this[this.contentNode]);
                selection.forEach(lang.hitch(this, '_attach', normalizedPoint));
            }
        },

        _attach: function (point, node) {
            // Prefer a widget if it exists.
            var target = manager.byNode(node) || node;

            if (point.name) {
                // Assign the name as a property of this widget referencing the target.
                lang.setObject(point.name, target, this);

                // Remember the names so we can clear them out when content changes.
                this._attachedContentNames.push(point.name);
            }

            // Make the connection from the event to the method.
            if (point.event && point.method) {
                // Set up a function to fire the method in the right context when the specified event happens.
                var methodWithArgs = lang.hitch.apply(lang, [this, point.method].concat(point.args));

                // Remember the connection so we can remove it when content changes.
                this._attachedContentConnections.push(on(target, point.event, methodWithArgs));
            }
        }
    };

    return provide(module.id, null,  _ContentAttachPoints);
});

},
'pepper/library/filter/ui/FacetedSearch':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'dojo/aspect', 'dojo/query', 'dojo/dom-class', 'dojo/dom-construct', 'dojo/keys',
    'dijit/registry', 'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'dojox/widget/TitleGroup', 'dijit/TitlePane',
    'vodori/renderTemplate',
    'pepper/library/filter/model/FacetedSearch',
    'pepper/data/FacetStore',
    'dojo/text!pepper/library/filter/ui/templates/FacetedSearch.html',
    'dojo/text!pepper/library/filter/ui/templates/SearchFacet.html',

    /* unreferenced MIDs */
    'dijit/ConfirmTooltipDialog'
], function (provide, module,
             _,
             lang,
             aspect, query, domClass, domConstruct, keys,
             registry, _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
             TitleGroup, TitlePane,
             renderTemplate,
             FacetedSearch,
             facetStore,
             facetedSearchTemplate,
             searchFacetTemplate) {

    /**
     * @class FacetedSearch
     *
     * Advanced search dialog that allows for additional Pepper Library search features that can be configured.
     */
    return provide(module, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin],
        {

            /**
             * prototypical variables (static)
             *
             * @type {string}
             */
            templateString: facetedSearchTemplate,

            /**
             * instance attach points:
             *
             * _dropDownButton
             * _facetsDialog
             * _facetsContainer
             * _facetsTitleGroup
             */

            /**
             * instance variables:
             *
             * filter
             * _searchFacetWidgets
             * _searchFacetQuery
             */

            postMixInProperties: function() {
                this.filter = new FacetedSearch();
                this._searchFacetWidgets = [];
                this._searchFacetQuery = {};
            },

            startup: function() {

                var config = this._getConfig();

                if (!_.isEmpty(config)) {
                    this._buildFacets(config);
                    this._hookupApply();
                    this._hookupClearAll();
                    this._hookupAutoOpenFacets();
                } else {
                    // No config found, no faceted search needed
                    domClass.add(this.domNode, 'hidden');
                }

                this.inherited(arguments);
            },

            // Actions -------------------------------------------------------------------------------------------------

            applyFacets: function() {
                this._processSearchFacets();
                this.filter.set('query', this._searchFacetQuery);
            },

            clearAll: function() {
                _.forEach(this._searchFacetWidgets, function(facet) {
                    facet.input.set('value', '');
                    facet.input.set('open', false);
                });

                this.applyFacets();
            },

            /**
             * Expands all facets containing values and collapses all facets not containing values if
             * collapseAllFacetsWithoutValues is true (which it is by default).
             *
             * @param {boolean} [collapseAllFacetsWithoutValues = true]
             */
            expandAllFacetsWithValues: function(collapseAllFacetsWithoutValues) {
                collapseAllFacetsWithoutValues = collapseAllFacetsWithoutValues === undefined;

                _.forEach(this._searchFacetWidgets, function (facet) {
                    if (facet.input.textbox) {
                        var facetHasValue = !_.isEmpty(facet.input.get('value'));
                        if ((facetHasValue && !facet.pane.open) ||
                            (!facetHasValue && collapseAllFacetsWithoutValues && facet.pane.open)) {

                            facet.pane.toggle();
                            if (facet.input.focused) {
                                facet.input.focusNode.blur();
                            }
                        }
                    }
                });
            },

            _processSearchFacets: function() {
                var activeFacetCount = 0;
                var queryFacets = {};

                _.forEach(this._searchFacetWidgets, function(facet) {
                    var value = facet.input.get('value');

                    if(!_.isEmpty(value)) {
                        queryFacets[facet.input.get('name')] = value;
                        activeFacetCount++;
                    }
                });

                this._searchFacetQuery = { facets: queryFacets };
                this._dropDownButton.set('label', activeFacetCount !== 0 ? activeFacetCount : '');
                domClass.toggle(this._dropDownButton.titleNode, 'hasText', activeFacetCount !== 0);
            },

            // Initialization ------------------------------------------------------------------------------------------

            _getConfig: function() {
                return facetStore.data;
            },

            _buildFacets: function(config) {
                _.forEach(config, lang.hitch(this, '_buildFacet'));
            },

            _buildFacet: function(facetConfig) {
                var pane = new TitlePane({
                    open: false,
                    title: facetConfig.display,
                    content: renderTemplate(searchFacetTemplate, {
                        property: facetConfig.property,
                        placeHolder: facetConfig.placeholderText
                    })
                });
                pane.startup();

                var facetInput = query('.searchFacet', pane.domNode).map(function (node) {
                    return registry.byNode(node);
                }).pop();

                this._searchFacetWidgets.push({
                    pane: pane,
                    input: facetInput
                });

                // Focus input on clicking title pane
                aspect.after(pane, 'toggle', function() {
                    if (pane.open) {
                        facetInput.focus();
                    }
                });

                this.own(
                    // Apply facets on enter
                    facetInput.on('keydown', lang.hitch(this, function(event) {
                        if(event.keyCode === keys.ENTER) {
                            this.applyFacets();
                            this._dropDownButton.closeDropDown();
                        }
                    }))
                );

                domConstruct.place(pane.domNode, this._facetsContainer);
            },

            _hookupApply: function() {
                this._facetsDialog.onExecute = lang.hitch(this, 'applyFacets');
            },

            _hookupClearAll: function() {
                this._facetsDialog.onCancel = lang.hitch(this, 'clearAll');
            },

            _hookupAutoOpenFacets: function() {
                aspect.before(this._dropDownButton, 'openDropDown', lang.hitch(this, 'expandAllFacetsWithValues'));
            }

        }
    );
});
},
'dojox/widget/TitleGroup':function(){
define(["dojo", "dijit/registry", "dijit/_Widget", "dijit/TitlePane"], function(dojo, registry, widget, titlepane){
	
	var tp = titlepane.prototype,
		lookup = function(){
			// generic handler function for click and keypress
			var parent = this._dxfindParent && this._dxfindParent();
			parent && parent.selectChild(this);
		}
	;
	
	// this might hide this uberprivate function from the docparser.
	tp._dxfindParent = function(){
		// summary:
		//		TitlePane's MUST be first-children of a TitleGroup. only used by
		//		`dojox.widget.TitleGroup`. Finds a possible parent TitleGroup of a TitlePane
		var n = this.domNode.parentNode;
		if(n){
			n = registry.getEnclosingWidget(n);
			return n && n instanceof dojox.widget.TitleGroup && n;
		}
		return n;
	};

	// if we click our own title, hide everyone
	dojo.connect(tp, "_onTitleClick", lookup);
	dojo.connect(tp, "_onTitleKey", function(e){
		// if we're tabbing through the items in a group, don't do toggles.
		// if we hit enter, let it happen.
		if(!(e && e.type && e.type == "keypress" && e.charOrCode == dojo.keys.TAB)){
			lookup.apply(this, arguments);
		}
	});
		
	return dojo.declare("dojox.widget.TitleGroup", dijit._Widget, {
		// summary:
		//		A container which controls a series of `dijit.TitlePane`s,
		//		allowing one to be visible and hiding siblings
		// description:
		//		A container which controls a series of `dijit.TitlePane`s,
		//		allowing one to be visible and hiding siblings. Behaves similarly
		//		to a `dijit.layout.AccordionContainer` in that the children
		//		are all stacked, though merges the TitlePane behavior of
		//		variable height
		// example:
		//	|	var group = new dojox.widget.TitleGroup().placeAt(dojo.body());
		//	|	new dijit.TitlePane({ title:"One" }, "fromsource").placeAt(group);
		//	|	new dijit.TitlePane({ title:"Remote", href:"foo.html" }).placeAt(group);
		
		"class":"dojoxTitleGroup",

		addChild: function(widget, position){
			// summary:
			//		Add a passed widget reference to this container at an optional
			//		position index.
			// widget: dijit.TitlePane
			//		A widget reference to add
			// position: String|Int?
			//		An optional index or position to pass. defaults to "last"
			return widget.placeAt(this.domNode, position); // dijit.TitlePane
		},
		
		removeChild: function(widget){
			// summary:
			//		Remove the passed widget from this container. Does not destroy
			//		child.
			
			this.domNode.removeChild(widget.domNode);
			return widget;
		},
		
		selectChild: function(widget){
			// summary:
			//		close all found titlePanes within this group, excluding
			//		the one the we pass to select
			widget && dojo.query("> .dijitTitlePane", this.domNode).forEach(function(n){
				var tp = registry.byNode(n);
				tp && tp !== widget && tp.open && tp.toggle(); // could race if open is set onEnd of slide
			});
			return widget; // dijit/TitlePane
		}
	
	});

});

},
'pepper/library/filter/model/FacetedSearch':function(){
define([
        'lodash',
        'dojo/_base/declare',
        'vodori/filter/model/_FilterBase',
        'vodori/filter/model/FilterType'
    ],
    function (_, declare, _FilterBase, FilterType) {

        'use strict';
        return declare([_FilterBase], {
            filterType: FilterType.FREEFORM,
            key: 'facets',
            _querySetter: function(query) {
                if (!(this.key in query) && _.keys(query).length > 0) {
                    var message = 'This query (%o) contains nothing that matches this filter\'s key: %s ';
                    console.warn(message, query, this.key);
                    return;
                }
                this.query = {
                    facets: query.facets
                };
                this._analyzeQuery = true;
            },
            reset: function() {
                // Never reset the faceted search filter
            }
        });
    }
);
},
'pepper/data/FacetStore':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'module', 'vodori/provide',
    'dojo/store/Memory', 'dojo/store/Observable',
    'vodori/util/_TemplatedData'
], function (
    module, provide,
    Memory, Observable,
    _TemplatedData) {

    var FacetStore = provide(module, [_TemplatedData, Memory], {

        facets : null,

        constructor: function() {
            if (this.facets) {
                this.setData(this.facets);
            } else {
                console.warn('FacetStore requested, but no templated data was found');
                this.data = [];
            }
        }
    });

    return new Observable(new FacetStore());
});
},
'dijit/ConfirmTooltipDialog':function(){
define([
	"dojo/_base/declare",
	"./TooltipDialog",
	"./_ConfirmDialogMixin"
], function(declare, TooltipDialog, _ConfirmDialogMixin) {
	
	return declare("dijit/ConfirmTooltipDialog", [TooltipDialog, _ConfirmDialogMixin], {
		// summary:
		//		A TooltipDialog with OK/Cancel buttons.
	});
});

},
'dijit/_ConfirmDialogMixin':function(){
define([
	"dojo/_base/declare",
	"./_WidgetsInTemplateMixin",
	"dojo/i18n!./nls/common",
	"dojo/text!./templates/actionBar.html",
	"./form/Button"		// used by template
], function(declare, _WidgetsInTemplateMixin, strings, actionBarMarkup) {

	return declare("dijit/_ConfirmDialogMixin", _WidgetsInTemplateMixin, {
		// summary:
		//		Mixin for Dialog/TooltipDialog with OK/Cancel buttons.

		// HTML snippet for action bar, overrides _DialogMixin.actionBarTemplate
		actionBarTemplate: actionBarMarkup,

		// buttonOk: String
		//		Label of OK button
		buttonOk: strings.buttonOk,
		_setButtonOkAttr: { node: "okButton", attribute: "label" },

		// buttonCancel: String
		//		Label of cancel button
		buttonCancel: strings.buttonCancel,
		_setButtonCancelAttr: { node: "cancelButton", attribute: "label" }
	});
});

},
'pepper/tinymce/AdvImage':function(){
define([
    'vodori/provide', 'module',
    'dojo/_base/lang', 'dojo/on', 'dojo/dom', 'dojo/query',
    'vodori/amd/tinymce',
    'vodori/tinymce/util/augmentWithLoader', 'vodori/tinymce/util/getPluginName',
    'vodori/tinymce/util/getResourceUrl',
    'vodori/tinymce/_GetInfoMixin',
    'pepper/library/LibraryDialog', 'pepper/library/FilterOverrideLibrary'
], function (provide, module,
             lang, on, dom, query,
             tinymce,
             augmentWithLoader, getPluginName,
             getResourceUrl,
             _GetInfoMixin,
             LibraryDialog, FilterOverrideLibrary) {
    'use strict';

    var pluginName = getPluginName(module);

    var plugin = provide(module.id, [_GetInfoMixin], {
        /**
         * @type {string}
         */
        pluginName: pluginName,

        /**
         * @type {DOMWindow}
         */
        frameWindow: null,

        /**
         * @type {Object}
         */
        modal: null,

        /**
         * @param {tinymce.Editor} ed
         */
        init: function (ed) {
            var url = this.url = getResourceUrl(module);

            // Register commands
            ed.addCommand('mceAdvImage', function () {
                // Internal image object like a flash placeholder
                if (ed.dom.getAttrib(ed.selection.getNode(), 'class').indexOf('mceItem') !== -1) {
                    return;
                }

                var modal = this.modal = ed.windowManager.open({
                    file: url + '/image.htm',
                    width: 480 + parseInt(ed.getLang('advimage.delta_width', 0), 10),
                    height: 385 + parseInt(ed.getLang('advimage.delta_height', 0), 10),
                    inline: 1
                }, {
                    /* jshint -W106 */
                    plugin_url: url
                    /* jshint +W106 */
                });

                this.frameWindow = modal.iframeElement.get().contentWindow;

                augmentWithLoader(modal).require([
                    'dojo/parser', 'dojo/query', 'dojo/on', 'dojo/_base/lang',
                    'vodori/ui/Button', 'dojo/domReady!'
                ], lang.hitch(this, function (parser, query, on, lang) {
                    parser.parse({template:false});
                    query('.browse').on('click', lang.hitch(this, function () {
                        this.toggleModal(false);
                        this.browsePepper();
                    }));
                }));

            }, this);

            // Register buttons
            ed.addButton('image', {
                title: 'advimage.image_desc',
                cmd: 'mceAdvImage'
            });
        },

        /**
         * Hide or show the tinymce modal associated with this plugin.
         *
         * @param {boolean?} show
         * @return {void}
         */
        toggleModal: function (show) {
            var blocker = query('#mceModalBlocker');
            if (this.modal.isHidden || show) {
                this.modal.element.show();
                blocker.style('display', 'block');
            } else {
                this.modal.element.hide();
                blocker.style('display', 'none');
            }
        },

        /**
         * Launch the browser and wait for a response.
         *
         * @return {void}
         */
        browsePepper: function () {
            var modal = new LibraryDialog({
                widget: new FilterOverrideLibrary({
                    readOnly: true,
                    resultsGridView: 'grid',
                    libraryFilterOverrides: [
                        {
                            'widget': 'pepper/library/filter/ui/ContentType',
                            'filterData': {
                                'default': 'Image'
                            }
                        },
                        {
                            'filterData': {
                                'exclude': ['Reception']
                            },
                            'widget': 'pepper/library/filter/ui/StateVersion'
                        }
                    ],
                    confirmHandler: lang.hitch(this, function(selection) {
                        this.setPepperObject(selection.pop() || {});
                    })
                }),
                onHide: lang.hitch(this, function() {
                    this.toggleModal(true);
                })
            });
            modal.startup();
            modal.show();
        },

        /**
         * @param {Object} pepperObject the first selection.
         * @return {void}
         */
        setPepperObject: function (pepperObject) {
            var forms = query('form', this.frameWindow.document.body);

            // Might as well support more than one form.
            forms.forEach(function (form) {
                form.src.value = pepperObject.pathInCurrentSubscription || '';
                form.alt.value = pepperObject.htmlAltText || pepperObject.name || '';
                form.title.value = pepperObject.title || '';
                form.src.onchange();
            }, this);
        }

    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'pepper/tinymce/PepperLink':function(){
/**
 * Replaces the tinymce links commands. Relies on OverrideContextCommand to
 * modify the context menu, so ensure that plugin is mapped into the config.
 */
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/topic', 'dojo/_base/window',
    'dojo/dom', 'dojo/dom-construct',
    'dojox/html/entities',
    'vodori/amd/tinymce',
    'vodori/util/node/htmlToText', 'vodori/tinymce/_Selection', 'vodori/util/propsToObject',
    'pepper/events', 'pepper/dialogs/LinkManager', 'pepper/enums/linkAttrEnum'
], function (module, provide,
             _,
             lang, topic, topWin,
             dom, domConstruct,
             entities,
             tinymce,
             htmlToText, _Selection, propsToObject,
             events, LinkManager, linkAttrEnum) {
    'use strict';

    /**
     * Keep a reference to the most recent last in number, so we can find the
     * element later.
     *
     * @type {number}
     */
    var lastInCounter = 0;

    var ALLOWED_CUSTOM_EVENTS = ['onclick', 'onmouseover'];

    var Plugin = provide(module.id, [_Selection], {

        /**
         * @type {tinymce.Editor}
         */
        editor: null,

        /**
         * A collection of dojo event handlers.
         *
         * @type {Array.<{remove: Function}>}
         */
        handles: null,

        /**
         * @type {dojo.Deferred.promise}
         */
        _linkManagerClosePromise: null,

        /**
         * Used for modal popup
         * @type {string}
         */
        PROTECTED_CSS_CLASS: 'vodori_ui_DialogLink',

        /**
         * @param {tinymce.Editor} ed
         * @return {void}
         */
        init: function (ed) {
            this.handles = [];
            this.editor = ed;

            ed.addCommand('pepperLink', this.launchLinkManager, this);

            ed.addButton('link', {
                title: 'Insert or modify a link',
                cmd: 'pepperLink'
            });

            // See this: http://goo.gl/hC0Oa for details
            ed.addShortcut('ctrl+k', 'Insert a pepper link', 'pepperLink');

            // Snagged from advanced link.
            ed.onNodeChange.add(this.manageEnabling, this);
        },

        /**
         * @return {void}
         */
        launchLinkManager: function () {
            var ed = this.editor,
                sel = ed.selection;

            // The selection is either an anchor or null.
            var selection = this.getContainingAnchor(sel);

            // Force user to select text unless their cursor is in an anchor
            if (sel.isCollapsed() && !selection) {
                return;
            }

            // sel.getContent() has a bug that sometimes returns the whole editor
            var isAnchor = false;
            var asText = sel.getContent({format: 'text'});
            // It's not null.
            if (!!selection) {
                isAnchor = true;
                // Make sure the anchor is selected to simplify.
                this.editor.selection.select(selection);
                this.saveSelection();
            }
            // It's null, so figure out what the new anchor should wrap.
            else {
                this.saveSelection();
                selection = sel.getNode();
                // If the next highest node contains other stuff, then we just want the text.
                if (selection.innerHTML && selection.innerHTML !== asText) {
                    selection = asText;
                }
                // Otherwise, we want the node as text.
                else {
                    selection = tinymce.DOM.getOuterHTML(selection);
                }
            }

            // Make a new dialog.
            var linkManager = new LinkManager({
                selected: selection
            });

            linkManager.show().then(lang.hitch(this, function () {
                if (isAnchor) {
                    this.populateLinkManager(linkManager, selection);
                }
            }));

            this.handles.push(
                topic.subscribe(events.content.linkManager.apply, lang.hitch(this, 'handleApply'))
            );

            this.handles.push(
                topic.subscribe(events.content.linkManager.cancel, lang.hitch(this, 'handleCancel'))
            );
        },

        /**
         * Catch the message from LinkManager and put it into the content.
         *
         * @param {{objectId: string, closePromise: dojo.Deferred.promise, breakConnection: boolean}} message
         * @return {void}
         */
        handleApply: function (message) {
            var ed = this.editor,
                dom = ed.dom;

            this._linkManagerClosePromise = message.closePromise;

            var sel = this.restoreSelection();

            var lastIn = dom.select('a.pepperLastInTracker' + String(lastInCounter))[0];

            var target = message.target;

            var attrs = {
                'href': message.path,
                'title': htmlToText(message.toolTip),
                'class': message.classes
            };

            attrs[linkAttrEnum.TARGET_ATTR] = target;
            attrs[linkAttrEnum.HYPER_TYPE_ATTR] = message.hyperType;
            attrs[linkAttrEnum.TOOLTIP_ATTR] = message.toolTip;

            // Build the handlers for all the defined events found in the message,
            // scrubbing double quotes and other possibly problematic characters
            _.forEach(message.eventHandlers, function(eventContent, eventType){
                attrs[eventType] = entities.encode(eventContent);
            });

            // If native popup, insert code to open popup window into href
            if (target === '_new') {
                attrs.href = "javascript:void(/mceContentBody|editMode/.test(document.documentElement.className) ? 0 " +
                    ": window.open('" + message.path + "','nativePopup','scrollbars=yes,width=" + message.popupWidth +
                    ", height=" + message.popupHeight + "'))";
                if (message.classes && message.classes.contains(this.PROTECTED_CSS_CLASS)) {
                    message.classes.remove(this.PROTECTED_CSS_CLASS);
                }
                if (message.classes && message.classes.contains('ConfigurableTransformer')) {
                    message.classes.remove('ConfigurableTransformer');
                }
                attrs['class'] = message.classes;
            }

            // If modal popup, add data-dojo-props to anchor
            if (target === '_popup') {
                var popupHeight = message.popupHeight;
                popupHeight = popupHeight === '' ? '500' : popupHeight;
                var popupWidth = message.popupWidth;
                popupWidth = popupWidth === '' ? '700' : popupWidth;

                attrs['data-dojo-props'] = 'popupHeight: ' + popupHeight + ', popupWidth: ' + popupWidth;
                attrs['class'] = this.PROTECTED_CSS_CLASS;
            }

            if (!!message.objectId) {
                attrs[linkAttrEnum.PEPPER_OBJECT_ID_ATTR] = message.objectId;
            }

            if (this.isValidTargetType(target)) {
                attrs.target = target;
            }

            var anchor = dom.create('a', attrs, this.stripPTags(message.display));

            if (message.breakConnection) {
                ed.save();
                this._cleanup();
            } else {
                // Have to keep indirect reference, since tinymce converts to
                // a string.
                dom.addClass(anchor, 'pepperLastInTracker' + String(++lastInCounter));
            }

            // Must get this reference before setNode or we'll wipe ourselves.
            var existingAnchor = this.getContainingAnchor(sel);

            if (!!existingAnchor) {
                dom.insertAfter(anchor, existingAnchor);
                dom.remove(existingAnchor); // get rid of the old anchor
            } else if (!!lastIn) {
                dom.insertAfter(anchor, lastIn);
                dom.remove(lastIn);
            } else {
                sel.setNode(anchor);
            }

        },

        /**
         *
         * @param {{closePromise: dojo.Deferred.promise}} message
         */
        handleCancel: function (message) {
            this._linkManagerClosePromise = message.closePromise;
            this._cleanup();
        },

        /**
         * @param {pepper.dialogs.LinkManager}
         * @param {Element} anchor
         * @return {void}
         */
        populateLinkManager: function (linker, anchor) {
            var hyper = this.getAttr(anchor, linkAttrEnum.HYPER_TYPE_ATTR);
            if (hyper) {
                linker.setTabByHyperType(hyper);
            }
            linker.set('target', this.getAttr(anchor, linkAttrEnum.TARGET_ATTR, 'target'));
            linker.set('hyperType', hyper);
            linker.set('toolTip', this.getAttr(anchor, linkAttrEnum.TOOLTIP_ATTR, 'title'));
            linker.set('path', this.getAttr(anchor, 'href'));
            linker.set('display', String(anchor.innerHTML));
            linker.set('objectId', this.getAttr(anchor, linkAttrEnum.PEPPER_OBJECT_ID_ATTR));

            // Look for any sanctioned events on the node and prepare a description of handlers
            // for the link manager.
            _.forEach(ALLOWED_CUSTOM_EVENTS, lang.hitch(this, function (eventAttr) {
                if (this.getAttr(anchor, eventAttr)) {
                    linker.eventHandlers[eventAttr] = this.getAttr(anchor, eventAttr);
                }
            }));

            // If native popup (IE8/9 do not correctly load the popup window with a 'target' attribute value of '_new',
            // so target attribute therefore is no longer put onto popup links and we need to use 'data-pepper-target'
            // here instead)
            if (this.getAttr(anchor, 'data-pepper-target') === '_new') {
                var href = this.getAttr(anchor, 'href'),
                    pathInfo, path, width, height;

                // Try to find the full popup opening code snippet
                pathInfo = /window\.open\([^\)]*\)/i.exec(href);

                // If we found it, extract info
                if (pathInfo) {
                    pathInfo = pathInfo[0]; // Need to get the result out of the regex results
                    path = /'[^']*'/.exec(pathInfo);
                    width = /width=(\d*)/i.exec(pathInfo);
                    height = /height=(\d*)/i.exec(pathInfo);
                }

                // For each piece of info, if one was found then extract it from the regex results
                linker.set('path', path ? path[0].slice(1, -1) : ''); // Need to slice leading/trailing quotes
                linker.set('popupWidth', width ? width[1] : ''); // Width/height are a memorized regex match
                linker.set('popupHeight', height ? height[1] : '');
            }

            // If modal popup
            if (this.getAttr(anchor, 'target') === '_popup') {
                var dojoPropObj = propsToObject(this.getAttr(anchor, "data-dojo-props"));
                linker.set('popupHeight', dojoPropObj.popupHeight);
                linker.set('popupWidth', dojoPropObj.popupWidth);
            }
        },

        /**
         * Prefer pepper attr., but get native if not available.
         *
         * @param {Element} elem
         * @param {string} pepperAttrName
         * @param {string?} nativeName
         * @return {string}
         */
        getAttr: function (elem, pepperAttrName, nativeName) {
            var dom = this.editor.dom,
                value = dom.getAttrib(elem, pepperAttrName);

            nativeName = !!nativeName ? nativeName : '';

            return !!value ? value : dom.getAttrib(elem, nativeName);
        },

        /**
         * @param selection
         * @return {Element|void}
         */
        getContainingAnchor: function (selection) {
            return this.editor.dom.getParent(selection.getNode(), 'A');
        },

        /**
         * @param {tinymce.Editor} editor
         * @param {tinymce.ControlManager} controller
         * @param {Element} node
         * @param {boolean} co
         * @return {void}
         */
        manageEnabling: function (editor, controller, node, co) {
            controller.setDisabled('link', co && node.nodeName !== 'A');
            controller.setActive('link', node.nodeName === 'A' && !node.name);
        },

        /**
         * Adapted from prototype.js
         * (c) Sam Stephenson http://goo.gl/FqAVd
         *
         * @param {Element|string} elem
         * @return {string}
         */
        stripPTags: function (elem) {
            if (typeof elem !== "string") {
                elem = this.editor.dom.getOuterHtml(elem);
            }

            return elem.replace(/<p(\s+("[^"]*"|'[^']*'|[^>])+)?>|<\/p>/gi, '');
        },

        /**
         * Ensure a link doesn't get a weird setting in target
         *
         * @param targetType
         */
        isValidTargetType: function (targetType) {
            var validType = {
                '_blank': true,
                '_new': false, // IE8/9 choke on this as a 'target' attribute value when opening popups
                '_self': true,
                '_top': true,
                '_popup': true
            };

            return !!validType[targetType];
        },

        _cleanup: function () {
            _.forEach(this.handles, function (handle) {
                handle.remove();
            });
            this._linkManagerClosePromise.then(lang.hitch(this, 'restoreSelection'));
        }

    });

    tinymce.PluginManager.add('pepperlink', Plugin);

    return Plugin;
});


},
'dojox/html/entities':function(){
define(["dojo/_base/lang"], function(lang) {
	// dojox.html.entities.html [public] Array
	//		Entity characters for HTML, represented as an array of
	//		character code, entity name (minus & and ; wrapping.
	//		The function wrapper is to fix global leking with the build tools.
	var dhe = lang.getObject("dojox.html.entities",true);	
	
	var _applyEncodingMap = function(str, map){
		// summary:
		//		Private internal function for performing encoding of entity characters.
		// tags:
		//		private
	
		// Check to see if we have genned and cached a regexp for this map yet
		// If we have, use it, if not, gen it, cache, then use.
		var mapper, regexp;
		if(map._encCache &&
			map._encCache.regexp &&
			map._encCache.mapper &&
			map.length == map._encCache.length){
			mapper = map._encCache.mapper;
			regexp = map._encCache.regexp;
		}else{
			mapper = {};
			regexp = ["["];
			var i;
			for(i = 0; i < map.length; i++){
				mapper[map[i][0]] = "&" + map[i][1] + ";";
				regexp.push(map[i][0]);
			}
			regexp.push("]");
			regexp = new RegExp(regexp.join(""), "g");
			map._encCache = {
				mapper: mapper,
				regexp: regexp,
				length: map.length
			};
		}
		str = str.replace(regexp, function(c){
			return mapper[c];
		});
		return str;
	};
	
	var _applyDecodingMap = function(str, map){
		// summary:
		//		Private internal function for performing decoding of entity characters.
		// tags:
		//		private
		var mapper, regexp;
		if(map._decCache &&
			map._decCache.regexp &&
			map._decCache.mapper &&
			map.length == map._decCache.length){
			mapper = map._decCache.mapper;
			regexp = map._decCache.regexp;
		}else{
			mapper = {};
			regexp = ["("];
			var i;
			for(i = 0; i < map.length; i++){
				var e = "&" + map[i][1] + ";";
				if(i){regexp.push("|");}
				mapper[e] = map[i][0];
				regexp.push(e);
			}
			regexp.push(")");
			regexp = new RegExp(regexp.join(""), "g");
			map._decCache = {
				mapper: mapper,
				regexp: regexp,
				length: map.length
			};
		}
		str = str.replace(regexp, function(c){
			return mapper[c];
		});
		return str;
	};

	dhe.html = [
		["\u0026","amp"], ["\u0022","quot"],["\u003C","lt"], ["\u003E","gt"],
		["\u00A0","nbsp"]
	];
	
	// dojox.html.entities.latin [public] Array
	//		Entity characters for Latin characters and similar, represented as an array of
	//		character code, entity name (minus & and ; wrapping.
	dhe.latin = [
		["\u00A1","iexcl"],["\u00A2","cent"],["\u00A3","pound"],["\u20AC","euro"],
		["\u00A4","curren"],["\u00A5","yen"],["\u00A6","brvbar"],["\u00A7","sect"],
		["\u00A8","uml"],["\u00A9","copy"],["\u00AA","ordf"],["\u00AB","laquo"],
		["\u00AC","not"],["\u00AD","shy"],["\u00AE","reg"],["\u00AF","macr"],
		["\u00B0","deg"],["\u00B1","plusmn"],["\u00B2","sup2"],["\u00B3","sup3"],
		["\u00B4","acute"],["\u00B5","micro"],["\u00B6","para"],["\u00B7","middot"],
		["\u00B8","cedil"],["\u00B9","sup1"],["\u00BA","ordm"],["\u00BB","raquo"],
		["\u00BC","frac14"],["\u00BD","frac12"],["\u00BE","frac34"],["\u00BF","iquest"],
		["\u00C0","Agrave"],["\u00C1","Aacute"],["\u00C2","Acirc"],["\u00C3","Atilde"],
		["\u00C4","Auml"],["\u00C5","Aring"],["\u00C6","AElig"],["\u00C7","Ccedil"],
		["\u00C8","Egrave"],["\u00C9","Eacute"],["\u00CA","Ecirc"],["\u00CB","Euml"],
		["\u00CC","Igrave"],["\u00CD","Iacute"],["\u00CE","Icirc"],["\u00CF","Iuml"],
		["\u00D0","ETH"],["\u00D1","Ntilde"],["\u00D2","Ograve"],["\u00D3","Oacute"],
		["\u00D4","Ocirc"],["\u00D5","Otilde"],["\u00D6","Ouml"],["\u00D7","times"],
		["\u00D8","Oslash"],["\u00D9","Ugrave"],["\u00DA","Uacute"],["\u00DB","Ucirc"],
		["\u00DC","Uuml"],["\u00DD","Yacute"],["\u00DE","THORN"],["\u00DF","szlig"],
		["\u00E0","agrave"],["\u00E1","aacute"],["\u00E2","acirc"],["\u00E3","atilde"],
		["\u00E4","auml"],["\u00E5","aring"],["\u00E6","aelig"],["\u00E7","ccedil"],
		["\u00E8","egrave"],["\u00E9","eacute"],["\u00EA","ecirc"],["\u00EB","euml"],
		["\u00EC","igrave"],["\u00ED","iacute"],["\u00EE","icirc"],["\u00EF","iuml"],
		["\u00F0","eth"],["\u00F1","ntilde"],["\u00F2","ograve"],["\u00F3","oacute"],
		["\u00F4","ocirc"],["\u00F5","otilde"],["\u00F6","ouml"],["\u00F7","divide"],
		["\u00F8","oslash"],["\u00F9","ugrave"],["\u00FA","uacute"],["\u00FB","ucirc"],
		["\u00FC","uuml"],["\u00FD","yacute"],["\u00FE","thorn"],["\u00FF","yuml"],
		["\u0192","fnof"],["\u0391","Alpha"],["\u0392","Beta"],["\u0393","Gamma"],
		["\u0394","Delta"],["\u0395","Epsilon"],["\u0396","Zeta"],["\u0397","Eta"],
		["\u0398","Theta"], ["\u0399","Iota"],["\u039A","Kappa"],["\u039B","Lambda"],
		["\u039C","Mu"],["\u039D","Nu"],["\u039E","Xi"],["\u039F","Omicron"],
		["\u03A0","Pi"],["\u03A1","Rho"],["\u03A3","Sigma"],["\u03A4","Tau"],
		["\u03A5","Upsilon"],["\u03A6","Phi"],["\u03A7","Chi"],["\u03A8","Psi"],
		["\u03A9","Omega"],["\u03B1","alpha"],["\u03B2","beta"],["\u03B3","gamma"],
		["\u03B4","delta"],["\u03B5","epsilon"],["\u03B6","zeta"],["\u03B7","eta"],
		["\u03B8","theta"],["\u03B9","iota"],["\u03BA","kappa"],["\u03BB","lambda"],
		["\u03BC","mu"],["\u03BD","nu"],["\u03BE","xi"],["\u03BF","omicron"],
		["\u03C0","pi"],["\u03C1","rho"],["\u03C2","sigmaf"],["\u03C3","sigma"],
		["\u03C4","tau"],["\u03C5","upsilon"],["\u03C6","phi"],["\u03C7","chi"],
		["\u03C8","psi"],["\u03C9","omega"],["\u03D1","thetasym"],["\u03D2","upsih"],
		["\u03D6","piv"],["\u2022","bull"],["\u2026","hellip"],["\u2032","prime"],
		["\u2033","Prime"],["\u203E","oline"],["\u2044","frasl"],["\u2118","weierp"],
		["\u2111","image"],["\u211C","real"],["\u2122","trade"],["\u2135","alefsym"],
		["\u2190","larr"],["\u2191","uarr"],["\u2192","rarr"],["\u2193","darr"],
		["\u2194","harr"],["\u21B5","crarr"],["\u21D0","lArr"],["\u21D1","uArr"],
		["\u21D2","rArr"],["\u21D3","dArr"],["\u21D4","hArr"],["\u2200","forall"],
		["\u2202","part"],["\u2203","exist"],["\u2205","empty"],["\u2207","nabla"],
		["\u2208","isin"],["\u2209","notin"],["\u220B","ni"],["\u220F","prod"],
		["\u2211","sum"],["\u2212","minus"],["\u2217","lowast"],["\u221A","radic"],
		["\u221D","prop"],["\u221E","infin"],["\u2220","ang"],["\u2227","and"],
		["\u2228","or"],["\u2229","cap"],["\u222A","cup"],["\u222B","int"],
		["\u2234","there4"],["\u223C","sim"],["\u2245","cong"],["\u2248","asymp"],
		["\u2260","ne"],["\u2261","equiv"],["\u2264","le"],["\u2265","ge"],
		["\u2282","sub"],["\u2283","sup"],["\u2284","nsub"],["\u2286","sube"],
		["\u2287","supe"],["\u2295","oplus"],["\u2297","otimes"],["\u22A5","perp"],
		["\u22C5","sdot"],["\u2308","lceil"],["\u2309","rceil"],["\u230A","lfloor"],
		["\u230B","rfloor"],["\u2329","lang"],["\u232A","rang"],["\u25CA","loz"],
		["\u2660","spades"],["\u2663","clubs"],["\u2665","hearts"],["\u2666","diams"],
		["\u0152","OElig"],["\u0153","oelig"],["\u0160","Scaron"],["\u0161","scaron"],
		["\u0178","Yuml"],["\u02C6","circ"],["\u02DC","tilde"],["\u2002","ensp"],
		["\u2003","emsp"],["\u2009","thinsp"],["\u200C","zwnj"],["\u200D","zwj"],
		["\u200E","lrm"],["\u200F","rlm"],["\u2013","ndash"],["\u2014","mdash"],
		["\u2018","lsquo"],["\u2019","rsquo"],["\u201A","sbquo"],["\u201C","ldquo"],
		["\u201D","rdquo"],["\u201E","bdquo"],["\u2020","dagger"],["\u2021","Dagger"],
		["\u2030","permil"],["\u2039","lsaquo"],["\u203A","rsaquo"]
	];
	
	dhe.encode = function(str/*string*/, m /*array?*/){
		// summary:
		//		Function to obtain an entity encoding for a specified character
		// str:
		//		The string to process for possible entity encoding.
		// m:
		//		An optional list of character to entity name mappings (array of
		//		arrays).  If not provided, it uses the and Latin entities as the
		//		set to map and escape.
		// tags:
		//		public
		if(str){
			if(!m){
				// Apply the basic mappings.  HTML should always come first when decoding
				// as well.
				str = _applyEncodingMap(str, dhe.html);
				str = _applyEncodingMap(str, dhe.latin);
	
			}else{
				str = _applyEncodingMap(str, m);
			}
		}
		return str;
	};
	
	dhe.decode = function(str/*string*/, m /*array?*/){
		// summary:
		//		Function to obtain an entity encoding for a specified character
		// str:
		//		The string to process for possible entity encoding to decode.
		// m:
		//		An optional list of character to entity name mappings (array of
		//		arrays).  If not provided, it uses the HTML and Latin entities as the
		//		set to map and decode.
		// tags:
		//		public
		if(str){
			if(!m){
				// Apply the basic mappings.  HTML should always come first when decoding
				// as well.
				str = _applyDecodingMap(str, dhe.html);
				str = _applyDecodingMap(str, dhe.latin);
	
			}else{
				str = _applyDecodingMap(str, m);
			}
		}
		return str;
	};
	return dhe;
});


},
'vodori/util/node/htmlToText':function(){
define([
    './createFragmentedElement',
    'dojo/_base/lang'
], function (createFragmentedElement, lang) {
    /**
     * Takes any HTML and turns it into plain text. Also handles strings that
     * contain HTML.
     * @name vodori.util.node.htmlToText
     * @function
     * @param {Element|String} node
     * @return {String}
     */
    return function (node) {
        var container = null;

        if (lang.isString(node)) {
            container = createFragmentedElement();
            container.innerHTML = node;
            // It has a new div around it, but it won't matter.
            node = container;
        }

        /**
         * Mostly lifted from Sizzle
         * http://sizzlejs.com/
         * Copyright 2011, The Dojo Foundation
         * Released under the MIT, BSD, and GPL Licenses.
         *
         * @param {Element} node
         * @return {string}
         */
        return (function convertToText(elem) { // Recursive
            var i, node,
                nodeType = elem.nodeType,
                ret = '';

            if (nodeType) {
                if (nodeType === 1) {
                    // Use textContent || innerText for elements
                    if (typeof elem.textContent === 'string') {
                        return elem.textContent;
                    } else if (typeof elem.innerText === 'string') {
                        // Replace IE's carriage returns
                        return elem.innerText.replace(/\r\n/g, '');
                    } else {
                        // Traverse it's children
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            ret += convertToText(elem);
                        }
                    }
                } else if (nodeType === 3 || nodeType === 4) {
                    return elem.nodeValue;
                }
            } else {
                // If no nodeType, this is expected to be an array
                for (i = 0; (node = elem[i]); i++) {
                    // Do not traverse comment nodes
                    if (node.nodeType !== 8) {
                        ret += convertToText(node);
                    }
                }
            }
            return ret;
        }(node));

    };
});

},
'pepper/dialogs/LinkManager':function(){
define([
    'module', 'vodori/provide', 'require',
    'lodash',
    'dojo/_base/lang', 'dojo/on',
    'dojo/aspect', 'dojo/json',
    'dojo/Deferred', 'dojo/topic', 'dojo/when',
    'dojo/query',
    'dojo/dom-construct', 'dojo/dom-class',
    'dijit/registry',
    'vodori/input/Wysiwyg', 'vodori/renderTemplate',
    'vodori/ui/LazyDialog',
    'pepper/dialogs/BookmarkBrowser', 'pepper/dialogs/CustomEvents',
    'pepper/ui/handleNotification', 'pepper/ui/Wayfinder',
    'pepper/ui/_QuarantineMixin', 'pepper/ui/ComposingDialog',
    'pepper/commands/dialogs/showLibrary',
    'pepper/events', 'pepper/services',
    'dojo/text!./templates/LinkManager-pepper-link-actions.html',
    /* Unreferenced MIDs */
    'dojo/NodeList-dom',
    'vodori/tinymce/Antenna', 'vodori/tinymce/FixedToolbar', 'vodori/ui/Button',
    'vodori/ui/util/pane', 'vodori/input/TextBox', 'vodori/input/GroupedSelect',
    'pepper/ui/LibraryBrowserButton',
    'dijit/layout/BorderContainer', 'dijit/layout/ContentPane', 'dijit/layout/TabContainer',
    'dijit/TitlePane', 'dijit/form/CheckBox'
], function(
    module, provide, require,
    _,
    lang, on,
    aspect, json,
    Deferred, topic, when,
    query,
    domConstruct, domClass,
    registry,
    Wysiwyg, renderTemplate,
    LazyDialog,
    BookmarkBrowser, CustomEvents,
    handleNotification, Wayfinder,
    _QuarantineMixin, ComposingDialog,
    showLibrary,
    events, services,
    linkActionsTemplate
    ) {
    // We'll be converting some things to arrays.
    var aSlice = Array.prototype.slice;

    /**
     * Provide advanced functionality for adding and editing links.
     * @class pepper/dialogs/LinkManager
     * @mixes vodori/ui/LazyDialog
     * @mixes pepper/ui/_QuarantineMixin
     */
    return provide(module.id, [LazyDialog, _QuarantineMixin],
        /**
         * @lends pepper/dialogs/LinkManager.prototype
         */
        {
            /**
             * CSS class applied to the widget's outer Element
             *
             * @type {string}
             */
            baseClass: 'pepperLinkManager',

            /**
             * URL to template... need this to ensure that laziness works correctly
             * @type {string}
             */
            contentHref: require.toUrl('./templates/LinkManager.html'),

            /**
             * Text given to us by tinymce.
             *
             * @type {string}
             */
            selected: '',

            /**
             * @type {boolean}
             */
            destroyOnHide: true,

            /**
             * Let's PepperLink know if it should stop listening to the current
             * LinkManager (i.e. we're done modifying the link).
             *
             * @type {boolean}
             */
            breakConnection: false,

            /**
             * Flattened out for simplicity
             *
             * @type {Object.<string|Object.<string>>}
             */
            value: {
            /*
             id:  @type {number},
             hyperType: @type {string} external | pepper | onPage,
             path: path/to/file,
             display: @type {string} show this on page,
             toolTip: @type {string} HTML tooltip, use tinymce to strip out tags
             target: @type {string|Object} how the link opens
             popupHeight: @type {number} in pixels, if target value is popup
             popupWidth: @type {number} in pixels, if target value is popup
             */
            },

            // These are contained in value, but we'll hold them separate to
            // simplify updating.
            hyperType: '',
            path: '',
            display: '',
            toolTip: '',
            target: '',
            classes: '',
            popupHeight: '',
            popupWidth: '',

            lifecycleLabel: null,

            /**
             * Text for top of dialog
             *
             * @type {string}
             */
            title: 'In-Page Link Manager',

            hyperTypeToClassMap: {
                'pepper': 'inPepper',
                'bookmark': 'onPage',
                'external': 'external'
            },

            classToHyperTypeMap: {
                'inPepper': 'pepper',
                'onPage': 'bookmark',
                'external': 'external'
            },

            /**
             * @type {dijit.layout.TabContainer}
             */
            tabWidget: null,

            /**
             * @type {dojo.NodeList}
             */
            tabs: null,

            /**
             * Id of the currently handled link
             *
             * @type {string}
             */
            objectId: '',

            /**
             * @type {Object}
             */
            pepperObject: null,

            /**
             * Collection of settings for the wywsiwygs contained within.
             *
             * @type {Object.<string>}
             */
            wysiwygSettings: {
                theme: 'advanced',
                plugins: 'antenna, fixedtoolbar',
                /* jshint -W106 */
                theme_advanced_path: false,
                'theme_advanced_buttons': 'charmap, sup',
                'theme_advanced_buttons2': '',
                'theme_advanced_buttons3': '',
                /* jshint +W106 */
                // Totally lame solution to overriding a tinymce default.
                height: '44px !important'
            },

            /**
             * This object will be returned as part of the value object associated with the widget -
             * see the _getValueAttr() method.
             *
             * @type {Object}
             */
            otherAttrs: null,

            /**
             * Collection of event handlers to be applied to the lnk. Designed so that thre is only one statement
             * per event type (i.e., no semicolons allowed).
             *
             * @type {Object.<string, string>}
             */
            eventHandlers: null,

            /**
             * Collection of additional event handlers associated with the UI.
             *
             * @type {Array.<Object>}
             */
            _extraHandles: null,

            /**
             * @type {pepper.ui.Wayfinder}
             */
            _wayfinder: null,

            /**
             * @type {dojo.Deferred}
             */
            _closeDeferred: null,

            _buttonMappings: {
                'browseAnchorsButton': 'browseAnchors',
                'customEventsExternalLinkButton': 'manageCustomEvents',
                'customEventsPepperLibraryButton': 'manageCustomEvents',
                'cancelButton': 'handleCancel',
                'saveButton': 'save'
            },

            /**
             * @return {void}
             */
            constructor: function() {
                this.eventHandlers = {};
                this._extraHandles = [];
                this.tabs = [];
                this._closeDeferred = new Deferred();
                this.quarantineAreaClassNames += ' dialogContainer';
            },

            postCreate: function() {
                this.inherited(arguments);

                this.lazy(function () {
                    var targetInputs = this._getWidgetsBySelector('.targetWindow');
                    _.forEach(targetInputs, lang.hitch(this, function (targetInput) {
                        this.own(on(targetInput, 'change', lang.hitch(this, function (values) {
                            var value = values[0];

                            this._checkPopupSelected(value);
                        })));
                    }));
                });
            },

            /**
             * Set up the Wysiwygs.
             *
             * @return {void}
             */
            startup: function() {
                this.inherited(arguments);

                this.lazy(function () {

                    var tabWidget = this.tabWidget;

                    this.tabs = query('.dijitTabPane', tabWidget.domNode);

                    this.tabs.forEach(this.setupWysiwygs, this);

                    this._extraHandles.push(
                        aspect.after(this.tabWidget, 'selectChild', lang.hitch(this, 'handleTabChange')));

                    this.handleTabChange();

                    // If the display text is actually html, disable the display text input box
                    if (/<[^>]+\/>|<[^>]+>.*<\/[^>]+>/.test(this.selected)) { // Please don't hit me
                        // Grab the display input boxes from each tab
                        var displayInputs = this._getWidgetsBySelector('.display');
                        _.forEach(displayInputs, function(displayInput) {
                            when(displayInput.deferredEditor, function(editor) {
                                // Disable contentEditable in the display input box's tinyMCE editor DOM node.
                                editor.getBody().contentEditable = false;
                                query('iframe', editor.getContentAreaContainer()).style('display', 'none');

                                // And then create a duplicate node with the display input contents.
                                domConstruct.create(
                                    'div',
                                    {
                                        innerHTML: editor.getContent()
                                    },
                                    editor.getContentAreaContainer()
                                );
                            });
                        });
                    }
                });
            },

            /**
             * @param {string} hyperType
             * @return {void}
             */
            setTabByHyperType: function(hyperType) {
                this.setTabBySelector('.' + this.hyperTypeToClassMap[hyperType]);
            },

            /**
             * @param {string} selector
             * @return {void}
             */
            setTabBySelector: function(selector) {
                this.lazy(function(){
                    var tabWidget = this.tabWidget;
                    var tab = registry.byNode(query(selector, tabWidget.domNode)[0]);

                    if (!!tab) {
                        tabWidget.selectChild(tab);
                    }
                });
            },

            /**
             * @param {Element} tab
             * @return {void}
             */
            setupWysiwygs: function(tab) {

                var buttonContainer = query('.tinymceButtonContainer', tab)[0];

                var settings = lang.mixin({}, this.wysiwygSettings, {
                    /* jshint -W106 */
                    fixed_toolbar_node: buttonContainer
                    /* jshint +W106 */
                });

                query('.linkManagerWysiwyg', tab).forEach(function (place) {
                    var w = new Wysiwyg({
                        configuration: settings,
                        blockWhileLoading: false
                    }, place);

                    var selected = null;
                    var anchor = null;
                    // Use current selection as display initially.
                    if (domClass.contains(w.domNode, 'display')) {
                        selected = this.get('selected');

                        if (selected.nodeType === 1) {
                            anchor = query('a', selected.parentNode).pop();
                        }

                        if (anchor) {
                            w.set('value', anchor.innerHTML);
                        } else {
                            w.set('value', selected);
                        }
                    }

                    w.startup();

                }, this);
            },

            /**
             * Launch the BookmarkBrowser and wait for the value.
             *
             * @return {void}
             */
            browseAnchors: function() {
                // Make a new dialog.
                var browser = new BookmarkBrowser({});

                browser.show().then(lang.hitch(this, function (choice) {
                    this.set('path', '#' + String(choice.value));
                }));
            },

            /**
             * Launch the custom event manager and wait for the value
             */
            manageCustomEvents: function() {
                var widget = new CustomEvents({
                    handlerMap: this.eventHandlers,
                    disabled: this.disabled
                });

                widget.get('deferred').then(lang.hitch(this, function(handlerData) {
                    this.eventHandlers = handlerData;
                }));

                var dialog = new ComposingDialog({
                    widget: widget
                });

                return dialog.show();
            },

            /**
             * Let the server know about this, possibly new, link. Set the id of
             * the link based on the response. Probably gonna want a tinymce plugin
             * for this.
             *
             * @param {boolean} [isSave]
             * @return {void}
             */
            apply: function(isSave) {
                // I don't care about the event
                isSave = (typeof isSave !== 'object') ? isSave : false;

                topic.publish(events.content.linkManager.apply,
                    lang.mixin(this.get('value'), {
                        breakConnection: isSave,
                        closePromise: this._closeDeferred.promise
                    })
                );
            },

            /**
             * Clean up the editor selection properly if the user decides not to apply the link
             */
            handleCancel: function() {
                topic.publish(events.content.linkManager.cancel, {
                    closePromise: this._closeDeferred.promise
                });
                this.hide();
            },

            /**
             * Cleans up the dialog when we're finished adding the link.
             *
             * @return {void}
             */
            save: function() {
                if (this.isValid()) {
                    this.apply(true);
                    this.hide();
                }
            },

            isValid: function() {
                var values = this.get('value');

                if (values.display !== '' && values.path !== '') {
                    return true;
                }

                handleNotification({
                    title: 'One or more required values have not been filled out',
                    message: 'Please double check to make sure you have entered display text and chosen a target link.',
                    type: 'modal'
                });
            },

            /**
             * Set the hyper type based on the current tab.
             *
             * @return {void}
             */
            handleTabChange: function() {
                this.set('hyperType', this.classToHyperTypeMap[this.tabWidget.selectedChildWidget.hyperType]);
            },

            /**
             * Special handlers for the Wysiwygs.
             *
             * @param {TinyMCE.create.Editor} editor
             * @param {Object.<string|Object.<*>>} contents
             * @return {void}
             */
            handleWysiwygs: function(editor, contents) {
                var container = editor.getContainer().parentNode;

                if (domClass.contains(container, 'displayContainer')) {
                    this.set('display', contents.content);
                } else if (domClass.contains(container, 'titleContainer')) {
                    this.set('toolTip', contents.content);
                }
            },

            onHide: function() {
                this.inherited(arguments);
                this._closeDeferred.resolve();
            },

            /**
             * @return {void}
             */
            destroy: function() {
                this._destroyWayfinder();

                this.inherited(arguments);
            },

            /**
             * @param {Array.<Object>} selection
             * @return {T}
             */
            _librarySelectionHandler: function(selection) {
                var object = selection.pop();

                this.set('pepperObject', object);
                return this;
            },

            /**
             * Find the right instance based on the current tab, then get it's value
             *
             * @param {string} selector
             * @param {boolean} [isSingleTab=false]
             * @return {string}
             */
            _getWidgetValueBySelector: function(selector, isSingleTab) {
                if (!this.pointsReady) {
                    return null;
                }
                // default to true, e.g., only expand the number of inputs if
                // explicitly asked to.
                isSingleTab = isSingleTab !== false;

                var scopeNode = isSingleTab ? this.tabWidget.selectedChildWidget.domNode
                    : this.tabWidget.domNode;

                var widgets = this._getWidgetsBySelector(selector, scopeNode);

                // Only return the first value and assume it's in sync.
                // Make sure we return the raw value of any Wysiwygs. See: CAYENNE-1192
                if (widgets[0]) {
                    return widgets[0].getRawValue ? widgets[0].getRawValue() : widgets[0].get('value');
                } else {
                    return null;
                }
            },

            /**
             * Find the right instance based on the current tab, then get it's value
             *
             * @param {string} selector
             * @param {Element} [scope]  Optional scope to search within
             * @return {Array.<dijit._Widget>}
             */
            _getWidgetsBySelector: function(selector, scope) {
                // Find the nodes, then flip to an array, since they won't be nodes,
                // thus NodeList is inappropriate.
                var nodes = aSlice.call(query(selector, scope));

                var widgets = _.map(nodes, function (node) {
                    try { // If it's not there, ignore it.
                        return registry.byNode(node);
                    } catch (exception) {
                        console.warn(this, 'couldn\'t find a widget for', node);
                        return null;
                    }
                }, this);

                return _.filter(widgets, Boolean);
            },

            /**
             * @return {string}
             */
            _getPathAttr: function() {
                return this._getWidgetValueBySelector('.pathAttr');
            },

            /**
             * @return {string}
             */
            _getDisplayAttr: function() {
                return this._getWidgetValueBySelector('.display');
            },

            /**
             * @return {string}
             */
            _getToolTipAttr: function() {
                return this._getWidgetValueBySelector('.titleAttr');
            },

            /**
             * @return {string}
             */
            _getTargetAttr: function() {
                return this._getWidgetValueBySelector('.vodoriGroupedSelect');
            },

            /**
             * @return {Object.<DOMTokenList>}
             */
            _getClassesAttr: function() {
                return this.selected.classList;
            },

            /**
             * @return {string}
             */
            _getPopupHeightAttr: function() {
                return this._getWidgetValueBySelector('.popupHeightAttr');
            },

            /**
             * @return {string}
             */
            _getPopupWidthAttr: function() {
                return this._getWidgetValueBySelector('.popupWidthAttr');
            },

            /**
             * @return {Object.<string>}
             */
            _getValueAttr: function() {
                this.value = {
                    hyperType: this.get('hyperType'),
                    display: this.get('display'),
                    path: this.get('path'),
                    toolTip: this.get('toolTip'),
                    target: _.isArray(this.get('target')) ? this.get('target')[0] : this.get('target'),
                    objectId: this.get('objectId'),
                    otherAttrs: this.otherAttrs,
                    classes: this.get('classes'),
                    popupHeight: this.get('popupHeight'),
                    popupWidth: this.get('popupWidth'),
                    eventHandlers: this.get('eventHandlers')
                };
                return this.value;
            },

            /**
             * @param {Object} object
             * @retrun {T}
             */
            _setPepperObjectAttr: function(object) {
                this.set('path', object.path);

                // Not using the setter cause it'd be redundant.
                this.objectId = object.objectId;

                // Destroy the old wayfinder
                this._destroyWayfinder();

                // Keep a ref to the wayfinder for later destruction.
                var wayfinder = this._wayfinder = new Wayfinder({
                    objectId: object.objectId,
                    mini: true
                }, domConstruct.create('div', {}, this.wayfinderContainer));
                wayfinder.startup();

                this.lifecycleLabel.innerHTML = object.lifecycle.currentVersion;

                this.get('linkActionsContainer').innerHTML = renderTemplate(
                    linkActionsTemplate,
                    object);

                var libLink = query('[data-pepper-target=_library]', this.domNode).pop();

                on(libLink, 'click', function (evt) {
                    showLibrary({query: {search: this.get('path')}});
                    event.stop(evt);
                });

                return this;
            },

            /**
             * @param {string} selector
             * @param {string|number} value
             * @param {boolean} [isSingleTab]
             * @return {LinkManager}
             */
            _setWidgetValueBySelector: function(selector, value, isSingleTab) {
                // default to true, e.g., only expand the number of inputs if
                // explicitly asked to.
                isSingleTab = isSingleTab !== false;

                var scopeNode = isSingleTab ?
                    this.tabWidget.selectedChildWidget.domNode :
                    this.tabWidget.domNode;

                var widgets = this._getWidgetsBySelector(selector, scopeNode);

                _.forEach(widgets, function (widget) {
                    if (!widget.get('disabled')) {
                        widget.set('value', value);
                    } else {
                        widget.set('disabled', false);
                        widget.set('value', value);
                        widget.set('disabled', true);
                    }
                });

                return this;
            },

            /**
             * @param {string} value
             * @return {LinkManager}
             */
            _setPathAttr: function(value) {
                return this._setWidgetValueBySelector('.pathAttr', value);
            },

            /**
             * @param {string} value
             * @return {LinkManager}
             */
            _setDisplayAttr: function(value) {
                return this._setWidgetValueBySelector('.display', value, false);
            },

            /**
             * @param {string} value
             * @return {LinkManager}
             */
            _setToolTipAttr: function(value) {
                return this._setWidgetValueBySelector('.titleAttr', value, false);
            },

            /**
             * @param {string} value
             * @return {LinkManager}
             */
            _setTargetAttr: function(value) {
                return this._setWidgetValueBySelector('.vodoriGroupedSelect', value, false);
            },

            /**
             * @param {string} value
             * @return {LinkManager}
             */
            _setPopupHeightAttr: function(value) {
                return this._setWidgetValueBySelector('.popupHeightAttr', value, false);
            },

            /**
             * @param {string} value
             * @return {LinkManager}
             */
            _setPopupWidthAttr: function(value) {
                return this._setWidgetValueBySelector('.popupWidthAttr', value, false);
            },

            /**
             * @param {string} objectId
             * @return {LinkManager}
             */
            _setObjectIdAttr: function(objectId) {
                if (!objectId) {
                    return this;
                }

                this.objectId = objectId;

                services.getInfo({
                    params: {
                        objects: [
                            {
                                objectId: objectId
                            }
                        ]
                    }
                }).then(lang.hitch(this, function (response) {
                        this.set('pepperObject', response.results[0]);
                    }));

                return this;
            },

            _destroyWayfinder: function() {
                if (this._wayfinder) {
                    this._wayfinder.destroyRecursive();
                    domConstruct.empty(this.wayfinderContainer);
                }
            },

            _checkPopupSelected: function(value) {
                var options = query('.popupOptions');

                options.toggleClass('options-closed', !(value === '_popup' || value === '_new'));
            }
        });
});

},
'pepper/dialogs/BookmarkBrowser':function(){
define([
    'module',
    'vodori/provide',
    'dojo/_base/lang',
    'dojo/_base/window', 'dojo/query!css2.1',
    'dojo/dom-attr', 'dojo/dom-class',
    'require',
    '../ui/LazyDialog',
    'vodori/input/GroupedSelect',
    'dojo/Deferred',
    'dojo/text!./templates/BookmarkBrowser.html',
    'vodori/ui/Button',
    'vodori/ui/util/pane',
    'dijit/layout/BorderContainer',
    'dijit/layout/ContentPane',
    'dijit/layout/TabContainer',
    'dijit/TitlePane',
    'dijit/form/Button',
    'dijit/form/TextBox',
    'dijit/form/CheckBox',
    'dijit/form/_FormSelectWidget'
], function (module, provide, lang, win, query, domAttr, domClass, require, LazyDialog, GroupedSelect, Deferred) {
    /**
     * Allow choice of bookmarks based on a query for named anchors
     *
     * @class pepper/dialogs/BookmarkBrowser
     * @mixes pepper/ui/LazyDialog
     *
     */
    return provide(module.id, [LazyDialog],
        /**
         * @lends pepper/dialogs/BookmarkBrowser.prototype
         */
        {

            /**
             * @type {boolean}
             */
            destroyOnHide: true,

            /**
             * @type {dojo/Deferred.<string>}
             */
            deferred: null,

            /**
             * @type {string}
             */
            baseClass: 'pepperBookmarkBrowser',

            contentHref: require.toUrl('./templates/BookmarkBrowser.html'),

            /**
             * Let user resize.
             *
             * @type {boolean}
             */
            resizable: true,

            /**
             * Used as the dialog's title
             *
             * @type {string}
             */
            title: 'Select a Bookmark',

            /**
             * See vodori.ui.LazyDialog
             */
            _buttonMappings: {
                'cancelButton': 'cancelChoice',
                'insertButton': 'insertChoice'
            },

            /**
             * @type {Element}
             */
            bookmarkChoices: null,

            /**
             * @type {vodori.input.GroupedSelect}
             */
            groupedSelect: null,

            /**
             * Find all anchors with an id attr and add them to the GroupedSelect
             * (HTML5 does not allow the name attribute to be on anchor elements anymore)
             *
             * @return {void}
             */
            startup: function () {
                this.inherited(arguments);

                this.lazy(function () {
                    this.cancelButton.set('style', {
                        display: 'inline-block'
                    });
                    this.insertButton.set('style', {
                        display: 'inline-block'
                    });

                    var anchors = this.fetchAnchors();

                    this.groupedSelect = new GroupedSelect({
                        options: [
                            {
                                value: ' ',
                                label: 'None',
                                selected: true
                            }
                        ]
                    }, this.bookmarkChoices);

                    anchors.forEach(function (anchor) {
                        var name = domAttr.get(anchor, 'id');

                        this.groupedSelect.addOption({
                            value: name,
                            label: name
                        });
                    }, this);
                });
            },

            show: function () {
                this.inherited(arguments);

                // We'll give back a deferred, so the API is easier to follow.
                this.deferred = new Deferred();
                return this.deferred;
            },

            /**
             * Find all anchors associated with the current page.
             *
             * @return {Array.<Element>}
             */
            fetchAnchors: function () {
                // Mark certain anchors as not bookmarkable (primarily Pepper quarantine ones, and ones in property
                // wrappers since those are likely out of sync with their counterparts in editors)1
                query('.pepperPropertyWrapperOutput a[id], .quarantine a[id]:not(.mceButton)').addClass('not-anchor');

                // Any anchors marked as not bookmarkable, or ones that are TinyMCE buttons, should be excluded from the
                // list of bookmarks. This will not fetch anchors inside of iframes (editable regions).
                var anchors = query('a[id]:not(.not-anchor):not(.mceButton)', win.body());

                // Manually search inside of each editable region iframe for their anchors
                // and add them to the anchor list.
                query('iframe').attr('id').filter(Boolean).forEach(function (id) {
                    var doc = window.parent.frames[id].contentDocument;

                    var tags = doc.body.getElementsByTagName('a');

                    // Choices should be in order.
                    for (var i = 0, len = tags.length; i < len; i++) {
                        var tag = tags[i];
                        if (tag.hasAttribute('id')) {
                            anchors.push(tag);
                        }
                    }
                });

                return anchors;
            },

            /**
             * Publish the current value of the widget, then commit HariKari.
             *
             * @param {boolean} sendValue
             * @return {void}
             */
            unload: function (sendValue) {
                var sent = {
                    value: lang.trim(this.get('value'))
                };

                if (!sendValue) {
                    sent.value = '';
                }

                this.deferred.resolve(sent);

                this.hide();
            },

            /**
             * Pass appropriate value to unload, so LinkManager can catch it.
             *
             * @return {void}
             */
            insertChoice: function () {
                this.unload(true);
            },

            /**
             * Pass appropriate value to unload, so LinkManager can catch it.
             * Note: apparently dojo calls cancel when the _Widget loads??
             *
             * @return {void}
             */
            cancelChoice: function () {
                this.unload(false);
            },

            /**
             * This widget is a fancy wrapper for a GroupedSelect, so just get
             * that's value
             *
             * @return {string}
             */
            _getValueAttr: function () {
                var returnValue = '';

                if (this.groupedSelect) {
                    var groupedSelectValue = this.groupedSelect.get('value');

                    if (groupedSelectValue.length > 0) {
                        returnValue = groupedSelectValue[0];
                    }
                }

                return returnValue;
            }
        });
});

},
'pepper/dialogs/CustomEvents':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/on', 'dojo/Deferred',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'dojo/text!./templates/CustomEvents.html',

    'vodori/ui/util/NodeRepeater'

], function (module, provide,
             _,
             lang,
             on, Deferred,
             _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
             template) {
    /**
     * @description Allow choice of bookmarks based on a query for named anchors
     *
     */
    return provide(module.id, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {

        /* attach point widgets */
        onmouseoverTextArea: null,
        onclickTextArea: null,

        /**
         * @type {object}
         */
        handlerMap: null,

        /**
         * @type {dojo/Deferred}
         */
        deferred: null,

        /**
         * @type {string}
         */
        templateString: template,

        /**
         * @type {boolean}
         */
        disabled: false,

        insertButton: null,
        cancelButton: null,

        constructor: function () {
            this.deferred = new Deferred();
        },

        startup: function () {
            this.inherited(arguments);
            this.cancelButton.set('style', {display: 'inline-block'});
            this.insertButton.set('style', {display: 'inline-block'});

            on.emit(this.domNode, 'compose', {
                props: {
                    title: 'Custom Events Manager'
                },
                bubbles: true,
                cancelable: true
            });
        },

        postCreate: function () {
            this.inherited(arguments);

            this.own(on(this.cancelButton, 'click', lang.hitch(this, this._cancel)));

            if (this.handlerMap) {
                if (this.handlerMap.onmouseover) {
                    this.onmouseoverTextArea.set('value', this.handlerMap.onmouseover);
                }
                if (this.handlerMap.onclick) {
                    this.onclickTextArea.set('value', this.handlerMap.onclick);
                }
            }

            if (this.disabled) {
                this.insertButton.set('disabled', true);
                this.onmouseoverTextArea.set('disabled', true);
                this.onclickTextArea.set('disabled', true);
            } else {
                this.own(on(this.insertButton, 'click', lang.hitch(this, this._insert)));
            }

        },
        _cancel: function () {
            this._closeDialog();
        },

        _insert: function () {
            this._updateHandlers();

            this.deferred.resolve(this.handlerMap);

            this._closeDialog();
        },

        _closeDialog: function () {
            on.emit(this.domNode, 'compose', {
                methods: {
                    hide: true
                },
                bubbles: true,
                cancelable: true
            });
        },

        _cleanContents: function (contents) {
            if (!contents || !_.isString(contents)) {
                return null;
            }

            return contents.trim();
        },

        _updateHandlers: function () {

            // Clear the handler map before rebuilding based on current state of the DOM
            this.handlerMap = {};

            var onClickEventContents = this.onclickTextArea.get('value');
            var cleanedOnClickContents = this._cleanContents(onClickEventContents);

            if (cleanedOnClickContents) {
                this.handlerMap.onclick = cleanedOnClickContents;
            }

            var onMouseoverContents = this.onmouseoverTextArea.get('value');
            var cleanedOnMouseoverContents = this._cleanContents(onMouseoverContents);

            if (cleanedOnMouseoverContents) {
                this.handlerMap.onmouseover = cleanedOnMouseoverContents;
            }
        }


    });
});

},
'pepper/enums/linkAttrEnum':function(){
define(['vodori/util/Enum'], function (Enum) {
    return new Enum(
        {'PEPPER_OBJECT_ID_ATTR': 'data-pepper-object-id'},
        {'TARGET_ATTR': 'data-pepper-target'},
        {'HYPER_TYPE_ATTR': 'data-pepper-hypertype'},
        {'TOOLTIP_ATTR': 'data-pepper-tooltip'}
    );
});

},
'pepper/tinymce/Stamper':function(){
define([
    'vodori/amd/tinymce',
    'vodori/provide', 'module',
    'vodori/tinymce/util/getResourceUrl', 'vodori/tinymce/util/getPluginName',
    'vodori/tinymce/Stamp',
    'pepper/dialogs/Stamper', './_DialogLauncherMixin', 'vodori/tinymce/_GetInfoMixin'
], function (
    tinymce,
    provide, module,
    getResourceUrl, getPluginName,
    Stamp,
    StamperDialog, _DialogLauncherMixin, _GetInfoMixin) {

    var pluginName = getPluginName(module);

    var plugin = provide(module.id, [Stamp, _DialogLauncherMixin, _GetInfoMixin], {
        /**
         * {@inheritDoc}
         */
        pluginName: pluginName,

        /**
         * {@inheritDoc}
         */
        _dialogConstructor: StamperDialog
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;

});

},
'pepper/dialogs/Stamper':function(){
define([
    'require',
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'pepper/ui/LazyDialog',
    'vodori/amd/tinymce',
    'vodori/input/GroupedSelect',
    'dijit/layout/ContentPane',
    'vodori/renderTemplate',
    'dojo/text!./templates/Stamper-details.html',
    'dojo/text!./templates/Stamper-default-state.html',
    /* Unreferenced MIDs */
    'dijit/layout/BorderContainer',
    'vodori/ui/Tree',
    'pepper/ui/FormProxyPane',
    'vodori/ui/Button'
], function (require,
             provide, module,
             _,
             lang,
             LazyDialog,
             tinymce,
             GroupedSelect,
             ContentPane,
             renderTemplate,
             details,
             defaultState) {
    return provide(module, [LazyDialog],
        /**
         * @lends pepper/dialogs/Stamper.prototype
         */ {

            /**
             * @type {string}
             */
            baseClass: 'pepperTemplateStamperDialog',

            /**
             * This is setup in WysiwygConfig.js
             *
             * @type {Array.<Object>}
             */
            stampDefinitions: null,

            /**
             * @type {string}
             */
            title: 'Template Stamps',

            /**
             * @type {boolean}
             */
            resizable: true,

            /**
             * @type {boolean}
             */
            destroyOnHide: true,

            /**
             * Set in vodori.tinymce.Stamp
             *
             * @type {tinymce.create.Editor}
             */
            editor: null,

            /**
             * @type {vodori.ui.Tree}
             */
            categoriesTree: null,

            /**
             * @type {Element}
             */
            contentHref: require.toUrl('./templates/Stamper-content.html'),

            /**
             * @type {vodori.input.GroupedSelect}
             */
            stampSelect: null,

            /**
             * @type {pepper.ui.FormProxyPane}
             */
            stampProperties: null,

            _buttonMappings: {
                'cancelBtn': 'onCancel',
                'insertBtn': 'insertStamp'
            },

            /**
             * @type {Array.<Object>}
             */
            stampCategory: null,

            /**
             * @type {Object.<string>}
             */
            stamp: null,

            /**
             * @type {Array.<vodori.input.Wysiwyg>}
             */
            wysiwygs: null,

            /**
             * @constructs
             * @mixes pepper/ui/LazyDialog
             */
            constructor: function () {
                this.wysiwygs = [];
                this.stamp = {};
                this.stampCategory = [];
            },

            /** Fill the categoriesTree
             *
             * @return {void}
             */
            startup: function () {
                this.inherited(arguments);

                this.lazyOn('categoriesTree', 'change', lang.hitch(this, '_setStampCategoryAttr'));
                this.lazyOn('stampSelect', 'change', lang.hitch(this, function (stamps) {
                    this._setStampAttr(stamps[0]);
                }));

                this.lazy(function () {
                    var stamps = this.stampDefinitions = this.editor.getParam('stamperConfig');

                    this.categoriesTree.set('data', _.map(stamps, function (def) {
                        def.id = def.id || 'CATEGORY_' + String(+(new Date()));
                        return def;
                    })
                    );

                    this.initTemplateSelect();
                });
            },

            /**
             * @return {void}
             */
            insertStamp: function () {
                var stamp = this.stamp;

                require(
                    ['dojo/text!' + stamp.href],
                    lang.hitch(this, function (template) {
                        this.editor.execCommand('mce_stamp', false, {
                            template: template,
                            /* jshint -W106 */
                            forbiddenAncestors: stamp.forbidden_ancestors,
                            container: stamp.container,
                            loremIpsum: stamp.lorem_ipsum
                            /* jshint +W106 */
                        });

                        this.hide();
                    })
                );
            },

            /**
             * @return {string}
             */
            initTemplateSelect: function () {
                // Clear out any existing options
                this.stampSelect.set('options', []);

                // Include the thumbnail in the label
                this.stampSelect.labelTemplate = ([
                    '<img src="${thumbnail}" class="thumb" />',
                    '<span class="label">${label}</span>'
                ]).join('\n');
                return this.stampSelect.labelTemplate;
            },

            /**
             * @param {Array.<Object>} stampCategory
             * @return {T}
             */
            _setStampCategoryAttr: function (stampCategory) {
                var options = [];
                _.forEach(stampCategory, function (category) {
                    this.stampCategory = category;

                    _.forEach(category.stamps, function (stamp, index) {
                        options.push({
                            value: stamp.id,
                            label: stamp.label,
                            thumbnail: stamp.thumbnail || '',
                            selected: !index
                        });
                    }, this);
                }, this);

                if (this.stampSelect instanceof GroupedSelect) {
                    this.stampSelect.set('options', options);
                }

                return this;
            },

            /**
             * @param {Array.<string>?} stamp
             * @return {T}
             */
            _setStampAttr: function (stamp) {
                stamp = (this.stamp = this._getStampById(stamp));

                var template = stamp.id ? details : defaultState;

                if (this.stampProperties instanceof ContentPane) {
                    this.stampProperties.set(
                        'content',
                        renderTemplate(template, stamp));
                }

                return this;
            },

            /**
             * Find a stamps configuration based on its ID. (Needed to support
             * GroupedSelect).
             *
             * @param {string} id
             * @return {Object}
             */
            _getStampById: function (id) {
                var stamps = this.stampCategory.stamps,
                    returnStamp = {};

                if (stamps && stamps.length) {
                    _.forEach(stamps, function (stamp) {
                        if (stamp.id && stamp.id === id) {
                            returnStamp = stamp;
                            return false;
                        }
                    });
                }

                return returnStamp;
            }

        });
});

},
'vodori/ui/Tree':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang', 'dojo/on', 'dojo/aspect',
    'dojo/json', 'dojo/Deferred',
    'dojo/dom-attr',
    'dojo/data/ObjectStore', 'dojo/store/Memory',
    'dijit/Tree', 'dijit/tree/ForestStoreModel', 'dijit/Dialog',
    'vodori/ui/dndSource'
], function (provide, module,
             _,
             lang, on, aspect,
             JSON, Deferred,
             domAttr,
             ObjectStore, MemoryStore,
             Tree, ForestStoreModel, Dialog,
             dndSource) {
    return provide(module.id, [Tree], {
        baseClass: 'vodoriTree',

        enableDnd: false, // Only set dndController if DND is enabled
        multiSelect: false,
        showRoot: false,
        defaultOpen: false,

        data: [],
        model: null,

        suppressChanges: false,
        _suppressions: 0,

        constructor: function () {
            this.data = [];
        },

        postMixInProperties: function () {
            // If the data is JSON, parse it.
            if (typeof this.data === 'string') {
                this.data = JSON.parse(this.data);
            }

            // Build a tree from nested lists.
            var noData = this.data.length === 0;
            var listSourceIsData = noData && this.srcNodeRef && this.srcNodeRef.nodeName.match(/^ol$|^ul$/i);
            if (listSourceIsData) {
                this.data = _.map(this.srcNodeRef.children, this._liToTreeNode, this);
            }

            this.inherited(arguments);
        },

        _liToTreeNode: function (li) {
            var item = {
                label: li.innerHTML,
                id: domAttr.get(li, 'data-id') || 'item_' + Math.floor(Math.random() * 1000000)
            };

            if (li.children.length === 2 && li.children[1].nodeName.toLowerCase() === 'ul') {
                item.label = li.children[0].innerHTML; // Make sure there's a node before your list.
                item.children = _.map(li.children[1].children, this._liToTreeNode, this);
            }

            return item;
        },

        buildRendering: function () {
            if (this.enableDnd) {
                this.dndController = dndSource;
            }

            this.inherited(arguments);
        },

        postCreate: function () {
            this.inherited(arguments);

            this.watch('selectedItems', lang.hitch(this, function (attr, oldItems, items) {
                // Fire "onChange" when the selected item(s?) change.
                if (this._started && !this.suppressChanges && oldItems !== items) {
                    this.onChange(items);
                }
            }));

            // Indentation is broken in Firefox until the tree is shown.
            if (Dialog) {
                this.own(on(Dialog.prototype, 'show', lang.hitch(this, 'resize')));
            }
        },

        startup: function () {
            this.set('multiSelect', this.multiSelect);

            this.inherited(arguments);
        },

        _setDataAttr: function (data) {
            this.data = this.prepDataObject(data);
            this._createModel();

            // Let the initial data load finish naturally.
            if (!this._started) {
                return;
            }

            // If we're replacing the inital data, store the original _loadDeferred.
            var _originalLoadDeferred = this._loadDeferred;

            // Replace it with a dummy that restores the original when resolved.
            this._loadDeferred = new Deferred();
            this._loadDeferred.then(lang.hitch(this, function () {
                this._loadDeferred = _originalLoadDeferred;
            }));

            // Destroy the old root node.
            this.rootNode.destroyRecursive();

            // Recreate the root node and resolve the dummy _loadDeferred.
            this._load();
        },

        _createModel: function () {
            this.model = new ForestStoreModel({
                store: new ObjectStore({
                    objectStore: new MemoryStore({
                        data: this.data
                    })
                })
            });

            // Reconnect to the model
            this.own(aspect.after(this.model, 'onChange', lang.hitch(this, '_onItemChange'), true),
                     aspect.after(this.model, 'onChildrenChange', lang.hitch(this, '_onItemChildrenChange'), true),
                     aspect.after(this.model, 'onDelete', lang.hitch(this, '_onItemDelete'), true),
                     aspect.after(this.model, 'pasteItem', lang.hitch(this, 'onPasteItem'), true));
        },

        // Children are lazy-loaded, which makes it impossible to open something by ID.
        loadAllItems: function () {
            this.expandRecursive();
            this.collapseRecursive();
        },

        // Open everything (so we can select things by ID).
        expandRecursive: function (item) {
            item = item || this.rootNode;

            item.tree._expandNode(item);

            _.forEach(item.getChildren(), function (child) {
                child.tree.expandRecursive(child);
            });
        },

        // Close everything.
        collapseRecursive: function (item) {
            item = item || this.rootNode;

            _.forEach(item.getChildren(), function (child) {
                child.tree.collapseRecursive(child);
            });

            if (item !== item.tree.rootNode) {
                item.tree._collapseNode(item);
            }
        },

        // Expand to and select an item by ID or object.
        openTo: function (ids, select) {
            if (!_.isArray(ids)) {
                ids = [ids];
            }
            if (!this.multiSelect) {
                ids = [ids[0]];
            }

            select = true;

            this.set('selectedItems', ids); // Select the item.
            this.set('paths', this.get('paths')); // Open to its path.
        },

        onChange: function (items) {
            // Override me!
        },

        _getValueAttr: function () {
            return this.get('selectedItems');
        },

        /**
         * Called after an item has been dropped into a new parent
         */
        onPasteItem: function (childItem, oldParentItem, newParentItem) {
            // Ignore if node wasn't actually moved
            if (oldParentItem.id === newParentItem.id) {
                return;
            }

            console.log('Moved', childItem.id, 'from', oldParentItem.id, 'to', newParentItem.id);
        },

        /**
         * Make sure we're not dragging from one forest to another
         */
        checkAcceptance: function (source, nodes) {
            // If dragging a non-tree node into the tree, accept by default
            if (!source.tree) {
                return true;
            }
            return this.tree.id === source.tree.id;
        },

        // Make sure we're not dragging the root node
        checkItemAcceptance: function (target, source, position) {
            var rootNodes = source.tree.rootNode.item.children;
            var isRoot;

            source.forInSelectedItems(function (node) {
                isRoot = isRoot || _.some(rootNodes, function (item) {
                    return item === node.data.item;
                });
            });

            return !isRoot;
        },

        // Utility to convert badly formatted objects to goodly formatted ones.
        // Feel free to add more.
        prepDataObject: function (item) {
            if (_.isArray(item)) {
                return _.map(item, this.prepDataObject, this);
            }

            // Convert the "objectId" property to "id".
            if (!item.id) {
                item.id = item.objectId;
                delete item.objectId;
            }

            // Prepare children to be used in a tree.
            // Delete empty "children" arrays.
            if ('children' in item) {
                if (_.isArray(item.children) && item.children.length > 0) {
                    _.forEach(item.children, this.prepDataObject, this);
                } else {
                    delete item.children;
                }
            }

            return item;
        },

        deselectPath: function (pathToRemove) {
            var paths = this.get('paths');
            paths = _.filter(paths, function (path) {
                return path !== pathToRemove;
            });

            this.set('paths', paths);
        },

        // Select nothing.
        reset: function () {
            this.set('selectedItems', []);
        },

        _setMultiSelectAttr: function (value) {
            this.dndController.singular = !value;
            this.multiSelect = value;
        },

        _setSuppressChangesAttr: function (suppress) {
            this._suppressions += suppress ? +1 : -1;
            this.suppressChanges = this._suppressions !== 0;
        }
    });
});

},
'dojo/data/ObjectStore':function(){
define(["../_base/lang", "../Evented", "../_base/declare", "../_base/Deferred", "../_base/array", 
	"../_base/connect", "../regexp"
], function(lang, Evented, declare, Deferred, array, connect, regexp){

// module:
//		dojo/data/ObjectStore

function convertRegex(character){
	return character == '*' ? '.*' : character == '?' ? '.' : character; 
}
return declare("dojo.data.ObjectStore", [Evented],{
		// summary:
		//		A Dojo Data implementation that wraps Dojo object stores for backwards
		//		compatibility.

		objectStore: null,
		constructor: function(options){
			// options:
			//		The configuration information to pass into the data store.
			//
			//		- options.objectStore:
			//
			//		The object store to use as the source provider for this data store
			
			this._dirtyObjects = [];
			if(options.labelAttribute){
				// accept the old labelAttribute to make it easier to switch from old data stores
				options.labelProperty = options.labelAttribute; 
			}
			lang.mixin(this, options);
		},
		labelProperty: "label",

		getValue: function(/*Object*/ item, /*String*/property, /*value?*/defaultValue){
			// summary:
			//		Gets the value of an item's 'property'
			// item:
			//		The item to get the value from
			// property:
			//		property to look up value for
			// defaultValue:
			//		the default value

			return typeof item.get === "function" ? item.get(property) :
				property in item ?
					item[property] : defaultValue;
		},
		getValues: function(item, property){
			// summary:
			//		Gets the value of an item's 'property' and returns
			//		it. If this value is an array it is just returned,
			//		if not, the value is added to an array and that is returned.
			// item: Object
			// property: String
			//		property to look up value for

			var val = this.getValue(item,property);
			return val instanceof Array ? val : val === undefined ? [] : [val];
		},

		getAttributes: function(item){
			// summary:
			//		Gets the available attributes of an item's 'property' and returns
			//		it as an array.
			// item: Object

			var res = [];
			for(var i in item){
				if(item.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_')){
					res.push(i);
				}
			}
			return res;
		},

		hasAttribute: function(item,attribute){
			// summary:
			//		Checks to see if item has attribute
			// item: Object
			//		The item to check
			// attribute: String
			//		The attribute to check
			return attribute in item;
		},

		containsValue: function(item, attribute, value){
			// summary:
			//		Checks to see if 'item' has 'value' at 'attribute'
			// item: Object
			//		The item to check
			// attribute: String
			//		The attribute to check
			// value: Anything
			//		The value to look for
			return array.indexOf(this.getValues(item,attribute),value) > -1;
		},


		isItem: function(item){
			// summary:
			//		Checks to see if the argument is an item
			// item: Object
			//		The item to check

			// we have no way of determining if it belongs, we just have object returned from
			// service queries
			return (typeof item == 'object') && item && !(item instanceof Date);
		},

		isItemLoaded: function(item){
			// summary:
			//		Checks to see if the item is loaded.
			// item: Object
			//		The item to check

			return item && typeof item.load !== "function";
		},

		loadItem: function(args){
			// summary:
			//		Loads an item and calls the callback handler. Note, that this will call the callback
			//		handler even if the item is loaded. Consequently, you can use loadItem to ensure
			//		that an item is loaded is situations when the item may or may not be loaded yet.
			//		If you access a value directly through property access, you can use this to load
			//		a lazy value as well (doesn't need to be an item).
			// args: Object
			//		See dojo/data/api/Read.fetch()
			// example:
			//	|	store.loadItem({
			//	|		item: item, // this item may or may not be loaded
			//	|		onItem: function(item){
			//	|			// do something with the item
			//	|		}
			//	|	});

			var item;
			if(typeof args.item.load === "function"){
				Deferred.when(args.item.load(), function(result){
					item = result; // in synchronous mode this can allow loadItem to return the value
					var func = result instanceof Error ? args.onError : args.onItem;
					if(func){
						func.call(args.scope, result);
					}
				});
			}else if(args.onItem){
				// even if it is already loaded, we will use call the callback, this makes it easier to
				// use when it is not known if the item is loaded (you can always safely call loadItem).
				args.onItem.call(args.scope, args.item);
			}
			return item;
		},
		close: function(request){
			// summary:
			// 		See dojo/data/api/Read.close()
			return request && request.abort && request.abort();
		},
		fetch: function(args){
			// summary:
			//		See dojo/data/api/Read.fetch()

			args = lang.delegate(args, args && args.queryOptions);
			var self = this;
			var scope = args.scope || self;
			var query = args.query;
			if(typeof query == "object"){ // can be null, but that is ignore by for-in
				query = lang.delegate(query); // don't modify the original
				for(var i in query){
					// find any strings and convert them to regular expressions for wildcard support
					var required = query[i];
					if(typeof required == "string"){
						query[i] = RegExp("^" + regexp.escapeString(required, "*?\\").replace(/\\.|\*|\?/g, convertRegex) + "$", args.ignoreCase ? "mi" : "m");
						query[i].toString = (function(original){
							return function(){
								return original;
							};
						})(required);
					}
				}
			}

			var results = this.objectStore.query(query, args);
			Deferred.when(results.total, function(totalCount){
				Deferred.when(results, function(results){
					if(args.onBegin){
						args.onBegin.call(scope, totalCount || results.length, args);
					}
					if(args.onItem){
						for(var i=0; i<results.length;i++){
							args.onItem.call(scope, results[i], args);
						}
					}
					if(args.onComplete){
						args.onComplete.call(scope, args.onItem ? null : results, args);
					}
					return results;
				}, errorHandler);
			}, errorHandler);
			function errorHandler(error){
				if(args.onError){
					args.onError.call(scope, error, args);
				}
			}
			args.abort = function(){
				// abort the request
				if(results.cancel){
					results.cancel();
				}
			};
			if(results.observe){
				if(this.observing){
					// if we were previously observing, cancel the last time to avoid multiple notifications. Just the best we can do for the impedance mismatch between APIs
					this.observing.cancel();
				}
				this.observing = results.observe(function(object, removedFrom, insertedInto){
					if(array.indexOf(self._dirtyObjects, object) == -1){
						if(removedFrom == -1){
							self.onNew(object);
						}
						else if(insertedInto == -1){
							self.onDelete(object);
						}
						else{
							for(var i in object){
								if(i != self.objectStore.idProperty){
									self.onSet(object, i, null, object[i]);
								}
							}
						}
					}
				}, true);
			}
			this.onFetch(results);
			args.store = this;
			return args;
		},
		getFeatures: function(){
			// summary:
			//		return the store feature set

			return {
				"dojo.data.api.Read": !!this.objectStore.get,
				"dojo.data.api.Identity": true,
				"dojo.data.api.Write": !!this.objectStore.put,
				"dojo.data.api.Notification": true
			};
		},

		getLabel: function(/* dojo/data/api/Item */ item){
			// summary:
			//		See dojo/data/api/Read.getLabel()
			if(this.isItem(item)){
				return this.getValue(item,this.labelProperty); //String
			}
			return undefined; //undefined
		},

		getLabelAttributes: function(/* dojo/data/api/Item */ item){
			// summary:
			//		See dojo/data/api/Read.getLabelAttributes()
			return [this.labelProperty]; //array
		},

		//Identity API Support


		getIdentity: function(item){
			// summary:
			//		returns the identity of the given item
			//		See dojo/data/api/Read.getIdentity()
			return this.objectStore.getIdentity ? this.objectStore.getIdentity(item) : item[this.objectStore.idProperty || "id"];
		},

		getIdentityAttributes: function(item){
			// summary:
			//		returns the attributes which are used to make up the
			//		identity of an item.	Basically returns this.objectStore.idProperty
			//		See dojo/data/api/Read.getIdentityAttributes()

			return [this.objectStore.idProperty];
		},

		fetchItemByIdentity: function(args){
			// summary:
			//		fetch an item by its identity, by looking in our index of what we have loaded
			var item;
			Deferred.when(this.objectStore.get(args.identity),
				function(result){
					item = result;
					args.onItem.call(args.scope, result);
				},
				function(error){
					args.onError.call(args.scope, error);
				}
			);
			return item;
		},

		newItem: function(data, parentInfo){
			// summary:
			//		adds a new item to the store at the specified point.
			//		Takes two parameters, data, and options.
			// data: Object
			//		The data to be added in as an item.
			// data: Object
			//		See dojo/data/api/Write.newItem()
					
			if(parentInfo){
				// get the previous value or any empty array
				var values = this.getValue(parentInfo.parent,parentInfo.attribute,[]);
				// set the new value
				values = values.concat([data]);
				data.__parent = values;
				this.setValue(parentInfo.parent, parentInfo.attribute, values);
			}
			this._dirtyObjects.push({object:data, save: true});
			this.onNew(data);
			return data;
		},
		deleteItem: function(item){
			// summary:
			//		deletes item and any references to that item from the store.
			// item:
			//		item to delete

			// If the desire is to delete only one reference, unsetAttribute or
			// setValue is the way to go.
			this.changing(item, true);

			this.onDelete(item);
		},
		setValue: function(item, attribute, value){
			// summary:
			//		sets 'attribute' on 'item' to 'value'
			//		See dojo/data/api/Write.setValue()
			
			var old = item[attribute];
			this.changing(item);
			item[attribute]=value;
			this.onSet(item,attribute,old,value);
		},
		setValues: function(item, attribute, values){
			// summary:
			//		sets 'attribute' on 'item' to 'value' value
			//		must be an array.
			//		See dojo/data/api/Write.setValues()

			if(!lang.isArray(values)){
				throw new Error("setValues expects to be passed an Array object as its value");
			}
			this.setValue(item,attribute,values);
		},

		unsetAttribute: function(item, attribute){
			// summary:
			//		unsets 'attribute' on 'item'
			//		See dojo/data/api/Write.unsetAttribute()

			this.changing(item);
			var old = item[attribute];
			delete item[attribute];
			this.onSet(item,attribute,old,undefined);
		},

		changing: function(object,_deleting){
			// summary:
			//		adds an object to the list of dirty objects.  This object
			//		contains a reference to the object itself as well as a
			//		cloned and trimmed version of old object for use with
			//		revert.
			// object: Object
			//		Indicates that the given object is changing and should be marked as 
			// 		dirty for the next save
			// _deleting: [private] Boolean
			
			object.__isDirty = true;
			//if an object is already in the list of dirty objects, don't add it again
			//or it will overwrite the premodification data set.
			for(var i=0; i<this._dirtyObjects.length; i++){
				var dirty = this._dirtyObjects[i];
				if(object==dirty.object){
					if(_deleting){
						// we are deleting, no object is an indicator of deletiong
						dirty.object = false;
						if(!this._saveNotNeeded){
							dirty.save = true;
						}
					}
					return;
				}
			}
			var old = object instanceof Array ? [] : {};
			for(i in object){
				if(object.hasOwnProperty(i)){
					old[i] = object[i];
				}
			}
			this._dirtyObjects.push({object: !_deleting && object, old: old, save: !this._saveNotNeeded});
		},

		save: function(kwArgs){
			// summary:
			//		Saves the dirty data using object store provider. See dojo/data/api/Write for API.
			// kwArgs:
			//		- kwArgs.global:
			//		  This will cause the save to commit the dirty data for all
			//		  ObjectStores as a single transaction.
			//
			//		- kwArgs.revertOnError:
			//		  This will cause the changes to be reverted if there is an
			//		  error on the save. By default a revert is executed unless
			//		  a value of false is provide for this parameter.
			//
			//		- kwArgs.onError:
			//		  Called when an error occurs in the commit
			//
			//		- kwArgs.onComplete:
			//		  Called when an the save/commit is completed

			kwArgs = kwArgs || {};
			var result, actions = [];
			var savingObjects = [];
			var self = this;
			var dirtyObjects = this._dirtyObjects;
			var left = dirtyObjects.length;// this is how many changes are remaining to be received from the server
			try{
				connect.connect(kwArgs,"onError",function(){
					if(kwArgs.revertOnError !== false){
						var postCommitDirtyObjects = dirtyObjects;
						dirtyObjects = savingObjects;
						self.revert(); // revert if there was an error
						self._dirtyObjects = postCommitDirtyObjects;
					}
					else{
						self._dirtyObjects = dirtyObjects.concat(savingObjects);
					}
				});
				if(this.objectStore.transaction){
					var transaction = this.objectStore.transaction();
				}
				for(var i = 0; i < dirtyObjects.length; i++){
					var dirty = dirtyObjects[i];
					var object = dirty.object;
					var old = dirty.old;
					delete object.__isDirty;
					if(object){
						result = this.objectStore.put(object, {overwrite: !!old});
					}
					else if(typeof old != "undefined"){
						result = this.objectStore.remove(this.getIdentity(old));
					}
					savingObjects.push(dirty);
					dirtyObjects.splice(i--,1);
					Deferred.when(result, function(value){
						if(!(--left)){
							if(kwArgs.onComplete){
								kwArgs.onComplete.call(kwArgs.scope, actions);
							}
						}
					},function(value){

						// on an error we want to revert, first we want to separate any changes that were made since the commit
						left = -1; // first make sure that success isn't called
						kwArgs.onError.call(kwArgs.scope, value);
					});

				}
				if(transaction){
					transaction.commit();
				}
			}catch(e){
				kwArgs.onError.call(kwArgs.scope, value);
			}
		},

		revert: function(){
			// summary:
			//		returns any modified data to its original state prior to a save();

			var dirtyObjects = this._dirtyObjects;
			for(var i = dirtyObjects.length; i > 0;){
				i--;
				var dirty = dirtyObjects[i];
				var object = dirty.object;
				var old = dirty.old;
				if(object && old){
					// changed
					for(var j in old){
						if(old.hasOwnProperty(j) && object[j] !== old[j]){
							this.onSet(object, j, object[j], old[j]);
							object[j] = old[j];
						}
					}
					for(j in object){
						if(!old.hasOwnProperty(j)){
							this.onSet(object, j, object[j]);
							delete object[j];
						}
					}
				}else if(!old){
					// was an addition, remove it
					this.onDelete(object);
				}else{
					// was a deletion, we will add it back
					this.onNew(old);
				}
				delete (object || old).__isDirty;
				dirtyObjects.splice(i, 1);
			}

		},
		isDirty: function(item){
			// summary:
			//		returns true if the item is marked as dirty or true if there are any dirty items
			// item: Object
			//		The item to check
			if(!item){
				return !!this._dirtyObjects.length;
			}
			return item.__isDirty;
		},

		// Notification Support

		onSet: function(){
			// summary:
			// 		See dojo/data/api/Notification.onSet()
		},
		onNew: function(){
			// summary:
			// 		See dojo/data/api/Notification.onNew()
		},
		onDelete:	function(){
			// summary:
			// 		See dojo/data/api/Notification.onDelete()
		},
		// an extra to get result sets
		onFetch: function(results){
			// summary:
			// 		Called when a fetch occurs			
		}

	}
);
});

},
'dijit/Tree':function(){
define([
	"dojo/_base/array", // array.filter array.forEach array.map
	"dojo/aspect",
	"dojo/cookie", // cookie
	"dojo/_base/declare", // declare
	"dojo/Deferred", // Deferred
	"dojo/promise/all",
	"dojo/dom", // dom.isDescendant
	"dojo/dom-class", // domClass.add domClass.remove domClass.replace domClass.toggle
	"dojo/dom-geometry", // domGeometry.setMarginBox domGeometry.position
	"dojo/dom-style", // domStyle.set
	"dojo/errors/create", // createError
	"dojo/fx", // fxUtils.wipeIn fxUtils.wipeOut
	"dojo/has",
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/keys", // arrows etc.
	"dojo/_base/lang", // lang.getObject lang.mixin lang.hitch
	"dojo/on", // on(), on.selector()
	"dojo/topic",
	"dojo/touch",
	"dojo/when",
	"./a11yclick",
	"./focus",
	"./registry", // registry.byNode(), registry.getEnclosingWidget()
	"./_base/manager", // manager.defaultDuration
	"./_Widget",
	"./_TemplatedMixin",
	"./_Container",
	"./_Contained",
	"./_CssStateMixin",
	"./_KeyNavMixin",
	"dojo/text!./templates/TreeNode.html",
	"dojo/text!./templates/Tree.html",
	"./tree/TreeStoreModel",
	"./tree/ForestStoreModel",
	"./tree/_dndSelector",
	"dojo/query!css2"	// needed when on.selector() used with a string for the selector
], function(array, aspect, cookie, declare, Deferred, all,
			dom, domClass, domGeometry, domStyle, createError, fxUtils, has, kernel, keys, lang, on, topic, touch, when,
			a11yclick, focus, registry, manager, _Widget, _TemplatedMixin, _Container, _Contained, _CssStateMixin, _KeyNavMixin,
			treeNodeTemplate, treeTemplate, TreeStoreModel, ForestStoreModel, _dndSelector){

	// module:
	//		dijit/Tree

	function shimmedPromise(/*Deferred|Promise*/ d){
		// summary:
		//		Return a Promise based on given Deferred or Promise, with back-compat addCallback() and addErrback() shims
		//		added (TODO: remove those back-compat shims, and this method, for 2.0)

		return lang.delegate(d.promise || d, {
			addCallback: function(callback){
				this.then(callback);
			},
			addErrback: function(errback){
				this.otherwise(errback);
			}
		});
	}

	var TreeNode = declare("dijit._TreeNode", [_Widget, _TemplatedMixin, _Container, _Contained, _CssStateMixin], {
		// summary:
		//		Single node within a tree.   This class is used internally
		//		by Tree and should not be accessed directly.
		// tags:
		//		private

		// item: [const] Item
		//		the dojo.data entry this tree represents
		item: null,

		// isTreeNode: [protected] Boolean
		//		Indicates that this is a TreeNode.   Used by `dijit.Tree` only,
		//		should not be accessed directly.
		isTreeNode: true,

		// label: String
		//		Text of this tree node
		label: "",
		_setLabelAttr: function(val){
			this.labelNode[this.labelType == "html" ? "innerHTML" : "innerText" in this.labelNode ?
				"innerText" : "textContent"] = val;
			this._set("label", val);
		},

		// labelType: [const] String
		//		Specifies how to interpret the label.  Can be "html" or "text".
		labelType: "text",

		// isExpandable: [private] Boolean
		//		This node has children, so show the expando node (+ sign)
		isExpandable: null,

		// isExpanded: [readonly] Boolean
		//		This node is currently expanded (ie, opened)
		isExpanded: false,

		// state: [private] String
		//		Dynamic loading-related stuff.
		//		When an empty folder node appears, it is "NotLoaded" first,
		//		then after dojo.data query it becomes "Loading" and, finally "Loaded"
		state: "NotLoaded",

		templateString: treeNodeTemplate,

		baseClass: "dijitTreeNode",

		// For hover effect for tree node, and focus effect for label
		cssStateNodes: {
			rowNode: "dijitTreeRow"
		},

		// Tooltip is defined in _WidgetBase but we need to handle the mapping to DOM here
		_setTooltipAttr: {node: "rowNode", type: "attribute", attribute: "title"},

		buildRendering: function(){
			this.inherited(arguments);

			// set expand icon for leaf
			this._setExpando();

			// set icon and label class based on item
			this._updateItemClasses(this.item);

			if(this.isExpandable){
				this.labelNode.setAttribute("aria-expanded", this.isExpanded);
			}

			//aria-selected should be false on all selectable elements.
			this.setSelected(false);
		},

		_setIndentAttr: function(indent){
			// summary:
			//		Tell this node how many levels it should be indented
			// description:
			//		0 for top level nodes, 1 for their children, 2 for their
			//		grandchildren, etc.

			// Math.max() is to prevent negative padding on hidden root node (when indent == -1)
			var pixels = (Math.max(indent, 0) * this.tree._nodePixelIndent) + "px";

			domStyle.set(this.domNode, "backgroundPosition", pixels + " 0px");	// TODOC: what is this for???
			domStyle.set(this.rowNode, this.isLeftToRight() ? "paddingLeft" : "paddingRight", pixels);

			array.forEach(this.getChildren(), function(child){
				child.set("indent", indent + 1);
			});

			this._set("indent", indent);
		},

		markProcessing: function(){
			// summary:
			//		Visually denote that tree is loading data, etc.
			// tags:
			//		private
			this.state = "Loading";
			this._setExpando(true);
		},

		unmarkProcessing: function(){
			// summary:
			//		Clear markup from markProcessing() call
			// tags:
			//		private
			this._setExpando(false);
		},

		_updateItemClasses: function(item){
			// summary:
			//		Set appropriate CSS classes for icon and label dom node
			//		(used to allow for item updates to change respective CSS)
			// tags:
			//		private
			var tree = this.tree, model = tree.model;
			if(tree._v10Compat && item === model.root){
				// For back-compat with 1.0, need to use null to specify root item (TODO: remove in 2.0)
				item = null;
			}
			this._applyClassAndStyle(item, "icon", "Icon");
			this._applyClassAndStyle(item, "label", "Label");
			this._applyClassAndStyle(item, "row", "Row");

			this.tree._startPaint(true);		// signifies paint started and finished (synchronously)
		},

		_applyClassAndStyle: function(item, lower, upper){
			// summary:
			//		Set the appropriate CSS classes and styles for labels, icons and rows.
			//
			// item:
			//		The data item.
			//
			// lower:
			//		The lower case attribute to use, e.g. 'icon', 'label' or 'row'.
			//
			// upper:
			//		The upper case attribute to use, e.g. 'Icon', 'Label' or 'Row'.
			//
			// tags:
			//		private

			var clsName = "_" + lower + "Class";
			var nodeName = lower + "Node";
			var oldCls = this[clsName];

			this[clsName] = this.tree["get" + upper + "Class"](item, this.isExpanded);
			domClass.replace(this[nodeName], this[clsName] || "", oldCls || "");

			domStyle.set(this[nodeName], this.tree["get" + upper + "Style"](item, this.isExpanded) || {});
		},

		_updateLayout: function(){
			// summary:
			//		Set appropriate CSS classes for this.domNode
			// tags:
			//		private

			// if we are hiding the root node then make every first level child look like a root node
			var parent = this.getParent(),
				markAsRoot = !parent || !parent.rowNode || parent.rowNode.style.display == "none";
			domClass.toggle(this.domNode, "dijitTreeIsRoot", markAsRoot);

			domClass.toggle(this.domNode, "dijitTreeIsLast", !markAsRoot && !this.getNextSibling());
		},

		_setExpando: function(/*Boolean*/ processing){
			// summary:
			//		Set the right image for the expando node
			// tags:
			//		private

			var styles = ["dijitTreeExpandoLoading", "dijitTreeExpandoOpened",
					"dijitTreeExpandoClosed", "dijitTreeExpandoLeaf"],
				_a11yStates = ["*", "-", "+", "*"],
				idx = processing ? 0 : (this.isExpandable ? (this.isExpanded ? 1 : 2) : 3);

			// apply the appropriate class to the expando node
			domClass.replace(this.expandoNode, styles[idx], styles);

			// provide a non-image based indicator for images-off mode
			this.expandoNodeText.innerHTML = _a11yStates[idx];

		},

		expand: function(){
			// summary:
			//		Show my children
			// returns:
			//		Promise that resolves when expansion is complete

			// If there's already an expand in progress or we are already expanded, just return
			if(this._expandDeferred){
				return shimmedPromise(this._expandDeferred);		// dojo/promise/Promise
			}

			// cancel in progress collapse operation
			if(this._collapseDeferred){
				this._collapseDeferred.cancel();
				delete this._collapseDeferred;
			}

			// All the state information for when a node is expanded, maybe this should be
			// set when the animation completes instead
			this.isExpanded = true;
			this.labelNode.setAttribute("aria-expanded", "true");
			if(this.tree.showRoot || this !== this.tree.rootNode){
				this.containerNode.setAttribute("role", "group");
			}
			domClass.add(this.contentNode, 'dijitTreeContentExpanded');
			this._setExpando();
			this._updateItemClasses(this.item);

			if(this == this.tree.rootNode && this.tree.showRoot){
				this.tree.domNode.setAttribute("aria-expanded", "true");
			}

			var wipeIn = fxUtils.wipeIn({
				node: this.containerNode,
				duration: manager.defaultDuration
			});

			// Deferred that fires when expand is complete
			var def = (this._expandDeferred = new Deferred(function(){
				// Canceller
				wipeIn.stop();
			}));

			aspect.after(wipeIn, "onEnd", function(){
				def.resolve(true);
			}, true);

			wipeIn.play();

			return shimmedPromise(def);		// dojo/promise/Promise
		},

		collapse: function(){
			// summary:
			//		Collapse this node (if it's expanded)
			// returns:
			//		Promise that resolves when collapse is complete

			if(this._collapseDeferred){
				// Node is already collapsed, or there's a collapse in progress, just return that Deferred
				return shimmedPromise(this._collapseDeferred);
			}

			// cancel in progress expand operation
			if(this._expandDeferred){
				this._expandDeferred.cancel();
				delete this._expandDeferred;
			}

			this.isExpanded = false;
			this.labelNode.setAttribute("aria-expanded", "false");
			if(this == this.tree.rootNode && this.tree.showRoot){
				this.tree.domNode.setAttribute("aria-expanded", "false");
			}
			domClass.remove(this.contentNode, 'dijitTreeContentExpanded');
			this._setExpando();
			this._updateItemClasses(this.item);

			var wipeOut = fxUtils.wipeOut({
				node: this.containerNode,
				duration: manager.defaultDuration
			});

			// Deferred that fires when expand is complete
			var def = (this._collapseDeferred = new Deferred(function(){
				// Canceller
				wipeOut.stop();
			}));

			aspect.after(wipeOut, "onEnd", function(){
				def.resolve(true);
			}, true);

			wipeOut.play();

			return shimmedPromise(def);		// dojo/promise/Promise
		},

		// indent: Integer
		//		Levels from this node to the root node
		indent: 0,

		setChildItems: function(/* Object[] */ items){
			// summary:
			//		Sets the child items of this node, removing/adding nodes
			//		from current children to match specified items[] array.
			//		Also, if this.persist == true, expands any children that were previously
			//		opened.
			// returns:
			//		Promise that resolves after all previously opened children
			//		have been expanded again (or fires instantly if there are no such children).

			var tree = this.tree,
				model = tree.model,
				defs = [];	// list of deferreds that need to fire before I am complete


			var focusedChild = tree.focusedChild;

			// Orphan all my existing children.
			// If items contains some of the same items as before then we will reattach them.
			// Don't call this.removeChild() because that will collapse the tree etc.
			var oldChildren = this.getChildren();
			array.forEach(oldChildren, function(child){
				_Container.prototype.removeChild.call(this, child);
			}, this);

			// All the old children of this TreeNode are subject for destruction if
			//		1) they aren't listed in the new children array (items)
			//		2) they aren't immediately adopted by another node (DnD)
			this.defer(function(){
				array.forEach(oldChildren, function(node){
					if(!node._destroyed && !node.getParent()){
						// If node is in selection then remove it.
						tree.dndController.removeTreeNode(node);

						// Deregister mapping from item id --> this node and its descendants
						function remove(node){
							var id = model.getIdentity(node.item),
								ary = tree._itemNodesMap[id];
							if(ary.length == 1){
								delete tree._itemNodesMap[id];
							}else{
								var index = array.indexOf(ary, node);
								if(index != -1){
									ary.splice(index, 1);
								}
							}
							array.forEach(node.getChildren(), remove);
						}

						remove(node);

						// Remove any entries involving this node from cookie tracking expanded nodes
						if(tree.persist){
							var destroyedPath = array.map(node.getTreePath(),function(item){
								return tree.model.getIdentity(item);
							}).join("/");
							for(var path in tree._openedNodes){
								if(path.substr(0, destroyedPath.length) == destroyedPath){
									delete tree._openedNodes[path];
								}
							}
							tree._saveExpandedNodes();
						}

						// If we've orphaned the focused node then move focus to the root node
						if(tree.lastFocusedChild && !dom.isDescendant(tree.lastFocusedChild, tree.domNode)){
							delete tree.lastFocusedChild;
						}
						if(focusedChild && !dom.isDescendant(focusedChild, tree.domNode)){
							tree.focus();	// could alternately focus this node (parent of the deleted node)
						}

						// And finally we can destroy the node
						node.destroyRecursive();
					}
				});

			});

			this.state = "Loaded";

			if(items && items.length > 0){
				this.isExpandable = true;

				// Create _TreeNode widget for each specified tree node, unless one already
				// exists and isn't being used (presumably it's from a DnD move and was recently
				// released
				array.forEach(items, function(item){    // MARKER: REUSE NODE
					var id = model.getIdentity(item),
						existingNodes = tree._itemNodesMap[id],
						node;
					if(existingNodes){
						for(var i = 0; i < existingNodes.length; i++){
							if(existingNodes[i] && !existingNodes[i].getParent()){
								node = existingNodes[i];
								node.set('indent', this.indent + 1);
								break;
							}
						}
					}
					if(!node){
						node = this.tree._createTreeNode({
							item: item,
							tree: tree,
							isExpandable: model.mayHaveChildren(item),
							label: tree.getLabel(item),
							labelType: (tree.model && tree.model.labelType) || "text",
							tooltip: tree.getTooltip(item),
							ownerDocument: tree.ownerDocument,
							dir: tree.dir,
							lang: tree.lang,
							textDir: tree.textDir,
							indent: this.indent + 1
						});
						if(existingNodes){
							existingNodes.push(node);
						}else{
							tree._itemNodesMap[id] = [node];
						}
					}
					this.addChild(node);

					// If node was previously opened then open it again now (this may trigger
					// more data store accesses, recursively)
					if(this.tree.autoExpand || this.tree._state(node)){
						defs.push(tree._expandNode(node));
					}
				}, this);

				// note that updateLayout() needs to be called on each child after
				// _all_ the children exist
				array.forEach(this.getChildren(), function(child){
					child._updateLayout();
				});
			}else{
				this.isExpandable = false;
			}

			if(this._setExpando){
				// change expando to/from dot or + icon, as appropriate
				this._setExpando(false);
			}

			// Set leaf icon or folder icon, as appropriate
			this._updateItemClasses(this.item);

			var def = all(defs);
			this.tree._startPaint(def);		// to reset TreeNode widths after an item is added/removed from the Tree
			return shimmedPromise(def);		// dojo/promise/Promise
		},

		getTreePath: function(){
			var node = this;
			var path = [];
			while(node && node !== this.tree.rootNode){
				path.unshift(node.item);
				node = node.getParent();
			}
			path.unshift(this.tree.rootNode.item);

			return path;
		},

		getIdentity: function(){
			return this.tree.model.getIdentity(this.item);
		},

		removeChild: function(/* treeNode */ node){
			this.inherited(arguments);

			var children = this.getChildren();
			if(children.length == 0){
				this.isExpandable = false;
				this.collapse();
			}

			array.forEach(children, function(child){
				child._updateLayout();
			});
		},

		makeExpandable: function(){
			// summary:
			//		if this node wasn't already showing the expando node,
			//		turn it into one and call _setExpando()

			// TODO: hmm this isn't called from anywhere, maybe should remove it for 2.0

			this.isExpandable = true;
			this._setExpando(false);
		},

		setSelected: function(/*Boolean*/ selected){
			// summary:
			//		A Tree has a (single) currently selected node.
			//		Mark that this node is/isn't that currently selected node.
			// description:
			//		In particular, setting a node as selected involves setting tabIndex
			//		so that when user tabs to the tree, focus will go to that node (only).
			this.labelNode.setAttribute("aria-selected", selected ? "true" : "false");
			domClass.toggle(this.rowNode, "dijitTreeRowSelected", selected);
		},

		focus: function(){
			focus.focus(this.focusNode);
		}
	});

	if(has("dojo-bidi")){
		TreeNode.extend({
			_setTextDirAttr: function(textDir){
				if(textDir && ((this.textDir != textDir) || !this._created)){
					this._set("textDir", textDir);
					this.applyTextDir(this.labelNode);
					array.forEach(this.getChildren(), function(childNode){
						childNode.set("textDir", textDir);
					}, this);
				}
			}
		});
	}

	var Tree = declare("dijit.Tree", [_Widget, _KeyNavMixin, _TemplatedMixin, _CssStateMixin], {
		// summary:
		//		This widget displays hierarchical data from a store.

		baseClass: "dijitTree",

		// store: [deprecated] String|dojo/data/Store
		//		Deprecated.  Use "model" parameter instead.
		//		The store to get data to display in the tree.
		store: null,

		// model: [const] dijit/tree/model
		//		Interface to read tree data, get notifications of changes to tree data,
		//		and for handling drop operations (i.e drag and drop onto the tree)
		model: null,

		// query: [deprecated] anything
		//		Deprecated.  User should specify query to the model directly instead.
		//		Specifies datastore query to return the root item or top items for the tree.
		query: null,

		// label: [deprecated] String
		//		Deprecated.  Use dijit/tree/ForestStoreModel directly instead.
		//		Used in conjunction with query parameter.
		//		If a query is specified (rather than a root node id), and a label is also specified,
		//		then a fake root node is created and displayed, with this label.
		label: "",

		// showRoot: [const] Boolean
		//		Should the root node be displayed, or hidden?
		showRoot: true,

		// childrenAttr: [deprecated] String[]
		//		Deprecated.   This information should be specified in the model.
		//		One ore more attributes that holds children of a tree node
		childrenAttr: ["children"],

		// paths: String[][] or Item[][]
		//		Full paths from rootNode to selected nodes expressed as array of items or array of ids.
		//		Since setting the paths may be asynchronous (because of waiting on dojo.data), set("paths", ...)
		//		returns a Promise to indicate when the set is complete.
		paths: [],

		// path: String[] or Item[]
		//		Backward compatible singular variant of paths.
		path: [],

		// selectedItems: [readonly] Item[]
		//		The currently selected items in this tree.
		//		This property can only be set (via set('selectedItems', ...)) when that item is already
		//		visible in the tree.   (I.e. the tree has already been expanded to show that node.)
		//		Should generally use `paths` attribute to set the selected items instead.
		selectedItems: null,

		// selectedItem: [readonly] Item
		//		Backward compatible singular variant of selectedItems.
		selectedItem: null,

		// openOnClick: Boolean
		//		If true, clicking a folder node's label will open it, rather than calling onClick()
		openOnClick: false,

		// openOnDblClick: Boolean
		//		If true, double-clicking a folder node's label will open it, rather than calling onDblClick()
		openOnDblClick: false,

		templateString: treeTemplate,

		// persist: Boolean
		//		Enables/disables use of cookies for state saving.
		persist: false,

		// autoExpand: Boolean
		//		Fully expand the tree on load.   Overrides `persist`.
		autoExpand: false,

		// dndController: [protected] Function|String
		//		Class to use as as the dnd controller.  Specifying this class enables DnD.
		//		Generally you should specify this as dijit/tree/dndSource.
		//		Setting of dijit/tree/_dndSelector handles selection only (no actual DnD).
		dndController: _dndSelector,

		// parameters to pull off of the tree and pass on to the dndController as its params
		dndParams: ["onDndDrop", "itemCreator", "onDndCancel", "checkAcceptance", "checkItemAcceptance", "dragThreshold", "betweenThreshold"],

		//declare the above items so they can be pulled from the tree's markup

		// onDndDrop: [protected] Function
		//		Parameter to dndController, see `dijit/tree/dndSource.onDndDrop()`.
		//		Generally this doesn't need to be set.
		onDndDrop: null,

		itemCreator: null,
		/*=====
		itemCreator: function(nodes, target, source){
			// summary:
			//		Returns objects passed to `Tree.model.newItem()` based on DnD nodes
			//		dropped onto the tree.   Developer must override this method to enable
			//		dropping from external sources onto this Tree, unless the Tree.model's items
			//		happen to look like {id: 123, name: "Apple" } with no other attributes.
			//
			//		For each node in nodes[], which came from source, create a hash of name/value
			//		pairs to be passed to Tree.model.newItem().  Returns array of those hashes.
			// nodes: DomNode[]
			//		The DOMNodes dragged from the source container
			// target: DomNode
			//		The target TreeNode.rowNode
			// source: dojo/dnd/Source
			//		The source container the nodes were dragged from, perhaps another Tree or a plain dojo/dnd/Source
			// returns: Object[]
			//		Array of name/value hashes for each new item to be added to the Tree, like:
			// |	[
			// |		{ id: 123, label: "apple", foo: "bar" },
			// |		{ id: 456, label: "pear", zaz: "bam" }
			// |	]
			// tags:
			//		extension
			return [{}];
		},
		=====*/

		// onDndCancel: [protected] Function
		//		Parameter to dndController, see `dijit/tree/dndSource.onDndCancel()`.
		//		Generally this doesn't need to be set.
		onDndCancel: null,

		/*=====
		checkAcceptance: function(source, nodes){
			// summary:
			//		Checks if the Tree itself can accept nodes from this source
			// source: dijit/tree/dndSource
			//		The source which provides items
			// nodes: DOMNode[]
			//		Array of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if
			//		source is a dijit/Tree.
			// tags:
			//		extension
			return true;	// Boolean
		},
		=====*/
		checkAcceptance: null,

		/*=====
		checkItemAcceptance: function(target, source, position){
			// summary:
			//		Stub function to be overridden if one wants to check for the ability to drop at the node/item level
			// description:
			//		In the base case, this is called to check if target can become a child of source.
			//		When betweenThreshold is set, position="before" or "after" means that we
			//		are asking if the source node can be dropped before/after the target node.
			// target: DOMNode
			//		The dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to
			//		Use registry.getEnclosingWidget(target) to get the TreeNode.
			// source: dijit/tree/dndSource
			//		The (set of) nodes we are dropping
			// position: String
			//		"over", "before", or "after"
			// tags:
			//		extension
			return true;	// Boolean
		},
		=====*/
		checkItemAcceptance: null,

		// dragThreshold: Integer
		//		Number of pixels mouse moves before it's considered the start of a drag operation
		dragThreshold: 5,

		// betweenThreshold: Integer
		//		Set to a positive value to allow drag and drop "between" nodes.
		//
		//		If during DnD mouse is over a (target) node but less than betweenThreshold
		//		pixels from the bottom edge, dropping the the dragged node will make it
		//		the next sibling of the target node, rather than the child.
		//
		//		Similarly, if mouse is over a target node but less that betweenThreshold
		//		pixels from the top edge, dropping the dragged node will make it
		//		the target node's previous sibling rather than the target node's child.
		betweenThreshold: 0,

		// _nodePixelIndent: Integer
		//		Number of pixels to indent tree nodes (relative to parent node).
		//		Default is 19 but can be overridden by setting CSS class dijitTreeIndent
		//		and calling resize() or startup() on tree after it's in the DOM.
		_nodePixelIndent: 19,

		_publish: function(/*String*/ topicName, /*Object*/ message){
			// summary:
			//		Publish a message for this widget/topic
			topic.publish(this.id, lang.mixin({tree: this, event: topicName}, message || {}));	// publish
		},

		postMixInProperties: function(){
			this.tree = this;

			if(this.autoExpand){
				// There's little point in saving opened/closed state of nodes for a Tree
				// that initially opens all it's nodes.
				this.persist = false;
			}

			this._itemNodesMap = {};

			if(!this.cookieName && this.id){
				this.cookieName = this.id + "SaveStateCookie";
			}

			// Deferred that resolves when all the children have loaded.
			this.expandChildrenDeferred = new Deferred();

			// Promise that resolves when all pending operations complete.
			this.pendingCommandsPromise = this.expandChildrenDeferred.promise;

			this.inherited(arguments);
		},

		postCreate: function(){
			this._initState();

			// Catch events on TreeNodes
			var self = this;
			this.own(
				on(this.containerNode, on.selector(".dijitTreeNode", touch.enter), function(evt){
					self._onNodeMouseEnter(registry.byNode(this), evt);
				}),
				on(this.containerNode, on.selector(".dijitTreeNode", touch.leave), function(evt){
					self._onNodeMouseLeave(registry.byNode(this), evt);
				}),
				on(this.containerNode, on.selector(".dijitTreeRow", a11yclick.press), function(evt){
					self._onNodePress(registry.getEnclosingWidget(this), evt);
				}),
				on(this.containerNode, on.selector(".dijitTreeRow", a11yclick), function(evt){
					self._onClick(registry.getEnclosingWidget(this), evt);
				}),
				on(this.containerNode, on.selector(".dijitTreeRow", "dblclick"), function(evt){
					self._onDblClick(registry.getEnclosingWidget(this), evt);
				})
			);

			// Create glue between store and Tree, if not specified directly by user
			if(!this.model){
				this._store2model();
			}

			// monitor changes to items
			this.own(
				aspect.after(this.model, "onChange", lang.hitch(this, "_onItemChange"), true),
				aspect.after(this.model, "onChildrenChange", lang.hitch(this, "_onItemChildrenChange"), true),
				aspect.after(this.model, "onDelete", lang.hitch(this, "_onItemDelete"), true)
			);

			this.inherited(arguments);

			if(this.dndController){
				// TODO: remove string support in 2.0.
				if(lang.isString(this.dndController)){
					this.dndController = lang.getObject(this.dndController);
				}
				var params = {};
				for(var i = 0; i < this.dndParams.length; i++){
					if(this[this.dndParams[i]]){
						params[this.dndParams[i]] = this[this.dndParams[i]];
					}
				}
				this.dndController = new this.dndController(this, params);
			}

			this._load();

			// onLoadDeferred should fire when all commands that are part of initialization have completed.
			// It will include all the set("paths", ...) commands that happen during initialization.
			this.onLoadDeferred = shimmedPromise(this.pendingCommandsPromise);

			this.onLoadDeferred.then(lang.hitch(this, "onLoad"));
		},

		_store2model: function(){
			// summary:
			//		User specified a store&query rather than model, so create model from store/query
			this._v10Compat = true;
			kernel.deprecated("Tree: from version 2.0, should specify a model object rather than a store/query");

			var modelParams = {
				id: this.id + "_ForestStoreModel",
				store: this.store,
				query: this.query,
				childrenAttrs: this.childrenAttr
			};

			// Only override the model's mayHaveChildren() method if the user has specified an override
			if(this.params.mayHaveChildren){
				modelParams.mayHaveChildren = lang.hitch(this, "mayHaveChildren");
			}

			if(this.params.getItemChildren){
				modelParams.getChildren = lang.hitch(this, function(item, onComplete, onError){
					this.getItemChildren((this._v10Compat && item === this.model.root) ? null : item, onComplete, onError);
				});
			}
			this.model = new ForestStoreModel(modelParams);

			// For backwards compatibility, the visibility of the root node is controlled by
			// whether or not the user has specified a label
			this.showRoot = Boolean(this.label);
		},

		onLoad: function(){
			// summary:
			//		Called when tree finishes loading and expanding.
			// description:
			//		If persist == true the loading may encompass many levels of fetches
			//		from the data store, each asynchronous.   Waits for all to finish.
			// tags:
			//		callback
		},

		_load: function(){
			// summary:
			//		Initial load of the tree.
			//		Load root node (possibly hidden) and it's children.
			this.model.getRoot(
				lang.hitch(this, function(item){
					var rn = (this.rootNode = this.tree._createTreeNode({
						item: item,
						tree: this,
						isExpandable: true,
						label: this.label || this.getLabel(item),
						labelType: this.model.labelType || "text",
						textDir: this.textDir,
						indent: this.showRoot ? 0 : -1
					}));

					if(!this.showRoot){
						rn.rowNode.style.display = "none";
						// if root is not visible, move tree role to the invisible
						// root node's containerNode, see #12135
						this.domNode.setAttribute("role", "presentation");
						this.domNode.removeAttribute("aria-expanded");
						this.domNode.removeAttribute("aria-multiselectable");

						// move the aria-label or aria-labelledby to the element with the role
						if(this["aria-label"]){
							rn.containerNode.setAttribute("aria-label", this["aria-label"]);
							this.domNode.removeAttribute("aria-label");
						}else if(this["aria-labelledby"]){
							rn.containerNode.setAttribute("aria-labelledby", this["aria-labelledby"]);
							this.domNode.removeAttribute("aria-labelledby");
						}
						rn.labelNode.setAttribute("role", "presentation");
						rn.containerNode.setAttribute("role", "tree");
						rn.containerNode.setAttribute("aria-expanded", "true");
						rn.containerNode.setAttribute("aria-multiselectable", !this.dndController.singular);
					}else{
						this.domNode.setAttribute("aria-multiselectable", !this.dndController.singular);
						this.rootLoadingIndicator.style.display = "none";
					}

					this.containerNode.appendChild(rn.domNode);
					var identity = this.model.getIdentity(item);
					if(this._itemNodesMap[identity]){
						this._itemNodesMap[identity].push(rn);
					}else{
						this._itemNodesMap[identity] = [rn];
					}

					rn._updateLayout();		// sets "dijitTreeIsRoot" CSS classname

					// Load top level children, and if persist==true, all nodes that were previously opened
					this._expandNode(rn).then(lang.hitch(this, function(){
						// Then, select the nodes specified by params.paths[], assuming Tree hasn't been deleted.
						if(!this._destroyed){
							this.rootLoadingIndicator.style.display = "none";
							this.expandChildrenDeferred.resolve(true);
						}
					}));
				}),
				lang.hitch(this, function(err){
					console.error(this, ": error loading root: ", err);
				})
			);
		},

		getNodesByItem: function(/*Item or id*/ item){
			// summary:
			//		Returns all tree nodes that refer to an item
			// returns:
			//		Array of tree nodes that refer to passed item

			if(!item){
				return [];
			}
			var identity = lang.isString(item) ? item : this.model.getIdentity(item);
			// return a copy so widget don't get messed up by changes to returned array
			return [].concat(this._itemNodesMap[identity]);
		},

		_setSelectedItemAttr: function(/*Item or id*/ item){
			this.set('selectedItems', [item]);
		},

		_setSelectedItemsAttr: function(/*Items or ids*/ items){
			// summary:
			//		Select tree nodes related to passed items.
			//		WARNING: if model use multi-parented items or desired tree node isn't already loaded
			//		behavior is undefined. Use set('paths', ...) instead.
			var tree = this;
			return this.pendingCommandsPromise = this.pendingCommandsPromise.always(lang.hitch(this, function(){
				var identities = array.map(items, function(item){
					return (!item || lang.isString(item)) ? item : tree.model.getIdentity(item);
				});
				var nodes = [];
				array.forEach(identities, function(id){
					nodes = nodes.concat(tree._itemNodesMap[id] || []);
				});
				this.set('selectedNodes', nodes);
			}));
		},

		_setPathAttr: function(/*Item[]|String[]*/ path){
			// summary:
			//		Singular variant of _setPathsAttr
			if(path.length){
				return shimmedPromise(this.set("paths", [path]).then(function(paths){ return paths[0]; }));
			}else{
				// Empty list is interpreted as "select nothing"
				return shimmedPromise(this.set("paths", []).then(function(paths){ return paths[0]; }));
			}
		},

		_setPathsAttr: function(/*Item[][]|String[][]*/ paths){
			// summary:
			//		Select the tree nodes identified by passed paths.
			// paths:
			//		Array of arrays of items or item id's
			// returns:
			//		Promise to indicate when the set is complete

			var tree = this;

			function selectPath(path, nodes){
				// Traverse path, returning Promise for node at the end of the path.
				// The next path component should be among "nodes".
				var nextPath = path.shift();
				var nextNode = array.filter(nodes, function(node){
					return node.getIdentity() == nextPath;
				})[0];
				if(!!nextNode){
					if(path.length){
						return tree._expandNode(nextNode).then(function(){
							return selectPath(path, nextNode.getChildren());
						});
					}else{
						// Successfully reached the end of this path
						return nextNode;
					}
				}else{
					throw new Tree.PathError("Could not expand path at " + nextPath);
				}
			}

			// Let any previous set("path", ...) commands complete before this one starts.
			// TODO for 2.0: make the user do this wait themselves?
			return shimmedPromise(this.pendingCommandsPromise = this.pendingCommandsPromise.always(function(){
				// We may need to wait for some nodes to expand, so setting
				// each path will involve a Deferred. We bring those deferreds
				// together with a dojo/promise/all.
				return all(array.map(paths, function(path){
					// normalize path to use identity
					path = array.map(path, function(item){
						return lang.isString(item) ? item : tree.model.getIdentity(item);
					});

					if(path.length){
						return selectPath(path, [tree.rootNode]);
					}else{
						throw new Tree.PathError("Empty path");
					}
				}));
			}).then(function setNodes(newNodes){
				// After all expansion is finished, set the selection to last element from each path
				tree.set("selectedNodes", newNodes);
				return tree.paths;
			}));
		},

		_setSelectedNodeAttr: function(node){
			this.set('selectedNodes', [node]);
		},
		_setSelectedNodesAttr: function(nodes){
			// summary:
			//		Marks the specified TreeNodes as selected.
			// nodes: TreeNode[]
			//		TreeNodes to mark.
			this.dndController.setSelection(nodes);
		},


		expandAll: function(){
			// summary:
			//		Expand all nodes in the tree
			// returns:
			//		Promise that resolves when all nodes have expanded

			var _this = this;

			function expand(node){
				// Expand the node
				return _this._expandNode(node).then(function(){
					// When node has expanded, call expand() recursively on each non-leaf child
					var childBranches = array.filter(node.getChildren() || [], function(node){
						return node.isExpandable;
					});

					// And when all those recursive calls finish, signal that I'm finished
					return all(array.map(childBranches, expand));
				});
			}

			return shimmedPromise(expand(this.rootNode));
		},

		collapseAll: function(){
			// summary:
			//		Collapse all nodes in the tree
			// returns:
			//		Promise that resolves when all nodes have collapsed

			var _this = this;

			function collapse(node){
				// Collapse children first
				var childBranches = array.filter(node.getChildren() || [], function(node){
						return node.isExpandable;
					}),
					defs = all(array.map(childBranches, collapse));

				// And when all those recursive calls finish, collapse myself, unless I'm the invisible root node,
				// in which case collapseAll() is finished
				if(!node.isExpanded || (node == _this.rootNode && !_this.showRoot)){
					return defs;
				}else{
					// When node has collapsed, signal that call is finished
					return defs.then(function(){
						return _this._collapseNode(node);
					});
				}
			}

			return shimmedPromise(collapse(this.rootNode));
		},

		////////////// Data store related functions //////////////////////
		// These just get passed to the model; they are here for back-compat

		mayHaveChildren: function(/*dojo/data/Item*/ /*===== item =====*/){
			// summary:
			//		Deprecated.   This should be specified on the model itself.
			//
			//		Overridable function to tell if an item has or may have children.
			//		Controls whether or not +/- expando icon is shown.
			//		(For efficiency reasons we may not want to check if an element actually
			//		has children until user clicks the expando node)
			// tags:
			//		deprecated
		},

		getItemChildren: function(/*===== parentItem, onComplete =====*/){
			// summary:
			//		Deprecated.   This should be specified on the model itself.
			//
			//		Overridable function that return array of child items of given parent item,
			//		or if parentItem==null then return top items in tree
			// tags:
			//		deprecated
		},

		///////////////////////////////////////////////////////
		// Functions for converting an item to a TreeNode
		getLabel: function(/*dojo/data/Item*/ item){
			// summary:
			//		Overridable function to get the label for a tree node (given the item)
			// tags:
			//		extension
			return this.model.getLabel(item);	// String
		},

		getIconClass: function(/*dojo/data/Item*/ item, /*Boolean*/ opened){
			// summary:
			//		Overridable function to return CSS class name to display icon
			// tags:
			//		extension
			return (!item || this.model.mayHaveChildren(item)) ? (opened ? "dijitFolderOpened" : "dijitFolderClosed") : "dijitLeaf"
		},

		getLabelClass: function(/*===== item, opened =====*/){
			// summary:
			//		Overridable function to return CSS class name to display label
			// item: dojo/data/Item
			// opened: Boolean
			// returns: String
			//		CSS class name
			// tags:
			//		extension
		},

		getRowClass: function(/*===== item, opened =====*/){
			// summary:
			//		Overridable function to return CSS class name to display row
			// item: dojo/data/Item
			// opened: Boolean
			// returns: String
			//		CSS class name
			// tags:
			//		extension
		},

		getIconStyle: function(/*===== item, opened =====*/){
			// summary:
			//		Overridable function to return CSS styles to display icon
			// item: dojo/data/Item
			// opened: Boolean
			// returns: Object
			//		Object suitable for input to dojo.style() like {backgroundImage: "url(...)"}
			// tags:
			//		extension
		},

		getLabelStyle: function(/*===== item, opened =====*/){
			// summary:
			//		Overridable function to return CSS styles to display label
			// item: dojo/data/Item
			// opened: Boolean
			// returns:
			//		Object suitable for input to dojo.style() like {color: "red", background: "green"}
			// tags:
			//		extension
		},

		getRowStyle: function(/*===== item, opened =====*/){
			// summary:
			//		Overridable function to return CSS styles to display row
			// item: dojo/data/Item
			// opened: Boolean
			// returns:
			//		Object suitable for input to dojo.style() like {background-color: "#bbb"}
			// tags:
			//		extension
		},

		getTooltip: function(/*dojo/data/Item*/ /*===== item =====*/){
			// summary:
			//		Overridable function to get the tooltip for a tree node (given the item)
			// tags:
			//		extension
			return "";	// String
		},

		/////////// Keyboard and Mouse handlers ////////////////////


		_onDownArrow: function(/*Event*/ evt, /*TreeNode*/ node){
			// summary:
			//		down arrow pressed; get next visible node, set focus there

			var nextNode = this._getNext(node);
			if(nextNode && nextNode.isTreeNode){
				this.focusNode(nextNode);
			}
		},

		_onUpArrow: function(/*Event*/ evt, /*TreeNode*/ node){
			// summary:
			//		Up arrow pressed; move to previous visible node

			// if younger siblings
			var previousSibling = node.getPreviousSibling();
			if(previousSibling){
				node = previousSibling;
				// if the previous node is expanded, dive in deep
				while(node.isExpandable && node.isExpanded && node.hasChildren()){
					// move to the last child
					var children = node.getChildren();
					node = children[children.length - 1];
				}
			}else{
				// if this is the first child, return the parent
				// unless the parent is the root of a tree with a hidden root
				var parent = node.getParent();
				if(!(!this.showRoot && parent === this.rootNode)){
					node = parent;
				}
			}

			if(node && node.isTreeNode){
				this.focusNode(node);
			}
		},

		_onRightArrow: function(/*Event*/ evt, /*TreeNode*/ node){
			// summary:
			//		Right arrow pressed; go to child node

			// if not expanded, expand, else move to 1st child
			if(node.isExpandable && !node.isExpanded){
				this._expandNode(node);
			}else if(node.hasChildren()){
				node = node.getChildren()[0];
				if(node && node.isTreeNode){
					this.focusNode(node);
				}
			}
		},

		_onLeftArrow: function(/*Event*/ evt, /*TreeNode*/ node){
			// summary:
			//		Left arrow pressed.
			//		If not collapsed, collapse, else move to parent.

			if(node.isExpandable && node.isExpanded){
				this._collapseNode(node);
			}else{
				var parent = node.getParent();
				if(parent && parent.isTreeNode && !(!this.showRoot && parent === this.rootNode)){
					this.focusNode(parent);
				}
			}
		},

		focusLastChild: function(){
			// summary:
			//		End key pressed; go to last visible node.

			var node = this._getLast();
			if(node && node.isTreeNode){
				this.focusNode(node);
			}
		},

		_getFirst: function(){
			// summary:
			//		Returns the first child.
			// tags:
			//		abstract extension
			return this.showRoot ? this.rootNode : this.rootNode.getChildren()[0];
		},

		_getLast: function(){
			// summary:
			//		Returns the last descendant.
			// tags:
			//		abstract extension
			var node = this.rootNode;
			while(node.isExpanded){
				var c = node.getChildren();
				if(!c.length){
					break;
				}
				node = c[c.length - 1];
			}
			return node;
		},

		// Tree only searches forward so dir parameter is unused
		_getNext: function(node){
			// summary:
			//		Returns the next descendant, compared to "child".
			// node: Widget
			//		The current widget
			// tags:
			//		abstract extension

			if(node.isExpandable && node.isExpanded && node.hasChildren()){
				// if this is an expanded node, get the first child
				return node.getChildren()[0];		// TreeNode
			}else{
				// find a parent node with a sibling
				while(node && node.isTreeNode){
					var returnNode = node.getNextSibling();
					if(returnNode){
						return returnNode;		// TreeNode
					}
					node = node.getParent();
				}
				return null;
			}
		},

		// Implement _KeyNavContainer.childSelector, to identify which nodes are navigable
		childSelector: ".dijitTreeRow",

		isExpandoNode: function(node, widget){
			// summary:
			//		check whether a dom node is the expandoNode for a particular TreeNode widget
			return dom.isDescendant(node, widget.expandoNode) || dom.isDescendant(node, widget.expandoNodeText);
		},

		_onNodePress: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
			// Touching a node should focus it, even if you touch the expando node or the edges rather than the label.
			// Especially important to avoid _KeyNavMixin._onContainerFocus() causing the previously focused TreeNode
			// to get focus
			this.focusNode(nodeWidget);
		},

		__click: function(/*TreeNode*/ nodeWidget, /*Event*/ e, /*Boolean*/doOpen, /*String*/func){
			var domElement = e.target,
				isExpandoClick = this.isExpandoNode(domElement, nodeWidget);

			if(nodeWidget.isExpandable && (doOpen || isExpandoClick)){
				// expando node was clicked, or label of a folder node was clicked; open it
				this._onExpandoClick({node: nodeWidget});
			}else{
				this._publish("execute", { item: nodeWidget.item, node: nodeWidget, evt: e });
				this[func](nodeWidget.item, nodeWidget, e);
				this.focusNode(nodeWidget);
			}
			e.stopPropagation();
			e.preventDefault();
		},
		_onClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
			// summary:
			//		Translates click events into commands for the controller to process
			this.__click(nodeWidget, e, this.openOnClick, 'onClick');
		},
		_onDblClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
			// summary:
			//		Translates double-click events into commands for the controller to process
			this.__click(nodeWidget, e, this.openOnDblClick, 'onDblClick');
		},

		_onExpandoClick: function(/*Object*/ message){
			// summary:
			//		User clicked the +/- icon; expand or collapse my children.
			var node = message.node;

			// If we are collapsing, we might be hiding the currently focused node.
			// Also, clicking the expando node might have erased focus from the current node.
			// For simplicity's sake just focus on the node with the expando.
			this.focusNode(node);

			if(node.isExpanded){
				this._collapseNode(node);
			}else{
				this._expandNode(node);
			}
		},

		onClick: function(/*===== item, node, evt =====*/){
			// summary:
			//		Callback when a tree node is clicked
			// item: Object
			//		Object from the dojo/store corresponding to this TreeNode
			// node: TreeNode
			//		The TreeNode itself
			// evt: Event
			//		The event
			// tags:
			//		callback
		},
		onDblClick: function(/*===== item, node, evt =====*/){
			// summary:
			//		Callback when a tree node is double-clicked
			// item: Object
			//		Object from the dojo/store corresponding to this TreeNode
			// node: TreeNode
			//		The TreeNode itself
			// evt: Event
			//		The event
			// tags:
			//		callback
		},
		onOpen: function(/*===== item, node =====*/){
			// summary:
			//		Callback when a node is opened
			// item: dojo/data/Item
			// node: TreeNode
			// tags:
			//		callback
		},
		onClose: function(/*===== item, node =====*/){
			// summary:
			//		Callback when a node is closed
			// item: Object
			//		Object from the dojo/store corresponding to this TreeNode
			// node: TreeNode
			//		The TreeNode itself
			// tags:
			//		callback
		},

		_getNextNode: function(node){
			// summary:
			//		Get next visible node

			kernel.deprecated(this.declaredClass + "::_getNextNode(node) is deprecated. Use _getNext(node) instead.", "", "2.0");
			return this._getNext(node);
		},

		_getRootOrFirstNode: function(){
			// summary:
			//		Get first visible node
			kernel.deprecated(this.declaredClass + "::_getRootOrFirstNode() is deprecated. Use _getFirst() instead.", "", "2.0");
			return this._getFirst();
		},

		_collapseNode: function(/*TreeNode*/ node){
			// summary:
			//		Called when the user has requested to collapse the node
			// returns:
			//		Promise that resolves when the node has finished closing

			if(node._expandNodeDeferred){
				delete node._expandNodeDeferred;
			}

			if(node.state == "Loading"){
				// ignore clicks while we are in the process of loading data
				return;
			}

			if(node.isExpanded){
				var ret = node.collapse();

				this.onClose(node.item, node);
				this._state(node, false);

				this._startPaint(ret);	// after this finishes, need to reset widths of TreeNodes

				return ret;
			}
		},

		_expandNode: function(/*TreeNode*/ node){
			// summary:
			//		Called when the user has requested to expand the node
			// returns:
			//		Promise that resolves when the node is loaded and opened and (if persist=true) all it's descendants
			//		that were previously opened too

			if(node._expandNodeDeferred){
				// there's already an expand in progress, or completed, so just return
				return node._expandNodeDeferred;	// dojo/Deferred
			}

			var model = this.model,
				item = node.item,
				_this = this;

			// Load data if it's not already loaded
			if(!node._loadDeferred){
				// need to load all the children before expanding
				node.markProcessing();

				// Setup deferred to signal when the load and expand are finished.
				// Save that deferred in this._expandDeferred as a flag that operation is in progress.
				node._loadDeferred = new Deferred();

				// Get the children
				model.getChildren(
					item,
					function(items){
						node.unmarkProcessing();

						// Display the children and also start expanding any children that were previously expanded
						// (if this.persist == true).   The returned Deferred will fire when those expansions finish.
						node.setChildItems(items).then(function(){
							node._loadDeferred.resolve(items);
						});
					},
					function(err){
						console.error(_this, ": error loading " + node.label + " children: ", err);
						node._loadDeferred.reject(err);
					}
				);
			}

			// Expand the node after data has loaded
			var def = node._loadDeferred.then(lang.hitch(this, function(){
				var def2 = node.expand();

				// seems like these should delayed until node.expand() completes, but left here for back-compat about
				// when this.isOpen flag gets set (ie, at the beginning of the animation)
				this.onOpen(node.item, node);
				this._state(node, true);

				return def2;
			}));

			this._startPaint(def);	// after this finishes, need to reset widths of TreeNodes

			return def;	// dojo/promise/Promise
		},

		////////////////// Miscellaneous functions ////////////////

		focusNode: function(/* _tree.Node */ node){
			// summary:
			//		Focus on the specified node (which must be visible)
			// tags:
			//		protected

			var scrollLeft = this.domNode.scrollLeft;
			this.focusChild(node);
			this.domNode.scrollLeft = scrollLeft;
		},

		_onNodeMouseEnter: function(/*dijit/_WidgetBase*/ /*===== node =====*/){
			// summary:
			//		Called when mouse is over a node (onmouseenter event),
			//		this is monitored by the DND code
		},

		_onNodeMouseLeave: function(/*dijit/_WidgetBase*/ /*===== node =====*/){
			// summary:
			//		Called when mouse leaves a node (onmouseleave event),
			//		this is monitored by the DND code
		},

		//////////////// Events from the model //////////////////////////

		_onItemChange: function(/*Item*/ item){
			// summary:
			//		Processes notification of a change to an item's scalar values like label
			var model = this.model,
				identity = model.getIdentity(item),
				nodes = this._itemNodesMap[identity];

			if(nodes){
				var label = this.getLabel(item),
					tooltip = this.getTooltip(item);
				array.forEach(nodes, function(node){
					node.set({
						item: item, // theoretically could be new JS Object representing same item
						label: label,
						tooltip: tooltip
					});
					node._updateItemClasses(item);
				});
			}
		},

		_onItemChildrenChange: function(/*dojo/data/Item*/ parent, /*dojo/data/Item[]*/ newChildrenList){
			// summary:
			//		Processes notification of a change to an item's children
			var model = this.model,
				identity = model.getIdentity(parent),
				parentNodes = this._itemNodesMap[identity];

			if(parentNodes){
				array.forEach(parentNodes, function(parentNode){
					parentNode.setChildItems(newChildrenList);
				});
			}
		},

		_onItemDelete: function(/*Item*/ item){
			// summary:
			//		Processes notification of a deletion of an item.
			//		Not called from new dojo.store interface but there's cleanup code in setChildItems() instead.

			var model = this.model,
				identity = model.getIdentity(item),
				nodes = this._itemNodesMap[identity];

			if(nodes){
				array.forEach(nodes, function(node){
					// Remove node from set of selected nodes (if it's selected)
					this.dndController.removeTreeNode(node);

					var parent = node.getParent();
					if(parent){
						// if node has not already been orphaned from a _onSetItem(parent, "children", ..) call...
						parent.removeChild(node);
					}

					// If we've orphaned the focused node then move focus to the root node
					if(this.lastFocusedChild && !dom.isDescendant(this.lastFocusedChild, this.domNode)){
						delete this.lastFocusedChild;
					}
					if(this.focusedChild && !dom.isDescendant(this.focusedChild, this.domNode)){
						this.focus();
					}

					node.destroyRecursive();
				}, this);
				delete this._itemNodesMap[identity];
			}
		},

		/////////////// Miscellaneous funcs

		_initState: function(){
			// summary:
			//		Load in which nodes should be opened automatically
			this._openedNodes = {};
			if(this.persist && this.cookieName){
				var oreo = cookie(this.cookieName);
				if(oreo){
					array.forEach(oreo.split(','), function(item){
						this._openedNodes[item] = true;
					}, this);
				}
			}
		},

		_state: function(node, expanded){
			// summary:
			//		Query or set expanded state for an node
			if(!this.persist){
				return false;
			}
			var path = array.map(node.getTreePath(),function(item){
				return this.model.getIdentity(item);
			}, this).join("/");
			if(arguments.length === 1){
				return this._openedNodes[path];
			}else{
				if(expanded){
					this._openedNodes[path] = true;
				}else{
					delete this._openedNodes[path];
				}
				this._saveExpandedNodes();
			}
		},

		_saveExpandedNodes: function(){
			if(this.persist && this.cookieName){
				var ary = [];
				for(var id in this._openedNodes){
					ary.push(id);
				}
				cookie(this.cookieName, ary.join(","), {expires: 365});
			}
		},

		destroy: function(){
			if(this._curSearch){
				this._curSearch.timer.remove();
				delete this._curSearch;
			}
			if(this.rootNode){
				this.rootNode.destroyRecursive();
			}
			if(this.dndController && !lang.isString(this.dndController)){
				this.dndController.destroy();
			}
			this.rootNode = null;
			this.inherited(arguments);
		},

		destroyRecursive: function(){
			// A tree is treated as a leaf, not as a node with children (like a grid),
			// but defining destroyRecursive for back-compat.
			this.destroy();
		},

		resize: function(changeSize){
			if(changeSize){
				domGeometry.setMarginBox(this.domNode, changeSize);
			}

			// The main JS sizing involved w/tree is the indentation, which is specified
			// in CSS and read in through this dummy indentDetector node (tree must be
			// visible and attached to the DOM to read this).
			// If the Tree is hidden domGeometry.position(this.tree.indentDetector).w will return 0, in which case just
			// keep the default value.
			this._nodePixelIndent = domGeometry.position(this.tree.indentDetector).w || this._nodePixelIndent;

			// resize() may be called before this.rootNode is created, so wait until it's available
			this.expandChildrenDeferred.then(lang.hitch(this, function(){
				// If tree has already loaded, then reset indent for all the nodes
				this.rootNode.set('indent', this.showRoot ? 0 : -1);

				// Also, adjust widths of all rows to match width of Tree
				this._adjustWidths();
			}));
		},

		_outstandingPaintOperations: 0,
		_startPaint: function(/*Promise|Boolean*/ p){
			// summary:
			//		Called at the start of an operation that will change what's displayed.
			// p:
			//		Promise that tells when the operation will complete.  Alternately, if it's just a Boolean, it signifies
			//		that the operation was synchronous, and already completed.

			this._outstandingPaintOperations++;
			if(this._adjustWidthsTimer){
				this._adjustWidthsTimer.remove();
				delete this._adjustWidthsTimer;
			}

			var oc = lang.hitch(this, function(){
				this._outstandingPaintOperations--;

				if(this._outstandingPaintOperations <= 0 && !this._adjustWidthsTimer && this._started){
					// Use defer() to avoid a width adjustment when another operation will immediately follow,
					// such as a sequence of opening a node, then it's children, then it's grandchildren, etc.
					this._adjustWidthsTimer = this.defer("_adjustWidths");
				}
			});
			when(p, oc, oc);
		},

		_adjustWidths: function(){
			// summary:
			//		Size container to match widest TreeNode, so that highlighting with scrolling works (#13141, #16132)

			if(this._adjustWidthsTimer){
				this._adjustWidthsTimer.remove();
				delete this._adjustWidthsTimer;
			}

			this.containerNode.style.width = "auto";
			this.containerNode.style.width = this.domNode.scrollWidth > this.domNode.offsetWidth ? "auto" : "100%";
		},

		_createTreeNode: function(/*Object*/ args){
			// summary:
			//		creates a TreeNode
			// description:
			//		Developers can override this method to define their own TreeNode class;
			//		However it will probably be removed in a future release in favor of a way
			//		of just specifying a widget for the label, rather than one that contains
			//		the children too.
			return new TreeNode(args);
		},

		focus: function(){
			// summary:
			//		Default focus() implementation: focus the previously focused child, or first child.
			//		Some applications may want to change this method to focus the [first] selected child.

			if(this.lastFocusedChild){
				this.focusNode(this.lastFocusedChild);
			}else{
				this.focusFirstChild();
			}
		}
	});

	if(has("dojo-bidi")){
		Tree.extend({
			_setTextDirAttr: function(textDir){
				if(textDir && this.textDir != textDir){
					this._set("textDir", textDir);
					this.rootNode.set("textDir", textDir);
				}
			}
		});
	}

	Tree.PathError = createError("TreePathError");
	Tree._TreeNode = TreeNode;	// for monkey patching or creating subclasses of TreeNode

	return Tree;
});

},
'dijit/tree/TreeStoreModel':function(){
define([
	"dojo/_base/array", // array.filter array.forEach array.indexOf array.some
	"dojo/aspect", // aspect.after
	"dojo/_base/declare", // declare
	"dojo/_base/lang" // lang.hitch
], function(array, aspect, declare, lang){

	// module:
	//		dijit/tree/TreeStoreModel

	return declare("dijit.tree.TreeStoreModel", null, {
		// summary:
		//		Implements dijit/Tree/model connecting to a dojo.data store with a single
		//		root item.  Any methods passed into the constructor will override
		//		the ones defined here.

		// store: dojo/data/api/Read
		//		Underlying store
		store: null,

		// childrenAttrs: String[]
		//		One or more attribute names (attributes in the dojo.data item) that specify that item's children
		childrenAttrs: ["children"],

		// newItemIdAttr: String
		//		Name of attribute in the Object passed to newItem() that specifies the id.
		//
		//		If newItemIdAttr is set then it's used when newItem() is called to see if an
		//		item with the same id already exists, and if so just links to the old item
		//		(so that the old item ends up with two parents).
		//
		//		Setting this to null or "" will make every drop create a new item.
		newItemIdAttr: "id",

		// labelAttr: String
		//		If specified, get label for tree node from this attribute, rather
		//		than by calling store.getLabel()
		labelAttr: "",

		// root: [readonly] dojo/data/Item
		//		Pointer to the root item (read only, not a parameter)
		root: null,

		// query: anything
		//		Specifies datastore query to return the root item for the tree.
		//		Must only return a single item.   Alternately can just pass in pointer
		//		to root item.
		// example:
		//	|	{id:'ROOT'}
		query: null,

		// deferItemLoadingUntilExpand: Boolean
		//		Setting this to true will cause the TreeStoreModel to defer calling loadItem on nodes
		//		until they are expanded. This allows for lazying loading where only one
		//		loadItem (and generally one network call, consequently) per expansion
		//		(rather than one for each child).
		//		This relies on partial loading of the children items; each children item of a
		//		fully loaded item should contain the label and info about having children.
		deferItemLoadingUntilExpand: false,

		constructor: function(/* Object */ args){
			// summary:
			//		Passed the arguments listed above (store, etc)
			// tags:
			//		private

			lang.mixin(this, args);

			this.connects = [];

			var store = this.store;
			if(!store.getFeatures()['dojo.data.api.Identity']){
				throw new Error("dijit.tree.TreeStoreModel: store must support dojo.data.Identity");
			}

			// if the store supports Notification, subscribe to the notification events
			if(store.getFeatures()['dojo.data.api.Notification']){
				this.connects = this.connects.concat([
					aspect.after(store, "onNew", lang.hitch(this, "onNewItem"), true),
					aspect.after(store, "onDelete", lang.hitch(this, "onDeleteItem"), true),
					aspect.after(store, "onSet", lang.hitch(this, "onSetItem"), true)
				]);
			}
		},

		destroy: function(){
			var h;
			while(h = this.connects.pop()){ h.remove(); }
			// TODO: should cancel any in-progress processing of getRoot(), getChildren()
		},

		// =======================================================================
		// Methods for traversing hierarchy

		getRoot: function(onItem, onError){
			// summary:
			//		Calls onItem with the root item for the tree, possibly a fabricated item.
			//		Calls onError on error.
			if(this.root){
				onItem(this.root);
			}else{
				this.store.fetch({
					query: this.query,
					onComplete: lang.hitch(this, function(items){
						if(items.length != 1){
							throw new Error("dijit.tree.TreeStoreModel: root query returned " + items.length +
								" items, but must return exactly one");
						}
						this.root = items[0];
						onItem(this.root);
					}),
					onError: onError
				});
			}
		},

		mayHaveChildren: function(/*dojo/data/Item*/ item){
			// summary:
			//		Tells if an item has or may have children.  Implementing logic here
			//		avoids showing +/- expando icon for nodes that we know don't have children.
			//		(For efficiency reasons we may not want to check if an element actually
			//		has children until user clicks the expando node)
			return array.some(this.childrenAttrs, function(attr){
				return this.store.hasAttribute(item, attr);
			}, this);
		},

		getChildren: function(/*dojo/data/Item*/ parentItem, /*function(items)*/ onComplete, /*function*/ onError){
			// summary:
			//		Calls onComplete() with array of child items of given parent item, all loaded.

			var store = this.store;
			if(!store.isItemLoaded(parentItem)){
				// The parent is not loaded yet, we must be in deferItemLoadingUntilExpand
				// mode, so we will load it and just return the children (without loading each
				// child item)
				var getChildren = lang.hitch(this, arguments.callee);
				store.loadItem({
					item: parentItem,
					onItem: function(parentItem){
						getChildren(parentItem, onComplete, onError);
					},
					onError: onError
				});
				return;
			}
			// get children of specified item
			var childItems = [];
			for(var i=0; i<this.childrenAttrs.length; i++){
				var vals = store.getValues(parentItem, this.childrenAttrs[i]);
				childItems = childItems.concat(vals);
			}

			// count how many items need to be loaded
			var _waitCount = 0;
			if(!this.deferItemLoadingUntilExpand){
				array.forEach(childItems, function(item){ if(!store.isItemLoaded(item)){ _waitCount++; } });
			}

			if(_waitCount == 0){
				// all items are already loaded (or we aren't loading them).  proceed...
				onComplete(childItems);
			}else{
				// still waiting for some or all of the items to load
				array.forEach(childItems, function(item, idx){
					if(!store.isItemLoaded(item)){
						store.loadItem({
							item: item,
							onItem: function(item){
								childItems[idx] = item;
								if(--_waitCount == 0){
									// all nodes have been loaded, send them to the tree
									onComplete(childItems);
								}
							},
							onError: onError
						});
					}
				});
			}
		},

		// =======================================================================
		// Inspecting items

		isItem: function(/* anything */ something){
			return this.store.isItem(something);	// Boolean
		},

		fetchItemByIdentity: function(/* object */ keywordArgs){
			// summary:
			//		Given the identity of an item, this method returns the item that has
			//		that identity through the onItem callback.  Conforming implementations
			//		should return null if there is no item with the given identity.
			//		Implementations of fetchItemByIdentity() may sometimes return an item
			//		from a local cache and may sometimes fetch an item from a remote server.
			// tags:
			//		extension
			this.store.fetchItemByIdentity(keywordArgs);
		},

		getIdentity: function(/* item */ item){
			return this.store.getIdentity(item);	// Object
		},

		getLabel: function(/*dojo/data/Item*/ item){
			// summary:
			//		Get the label for an item
			if(this.labelAttr){
				return this.store.getValue(item,this.labelAttr);	// String
			}else{
				return this.store.getLabel(item);	// String
			}
		},

		// =======================================================================
		// Write interface

		newItem: function(/* dijit/tree/dndSource.__Item */ args, /*dojo/data/api/Item*/ parent, /*int?*/ insertIndex){
			// summary:
			//		Creates a new item.   See `dojo/data/api/Write` for details on args.
			//		Used in drag & drop when item from external source dropped onto tree.
			// description:
			//		Developers will need to override this method if new items get added
			//		to parents with multiple children attributes, in order to define which
			//		children attribute points to the new item.

			var pInfo = {parent: parent, attribute: this.childrenAttrs[0]}, LnewItem;

			if(this.newItemIdAttr && args[this.newItemIdAttr]){
				// Maybe there's already a corresponding item in the store; if so, reuse it.
				this.fetchItemByIdentity({identity: args[this.newItemIdAttr], scope: this, onItem: function(item){
					if(item){
						// There's already a matching item in store, use it
						this.pasteItem(item, null, parent, true, insertIndex);
					}else{
						// Create new item in the tree, based on the drag source.
						LnewItem=this.store.newItem(args, pInfo);
						if(LnewItem && (insertIndex!=undefined)){
							// Move new item to desired position
							this.pasteItem(LnewItem, parent, parent, false, insertIndex);
						}
					}
				}});
			}else{
				// [as far as we know] there is no id so we must assume this is a new item
				LnewItem=this.store.newItem(args, pInfo);
				if(LnewItem && (insertIndex!=undefined)){
					// Move new item to desired position
					this.pasteItem(LnewItem, parent, parent, false, insertIndex);
				}
			}
		},

		pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int?*/ insertIndex){
			// summary:
			//		Move or copy an item from one parent item to another.
			//		Used in drag & drop
			var store = this.store,
				parentAttr = this.childrenAttrs[0];	// name of "children" attr in parent item

			// remove child from source item, and record the attribute that child occurred in
			if(oldParentItem){
				array.forEach(this.childrenAttrs, function(attr){
					if(store.containsValue(oldParentItem, attr, childItem)){
						if(!bCopy){
							var values = array.filter(store.getValues(oldParentItem, attr), function(x){
								return x != childItem;
							});
							store.setValues(oldParentItem, attr, values);
						}
						parentAttr = attr;
					}
				});
			}

			// modify target item's children attribute to include this item
			if(newParentItem){
				if(typeof insertIndex == "number"){
					// call slice() to avoid modifying the original array, confusing the data store
					var childItems = store.getValues(newParentItem, parentAttr).slice();
					childItems.splice(insertIndex, 0, childItem);
					store.setValues(newParentItem, parentAttr, childItems);
				}else{
					store.setValues(newParentItem, parentAttr,
						store.getValues(newParentItem, parentAttr).concat(childItem));
				}
			}
		},

		// =======================================================================
		// Callbacks

		onChange: function(/*dojo/data/Item*/ /*===== item =====*/){
			// summary:
			//		Callback whenever an item has changed, so that Tree
			//		can update the label, icon, etc.   Note that changes
			//		to an item's children or parent(s) will trigger an
			//		onChildrenChange() so you can ignore those changes here.
			// tags:
			//		callback
		},

		onChildrenChange: function(/*===== parent, newChildrenList =====*/){
			// summary:
			//		Callback to do notifications about new, updated, or deleted items.
			// parent: dojo/data/Item
			// newChildrenList: dojo/data/Item[]
			// tags:
			//		callback
		},

		onDelete: function(/*dojo/data/Item*/ /*===== item =====*/){
			// summary:
			//		Callback when an item has been deleted.
			// description:
			//		Note that there will also be an onChildrenChange() callback for the parent
			//		of this item.
			// tags:
			//		callback
		},

		// =======================================================================
		// Events from data store

		onNewItem: function(/* dojo/data/Item */ item, /* Object */ parentInfo){
			// summary:
			//		Handler for when new items appear in the store, either from a drop operation
			//		or some other way.   Updates the tree view (if necessary).
			// description:
			//		If the new item is a child of an existing item,
			//		calls onChildrenChange() with the new list of children
			//		for that existing item.
			//
			// tags:
			//		extension

			// We only care about the new item if it has a parent that corresponds to a TreeNode
			// we are currently displaying
			if(!parentInfo){
				return;
			}

			// Call onChildrenChange() on parent (ie, existing) item with new list of children
			// In the common case, the new list of children is simply parentInfo.newValue or
			// [ parentInfo.newValue ], although if items in the store has multiple
			// child attributes (see `childrenAttr`), then it's a superset of parentInfo.newValue,
			// so call getChildren() to be sure to get right answer.
			this.getChildren(parentInfo.item, lang.hitch(this, function(children){
				this.onChildrenChange(parentInfo.item, children);
			}));
		},

		onDeleteItem: function(/*Object*/ item){
			// summary:
			//		Handler for delete notifications from underlying store
			this.onDelete(item);
		},

		onSetItem: function(item, attribute /*===== , oldValue, newValue =====*/){
			// summary:
			//		Updates the tree view according to changes in the data store.
			// description:
			//		Handles updates to an item's children by calling onChildrenChange(), and
			//		other updates to an item by calling onChange().
			//
			//		See `onNewItem` for more details on handling updates to an item's children.
			// item: Item
			// attribute: attribute-name-string
			// oldValue: Object|Array
			// newValue: Object|Array
			// tags:
			//		extension

			if(array.indexOf(this.childrenAttrs, attribute) != -1){
				// item's children list changed
				this.getChildren(item, lang.hitch(this, function(children){
					// See comments in onNewItem() about calling getChildren()
					this.onChildrenChange(item, children);
				}));
			}else{
				// item's label/icon/etc. changed.
				this.onChange(item);
			}
		}
	});
});

},
'dijit/tree/ForestStoreModel':function(){
define([
	"dojo/_base/array", // array.indexOf array.some
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // global
	"dojo/_base/lang", // lang.hitch
	"./TreeStoreModel"
], function(array, declare, kernel, lang, TreeStoreModel){

// module:
//		dijit/tree/ForestStoreModel

return declare("dijit.tree.ForestStoreModel", TreeStoreModel, {
	// summary:
	//		Interface between a dijit.Tree and a dojo.data store that doesn't have a root item,
	//		a.k.a. a store that has multiple "top level" items.
	//
	// description:
	//		Use this class to wrap a dojo.data store, making all the items matching the specified query
	//		appear as children of a fabricated "root item".  If no query is specified then all the
	//		items returned by fetch() on the underlying store become children of the root item.
	//		This class allows dijit.Tree to assume a single root item, even if the store doesn't have one.
	//
	//		When using this class the developer must override a number of methods according to their app and
	//		data, including:
	//
	//		- onNewRootItem
	//		- onAddToRoot
	//		- onLeaveRoot
	//		- onNewItem
	//		- onSetItem

	// Parameters to constructor

	// rootId: String
	//		ID of fabricated root item
	rootId: "$root$",

	// rootLabel: String
	//		Label of fabricated root item
	rootLabel: "ROOT",

	// query: String
	//		Specifies the set of children of the root item.
	// example:
	//	|	{type:'continent'}
	query: null,

	// End of parameters to constructor

	constructor: function(params){
		// summary:
		//		Sets up variables, etc.
		// tags:
		//		private

		// Make dummy root item
		this.root = {
			store: this,
			root: true,
			id: params.rootId,
			label: params.rootLabel,
			children: params.rootChildren	// optional param
		};
	},

	// =======================================================================
	// Methods for traversing hierarchy

	mayHaveChildren: function(/*dojo/data/Item*/ item){
		// summary:
		//		Tells if an item has or may have children.  Implementing logic here
		//		avoids showing +/- expando icon for nodes that we know don't have children.
		//		(For efficiency reasons we may not want to check if an element actually
		//		has children until user clicks the expando node)
		// tags:
		//		extension
		return item === this.root || this.inherited(arguments);
	},

	getChildren: function(/*dojo/data/Item*/ parentItem, /*function(items)*/ callback, /*function*/ onError){
		// summary:
		//		Calls onComplete() with array of child items of given parent item, all loaded.
		if(parentItem === this.root){
			if(this.root.children){
				// already loaded, just return
				callback(this.root.children);
			}else{
				this.store.fetch({
					query: this.query,
					onComplete: lang.hitch(this, function(items){
						this.root.children = items;
						callback(items);
					}),
					onError: onError
				});
			}
		}else{
			this.inherited(arguments);
		}
	},

	// =======================================================================
	// Inspecting items

	isItem: function(/* anything */ something){
		return (something === this.root) ? true : this.inherited(arguments);
	},

	fetchItemByIdentity: function(/* object */ keywordArgs){
		if(keywordArgs.identity == this.root.id){
			var scope = keywordArgs.scope || kernel.global;
			if(keywordArgs.onItem){
				keywordArgs.onItem.call(scope, this.root);
			}
		}else{
			this.inherited(arguments);
		}
	},

	getIdentity: function(/* item */ item){
		return (item === this.root) ? this.root.id : this.inherited(arguments);
	},

	getLabel: function(/* item */ item){
		return	(item === this.root) ? this.root.label : this.inherited(arguments);
	},

	// =======================================================================
	// Write interface

	newItem: function(/* dijit/tree/dndSource.__Item */ args, /*Item*/ parent, /*int?*/ insertIndex){
		// summary:
		//		Creates a new item.   See dojo/data/api/Write for details on args.
		//		Used in drag & drop when item from external source dropped onto tree.
		if(parent === this.root){
			this.onNewRootItem(args);
			return this.store.newItem(args);
		}else{
			return this.inherited(arguments);
		}
	},

	onNewRootItem: function(/* dijit/tree/dndSource.__Item */ /*===== args =====*/){
		// summary:
		//		User can override this method to modify a new element that's being
		//		added to the root of the tree, for example to add a flag like root=true
	},

	pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int?*/ insertIndex){
		// summary:
		//		Move or copy an item from one parent item to another.
		//		Used in drag & drop
		if(oldParentItem === this.root){
			if(!bCopy){
				// It's onLeaveRoot()'s responsibility to modify the item so it no longer matches
				// this.query... thus triggering an onChildrenChange() event to notify the Tree
				// that this element is no longer a child of the root node
				this.onLeaveRoot(childItem);
			}
		}
		this.inherited(arguments, [childItem,
			oldParentItem === this.root ? null : oldParentItem,
			newParentItem === this.root ? null : newParentItem,
			bCopy,
			insertIndex
		]);
		if(newParentItem === this.root){
			// It's onAddToRoot()'s responsibility to modify the item so it matches
			// this.query... thus triggering an onChildrenChange() event to notify the Tree
			// that this element is now a child of the root node
			this.onAddToRoot(childItem);
		}
	},

	// =======================================================================
	// Handling for top level children

	onAddToRoot: function(/* item */ item){
		// summary:
		//		Called when item added to root of tree; user must override this method
		//		to modify the item so that it matches the query for top level items
		// example:
		//	|	store.setValue(item, "root", true);
		// tags:
		//		extension
		console.log(this, ": item ", item, " added to root");
	},

	onLeaveRoot: function(/* item */ item){
		// summary:
		//		Called when item removed from root of tree; user must override this method
		//		to modify the item so it doesn't match the query for top level items
		// example:
		//	|	store.unsetAttribute(item, "root");
		// tags:
		//		extension
		console.log(this, ": item ", item, " removed from root");
	},

	// =======================================================================
	// Events from data store

	_requeryTop: function(){
		// reruns the query for the children of the root node,
		// sending out an onSet notification if those children have changed
		var oldChildren = this.root.children || [];
		this.store.fetch({
			query: this.query,
			onComplete: lang.hitch(this, function(newChildren){
				this.root.children = newChildren;

				// If the list of children or the order of children has changed...
				if(oldChildren.length != newChildren.length ||
					array.some(oldChildren, function(item, idx){ return newChildren[idx] != item;})){
					this.onChildrenChange(this.root, newChildren);
				}
			})
		});
	},

	onNewItem: function(/* dojo/data/api/Item */ item, /* Object */ parentInfo){
		// summary:
		//		Handler for when new items appear in the store.  Developers should override this
		//		method to be more efficient based on their app/data.
		// description:
		//		Note that the default implementation requeries the top level items every time
		//		a new item is created, since any new item could be a top level item (even in
		//		addition to being a child of another item, since items can have multiple parents).
		//
		//		If developers can detect which items are possible top level items (based on the item and the
		//		parentInfo parameters), they should override this method to only call _requeryTop() for top
		//		level items.  Often all top level items have parentInfo==null, but
		//		that will depend on which store you use and what your data is like.
		// tags:
		//		extension
		this._requeryTop();

		this.inherited(arguments);
	},

	onDeleteItem: function(/*Object*/ item){
		// summary:
		//		Handler for delete notifications from underlying store

		// check if this was a child of root, and if so send notification that root's children
		// have changed
		if(array.indexOf(this.root.children, item) != -1){
			this._requeryTop();
		}

		this.inherited(arguments);
	},

	onSetItem: function(/* item */ item,
					/* attribute-name-string */ attribute,
					/* Object|Array */ oldValue,
					/* Object|Array */ newValue){
		// summary:
		//		Updates the tree view according to changes to an item in the data store.
		//		Developers should override this method to be more efficient based on their app/data.
		// description:
		//		Handles updates to an item's children by calling onChildrenChange(), and
		//		other updates to an item by calling onChange().
		//
		//		Also, any change to any item re-executes the query for the tree's top-level items,
		//		since this modified item may have started/stopped matching the query for top level items.
		//
		//		If possible, developers should override this function to only call _requeryTop() when
		//		the change to the item has caused it to stop/start being a top level item in the tree.
		// tags:
		//		extension

		this._requeryTop();
		this.inherited(arguments);
	}

});

});

},
'dijit/tree/_dndSelector':function(){
define([
	"dojo/_base/array", // array.filter array.forEach array.map
	"dojo/_base/declare", // declare
	"dojo/_base/kernel",	// global
	"dojo/_base/lang", // lang.hitch
	"dojo/dnd/common",
	"dojo/dom", // isDescendant
	"dojo/mouse", // mouse.isLeft
	"dojo/on",
	"dojo/touch",
	"../a11yclick",
	"./_dndContainer"
], function(array, declare, kernel, lang, dndCommon, dom, mouse, on, touch, a11yclick, _dndContainer){

	// module:
	//		dijit/tree/_dndSelector

	return declare("dijit.tree._dndSelector", _dndContainer, {
		// summary:
		//		This is a base class for `dijit/tree/dndSource`, and isn't meant to be used directly.
		//		It's based on `dojo/dnd/Selector`.
		// tags:
		//		protected

		/*=====
		// selection: Object
		//		(id to DomNode) map for every TreeNode that's currently selected.
		//		The DOMNode is the TreeNode.rowNode.
		selection: {},
		=====*/

		constructor: function(){
			// summary:
			//		Initialization
			// tags:
			//		private

			this.selection={};
			this.anchor = null;

			this.events.push(
				// listeners setup here but no longer used (left for backwards compatibility
				on(this.tree.domNode, touch.press, lang.hitch(this,"onMouseDown")),
				on(this.tree.domNode, touch.release, lang.hitch(this,"onMouseUp")),

				// listeners used in this module
				on(this.tree.domNode, touch.move, lang.hitch(this,"onMouseMove")),
				on(this.tree.domNode, a11yclick.press, lang.hitch(this,"onClickPress")),
				on(this.tree.domNode, a11yclick.release, lang.hitch(this,"onClickRelease"))
			);
		},

		// singular: Boolean
		//		Allows selection of only one element, if true.
		//		Tree hasn't been tested in singular=true mode, unclear if it works.
		singular: false,

		// methods
		getSelectedTreeNodes: function(){
			// summary:
			//		Returns a list of selected node(s).
			//		Used by dndSource on the start of a drag.
			// tags:
			//		protected
			var nodes=[], sel = this.selection;
			for(var i in sel){
				nodes.push(sel[i]);
			}
			return nodes;
		},

		selectNone: function(){
			// summary:
			//		Unselects all items
			// tags:
			//		private

			this.setSelection([]);
			return this;	// self
		},

		destroy: function(){
			// summary:
			//		Prepares the object to be garbage-collected
			this.inherited(arguments);
			this.selection = this.anchor = null;
		},
		addTreeNode: function(/*dijit/Tree._TreeNode*/ node, /*Boolean?*/isAnchor){
			// summary:
			//		add node to current selection
			// node: Node
			//		node to add
			// isAnchor: Boolean
			//		Whether the node should become anchor.

			this.setSelection(this.getSelectedTreeNodes().concat( [node] ));
			if(isAnchor){ this.anchor = node; }
			return node;
		},
		removeTreeNode: function(/*dijit/Tree._TreeNode*/ node){
			// summary:
			//		remove node and it's descendants from current selection
			// node: Node
			//		node to remove
			var newSelection = array.filter(this.getSelectedTreeNodes(), function(selectedNode){
				return !dom.isDescendant(selectedNode.domNode, node.domNode); // also matches when selectedNode == node
			});
			this.setSelection(newSelection);
			return node;
		},
		isTreeNodeSelected: function(/*dijit/Tree._TreeNode*/ node){
			// summary:
			//		return true if node is currently selected
			// node: Node
			//		the node to check whether it's in the current selection

			return node.id && !!this.selection[node.id];
		},
		setSelection: function(/*dijit/Tree._TreeNode[]*/ newSelection){
			// summary:
			//		set the list of selected nodes to be exactly newSelection. All changes to the
			//		selection should be passed through this function, which ensures that derived
			//		attributes are kept up to date. Anchor will be deleted if it has been removed
			//		from the selection, but no new anchor will be added by this function.
			// newSelection: Node[]
			//		list of tree nodes to make selected
			var oldSelection = this.getSelectedTreeNodes();
			array.forEach(this._setDifference(oldSelection, newSelection), lang.hitch(this, function(node){
				node.setSelected(false);
				if(this.anchor == node){
					delete this.anchor;
				}
				delete this.selection[node.id];
			}));
			array.forEach(this._setDifference(newSelection, oldSelection), lang.hitch(this, function(node){
				node.setSelected(true);
				this.selection[node.id] = node;
			}));
			this._updateSelectionProperties();
		},
		_setDifference: function(xs,ys){
			// summary:
			//		Returns a copy of xs which lacks any objects
			//		occurring in ys. Checks for membership by
			//		modifying and then reading the object, so it will
			//		not properly handle sets of numbers or strings.

			array.forEach(ys, function(y){ y.__exclude__ = true; });
			var ret = array.filter(xs, function(x){ return !x.__exclude__; });

			// clean up after ourselves.
			array.forEach(ys, function(y){ delete y['__exclude__'] });
			return ret;
		},
		_updateSelectionProperties: function(){
			// summary:
			//		Update the following tree properties from the current selection:
			//		path[s], selectedItem[s], selectedNode[s]

			var selected = this.getSelectedTreeNodes();
			var paths = [], nodes = [];
			array.forEach(selected, function(node){
				var ary = node.getTreePath();
				nodes.push(node);
				paths.push(ary);
			}, this);
			var items = array.map(nodes,function(node){ return node.item; });
			this.tree._set("paths", paths);
			this.tree._set("path", paths[0] || []);
			this.tree._set("selectedNodes", nodes);
			this.tree._set("selectedNode", nodes[0] || null);
			this.tree._set("selectedItems", items);
			this.tree._set("selectedItem", items[0] || null);
		},

		// selection related events
		onClickPress: function(e){
			// summary:
			//		Event processor for onmousedown/ontouchstart/onkeydown corresponding to a click event
			// e: Event
			//		onmousedown/ontouchstart/onkeydown event
			// tags:
			//		protected

			// ignore mouse or touch on expando node
			if(this.current && this.current.isExpandable && this.tree.isExpandoNode(e.target, this.current)){ return; }

			if(e.type == "mousedown" && mouse.isLeft(e)){
				// Prevent text selection while dragging on desktop, see #16328.   But don't call preventDefault()
				// for mobile because it will break things completely, see #15838.  Also, don't preventDefault() on
				// MSPointerDown or pointerdown events, because that stops the mousedown event from being generated,
				// see #17709.
				// TODO: remove this completely in 2.0.  It shouldn't be needed since dojo/dnd/Manager already
				// calls preventDefault() for the "selectstart" event.  It can also be achieved via CSS:
				// http://stackoverflow.com/questions/826782/css-rule-to-disable-text-selection-highlighting
				e.preventDefault();
			}

			var treeNode = e.type == "keydown" ? this.tree.focusedChild : this.current;

			if(!treeNode){
				// Click must be on the Tree but not on a TreeNode, happens especially when Tree is stretched to fill
				// a pane of a BorderContainer, etc.
				return;
			}

			var copy = dndCommon.getCopyKeyState(e), id = treeNode.id;

			// if shift key is not pressed, and the node is already in the selection,
			// delay deselection until onmouseup so in the case of DND, deselection
			// will be canceled by onmousemove.
			if(!this.singular && !e.shiftKey && this.selection[id]){
				this._doDeselect = true;
				return;
			}else{
				this._doDeselect = false;
			}
			this.userSelect(treeNode, copy, e.shiftKey);
		},

		onClickRelease: function(e){
			// summary:
			//		Event processor for onmouseup/ontouchend/onkeyup corresponding to a click event
			// e: Event
			//		onmouseup/ontouchend/onkeyup event
			// tags:
			//		protected

			// _doDeselect is the flag to indicate that the user wants to either ctrl+click on
			// an already selected item (to deselect the item), or click on a not-yet selected item
			// (which should remove all current selection, and add the clicked item). This can not
			// be done in onMouseDown, because the user may start a drag after mousedown. By moving
			// the deselection logic here, the user can drag an already selected item.
			if(!this._doDeselect){ return; }
			this._doDeselect = false;
			this.userSelect(e.type == "keyup" ? this.tree.focusedChild : this.current, dndCommon.getCopyKeyState(e), e.shiftKey);
		},
		onMouseMove: function(/*===== e =====*/){
			// summary:
			//		event processor for onmousemove/ontouchmove
			// e: Event
			//		onmousemove/ontouchmove event
			this._doDeselect = false;
		},

		// mouse/touch events that are no longer used
		onMouseDown: function(){
			// summary:
			//		Event processor for onmousedown/ontouchstart
			// e: Event
			//		onmousedown/ontouchstart event
			// tags:
			//		protected
		},
		onMouseUp: function(){
			// summary:
			//		Event processor for onmouseup/ontouchend
			// e: Event
			//		onmouseup/ontouchend event
			// tags:
			//		protected
		},

		_compareNodes: function(n1, n2){
			if(n1 === n2){
				return 0;
			}

			if('sourceIndex' in document.documentElement){ //IE
				//TODO: does not yet work if n1 and/or n2 is a text node
				return n1.sourceIndex - n2.sourceIndex;
			}else if('compareDocumentPosition' in document.documentElement){ //FF, Opera
				return n1.compareDocumentPosition(n2) & 2 ? 1: -1;
			}else if(document.createRange){ //Webkit
				var r1 = doc.createRange();
				r1.setStartBefore(n1);

				var r2 = doc.createRange();
				r2.setStartBefore(n2);

				return r1.compareBoundaryPoints(r1.END_TO_END, r2);
			}else{
				throw Error("dijit.tree._compareNodes don't know how to compare two different nodes in this browser");
			}
		},

		userSelect: function(node, multi, range){
			// summary:
			//		Add or remove the given node from selection, responding
			//		to a user action such as a click or keypress.
			// multi: Boolean
			//		Indicates whether this is meant to be a multi-select action (e.g. ctrl-click)
			// range: Boolean
			//		Indicates whether this is meant to be a ranged action (e.g. shift-click)
			// tags:
			//		protected

			if(this.singular){
				if(this.anchor == node && multi){
					this.selectNone();
				}else{
					this.setSelection([node]);
					this.anchor = node;
				}
			}else{
				if(range && this.anchor){
					var cr = this._compareNodes(this.anchor.rowNode, node.rowNode),
					begin, end, anchor = this.anchor;

					if(cr < 0){ //current is after anchor
						begin = anchor;
						end = node;
					}else{ //current is before anchor
						begin = node;
						end = anchor;
					}
					var nodes = [];
					//add everything betweeen begin and end inclusively
					while(begin != end){
						nodes.push(begin);
						begin = this.tree._getNext(begin);
					}
					nodes.push(end);

					this.setSelection(nodes);
				}else{
					if( this.selection[ node.id ] && multi ){
						this.removeTreeNode( node );
					}else if(multi){
						this.addTreeNode(node, true);
					}else{
						this.setSelection([node]);
						this.anchor = node;
					}
				}
			}
		},

		getItem: function(/*String*/ key){
			// summary:
			//		Returns the dojo/dnd/Container._Item (representing a dragged node) by it's key (id).
			//		Called by dojo/dnd/Source.checkAcceptance().
			// tags:
			//		protected

			var widget = this.selection[key];
			return {
				data: widget,
				type: ["treeNode"]
			}; // dojo/dnd/Container._Item
		},

		forInSelectedItems: function(/*Function*/ f, /*Object?*/ o){
			// summary:
			//		Iterates over selected items;
			//		see `dojo/dnd/Container.forInItems()` for details
			o = o || kernel.global;
			for(var id in this.selection){
				// console.log("selected item id: " + id);
				f.call(o, this.getItem(id), id, this);
			}
		}
	});
});

},
'dijit/tree/_dndContainer':function(){
define([
	"dojo/aspect", // aspect.after
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove domClass.replace
	"dojo/_base/lang", // lang.mixin lang.hitch
	"dojo/on",
	"dojo/touch"
], function(aspect, declare, domClass, lang, on, touch){

	// module:
	//		dijit/tree/_dndContainer

	/*=====
	 var __Args = {
	 // summary:
	 //		A dict of parameters for Tree source configuration.
	 // isSource: Boolean?
	 //		Can be used as a DnD source. Defaults to true.
	 // accept: String[]
	 //		List of accepted types (text strings) for a target; defaults to
	 //		["text", "treeNode"]
	 // copyOnly: Boolean?
	 //		Copy items, if true, use a state of Ctrl key otherwise,
	 // dragThreshold: Number
	 //		The move delay in pixels before detecting a drag; 0 by default
	 // betweenThreshold: Integer
	 //		Distance from upper/lower edge of node to allow drop to reorder nodes
	 };
	 =====*/

	return declare("dijit.tree._dndContainer", null, {

		// summary:
		//		This is a base class for `dijit/tree/_dndSelector`, and isn't meant to be used directly.
		//		It's modeled after `dojo/dnd/Container`.
		// tags:
		//		protected

		/*=====
		 // current: TreeNode
		 //		The currently hovered TreeNode.  Not set to anything for keyboard operation.  (TODO: change?)
		 current: null,
		 =====*/

		constructor: function(tree, params){
			// summary:
			//		A constructor of the Container
			// tree: Node
			//		Node or node's id to build the container on
			// params: __Args
			//		A dict of parameters, which gets mixed into the object
			// tags:
			//		private
			this.tree = tree;
			this.node = tree.domNode;	// TODO: rename; it's not a TreeNode but the whole Tree
			lang.mixin(this, params);

			// states
			this.containerState = "";
			domClass.add(this.node, "dojoDndContainer");

			// set up events
			this.events = [
				// Mouse (or touch) enter/leave on Tree itself
				on(this.node, touch.enter, lang.hitch(this, "onOverEvent")),
				on(this.node, touch.leave, lang.hitch(this, "onOutEvent")),

				// switching between TreeNodes
				aspect.after(this.tree, "_onNodeMouseEnter", lang.hitch(this, "onMouseOver"), true),
				aspect.after(this.tree, "_onNodeMouseLeave", lang.hitch(this, "onMouseOut"), true),

				// cancel text selection and text dragging
				on(this.node, "dragstart, selectstart", function(evt){
					evt.preventDefault();
				})
			];
		},

		destroy: function(){
			// summary:
			//		Prepares this object to be garbage-collected

			var h;
			while(h = this.events.pop()){
				h.remove();
			}

			// this.clearItems();
			this.node = this.parent = null;
		},

		// mouse events
		onMouseOver: function(widget /*===== , evt =====*/){
			// summary:
			//		Called when mouse is moved over a TreeNode
			// widget: TreeNode
			// evt: Event
			// tags:
			//		protected
			this.current = widget;
		},

		onMouseOut: function(/*===== widget, evt =====*/){
			// summary:
			//		Called when mouse is moved away from a TreeNode
			// widget: TreeNode
			// evt: Event
			// tags:
			//		protected
			this.current = null;
		},

		_changeState: function(type, newState){
			// summary:
			//		Changes a named state to new state value
			// type: String
			//		A name of the state to change
			// newState: String
			//		new state
			var prefix = "dojoDnd" + type;
			var state = type.toLowerCase() + "State";
			//domClass.replace(this.node, prefix + newState, prefix + this[state]);
			domClass.replace(this.node, prefix + newState, prefix + this[state]);
			this[state] = newState;
		},

		_addItemClass: function(node, type){
			// summary:
			//		Adds a class with prefix "dojoDndItem"
			// node: Node
			//		A node
			// type: String
			//		A variable suffix for a class name
			domClass.add(node, "dojoDndItem" + type);
		},

		_removeItemClass: function(node, type){
			// summary:
			//		Removes a class with prefix "dojoDndItem"
			// node: Node
			//		A node
			// type: String
			//		A variable suffix for a class name
			domClass.remove(node, "dojoDndItem" + type);
		},

		onOverEvent: function(){
			// summary:
			//		This function is called once, when mouse is over our container
			// tags:
			//		protected
			this._changeState("Container", "Over");
		},

		onOutEvent: function(){
			// summary:
			//		This function is called once, when mouse is out of our container
			// tags:
			//		protected
			this._changeState("Container", "");
		}
	});
});

},
'vodori/ui/dndSource':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/query',
    'dojo/dnd/Manager',
    'dojo/_base/connect',
    'dijit/tree/dndSource'
], function (provide, module, _, query, DNDManager, connect, dndSource) {

    return provide(module.id, [dndSource], {

        _TREE_NODE_LABEL_CLASS: '.dijitTreeLabel',

        _lastTarget: null, // Fixes dragThreshold issue

        onMouseDown: function (e) {
            this._lastTarget = e.target || e.srcElement;
            this.inherited(arguments);
        },

        ancestorsSelected: function (n, selection) {
            var p = n.getParent();
            for (; p && p !== this.tree; p = p.getParent()) {
                if (selection[p.id]) { //parent is already selected, skip this node
                    return true;
                }
            }
            return false;
        },

        onMouseMove: function (e) {
            // summary:
            //		Called for any onmousemove/ontouchmove events over the Tree
            // e: Event
            //		onmousemouse/ontouchmove event
            // tags:
            //		private
            if (this.isDragging && this.targetState === 'Disabled') {
                return;
            }
            this._doDeselect = false;
            var m = DNDManager.manager();
            if (this.isDragging) {
                this._onDragMouse(e);
            } else if (this.mouseDown && this.isSource &&
                (Math.abs(e.pageX - this._lastX) >= this.dragThreshold ||
                    Math.abs(e.pageY - this._lastY) >= this.dragThreshold)) {
                var nodes = this.getSelectedTreeNodes();
                if (nodes.length) {
                    // Make the check for if we're actually dragging a node
                    if (this._checkTarget(this._lastTarget, nodes)) {
                        if (nodes.length > 1) {
                            //filter out all selected items which has one of their ancestor selected as well
                            var selection = this.selection,
                                i = 0,
                                r = [],
                                n;
                            while ((n = nodes[i++])) {
                                if (!this.ancestorsSelected(n, selection)) {
                                    r.push(n);
                                }
                            }
                            nodes = r;
                        }
                        nodes = _.map(nodes, function (n) {
                            return n.domNode;
                        });
                        m.startDrag(this, nodes, this.copyState(connect.isCopyKey(e)));
                    }
                }
            }
        },

        /**
         * See if the needle (clicked element) exists within the haystack (selected elements)
         * @param {HTMLElement} needle
         * @param {Array} haystack
         */
        _checkTarget: function (needle, haystack) {
            var searchString;

            // If user clicked directly on label node, we can easily get the search string
            if (needle.childElementCount === 0) {
                searchString = needle.innerHTML;
            } else {
                // Otherwise dig through for it
                var needleNodes = query(this._TREE_NODE_LABEL_CLASS, needle);
                if (needleNodes && needleNodes.length === 1) {
                    searchString = needleNodes[0].innerHTML;
                } else {
                    return false;
                }
            }

            // Check the haystack for the search string
            var found = false;
            _.forEach(haystack, function (node) {
                found = found || (searchString === node.label);
            });

            return found;
        }
    });
});

},
'dijit/tree/dndSource':function(){
define([
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/dnd/common",
	"dojo/dom-class", // domClass.add
	"dojo/dom-geometry", // domGeometry.position
	"dojo/_base/lang", // lang.mixin lang.hitch
	"dojo/on", // subscribe
	"dojo/touch",
	"dojo/topic",
	"dojo/dnd/Manager", // DNDManager.manager
	"./_dndSelector"
], function(array, declare, dndCommon, domClass, domGeometry, lang, on, touch, topic, DNDManager, _dndSelector){

	// module:
	//		dijit/tree/dndSource

	/*=====
	var __Item = {
		// summary:
		//		New item to be added to the Tree, like:
		// id: Anything
		id: "",
		// name: String
		name: ""
	};
	=====*/

	var dndSource = declare("dijit.tree.dndSource", _dndSelector, {
		// summary:
		//		Handles drag and drop operations (as a source or a target) for `dijit.Tree`

		// isSource: Boolean
		//		Can be used as a DnD source.
		isSource: true,

		// accept: String[]
		//		List of accepted types (text strings) for the Tree; defaults to
		//		["text"]
		accept: ["text", "treeNode"],

		// copyOnly: [private] Boolean
		//		Copy items, if true, use a state of Ctrl key otherwise
		copyOnly: false,

		// dragThreshold: Number
		//		The move delay in pixels before detecting a drag; 5 by default
		dragThreshold: 5,

		// betweenThreshold: Integer
		//		Distance from upper/lower edge of node to allow drop to reorder nodes
		betweenThreshold: 0,

		// Flag used by Avatar.js to signal to generate text node when dragging
		generateText: true,

		constructor: function(/*dijit/Tree*/ tree, /*dijit/tree/dndSource*/ params){
			// summary:
			//		a constructor of the Tree DnD Source
			// tags:
			//		private
			if(!params){
				params = {};
			}
			lang.mixin(this, params);
			var type = params.accept instanceof Array ? params.accept : ["text", "treeNode"];
			this.accept = null;
			if(type.length){
				this.accept = {};
				for(var i = 0; i < type.length; ++i){
					this.accept[type[i]] = 1;
				}
			}

			// class-specific variables
			this.isDragging = false;
			this.mouseDown = false;
			this.targetAnchor = null;	// DOMNode corresponding to the currently moused over TreeNode
			this.targetBox = null;	// coordinates of this.targetAnchor
			this.dropPosition = "";	// whether mouse is over/after/before this.targetAnchor
			this._lastX = 0;
			this._lastY = 0;

			// states
			this.sourceState = "";
			if(this.isSource){
				domClass.add(this.node, "dojoDndSource");
			}
			this.targetState = "";
			if(this.accept){
				domClass.add(this.node, "dojoDndTarget");
			}

			// set up events
			this.topics = [
				topic.subscribe("/dnd/source/over", lang.hitch(this, "onDndSourceOver")),
				topic.subscribe("/dnd/start", lang.hitch(this, "onDndStart")),
				topic.subscribe("/dnd/drop", lang.hitch(this, "onDndDrop")),
				topic.subscribe("/dnd/cancel", lang.hitch(this, "onDndCancel"))
			];
		},

		// methods
		checkAcceptance: function(/*===== source, nodes =====*/){
			// summary:
			//		Checks if the target can accept nodes from this source
			// source: dijit/tree/dndSource
			//		The source which provides items
			// nodes: DOMNode[]
			//		Array of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if
			//		source is a dijit/Tree.
			// tags:
			//		extension
			return true;	// Boolean
		},

		copyState: function(keyPressed){
			// summary:
			//		Returns true, if we need to copy items, false to move.
			//		It is separated to be overwritten dynamically, if needed.
			// keyPressed: Boolean
			//		The "copy" control key was pressed
			// tags:
			//		protected
			return this.copyOnly || keyPressed;	// Boolean
		},
		destroy: function(){
			// summary:
			//		Prepares the object to be garbage-collected.
			this.inherited(arguments);
			var h;
			while(h = this.topics.pop()){
				h.remove();
			}
			this.targetAnchor = null;
		},

		_onDragMouse: function(e, firstTime){
			// summary:
			//		Helper method for processing onmousemove/onmouseover events while drag is in progress.
			//		Keeps track of current drop target.
			// e: Event
			//		The mousemove event.
			// firstTime: Boolean?
			//		If this flag is set, this is the first mouse move event of the drag, so call m.canDrop() etc.
			//		even if newTarget == null because the user quickly dragged a node in the Tree to a position
			//		over Tree.containerNode but not over any TreeNode (#7971)

			var m = DNDManager.manager(),
				oldTarget = this.targetAnchor, // the TreeNode corresponding to TreeNode mouse was previously over
				newTarget = this.current, // TreeNode corresponding to TreeNode mouse is currently over
				oldDropPosition = this.dropPosition;	// the previous drop position (over/before/after)

			// calculate if user is indicating to drop the dragged node before, after, or over
			// (i.e., to become a child of) the target node
			var newDropPosition = "Over";
			if(newTarget && this.betweenThreshold > 0){
				// If mouse is over a new TreeNode, then get new TreeNode's position and size
				if(!this.targetBox || oldTarget != newTarget){
					this.targetBox = domGeometry.position(newTarget.rowNode, true);
				}
				if((e.pageY - this.targetBox.y) <= this.betweenThreshold){
					newDropPosition = "Before";
				}else if((e.pageY - this.targetBox.y) >= (this.targetBox.h - this.betweenThreshold)){
					newDropPosition = "After";
				}
			}

			if(firstTime || newTarget != oldTarget || newDropPosition != oldDropPosition){
				if(oldTarget){
					this._removeItemClass(oldTarget.rowNode, oldDropPosition);
				}
				if(newTarget){
					this._addItemClass(newTarget.rowNode, newDropPosition);
				}

				// Check if it's ok to drop the dragged node on/before/after the target node.
				if(!newTarget){
					m.canDrop(false);
				}else if(newTarget == this.tree.rootNode && newDropPosition != "Over"){
					// Can't drop before or after tree's root node; the dropped node would just disappear (at least visually)
					m.canDrop(false);
				}else{
					// Guard against dropping onto yourself or your parent.
					// But when dragging multiple objects, it's OK if some of them are being dropped onto own parent.
					var dropOntoSelf = false,
						dropOntoParent = false;
					if(m.source == this){
						dropOntoParent = (newDropPosition === "Over");
						for(var dragId in this.selection){
							var dragNode = this.selection[dragId];
							if(dragNode.item === newTarget.item){
								dropOntoSelf = true;
								break;
							}
							if(dragNode.getParent().id !== newTarget.id){
								dropOntoParent = false;
							}
						}
					}
					m.canDrop(
						!dropOntoSelf && !dropOntoParent &&
						!this._isParentChildDrop(m.source, newTarget.rowNode) &&
						this.checkItemAcceptance(newTarget.rowNode, m.source, newDropPosition.toLowerCase())
					);
				}

				this.targetAnchor = newTarget;
				this.dropPosition = newDropPosition;
			}
		},

		onMouseMove: function(e){
			// summary:
			//		Called for any onmousemove/ontouchmove events over the Tree
			// e: Event
			//		onmousemouse/ontouchmove event
			// tags:
			//		private
			if(this.isDragging && this.targetState == "Disabled"){
				return;
			}
			this.inherited(arguments);
			var m = DNDManager.manager();
			if(this.isDragging){
				this._onDragMouse(e);
			}else{
				if(this.mouseDown && this.isSource &&
					(Math.abs(e.pageX - this._lastX) >= this.dragThreshold || Math.abs(e.pageY - this._lastY) >= this.dragThreshold)){
					var nodes = this.getSelectedTreeNodes();
					if(nodes.length){
						if(nodes.length > 1){
							//filter out all selected items which has one of their ancestor selected as well
							var seen = this.selection, i = 0, r = [], n, p;
							nextitem: while((n = nodes[i++])){
								for(p = n.getParent(); p && p !== this.tree; p = p.getParent()){
									if(seen[p.id]){ //parent is already selected, skip this node
										continue nextitem;
									}
								}
								//this node does not have any ancestors selected, add it
								r.push(n);
							}
							nodes = r;
						}
						nodes = array.map(nodes, function(n){
							return n.domNode
						});
						m.startDrag(this, nodes, this.copyState(dndCommon.getCopyKeyState(e)));
						this._onDragMouse(e, true);	// because this may be the only mousemove event we get before the drop
					}
				}
			}
		},

		onMouseDown: function(e){
			// summary:
			//		Event processor for onmousedown/ontouchstart
			// e: Event
			//		onmousedown/ontouchend event
			// tags:
			//		private
			this.mouseDown = true;
			this.mouseButton = e.button;
			this._lastX = e.pageX;
			this._lastY = e.pageY;
			this.inherited(arguments);
		},

		onMouseUp: function(e){
			// summary:
			//		Event processor for onmouseup/ontouchend
			// e: Event
			//		onmouseup/ontouchend event
			// tags:
			//		private
			if(this.mouseDown){
				this.mouseDown = false;
				this.inherited(arguments);
			}
		},

		onMouseOut: function(){
			// summary:
			//		Event processor for when mouse is moved away from a TreeNode
			// tags:
			//		private
			this.inherited(arguments);
			this._unmarkTargetAnchor();
		},

		checkItemAcceptance: function(/*===== target, source, position =====*/){
			// summary:
			//		Stub function to be overridden if one wants to check for the ability to drop at the node/item level
			// description:
			//		In the base case, this is called to check if target can become a child of source.
			//		When betweenThreshold is set, position="before" or "after" means that we
			//		are asking if the source node can be dropped before/after the target node.
			// target: DOMNode
			//		The dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to
			//		Use dijit.getEnclosingWidget(target) to get the TreeNode.
			// source: dijit/tree/dndSource
			//		The (set of) nodes we are dropping
			// position: String
			//		"over", "before", or "after"
			// tags:
			//		extension
			return true;
		},

		// topic event processors
		onDndSourceOver: function(source){
			// summary:
			//		Topic event processor for /dnd/source/over, called when detected a current source.
			// source: Object
			//		The dijit/tree/dndSource / dojo/dnd/Source which has the mouse over it
			// tags:
			//		private
			if(this != source){
				this.mouseDown = false;
				this._unmarkTargetAnchor();
			}else if(this.isDragging){
				var m = DNDManager.manager();
				m.canDrop(false);
			}
		},
		onDndStart: function(source, nodes, copy){
			// summary:
			//		Topic event processor for /dnd/start, called to initiate the DnD operation
			// source: Object
			//		The dijit/tree/dndSource / dojo/dnd/Source which is providing the items
			// nodes: DomNode[]
			//		The list of transferred items, dndTreeNode nodes if dragging from a Tree
			// copy: Boolean
			//		Copy items, if true, move items otherwise
			// tags:
			//		private

			if(this.isSource){
				this._changeState("Source", this == source ? (copy ? "Copied" : "Moved") : "");
			}
			var accepted = this.checkAcceptance(source, nodes);

			this._changeState("Target", accepted ? "" : "Disabled");

			if(this == source){
				DNDManager.manager().overSource(this);
			}

			this.isDragging = true;
		},

		itemCreator: function(nodes /*===== , target, source =====*/){
			// summary:
			//		Returns objects passed to `Tree.model.newItem()` based on DnD nodes
			//		dropped onto the tree.   Developer must override this method to enable
			//		dropping from external sources onto this Tree, unless the Tree.model's items
			//		happen to look like {id: 123, name: "Apple" } with no other attributes.
			// description:
			//		For each node in nodes[], which came from source, create a hash of name/value
			//		pairs to be passed to Tree.model.newItem().  Returns array of those hashes.
			// nodes: DomNode[]
			// target: DomNode
			// source: dojo/dnd/Source
			// returns: __Item[]
			//		Array of name/value hashes for each new item to be added to the Tree
			// tags:
			//		extension

			// TODO: for 2.0 refactor so itemCreator() is called once per drag node, and
			// make signature itemCreator(sourceItem, node, target) (or similar).

			return array.map(nodes, function(node){
				return {
					"id": node.id,
					"name": node.textContent || node.innerText || ""
				};
			}); // Object[]
		},

		onDndDrop: function(source, nodes, copy){
			// summary:
			//		Topic event processor for /dnd/drop, called to finish the DnD operation.
			// description:
			//		Updates data store items according to where node was dragged from and dropped
			//		to.   The tree will then respond to those data store updates and redraw itself.
			// source: Object
			//		The dijit/tree/dndSource / dojo/dnd/Source which is providing the items
			// nodes: DomNode[]
			//		The list of transferred items, dndTreeNode nodes if dragging from a Tree
			// copy: Boolean
			//		Copy items, if true, move items otherwise
			// tags:
			//		protected
			if(this.containerState == "Over"){
				var tree = this.tree,
					model = tree.model,
					target = this.targetAnchor;

				this.isDragging = false;

				// Compute the new parent item
				var newParentItem;
				var insertIndex;
				var before;		// drop source before (aka previous sibling) of target
				newParentItem = (target && target.item) || tree.item;
				if(this.dropPosition == "Before" || this.dropPosition == "After"){
					// TODO: if there is no parent item then disallow the drop.
					// Actually this should be checked during onMouseMove too, to make the drag icon red.
					newParentItem = (target.getParent() && target.getParent().item) || tree.item;
					// Compute the insert index for reordering
					insertIndex = target.getIndexInParent();
					if(this.dropPosition == "After"){
						insertIndex = target.getIndexInParent() + 1;
						before = target.getNextSibling() && target.getNextSibling().item;
					}else{
						before = target.item;
					}
				}else{
					newParentItem = (target && target.item) || tree.item;
				}

				// If necessary, use this variable to hold array of hashes to pass to model.newItem()
				// (one entry in the array for each dragged node).
				var newItemsParams;

				array.forEach(nodes, function(node, idx){
					// dojo/dnd/Item representing the thing being dropped.
					// Don't confuse the use of item here (meaning a DnD item) with the
					// uses below where item means dojo.data item.
					var sourceItem = source.getItem(node.id);

					// Information that's available if the source is another Tree
					// (possibly but not necessarily this tree, possibly but not
					// necessarily the same model as this Tree)
					if(array.indexOf(sourceItem.type, "treeNode") != -1){
						var childTreeNode = sourceItem.data,
							childItem = childTreeNode.item,
							oldParentItem = childTreeNode.getParent().item;
					}

					if(source == this){
						// This is a node from my own tree, and we are moving it, not copying.
						// Remove item from old parent's children attribute.
						// TODO: dijit/tree/dndSelector should implement deleteSelectedNodes()
						// and this code should go there.

						if(typeof insertIndex == "number"){
							if(newParentItem == oldParentItem && childTreeNode.getIndexInParent() < insertIndex){
								insertIndex -= 1;
							}
						}
						model.pasteItem(childItem, oldParentItem, newParentItem, copy, insertIndex, before);
					}else if(model.isItem(childItem)){
						// Item from same model
						// (maybe we should only do this branch if the source is a tree?)
						model.pasteItem(childItem, oldParentItem, newParentItem, copy, insertIndex, before);
					}else{
						// Get the hash to pass to model.newItem().  A single call to
						// itemCreator() returns an array of hashes, one for each drag source node.
						if(!newItemsParams){
							newItemsParams = this.itemCreator(nodes, target.rowNode, source);
						}

						// Create new item in the tree, based on the drag source.
						model.newItem(newItemsParams[idx], newParentItem, insertIndex, before);
					}
				}, this);

				// Expand the target node (if it's currently collapsed) so the user can see
				// where their node was dropped.   In particular since that node is still selected.
				this.tree._expandNode(target);
			}
			this.onDndCancel();
		},

		onDndCancel: function(){
			// summary:
			//		Topic event processor for /dnd/cancel, called to cancel the DnD operation
			// tags:
			//		private
			this._unmarkTargetAnchor();
			this.isDragging = false;
			this.mouseDown = false;
			delete this.mouseButton;
			this._changeState("Source", "");
			this._changeState("Target", "");
		},

		// When focus moves in/out of the entire Tree
		onOverEvent: function(){
			// summary:
			//		This method is called when mouse is moved over our container (like onmouseenter)
			// tags:
			//		private
			this.inherited(arguments);
			DNDManager.manager().overSource(this);
		},
		onOutEvent: function(){
			// summary:
			//		This method is called when mouse is moved out of our container (like onmouseleave)
			// tags:
			//		private
			this._unmarkTargetAnchor();
			var m = DNDManager.manager();
			if(this.isDragging){
				m.canDrop(false);
			}
			m.outSource(this);

			this.inherited(arguments);
		},

		_isParentChildDrop: function(source, targetRow){
			// summary:
			//		Checks whether the dragged items are parent rows in the tree which are being
			//		dragged into their own children.
			//
			// source:
			//		The DragSource object.
			//
			// targetRow:
			//		The tree row onto which the dragged nodes are being dropped.
			//
			// tags:
			//		private

			// If the dragged object is not coming from the tree this widget belongs to,
			// it cannot be invalid.
			if(!source.tree || source.tree != this.tree){
				return false;
			}


			var root = source.tree.domNode;
			var ids = source.selection;

			var node = targetRow.parentNode;

			// Iterate up the DOM hierarchy from the target drop row,
			// checking of any of the dragged nodes have the same ID.
			while(node != root && !ids[node.id]){
				node = node.parentNode;
			}

			return node.id && ids[node.id];
		},

		_unmarkTargetAnchor: function(){
			// summary:
			//		Removes hover class of the current target anchor
			// tags:
			//		private
			if(!this.targetAnchor){
				return;
			}
			this._removeItemClass(this.targetAnchor.rowNode, this.dropPosition);
			this.targetAnchor = null;
			this.targetBox = null;
			this.dropPosition = null;
		},

		_markDndStatus: function(copy){
			// summary:
			//		Changes source's state based on "copy" status
			this._changeState("Source", copy ? "Copied" : "Moved");
		}
	});

	/*=====
	dndSource.__Item = __Item;
	=====*/

	return dndSource;
});

},
'pepper/tinymce/_DialogLauncherMixin':function(){
define([
    'lodash',
    'vodori/provide', 'module',
    'dojo/_base/lang', 'dojo/Deferred',
    'vodori/util/string/capitalize'
], function (_, provide, module, lang, Deferred, capitalize) {
    return provide(module.id, null, {
        /**
         * @type {tinymce.Editor}
         */
        editor: null,

        /**
         * Name of the current plugin.
         *
         * @type {string}
         */
        pluginName: '',

        /**
         * Setting for the dialog button.
         *
         * @see: tinymce.Editor.addButton
         * @type {Object}
         */
        dialogButtonSettings: null,

        /**
         * @protected
         * @type {dijit.Dialog}
         */
        _dialogConstructor: null,

        /**
         * @protected
         * @type {Object}
         */
        _dialogArguments: null,

        /**
         * The return value of tinymce.Editor.selection.getBookmark
         *
         * @type {{id:string}}
         */
        _bookmark: null,

        init: function () {
            this.inherited(arguments);
            this.addDialogButton();
        },

        /**
         * Add the dialog button with reasonable default settings.
         *
         * @return {void}
         */
        addDialogButton: function () {
            var cappedName = capitalize(this.pluginName);

            // Setup some defaults.
            var buttonSettings = this.dialogButtonSettings = lang.mixin({
                label: cappedName,
                title: 'Open the ' + cappedName + ' dialog.',
                cmd: 'mce_open' + cappedName + 'Dialog'
            }, this.dialogButtonSettings);

            // Add button to the toolbar.
            this.editor.addButton(this.pluginName + '_dialog', buttonSettings);

            // Add a command to open the dialog.
            this.editor.addCommand(buttonSettings.cmd, this.showDialog, this);
        },

        /**
         * Launch `dijit.Dialog`s in a standard way.
         *
         * @return {dojo.Deferred}
         */
        showDialog: function (ed, params) {
            // Cache the current selection safely.
            if (this.saveSelection) {
                this.saveSelection();
            }

            var dialogArgs;

            if(_.isObject(params)){
                dialogArgs = lang.mixin({
                    editor: this.editor
                }, params, this._dialogArguments);
            } else {
                dialogArgs = lang.mixin({
                    editor: this.editor
                }, this._dialogArguments);
            }

            var dialog = new this._dialogConstructor(dialogArgs);
            dialog.startup();
            dialog.show();

            var def = new Deferred();
            var handle = dialog.on('hide', lang.hitch(this, function () {
                handle.remove();
                this.editor.focus();

                // Restore the preexisting selection
                this.restoreSelection();

                def.resolve(this);
            }));

            return def;
        }
    });
});

},
'pepper/tinymce/ThemeChanger':function(){
define([
    'vodori/amd/tinymce',
    'vodori/provide', 'module',
    'vodori/tinymce/util/getResourceUrl', 'vodori/tinymce/util/getPluginName',
    'pepper/dialogs/ThemeChanger', './_DialogLauncherMixin', 'vodori/tinymce/_Selection', 'vodori/tinymce/_GetInfoMixin'
], function (tinymce,
             provide, module,
             getResourceUrl, getPluginName,
             ThemeChangerDialog, _DialogLauncherMixin, _Selection, _GetInfoMixin) {

    var pluginName = getPluginName(module);

    var plugin = provide(module.id, [_DialogLauncherMixin, _Selection, _GetInfoMixin], {
        /**
         * {@inheritDoc}
         */
        pluginName: pluginName,

        /**
         * {@inheritDoc}
         */
        _dialogConstructor: ThemeChangerDialog,

        /**
         * @type {tinymce.Editor}
         */
        editor: null,

        init: function (ed) {
            this.editor = ed;
            this.inherited(arguments);
        },

        addDialogButton: function () {
            this.editor.addCommand("mce_openThemeChangerDialog", this.showDialog, this);
        }
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;

});

},
'pepper/dialogs/ThemeChanger':function(){
define([
    'require',
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang',
    'dojo/dom-class',
    'dijit/layout/ContentPane',
    'vodori/amd/tinymce',
    'vodori/input/GroupedSelect',
    'vodori/renderTemplate',
    'pepper/ui/LazyDialog',
    'dojo/text!./templates/ThemeChanger-details.html',
    'dojo/text!./templates/ThemeChanger-default-state.html',
    /* Unreferenced MIDs */
    'dojo/text!./templates/ThemeChanger-content.html',
    'dijit/layout/BorderContainer',
    'vodori/ui/Tree',
    'pepper/ui/FormProxyPane',
    'vodori/ui/Button'
], function (require,
             provide, module,
             _,
             lang,
             domClass,
             ContentPane,
             tinymce,
             GroupedSelect,
             renderTemplate,
             LazyDialog,
             details,
             defaultState) {
    /**
     * @class pepper/dialogs/ThemeChanger
     * @extends pepper/ui/LazyDialog
     */
    return provide(module.id, [LazyDialog],
        /**
         * @lends pepper/dialogs/ThemeChanger#
         */
        {

            /**
             * @type {string}
             */
            baseClass: 'pepperTemplateThemeChangerDialog',

            /**
             * This is setup in WysiwygConfig.js
             *
             * @type {Array.<Object>}
             */
            themeDefinitions: null,

            /**
             * @type {string}
             */
            title: 'Stamp Themes',

            /**
             * @type {boolean}
             */
            resizable: true,

            /**
             * @type {boolean}
             */
            destroyOnHide: true,

            /**
             * Set in vodori.tinymce.ThemeChanger
             *
             * @type {tinymce.create.Editor}
             */
            editor: null,

            /**
             * @type {Widget}
             */
            widgetOfInterest: null,

            /**
             * @type {vodori.ui.Tree}
             */
            categoriesTree: null,

            /**
             * @type {Element}
             */
            contentHref: require.toUrl('./templates/ThemeChanger-content.html'),

            /**
             * @type {vodori.input.GroupedSelect}
             */
            themeSelect: null,

            /**
             * @type {pepper.ui.FormProxyPane}
             */
            themeProperties: null,

            _buttonMappings: {
                'cancelButton': 'onCancel',
                'insertButton': 'insertTheme'
            },

            /**
             * @type {Array.<Object>}
             */
            themeCategory: null,

            /**
             * @type {Object.<string>}
             */
            theme: null,

            /**
             * @type {Array.<vodori.input.Wysiwyg>}
             */
            wysiwygs: null,

            /**
             * @constructs
             * @mixes pepper/ui/LazyDialog_
             */
            constructor: function () {
                this.wysiwygs = [];
                this.theme = {};
                this.themeCategory = [];
            },

            startup: function () {
                this.inherited(arguments);

                this.lazyOn('themeSelect', 'change', lang.hitch(this, function (themes) {
                    this._setThemeAttr(themes[0]);
                }));
                this.lazyOn('categoriesTree', 'change', lang.hitch(this, '_setThemeCategoryAttr'));

                this.lazy(function () {
                    var themes = this.themeDefinitions = this.editor.getParam('themeConfig');
                    this.categoriesTree.set('data', _.map(themes, function (def) {
                        def.id = def.id || 'CATEGORY_' + String(+(new Date()));
                        return def;
                    }));

                    this.initTemplateSelect();
                });
            },

            /**
             * @return {void}
             */
            insertTheme: function () {

                if(this.widgetOfInterest){
                    this.widgetOfInterest.applyTheme(this.theme);
                }

                this.hide();
            },

            /**
             * @return {string}
             */
            initTemplateSelect: function () {
                this.lazy(function () {
                    // Clear out any existing options
                    this.themeSelect.set('options', []);

                    // Include the thumbnail in the label
                    this.themeSelect.labelTemplate = ([
                        '<img src="${thumbnail}" class="thumb" />',
                        '<span class="label">${label}</span>'
                    ]).join('\n');
                    return this.themeSelect.labelTemplate;
                });
            },

            /**
             * @param {Array.<Object>} themeCategory
             * @return {T}
             * @private
             */
            _setThemeCategoryAttr: function (themeCategory) {
                var options = [];
                _.forEach(themeCategory, function (category) {
                    this.themeCategory = category;

                    _.forEach(category.themes, function (theme, index) {
                        options.push({
                            value: theme.id,
                            label: theme.label,
                            thumbnail: theme.thumbnail || '',
                            selected: !index
                        });
                    }, this);
                }, this);

                if (this.themeSelect instanceof GroupedSelect) {
                    this.themeSelect.set('options', options);
                }

                return this;
            },

            /**
             * @param {Object.<string>?} theme
             * @return {T}
             * @private
             */
            _setThemeAttr: function (theme) {

                this.lazy(function () {
                    theme = (this.theme = this._getThemeById(theme));

                    var template = theme.id ? details : defaultState;

                    if (this.themeProperties instanceof ContentPane) {
                        this.themeProperties.set(
                            'content',
                            renderTemplate(template, theme));
                    }
                });

                return this;
            },

            /**
             * Find a themes configuration based on its ID. (Needed to support
             * GroupedSelect).
             *
             * @param {string} id
             * @return {Object}
             * @private
             */
            _getThemeById: function (id) {
                var themes = this.themeCategory.themes;

                if (!themes || !themes.length) {
                    return {};
                }

                var current = {};
                for (var i = 0, len = themes.length; i < len; ++i) {
                    current = themes[i];
                    if (current.id && current.id === id) {
                        return current;
                    }
                }

                return {};
            }

        });
});

},
'pepper/tinymce/VodoriVideo':function(){
define([
    'vodori/provide', 'module',
    'dojo/_base/lang',
    'dojo/dom-attr', 'dojo/dom-class',
    'dojo/on', 'dojo/query',
    'vodori/amd/tinymce',
    'vodori/video/VideoPlayer',
    'vodori/tinymce/ConfigurableTransformer',
    'vodori/tinymce/util/augmentWithLoader',
    'vodori/tinymce/util/getResourceUrl',  'vodori/tinymce/util/getPluginName',
    'vodori/util/objectToProps', 'vodori/util/propsToObject',
    'pepper/library/LibraryDialog', 'pepper/library/FilterOverrideLibrary',
    'dojo/NodeList-dom'
], function (
    provide, module,
    lang,
    domAttr, domClass,
    on, query,
    tinymce,
    VideoPlayer,
    ConfigurableTransformer,
    augmentWithLoader,
    getResourceUrl, getPluginName,
    objectToProps, propsToObject,
    LibraryDialog, FilterOverrideLibrary
    ) {
    var pluginName = getPluginName(module);

    var resourceUrl = getResourceUrl(module);

    var plugin = provide(module.id, [ConfigurableTransformer], {

        dijitDeclaredClass: VideoPlayer.prototype.declaredClass,

        url: resourceUrl,
        resourceUrl: resourceUrl,

        pluginName: pluginName,

        title: 'Video',

        placeholderClass: 'mceVideoPlaceholder',
        placeholderWidth: 100,
        placeholderHeight: 100,

        popupWidth: 500,
        popupHeight: 550,
        popupOnCreate: true,

        wrapperTagName: 'div',
        placeHolderWrapperTagName: 'img',

        frameWindow: null,
        modal: null,

        button: {
            label: '',
            image: 'img/television.png',
            title: 'Insert a video player.',
            changeStates: {
                highlight: [pluginName],
                enable: [],
                disable: []
            }
        },

        styleSheet: true,

        defaultAttrs: {
            videoTitle: '',
            videoHeight: '480',
            videoWidth: '720',
            videoSrc: resourceUrl + '/_test/video/barsandtone.flv',
            autoPlay: false,
            playInline: false,
            imgSrc: '',
            imgHeight: '',
            imgWidth: ''
        },

        init: function(){
            this.inherited(arguments);

            // When the editor deactivates we can remove any 'selected' classes from their video player widgets
            var _this = this;
            this.editor.onDeactivate.add(function(){
                _this.removeSelectedHighlighting(this);
            });
        },

        popupOptionsFor:function (wrapper, isInitial) {
            var ed = this.editor;

            var modal = this.modal = ed.windowManager.open({
                file: this.resourceUrl + '/vodorivideo.htm',
                width:this.popupWidth + ed.getLang('iframe.delta_width', 0),
                height:this.popupHeight + ed.getLang('iframe.delta_height', 0),
                inline:1
            }, {
                plugin:this,
                wrapper:wrapper,
                attrs:propsToObject(domAttr.get(wrapper, 'data-dojo-props')),
                isInitial: isInitial
            });

            this.frameWindow = modal.iframeElement.get().contentWindow;

            augmentWithLoader(modal);

            this.connectBrowse();
        },

        connectBrowse: function () {
            this.modal.require([
                'dojo/_base/lang', 'dojo/on', 'dojo/parser', 'dojo/query',
                'vodori/ui/Button', 'dojo/domReady!'
            ], lang.hitch(this, function (lang, on, parser, query) {
                parser.parse({template:false});

                var imageBrowseButton = query('.img_browse').pop();
                on(imageBrowseButton, 'click', lang.hitch(this, function () {
                    this.toggleModal(false);
                    this.browsePepper('Image');
                }));

                var videoBrowseButton = query('.vid_browse').pop();
                on(videoBrowseButton, 'click', lang.hitch(this, function () {
                    this.toggleModal(false);
                    this.browsePepper('Video');
                }));
            }));
        },

        _updatePlaceHolderAttrs: function(wrapperNode) {
            var properties = {};
            if(wrapperNode) {
                properties =  propsToObject(domAttr.get(wrapperNode, 'data-dojo-props'));
            }
            properties = lang.mixin({}, this.defaultAttrs, properties);

            // Set the height and width for the editing-mode placeholder image
            if (properties.playInline){
                // If we're playing the video inline use the video's height and width
                this.placeholderWidth   = properties.videoWidth;
                this.placeholderHeight  = properties.videoHeight;
            }
            // Override though if we have a placeholder image
            if (properties.imgWidth !== '' ) {
                this.placeholderWidth = properties.imgWidth;
            }
            if (properties.imgHeight !== ''){
                this.placeholderHeight = properties.imgHeight;
            }

            this.placeHolderAttrs = {
                'style': 'width: '  + this.placeholderWidth + 'px;' +
                    'height: ' + this.placeholderHeight + 'px; overflow:hidden;',
                'class': 'mceItem'
            };
        },

        /**
         * @param {tinymce.Editor} ed
         * @param {tinymce.ControlManager} cm
         * @param {Element} n
         * @return {void}
         */
        handleNodeChange: function(ed, cm, n) {
            if (domClass.contains(n,'vodori_video_VideoPlayer')){
                domClass.add(n,'vodoriVideoSelected');
            } else {
                this.removeSelectedHighlighting(ed);
            }
        },

        removeSelectedHighlighting: function(ed){
            query('.vodoriVideoSelected',ed.getBody()).forEach(function(node,index,arr){
                domClass.remove(node, 'vodoriVideoSelected');
            });
        },

        /**
         * @param {tinymce.Editor} ed
         * @param {Element} node
         * @return {Array.<Element>}
         */
        convertToWidgets: function (ed, node) {
            var wrappers = this.inherited(arguments);
            var dom = tinymce.DOM;
            tinymce.each(wrappers, function (wrapper) {
                var props = propsToObject(domAttr.get(wrapper, 'data-dojo-props'));
                dom.setAttribs(wrapper, {
                    style: 'height:' + this.videoHeight +
                        'width:'  + this.videoWidth,
                    src: this.videoSrc,
                    'data-dojo-props': objectToProps(props)
                });
            });
            return wrappers;
        },

        /**
         * Hide or show the tinymce modal associated with this plugin.
         *
         * @param {boolean?} show
         * @return {void}
         */
        toggleModal: function (show) {
            var blocker = query('#mceModalBlocker');
            if (this.modal.isHidden || show) {
                this.modal.element.show();
                blocker.style('display', 'block');
            } else {
                this.modal.element.hide();
                blocker.style('display', 'none');
            }
        },

        /**
         * Launch the browser and wait for a response.
         *
         * @param {String} type will default the library to the correct file type
         *                  (in this case, it'll likely be 'Image' or 'Video')
         * @return {void}
         */
        browsePepper: function (type) {
            var modal = new LibraryDialog({
                widget: new FilterOverrideLibrary({
                    readOnly: true,
                    resultsGridView: 'grid',
                    libraryFilterOverrides: [
                        {
                            'widget': 'pepper/library/filter/ui/ContentType',
                            'filterData': {
                                'default': type
                            }
                        },
                        {
                            'filterData': {
                                'exclude': ['Reception']
                            },
                            'widget': 'pepper/library/filter/ui/StateVersion'
                        }
                    ],
                    confirmHandler: lang.hitch(this, function(selection) {
                        this.setPepperObject(selection.pop() || {}, type);
                        this.toggleModal(true);
                    })
                }),
                onHide: lang.hitch(this, function() {
                    this.toggleModal(true);
                })
            });
            modal.startup();
            modal.show();
        },

        /**
         * @param {Object} pepperObject the first selection
         * @param {string} type will dictate which form input to update
         * @return {void}
         */
        setPepperObject: function (pepperObject, type) {
            var forms = query('form', this.frameWindow.document.body);

            // Might as well support more than one form.
            forms.forEach(function (form) {
                if( type === 'Image') {
                    form.imgSrc.value = pepperObject.pathInCurrentSubscription || '';
                    form.imgSrc.onchange();
                }
                if( type === 'Video') {
                    form.videoSrc.value = pepperObject.pathInCurrentSubscription || '';
                    form.videoSrc.onchange();
                }
            }, this);
        }

    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'vodori/tinymce/StickyHeader':function(){
define([
    '../ui/StickyHeader',
    'vodori/tinymce/ConfigurableTransformer',
    'vodori/amd/tinymce',
    'module',
    'vodori/provide',
    'vodori/tinymce/util/getPluginName',
    'vodori/tinymce/util/getResourceUrl'
], function (StickyHeaderWidget, ConfigurableTransformer, tinymce, module, provide, getPluginName, getResourceUrl) {
    var pluginName = getPluginName(module);

    /**
     * This module is for sticky headers that, as you scroll past them will stack at the top of the window.
     * @type {*}
     */
    var plugin = provide(module.id, [ConfigurableTransformer], {

        dijitDeclaredClass: StickyHeaderWidget.prototype.declaredClass,

        url: getResourceUrl(module),
        pluginName: pluginName,

        wrapperTagName: 'div',
        loremIpsum: 'Sticky Header',

        defaultAttrs: {

        },

        styleSheet: false
    });

    tinymce.PluginManager.add(pluginName, plugin);

    return plugin;
});

},
'vodori/ui/StickyHeader':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang',
    'dojo/dom-style', 'dojo/dom-class', 'dojo/dom-attr', 'dojo/dom-geometry',
    'dojo/Evented',
    'dijit/_WidgetBase',
    'vodori/ui/stickyheader/StickyHeaderManager'
], function (module, provide,
             _,
             lang,
             domStyle, domClass, domAttr, domGeometry,
             Evented,
             _WidgetBase,
             StickyHeaderManager) {

    return provide(module.id, [_WidgetBase, Evented], {

        isHidden: true,
        originalZ: 0,
        originalPosition: 0,
        nodeHeight: 0,
        isSticky: false,
        manager: new StickyHeaderManager(),

        startup: function () {
            this.resize();
            this.inherited(arguments);
        },

        resize: function () {
            this.inherited(arguments);

            var nodePosition = domGeometry.position(this.domNode, true);

            //Get original position
            this.originalPosition = nodePosition.y;

            //Get original z index
            this.originalZ = domAttr.get(this.domNode, 'zIndex');

            //Get height of node
            this.nodeHeight = nodePosition.h;
        },

        postCreate: function () {
            /*
             The manager is created as part of the prototype, therefore we do not need to search for it.
             We then register ourselves with the manager.  That manager manages all sticky headers on the page.
             */
            this.inherited(arguments);
            this.own(this.manager.register(this));
        },

        testHidden: function () {
            //determine hiddenness
            var isHiddenTestMessage = 'isHiddenTest must be a function or an array of functions';
            if (typeof this.isHiddenTest === 'function') {
                this.isHiddenTest();
            } else if (typeof this.isHiddenTest === 'object') {
                if (this.isHiddenTest instanceof Array) {
                    _.forEach(this.isHiddenTest, function (test) {
                        test(); //run each of the functions to test whether or not this node is hidden
                    });
                } else {
                    console.log(isHiddenTestMessage);
                }
            } else {
                console.log(isHiddenTestMessage);
            }
        },

        isHiddenTest: function () {
            //check for the basic display:none or display:hidden on this node or any of its parents
            var visibility = null;
            //check me
            visibility = domStyle.get(this.domNode, 'display');
            if (visibility !== 'hidden' && visibility !== 'none') {
                //check the parents for visibility
                var currentNode = this.domNode;
                do {
                    currentNode = currentNode.parentNode;
                    //Check that the current node exists, and you haven't just grabbed the document node
                    if (currentNode && currentNode.parentNode) {
                        visibility = domStyle.get(currentNode, 'display');
                    }
                } while (currentNode && visibility !== 'hidden' && visibility !== 'none');
                if (visibility !== 'hidden' && visibility !== 'none') {

                    this.emit('visible', {
                        bubbles: true,
                        cancelable: true,
                        header: this,
                        type: 'visible'
                    });
                    this.isHidden = false;

                    return this.isHidden;
                } else {

                    this.emit('hidden', {
                        bubbles: true,
                        cancelable: true,
                        header: this,
                        type: 'hidden'
                    });
                    this.isHidden = true;

                }


            } else {

                this.emit('visible', {
                    bubbles: true,
                    cancelable: true,
                    header: this,
                    type: 'visible'
                });
                this.isHidden = false;

            }
            return this.isHidden;
        }

    });

});

},
'vodori/ui/stickyheader/StickyHeaderManager':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/_base/window', 'dojo/on',
    'dojo/window',  //Differs from dojo/_base/window
    'dojo/dom-class', 'dojo/query', 'dojo/dom-style', 'dojo/dom-construct', 'dojo/dom-geometry',
    'dijit/_WidgetBase'
],
    function (module, provide,
              _,
              lang, baseWin, on,
              win,
              domClass, query, domStyle, domConstruct, domGeom,
              _WidgetBase) {
        return provide(module.id, [_WidgetBase], {

            /**
             *
             * @class Manages the Filters inside a DOM region
             */
            stickyHeaders: null,
            interval: 20,
            expandableElement: null,
            calculatedTop: 0,
            heightToAdd: 0,


            /**
             * Used to track whether a node should pinned to the top of the page.
             * This is used exclusively for hidden items that need to track their stickiness for getting the proper
             * class when made visible.
             *
             * @const
             * @type {string}
             */
            STUCK: 'stuck',

            /**
             * Used to track whether a node should pinned to the top of the page.
             * This class is applied to nodes that are sticky and should stick to the top of the page.
             *
             * @const
             * @type {string}
             */
            STICKY: 'sticky',

            constructor: function () {
                this.stickyHeaders = [];

            },

            postCreate: function () {
                this.inherited(arguments);
                this.expandableElement = domConstruct.create('div', {'class': 'expand'}, baseWin.body(), 'first');
                setInterval(lang.hitch(this, 'updateVisibility'), this.interval);
            },

            /**
             * Registers a stickyHeader
             * @param {abbott.ui.headers.StickyHeader} header The StickyHeader to register with the StickyHeaderManager
             * @return {{ remove : Function }} A handle - this can remove the header registration
             */
            register: function (header) {

                this.stickyHeaders.push(header);

                var toRemove = _.map([
                    {event: 'enabled, disabled', handler: 'toggleHeader'},
                    {event: 'visible, hidden', handler: 'handleHeader'}
                ],
                    function (def) {
                        return on(header, def.event, lang.hitch(this, def.handler));
                    }, this);

                var remove = function (toRemove, header) {
                    _.forEach(toRemove, function (handler) {
                        handler.remove();
                    }, this);
                    this.stickyHeaders = _.filter(this.stickyHeaders, function (currentHeader) {
                        return currentHeader !== header;
                    });
                };

                return {
                    unregister: lang.hitch(this, remove, toRemove, header),
                    remove: lang.hitch(this, remove, toRemove, header)
                };
            },

            updateVisibility: function () {
                _.forEach(this.stickyHeaders, function (stickyHeader) {
                    stickyHeader.testHidden();
                });
            },

            toggleHeader: function (evt) {
                var node = evt.header.domNode;
                if (evt.type === 'enabled') {
                    domClass.remove(node, 'disabled');
                    domStyle.set(this.expandableElement, 'display', 'block');
                } else {
                    domClass.add(node, 'disabled');
                    domStyle.set(this.expandableElement, 'display', 'none');
                }
            },

            handleHeader: function (evt) {
                var node = evt.header.domNode;
                var nodeHeight = evt.header.nodeHeight;
                var shouldStick = this.nodeShouldStick(evt.header);
                var expandableHeight = domStyle.get(this.expandableElement, 'height');

                if (shouldStick) {
                    evt.header.isSticky = true;
                    if (evt.type === 'visible') {
                        expandableHeight = this.handleVisibleHeader(node, nodeHeight, expandableHeight);
                    } else {
                        expandableHeight = this.handleHiddenHeader(node, nodeHeight, expandableHeight);
                    }
                    domStyle.set(this.expandableElement, 'height', expandableHeight + 'px');
                } else {
                    evt.header.isSticky = false;
                    if (domClass.contains(node, 'sticky')) {
                        expandableHeight = expandableHeight - nodeHeight;
                        domStyle.set(this.expandableElement, 'height', expandableHeight + 'px');
                        domStyle.set(node, 'top', '');
                    }
                    domClass.remove(node, 'stuck');
                    domClass.remove(node, 'sticky');
                }
            },

            handleVisibleHeader: function (node, nodeHeight, expandableHeight) {
                domClass.remove(node, 'stuck');
                if (!domClass.contains(node, 'sticky')) {
                    domClass.add(node, 'sticky');
                    //add to the expandable element, and push the node down the correct amount
                    expandableHeight = expandableHeight + nodeHeight;
                    domStyle.set(node, 'top', this.heightToAdd + 'px');
                }
                return expandableHeight;
            },

            handleHiddenHeader: function (node, nodeHeight, expandableHeight) {
                if (domClass.contains(node, 'sticky')) {
                    //remove to the expandable element the amount that is about to be hidden
                    expandableHeight = expandableHeight - nodeHeight;
                }
                domClass.remove(node, 'sticky');
                domClass.add(node, 'stuck');
                return expandableHeight;
            },

            nodeShouldStick: function (node) {
                var top = win.getBox().t;
                //Get the position of all headers that are sticky and visible, and their heights
                //Calculate where the new top is
                this.calculatedTop = top();
                this.heightToAdd = 0;

                query('.sticky').forEach(lang.hitch(this, function (stickyNode) {
                    this.calculatedTop = this.calculatedTop + domGeom.position(stickyNode, true).h;
                    this.heightToAdd = this.heightToAdd + domGeom.position(stickyNode, true).h;
                }));

                if (node.isSticky) {
                    this.calculatedTop = this.calculatedTop - node.nodeHeight;
                    this.heightToAdd = this.heightToAdd - node.nodeHeight;
                }

                return (this.calculatedTop >= node.originalPosition);
            }
        });
    });

},
'abbott/editorConfigs/distributorPortalConfigs':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+stamperConfig': [
            {
                "id": "dp-welcome-stamps",
                "label": "Welcome",
                "stamps": [
                    {
                        "id": "dp_rotator_slide_stamp",
                        "label": "Rotator Slide",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/distributorPortal/dp-rotator-slide-stamp.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/distributorPortal/dp_rotator_slide_stamp.html",
                        "description": "Rotator slide stamp for the rotator on the Partners Portal \"Welcome\" page."
                    }
                ]
            },{
                "id": "dp-events-stamps",
                "label": "Events and Conferences",
                "stamps": [
                    {
                        "id": "dp_event_stamp",
                        "label": "Event",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/distributorPortal/dp-event-stamp.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/distributorPortal/dp_event.html",
                        "forbidden_ancestors": ['*'],
                        "description": "Event stamp for the Partners Portal \"Events and Conferences\" page."
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/amBannerConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+stamperConfig': [
            {
                "id": "am-banner",
                "label": "Banners",
                "stamps": [
                    {
                        "id": "am_banner",
                        "label": "Banner with text",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/banner-stamp.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/banner.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays the banner image and text."
                    }
                ]
            }
        ]
    }));
});

},
'abbott/editorConfigs/amThinBannerConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+stamperConfig': [
            {
                "id": "am-banner",
                "label": "Banners",
                "stamps": [
                    {
                        "id": "am_thin_banner",
                        "label": "Thin banner with text",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/banner-thin-stamp.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/banner-thin.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays the banner image and text."
                    },{
                        "id": "tab_columns",
                        "label": "Tab Columns",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/tab-columns.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/tab-columns.html",
                        "description": "This stamp generates one or more tab columns.",
                        "container": ".tab-columns--tabs",
                        "forbidden_ancestors": ['']
                    }
                ]
            }
        ]
    }));
});

},
'abbott/editorConfigs/amAboutUsConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+stamperConfig': [
            {
                "id": "am-about-us-stamps",
                "label": "About Us",
                "stamps": [
                    {
                        "id": "aboutus_locations_intro",
                        "label": "Headquarters Info",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/aboutus/aboutus_locations_intro.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/aboutus/aboutus_locations_intro.html",
                        "description":"Headquarters info. Headline and text on left, large image on right." ,
                        "forbidden_ancestors": ['.post']
                    },{
                        "id": "aboutus_locations_card",
                        "label": "Location Info",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/aboutus/aboutus_locations_card.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/aboutus/aboutus_locations_card.html",
                        "description":"Location info. Subhead and copy." ,
                        "forbidden_ancestors": ['.box']
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/amProductDetailConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+stamperConfig': [
            {
                "id": "am-product-detail-stamps",
                "label": "Product Detail",
                "stamps": [
                    {
                        "id": "am_sticky_nav_section",
                        "label": "Sticky Navigation Section",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/sticky-navigation-section.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/sticky-navigation/sticky-navigation-section.html",
                        "description":"Sticky navigation section. When added, the section title will be added to the left, sticky navigation." ,
                        "forbidden_ancestors": ['div']
                    },{
                        "id": "am_package_insert",
                        "label": "Package Insert Link",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/package-insert-link.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/package-insert-link.html",
                        "description":"Package insert link.",
                        "forbidden_ancestors": ['*']
                    },{
                        "id": "am_table",
                        "label": "Styled Table",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/table-stamp.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/table.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays a styled table."
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/amProductsLandingConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+stamperConfig': [
            {
                "id": "am-products-landing",
                "label": "Products Landing",
                "stamps": [
                    {
                        "id": "am_products_landing_two_col_four_row",
                        "label": "Products Landing Main Two Column by Four Rows",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/products-landing/products-landing-two-col-four-row.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/products-landing/products-landing-two-col-four-row.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays a column of products by disease and another by technology."
                    },
                    {
                        "id": "am_products_landing_quick_lins",
                        "label": "Products Landing Quick Links",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/products-landing/products-landing-quick-links.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/products-landing/products-landing-quick-links.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays a four column stamp for quick links."
                    },
                    {
                        "id": "am_products_landing_main_two",
                        "label": "Products Landing Main Two Column",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/landing-block-stamp-two.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/products-landing/products-landing-main-two.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays two callouts with images and bottom captions."
                    },{
                        "id": "am_products_landing_main_one",
                        "label": "Products Landing Main One Column",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/landing-block-stamp-one.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/products-landing/products-landing-main-one.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays a callout with an image and a bottom caption."
                    },{
                        "id": "am_products_landing_callout",
                        "label": "Products Landing Callout",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/products-landing/callout-stamp.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/products-landing/products-landing-callout.html",
                        "forbidden_ancestors": ['*'],
                        "description": "Products Landing Callout"
                    }
                ]
            }
        ]
    }));
});

},
'abbott/editorConfigs/amEventsAndConferencesConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+stamperConfig': [
            {
                "id": "am-events-and-conferences-stamps",
                "label": "Events & Conferences",
                "stamps": [
                    {
                        "id": "events-and-conferences-month",
                        "label": "Month and Year",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/aboutus/events-and-conferences-month.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/aboutus/events-and-conferences-month.html",
                        "description":"This stamp displays a month and year with one event." ,
                        "forbidden_ancestors": ['.post']
                    },{
                        "id": "events-and-conferences-event",
                        "label": "Event",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/aboutus/events-and-conferences-event.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/aboutus/events-and-conferences-event.html",
                        "description":"This stamp displays a new event and is recommended to be placed under the 'Month and Year' stamp." ,
                        "forbidden_ancestors": ['.post']
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/amHomeConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+stamperConfig': [
            {
                "id": "am-home-stamps-banner",
                "label": "Home (Banner)",
                "stamps": [
                    {
                        "id": "home_banner_with_text_and_button",
                        "label": "Banner with Text and Button",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/home/home_banner_with_text_and_button.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/home/home_banner_with_text_and_button.html",
                        "description":"This stamp includes a banner image with a region of text and a button." ,
                        "forbidden_ancestors": ['']
                    },{
                        "id": "home_banner",
                        "label": "Banner image",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/home/home_banner.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/home/home_banner.html",
                        "description":"This stamp includes a banner image." ,
                        "forbidden_ancestors": ['']
                    }
                ]
            },{
                "id": "am-home-stamps-top",
                "label": "Home (Content)",
                "stamps": [
                    {
                        "id": "blue_background_columns",
                        "label": "Blue Background Columns",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/home/blue_background_columns.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/home/blue_background_columns.html",
                        "description": "One or more columns, each with a large blue button.",
                        "container": ".blue-background-columns-row",
                        "forbidden_ancestors": ['']
                    },{
                        "id": "three-column-callout",
                        "label": "Multi-Column Callout",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/home/three_column_callout.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/home/three_column_callout.html",
                        "description": "One column containing an image, subheader, and paragraph text.",
                        "container": ".three-column-callout-container",
                        "forbidden_ancestors": ['.stamp']
                    },{
                        "id": "three-column-callout-with-list",
                        "label": "Multi-Column Callout with List",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/home/three_column_callout_with_list.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/home/three_column_callout_with_list.html",
                        "description": "One column containing an image, subheader, paragraph text, and list.",
                        "container": ".three-column-callout-container",
                        "forbidden_ancestors": ['.stamp']
                    },{
                        "id": "success-story-spotlight",
                        "label": "Success Story Spotlight",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/home/success_story_spotlight.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/home/success_story_spotlight.html",
                        "description": "Success Story Spotlight containing an intro paragraph followed by a video " +
                            "(that will open in a lightbox) and an image.",
                        "forbidden_ancestors": ['.stamp']
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/amOneColWNavConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+stamperConfig': [
            {
                "id": "am-one-col",
                "label": "One Column With Nav",
                "stamps": [
                    {
                        "id": "am_sticky_nav_section",
                        "label": "Sticky Navigation Section",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/sticky-navigation-section.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/sticky-navigation/sticky-navigation-section.html",
                        "description":"Sticky navigation section. When added, the section title will be added to the left, sticky navigation." ,
                        "forbidden_ancestors": ['div']
                    },{
                        "id": "am_left_text_right_image",
                        "label": "Left Text - Right Image",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/left-text-right-image.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/left-text-right-image.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays text on the left and image on the right."
                    },{
                        "id": "am_left_image_right_text",
                        "label": "Left Image - Right Text",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/left-image-right-text.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/left-image-right-text.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays image on the left and text on the right."
                    },{
                        "id": "am_table",
                        "label": "Styled Table",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/table-stamp.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/table.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays a styled table."
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/amOneColConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+stamperConfig': [
            {
                "id": "am-stamps",
                "label": "One Column",
                "stamps": [
                    {
                        "id": "am_left_text_right_image",
                        "label": "Left Text - Right Image",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/left-text-right-image.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/left-text-right-image.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays text on the left and image on the right."
                    },{
                        "id": "am_left_image_right_text",
                        "label": "Left Image - Right Text",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/left-image-right-text.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/left-image-right-text.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays image on the left and text on the right."
                    },{
                        "id": "am_table",
                        "label": "Styled Table",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/table-stamp.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/table.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays a styled table."
                    },{
                        "id": "am_three_col_with_text",
                        "label": "Three Column With Text",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/three_col_with_text.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/three_col_with_text.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays a three column callout with text bellow."
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/amSitewideCalloutConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+stamperConfig': [
            {
                "id": "am-sitewide-callout-stamps",
                "label": "Sitewide Callout",
                "stamps": [
                    {
                        "id": "sitewide-callout",
                        "label": "Sitewide Callout",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/sitewide-callout.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/sitewide-callout.html",
                        "description":"This stamp displays an editable background image, headline text, and a green link button.",
                        "forbidden_ancestors": ['*']
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/abbottAlkConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+stamperConfig': [
            {
                "id": "alk-information-stamps",
                "label": "Information",
                "stamps": [
                    {
                        "id": "alk_information_block",
                        "label": "Information Block",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/alk/information-block.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/alk/information-block.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp allows for the addition of blocks of text that include a header separated the paragraph text by a blue line."
                    }
                ]
            },{
                "id": "alk-callout-stamps",
                "label": "Callout",
                "stamps": [
                    {
                        "id": "alk_grey_product",
                        "label": "Grey Product Block",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/alk/grey-product-block.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/alk/grey-product-block.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp is useful for calling out information, including bolded title text and paragraph text contained within a gray box."
                    },{
                        "id": "alk_callout",
                        "label": "ALK Callout",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/alk/alk-callout.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/alk/alk-callout.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp is useful for calling out information, including header text on a blue bar and paragraph text below it."
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/cdxConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+stamperConfig': [
            {
                "id": "cdx",
                "label": "Companion Diagnostics Stamps",
                "stamps": [
                    {
                        "id": "homepage-cards",
                        "label": "Homepage 4 cards",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/cdx/homepage-cards-stamp.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/cdx/homepage-cards.html",
                        "forbidden_ancestors": ['.homepage-cards', '.stamp'],
                        "description": "Adds 4 cards with an image and caption"
                    },{
                        "id": "two-column-stamp",
                        "label": "Two Column Stamp",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/cdx/two-column-stamp.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/cdx/two-column.html",
                        "forbidden_ancestors": ['.two-column-stamp', '.stamp'],
                        "description": "Adds 2 sections with Headline and Text"
                    },{
                        "id": "three-column-stamp",
                        "label": "Three Column Stamp",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/cdx/three-column-stamp.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/cdx/three-column.html",
                        "forbidden_ancestors": ['.three-column-stamp', '.stamp'],
                        "description": "Adds 3 sections with Headline and Text"
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/cynogenConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+theme_advanced_buttons2:6': ['media'],
        '+plugins': ['media'],

        '+stamperConfig': [
            {
                "id": "cynogen-stamps",
                "label": "PersonalizeDx",
                "stamps": [
                    {
                        "id": "cynogen_right_callout",
                        "label": "Right Callout Stamp",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/cynogen/right-callout.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/cynogen/right-callout.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp allows for the addition of blocks of text that include a header separated the paragraph text by a gray line. "
                    },{
                        "id": "cynogen_right_callout_box",
                        "label": "Right Callout-Box Stamp",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/cynogen/right-callout-box.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/cynogen/right-callout-box.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp is useful for calling out information, allowing for regions that are separated by white dotted lines and contained within a blue box."
                    },{
                        "id": "cynogen_right_callout_arrow",
                        "label": "Right Callout w/Arrow Stamp",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/cynogen/right-callout-arrow.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/cynogen/right-callout-arrow.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp is useful for indicating downloadable files, using a downward pointing arrow icon next to text and contained within a blue box."
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/goMolecularConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+stamperConfig': [
            {
                "id": "gomolecular-stamps",
                "label": "Go Molecular",
                "stamps": [
                    {
                        "id": "gomolecular_intro_image",
                        "label": "Introduction Image Stamp",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/gomolecular/intro-image.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/gomolecular/intro-image.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp allows for the addition of a banner image and caption text  in the top region of a page. "
                    },{
                        "id": "gomolecular_intro_content",
                        "label": "Introduction Content Stamp",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/gomolecular/intro-content.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/gomolecular/intro-content.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp allows for the addition of introductory content contained within a blue box, including a region for an image on the left and a text region on the right."
                    },{
                        "id": "gomolecular_references",
                        "label": "References Stamp",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/gomolecular/references.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/gomolecular/references.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp allows for the addition of footnoted references in a small, gray font, including a bolded title separated from paragraph text via a gray line."
                    },{
                        "id": "gomolecular_related_content",
                        "label": "Related Content Stamp",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/gomolecular/related-content.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/gomolecular/related-content.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp allows for the addition of related content links, including header text on a purple bar and lined text below. "
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/inlineEditorConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        'use_pepper_toolbar': false,

        theme_advanced_buttons1: [
            'FONT', '(', 'bold', 'italic', 'underline', ' |', 'strikethrough', 'sup', 'sub', 'charmap', 'advhr', ')',
            'PARAGRAPH', '(', 'bullist', 'numlist', '|', 'indent', 'outdent', '|', 'justifyleft', 'justifycenter', 'justifyright', ')',
            'LINKS', '(', 'link', 'unlink', 'anchor', ')',
            'STYLE', '(', 'styleselect', 'codemirror', ')'
        ],

        theme_advanced_buttons2: [
        ],

        theme_advanced_buttons3: [
        ]

    }));
});
},
'abbott/editorConfigs/iridicaConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+style_formats': [
            {title:'IRIDICA Font Wrapper', inline:'span', classes:'century-gothic'}
        ]

    }));
});
},
'abbott/editorConfigs/iridicaFullWidthConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/iridicaConfig',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, iridicaBase) {
    return provide(module.id, new WysiwygConfig(iridicaBase, {

        '+stamperConfig': [
            {
                "id": "full-width-stamps",
                "label": "Full-Width",
                "stamps": [
                    {
                        "id": "iridica_entry",
                        "label": "Audience",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/iridica/audience.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/iridica/audience.html",
                        "forbidden_ancestors": ['.iridica-stamp'],
                        "description": "Headline, image and button",
                        "container": "._3-column-row"
                    },
                    {
                        "id": "iridica_events",
                        "label": "Events",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/iridica/event.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/iridica/event.html",
                        "forbidden_ancestors": ['.iridica-stamp'],
                        "description": "Event icon with supporting text",
                        "container": ".noticeboard-center-div"
                    },
                    {
                        "id": "iridica_faq",
                        "label": "FAQ",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/iridica/faq.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/iridica/faq.html",
                        "forbidden_ancestors": ['.iridica-stamp'],
                        "description": "Question and answer content in an expand/collapse accordion",
                        "container": ".iridica-faq-section"
                    },
                    {
                        "id": "iridica_radical",
                        "label": "Study Overview",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/iridica/study-overview.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/iridica/study-overview.html",
                        "description": "Image with link and hover state",
                        "container": ".benefits-row"
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/iridicaSmallConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/iridicaConfig',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, iridicaBase) {
    return provide(module.id, new WysiwygConfig(iridicaBase, {

        '+stamperConfig': [
            {
                "id": "small-width-stamps",
                "label": "Stamps",
                "stamps": [
                    {
                        "id": "iridica_provides_list",
                        "label": "IRDICA Provides List",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/iridica/provides-list.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/iridica/provides-list.html",
                        "forbidden_ancestors": ['.iridica-stamp'],
                        "description": "Headline and bulleted list"
                    },{
                        "id": "references_list",
                        "label": "References List",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/iridica/references-list.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/iridica/references-list.html",
                        "forbidden_ancestors": ['.iridica-stamp'],
                        "description": "A numbered list of references"
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/iridicaRotatorConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/iridicaConfig',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, iridicaBase) {
    return provide(module.id, new WysiwygConfig(iridicaBase, {

        '+stamperConfig': [
            {
                "id": "iridica-rotator-stamps",
                "label": "Iridica Rotator Slides",
                "stamps": [
                    {
                        "id": "rotator_content_slide",
                        "label": "Content Slide",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/iridica/rotator-content-slide.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/iridica/rotator-content-slide.html",
                        "forbidden_ancestors": ['*'],
                        "description": "Background image, headline, paragraph, and button."
                    },{
                        "id": "rotator_video_slide",
                        "label": "Video Slide",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/iridica/rotator-video-slide.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/iridica/rotator-video-slide.html",
                        "forbidden_ancestors": ['*'],
                        "description": "Headline text laid over a video placeholder image. (Add the video source as the " +
                            "background image's link destination. Video will only play outside of Pepper mode.)"
                    },{
                        "id": "rotator_image_slide",
                        "label": "Image Slide",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/iridica/rotator-image-slide.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/iridica/rotator-image-slide.html",
                        "forbidden_ancestors": ['*'],
                        "description": "Background image that will shrink to fit within the height of the rotator."
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/mqOneColumnConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/mqConfig',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, mqConfig) {
    return provide(module.id, new WysiwygConfig(mqConfig, {

        '+stamperConfig': [
            {
                "id": "mq-stamps",
                "label": "One Column",
                "stamps": [
                    {
                        "id": "am_left_text_right_image",
                        "label": "Left Text - Right Image",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/left-text-right-image.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/left-text-right-image.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays text on the left and image on the right."
                    },{
                        "id": "am_left_image_right_text",
                        "label": "Left Image - Right Text",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/left-image-right-text.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/left-image-right-text.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays image on the left and text on the right."
                    },{
                        "id": "am_table",
                        "label": "Styled Table",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/table-stamp.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/table.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays a styled table."
                    },{
                        "id": "am_three_col_with_text",
                        "label": "Three Column With Text",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/general/three_col_with_text.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/general/three_col_with_text.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays a three column callout with text bellow."
                    },{
                        "id": "mq_intro_banner",
                        "label": "Intro Banner",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/mq/intro-banner.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/mq/intro-banner.html",
                        "forbidden_ancestors": ['*'],
                        "description": "This stamp displays a banner with editable text to introduce a section of the page."
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/mqConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

    }));
});
},
'abbott/editorConfigs/mqRotatorConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/mqConfig',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, mqConfig) {
    return provide(module.id, new WysiwygConfig(mqConfig, {

        '+stamperConfig': [
            {
                "id": "mq-rotator-stamps",
                "label": "Rotator Stamps",
                "stamps": [
                    {
                        "id": "home_banner_with_text_and_button",
                        "label": "Banner with Text and Button",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/home/home_banner_with_text_and_button.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/home/home_banner_with_text_and_button.html",
                        "description":"This stamp includes a banner image with a region of text and a button." ,
                        "forbidden_ancestors": ['']
                    },{
                        "id": "home_banner",
                        "label": "Banner image",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/home/home_banner.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/home/home_banner.html",
                        "description":"This stamp includes a banner image." ,
                        "forbidden_ancestors": ['']
                    }
                ]
            }
        ]
    }));
});
},
'abbott/editorConfigs/portal/amPortalDashboardConfig':function(){
define([
    'vodori/provide',
    'module',
    'vodori/input/WysiwygConfig',
    'abbott/editorConfigs/base',
    'vodori/tinymce/StickyHeader'
], function (provide, module, WysiwygConfig, base) {
    return provide(module.id, new WysiwygConfig(base, {

        '+stamperConfig': [
            {
                "id": "portal-banner",
                "label": "Rotator",
                "stamps": [
                    {
                        "id": "portal_banner",
                        "label": "Rotator Slide with Text Overlay",
                        "thumbnail": "/static/images/abbott/pepper/stampThumbs/am/portal/slide-stamp.png",
                        "href": "/static/js/abbott/tinymce/stamps/templates/am/portal/dashboard/slide.html",
                        "forbidden_ancestors": ['.slide'],
                        "description": "A rotator slide with editable headline, copy, and button overlaying a background image."
                    }
                ]
            }
        ]
    }));
});

},
'abbott/iridica/ui/IridicaTileSectionFormBasedEditor':function(){
define([
    'dojo/_base/declare',
    'lodash',
    'vodori/input/FormBasedEditor'
], function(declare,
            _,
            FormBasedEditor
    ) {
    return declare([FormBasedEditor], {

        prepareDataForValue: function(data) {

            var cleanedData = _.cloneDeep(data);

            cleanedData.hasBenefits = false;

            _.forEach(cleanedData.benefits, function(benefit) {
                _.forOwn(benefit, function(value, key) {
                    var replaced = value.replace(/(?:\r\n|\r|\n)/g, '<br />');
                    if (!_.isEmpty(replaced)) {
                        cleanedData.hasBenefits = true;
                    }
                    benefit[key] = _.escape(replaced);
                });
            });

            return cleanedData;
        },

        prepareDataForForm: function(data) {

            var cleanedData = _.cloneDeep(data);

            _.forEach(cleanedData.benefits, function(benefit) {
                _.forOwn(benefit, function(value, key) {
                    var unescaped = _.unescape(value);
                    benefit[key] = unescaped.replace(/(<br \/>)/g, '\n');
                });
            });
            return cleanedData;
        }
    });
});
},
'abbott/util/OtherInput':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dojo/_base/lang', 'dojo/on', 'dojo/dom-class', 'dojo/query',
    'dijit/layout/ContentPane', 'dijit/registry', 'dijit/form/MultiSelect', 'dijit/Destroyable'
], function(provide, module,
            _,
            lang, on, domClass, query,
            ContentPane, registry, MultiSelect, Destroyable
            ) {
    return provide(module.id, [ContentPane, Destroyable],  {

        _selectOptions: null,
        _selectOtherValue: 'Other',
        _otherInput: null,

        /**
         * Watch for a form's _selectOptions change. If it has a value of _selectOtherValue we'll show _otherInput
         * Used for: A multi select with an option of "Other (require comment)" which, if chosen, we'll  show an
         *           input field where they can type in the comment.
         * Need to extend ContentPane for the Pepper form to recognize the fields
         */
        postCreate:function(){
            this.inherited(arguments);

            // Find the select and input fields (can't use attach points because of issues with the Pepper form)
            this._selectOptions = _.filter(registry.findWidgets(this.domNode), function(widget){
                return widget.isInstanceOf(MultiSelect);
            })[0];
            this._otherInput = query('.required-other-input', this.domNode)[0];

            // Initially hide the input field
            domClass.add(this._otherInput, 'hidden');

            // Check if 'Other' was already set on the select
            this._checkSelectValue();

            // Watch for changes on the select's value
            this.own(on(this._selectOptions, 'change', lang.hitch(this, '_checkSelectValue')));
        },

        /**
         * Hide/show the input field based on the select's value
         * @private
         */
        _checkSelectValue:function(){
            var selectValue = this._selectOptions.value;

            if(selectValue.indexOf(this._selectOtherValue) > -1){
                domClass.remove(this._otherInput, 'hidden');
            } else {
                domClass.add(this._otherInput, 'hidden');
            }
        }
    });
});
},
'abbott/ui/ImageInput':function(){
define([
        'module', 'vodori/provide',
        'abbott/ui/AssetInput'
    ],
    function (
        module, provide,
        AssetInput
        ) {

        /*
         * @class abbott/ui/ImageInput
         *
         * Adds a library browser button to a textbox for selecting an image from the Pepper Library.
         *
         * @extends abbott/ui/AssetInput
         */
        return provide(module, [AssetInput],
            /**
             * @lends abbott/ui/ImageInput.prototype
             */
            {
                BUTTON_CLASS: 'image-browser-button',

                TEXT_INPUT_CLASS: 'image-browser-input',

                constructor: function() {
                    this.query = {
                        type: ['Image']
                    }
                }
            });
    }
);
},
'abbott/ui/AssetInput':function(){
define([
        'module', 'vodori/provide',
        'dojo/dom-construct', 'dojo/dom-class', 'dojo/dom-attr',
        'vodori/input/TextBox',
        'pepper/ui/LibraryBrowserButton'
    ],
    function (
        module, provide,
        domConstruct, domClass, domAttr,
        TextBox,
        LibraryBrowserButton
        ) {

        /*
         * @class abbott/ui/AssetInput
         *
         * Provides a general-purpose asset input widget.
         *
         * @extends dijit/_WidgetBase
         */
        return provide(module, [TextBox],
            /**
             * @lends abbott/ui/AssetInput.prototype
             */
            {

                /**
                 * Any particular class that should be placed on the button
                 * @type {String}
                 */
                BUTTON_CLASS: '',

                /**
                 * Any particular class that should be placed on the text input
                 * @type {String}
                 */
                TEXT_INPUT_CLASS: '',

                /**
                 * Label for browse button
                 * @type {String}
                 */
                browseLabel: '...',

                /**
                 * Any particular query with which the associated library browsing window
                 * should be opened
                 * @type {Object}
                 */
                query: null,

                /**
                 * If true, use standard Pepper styling for the browse button. If false, no automatic
                 * styling is applied.
                 * @type {Boolean}
                 */
                standardButtonStyling: true,

                /**
                 * reference to browser button widget
                 * @type {pepper/ui/LibraryBrowserButton}
                 * @private
                 */
                _browseButton: null,

                constructor: function() {
                    this.query = {};
                },

                postCreate: function() {
                    this.inherited(arguments);

                    domClass.add(this.domNode, this.TEXT_INPUT_CLASS);

                    this._addBrowseButton();
                },

                /**
                 * Adds a Library browser button after the input for selecting an image
                 * @private
                 */
                _addBrowseButton: function() {
                    this._browseButton = new LibraryBrowserButton({
                        targetInput: this.domNode,
                        idProperty: 'pathInCurrentSubscription',
                        maxSelections: 1,
                        query: this.query,
                        view: 'grid',
                        'class': this.BUTTON_CLASS,
                        label: this.browseLabel
                    });

                    domConstruct.place(this._browseButton.domNode, this.domNode, 'after');

                    this._browseButton.startup();
                }
            });
    }
);
},
'abbott/ui/VideoInput':function(){
define([
        'module', 'vodori/provide',
        'abbott/ui/AssetInput'
    ],
    function (
        module, provide,
        AssetInput
        ) {

        /*
         * @class abbott/ui/VideoInput
         *
         * Adds a library browser button to a textbox for selecting a video from the Pepper Library.
         *
         * @extends abbott/ui/AssetInput
         */
        return provide(module, [AssetInput],
            /**
             * @lends abbott/ui/VideoInput.prototype
             */
            {
                BUTTON_CLASS: 'video-browser-button',

                TEXT_INPUT_CLASS: 'video-browser-input',

                constructor: function() {
                    this.query = {
                        type: ['Video']
                    }
                }
            });
    }
);
},
'abbott/ui/TranslatorHtml':function(){
/**
 * This is a widget to translate globally defined javascript translation keys
 * The inner text of this widget should ONLY contain the global translation
 * variable name and nothing else (Ex - 'window.listOfEventsTranslations.eventDate').
 *
 * This extends the original Translator module but injects the translation as HTML instead of text.
 */
define([
    'module',
    'vodori/provide',
    'dijit/_WidgetBase',
    'abbott-shared/util/Translator'
], function(module,
            provide,
            _WidgetBase,
            Translator) {
    return provide(module.id, [Translator], {

        /**
         * Overrides the insert translation function to inject the translation as HTML instead of text.
         */
        insertTranslation: function() {
            if (this.translationVar) {
                try {
                    var translatedText = eval(this.translationVar);
                    if (translatedText) {
                        this.$domNode.html(translatedText);
                    } else {
                        console.error("The global translation variable: " + this.translationVar + " is undefined");
                    }
                } catch(e) {
                    console.error("Error evaluating global translation variable: " + this.translationVar);
                }
            } else {
                console.error("Global translation variable must be defined");
            }
        }
    })
});
},
'abbott/input/LibraryInput':function(){
/*jshint dojo:true devel:true strict:false*/
/*global define:true */
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
/**
 *
 * Adds a library browser button to a textbox for selecting an item from the Pepper Library.
 *
 * Use:
 * <input type="text" data-dojo-type="abbott/input/LibraryInput" />
 *
 * <input type="text" data-dojo-type="abbott/input/LibraryInput"
 *                      data-dojo-props="type: "image"" />
 *
 * <input type="text" data-dojo-type="abbott/input/LibraryInput"
 *                      data-dojo-props="type: "mp4"" />
 *
 */
define([
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'dojo/dom-construct', 'dojo/dom-class',
    'dijit/_WidgetBase',
    'pepper/data/GetChannelsType',
    'abbott/input/OverrideLibraryBrowserButton'
],
    function (
        module, provide,
        lang,
        domConstruct, domClass,
        _WidgetBase,
        GetChannelsType,
        OverrideLibraryBrowserButton
        ) {

        return provide(module, [_WidgetBase], {

            /**
             * Label for browse button
             *
             * @type {string}
             */
            browseLabel: 'Choose',

            /**
             * Set to the key value of an item in the _configs mapping (e.g. 'image' or 'mp4')
             *
             * @type {string}
             */
            queryFor: null,

            /**
             * Flag to show all channels, regardless of subscription
             *
             * @type {boolean}
             */
            showAllChannels: false,

            /**
             * reference to text input element
             *
             * @type {HTMLElement}
             */
            _textBox: null,

            /**
             * reference to the button widget
             *
             * @type {abbott/input/OverrideLibraryBrowserButton}
             */
            _browseButton: null,

            /**
             * Map of configs to be picked from for what is passed in to the library browser button
             *
             * @type {Object}
             */
            _configs: null,

            constructor: function() {
                this._configs = {
                    image: {
                        query: {
                            type: ['Image']
                        },
                        view: 'grid'
                    },
                    mp4: {
                        query: {
                            type: ['Video'],
                            search: '*.mp4'
                        }
                    }
                };
            },

            buildRendering: function() {
                this.inherited(arguments);

                this._textBox = this.domNode;

                this.domNode = domConstruct.create('span', {'class': 'library-input'});

                this._addBrowseButton();
            },

            startup: function() {
                this.inherited(arguments);
                domConstruct.place(this._textBox, this.domNode, 'first');
            },

            _addBrowseButton: function() {
                var browseButtonConfig = {
                    targetInput: this._textBox,
                    idProperty: 'pathInCurrentSubscription',
                    'class': 'browse-button',
                    maxSelections: 1,
                    label: this.browseLabel
                };

                if (this.type) {
                    lang.mixin(browseButtonConfig, this._configs[this.queryFor]);
                }

                if (this.showAllChannels) {
                    browseButtonConfig.showChannels = GetChannelsType.all;
                }

                this._browseButton = new OverrideLibraryBrowserButton(browseButtonConfig);

                this._browseButton.placeAt(this.domNode);
                this._browseButton.startup();
            },

            _setValueAttr: function(value) {
                this._textBox.value = value;
            },

            _getValueAttr: function() {
                return this._browseButton.get('selection');
            }

        });
    }
);
},
'abbott/input/OverrideLibraryBrowserButton':function(){
/*jshint dojo:true devel:true strict:false*/
/*global define:true */
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define(['module', 'vodori/provide',
        'lodash',
        'dojo/Deferred', 'dojo/when', 'dojo/_base/lang',
        'pepper/library/LibraryDialog',
        'pepper/ui/LibraryBrowserButton',
        'abbott/input/config/LibraryBrowserConfigs'
], function(module, provide,
            _,
            Deferred, when, lang,
            LibraryDialog,
            LibraryBrowserButton,
            LibraryBrowserConfigs) {
    /**
     * This module subclasses {pepper/ui/LibraryBrowserButton} in order to
     * add flexibility to the kind of library that the widget loads when told to
     * `browse` for assets. Its main benefit derives from using the `FilterOverrideLibrary`
     * by default, hence the name of this module (not just called `Override` because we
     * are overriding the LibraryBrowserButton).
     *
     * @extends {pepper/ui/LibraryBrowserButton}
     */
    return provide(module, [LibraryBrowserButton], {

        /**
         * The configuration to be passed in to the library when the
         * library is instantiated.
         *
         * @type {Object} a mapping of library settings
         */
        libraryConfig: null,

        /**
         * Module id for the library that should be required in and loaded
         * on `browse`
         *
         * Note that the identified module should conform to the
         * {pepper/library/LibraryNouveau} API.
         *
         * @type {string} a module identifier
         */
        libraryMid: 'pepper/library/FilterOverrideLibrary',

        /**
         * The default configuration for the library browser should match
         * the behavior of other library browsers in the editor toolbar.
         */
        constructor: function() {
            this.set('libraryConfig', LibraryBrowserConfigs.readOnlyNoReception);
        },

        /**
         * Deferred associated with `browse` call.
         *
         * @type {dojo/Deferred}
         * @private
         */
        _browseDeferred: null,

        /**
         * Launch the browser.
         *
         * @override
         * @return {dojo/promise/Promise} a promise resolving to the selection array.
         */
        browse: function () {
            this._browseDeferred = new Deferred();

            when(this._assembleLibraryConfig(), lang.hitch(this, function() {
                require([this.libraryMid],
                    lang.hitch(this, function (Library) {

                        var modal = new LibraryDialog({
                            destroyOnHide: true,
                            parseOnFirstShow: false,
                            widget: new Library(this.libraryConfig),
                            'class': 'library-dialog'
                        });

                        modal.startup();
                        modal.show();
                    })
                );
            }));

            return this._browseDeferred.promise;
        },

        /**
         * Subclasses can implement this method to perform further
         * modifications to the library settings before the library is
         * instantiated. The button will wait on a promise resolution
         * if asynchronous behavior is required.
         */
        customLibraryConfig: function() {},

        /**
         * Completes the assembly of the library configuration object with other properties
         * on this object.
         *
         * Note this is left as-is so as not to frustrate expectations of clients using
         * LibraryInput already (with the expected behaviors of dependencies like LibraryBrowserButton)
         *
         * @private
         */
        _assembleLibraryConfig: function() {
            var deferred = new Deferred();
            lang.mixin(this.libraryConfig, {
                showChannels: this.showChannels,
                resultsGridView: this.view,
                query: _.clone(this.query, true),
                confirmHandler: lang.hitch(this, function (selection) {
                    this._handleLibraryConfirm(selection);
                    this._browseDeferred.resolve(selection);
                })
            });

            when(this.customLibraryConfig(), function() {
                deferred.resolve();
            });

            return deferred.promise;
        },

        /**
         * Ensure that we set the library config to a cloned object, since
         * we are going to mutate it.
         *
         * @type {Object} config settings for the library
         * @private
         */
        _setLibraryConfigAttr: function(config) {
            this.libraryConfig = _.clone(config);
        }
    });
});
},
'abbott/input/config/LibraryBrowserConfigs':function(){
/*jshint dojo:true devel:true strict:false*/
/*global define:true */
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define(['module',
        'vodori/provide'
], function(module,
            provide) {
    /**
     * This mapping defines configurations for
     * library browsers.
     *
     * @see {pepper/ui/FilterOverrideLibrary}
     */
    return provide(module, {
        readOnlyNoReception: {
            readOnly: true,
            libraryFilterOverrides: [
                {
                    'filterData': {
                        'exclude': ['Reception']
                    },
                    'widget': 'pepper/library/filter/ui/StateVersion'
                }
            ]
        }
    });
});
},
'abbott/input/video/VideoFlyoutList':function(){
/*jshint dojo:true, devel:true, strict:false*/
define([
    'module',
    'vodori/provide',
    'dojo/_base/lang',
    'dojo/dom-class', 'dojo/dom-attr', 'dojo/string', 'dojo/query',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    "dojo/text!./templates/VideoFlyoutList.html",
    "dojo/text!./templates/VideoFlyoutListFormItem.html",

        "dijit/form/Button",
        "dijit/form/CheckBox",
        "pepper/ui/LibraryBrowserButton",
        "abbott/ui/NodeRepeater",
        "vodori/input/FormBasedEditor",
        "abbott/ui/video/VideoFlyoutList"

],
    function (
        module,
        provide,
        lang,
        domClass, domAttr, string, query,
        _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
        VideoFlyoutList,
        VideoFlyoutListFormItem
        ) {

        /*
         * @class VideoFlyoutList
         * @extends dijit/_WidgetBase
         * @extends dijit/_TemplatedMixin
         * @extends dijit/_WidgetsInTemplate
         */
           return provide(module.id, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin],
             /**
              *
              * @lends VideoFlyoutList.prototype
              */
           {

               templateString: VideoFlyoutList,
               formItemTemplate: VideoFlyoutListFormItem,

               /**
                * The HTML for a VideoFlyoutList widget for the visitor layer.
                *
                * When read from, this value will be unparsed, declarative Dojo HTML representing the VideoFlyoutList
                * widget with an order list of video links. If this widget is set to *not* display the visitor widget,
                * then the HTML will be wrapped in a comment.
                *
                * When written to, this widget will parse the HTML and populate the form accordingly. Thus, if the
                * HTML is wrapped in a comment, then the checkbox for displaying the visitor widget will be unchecked,
                * but the form will be populated correctly.
                *
                * If the form has *no* video links and is set not to display, then an empty string is returned.
                *
                * @type string
                */
               value: "",

               /**
                * The CheckBox that a user can use to set whether this widget be displayed on a visitor page or not
                * @type dijit/form/CheckBox
                */
               displayCheckbox: undefined,

               /**
                * If true, the VideoFlyoutList widget should be displayed on a visitor page. Otherwise, it should
                * not
                * @type boolean
                */
               shouldDisplayWidget: false,

               postMixInProperties: function() {
                    this.value = domAttr.get(this.srcNodeRef, 'data-abbott-testimonial-videos');
               },

               postCreate: function() {
                   this.inherited(arguments);
                   this.set('value', this.value);

                   this.displayCheckbox.set('value', this.get('shouldDisplayWidget'));
                   this.displayCheckbox.on('change', lang.hitch(this, "set", "shouldDisplayWidget"));
               },

               startup: function() {
                   this.inherited(arguments);
                   this.watch('shouldDisplayWidget', lang.hitch(this, "_updateFormDisplay"));
               },

               _getValueAttr: function() {
                   var hasMediaLinks = query("input[name=\"flyout-link-name\"",this.form.domNode).length > 0;
                   if(!this.form) {
                       return "";
                   }

                   if(this.get('shouldDisplayWidget')) {
                       return this.form.get('value');

                   }
                   else if(hasMediaLinks) {
                       return "<!-- " + this.form.get('value') + " -->";
                   }
                   else {
                       return "";
                   }

               },

               _setValueAttr: function(value) {
                   var trimmedValue = string.trim(value).replace(/\n/g,""),
                       wasCommented = trimmedValue.match(/<!--(.*)-->/),
                       uncommentedValue = wasCommented ? wasCommented[1] : trimmedValue;

                   if(this.form) {
                       this.form.set('value', uncommentedValue);
                       this.set('shouldDisplayWidget', uncommentedValue !== "" && !wasCommented);
                       if(!this._started) {
                           this._updateFormDisplay();
                       }
                   }
               } ,

               _updateFormDisplay: function() {
                   domClass.toggle(this.domNode, 'displayed', this.get('shouldDisplayWidget'));
               }
            });
       }
);
},
'abbott/ui/am/customerPortal/admin/ResourceBrowserButton':function(){
/*jshint dojo:true devel:true strict:false*/
/*global define:true */
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define(['module', 'vodori/provide',
    'lodash',
    'dojo/_base/connect',
    'dojo/Deferred', 'dojo/when', 'dojo/_base/lang',
    'pepper/ui/LibraryBrowserButton'
], function(module, provide,
            _,
            connect,
            Deferred, when, lang,
            LibraryBrowserButton) {

    return provide(module, [LibraryBrowserButton], {

        targetInput: 'resources-input',
        idProperty: 'path',
        view: 'grid',
        appendToInput: true,
        query:{
            templateId: ['amCustomerPortalResourceImportTemplate'],
            states: 'Live'
        },

        postCreate: function() {
            this.inherited(arguments);
        },

        /**
         * Overriding the LibraryBrowseButton _handleLibraryConfirm function so that we can update our table
         *
         * @param selections
         * @private
         */
        _handleLibraryConfirm: function (selections) {
            connect.publish('/customerPortal/admin/addResources', [selections]);

            this.inherited(arguments);
        }
    });
});
},
'abbott/ui/am/customerPortal/admin/ResourceTable':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/declare', 'dojo/_base/connect', 'dojo/_base/lang',
    'dojo/on', 'dojo/query', 'dojo/dom-construct', 'dojo/dom-attr', 'dojo/html',
    'dijit/_WidgetBase',
    'vodori/renderTemplate',
    'abbott/ajax/abbottMolecularApi',
    'dojo/text!./templates/ResourceRow.mustache'
], function(module, provide,
            _,
            declare, connect, lang,
            on, query, domConstruct, domAttr, html,
            _WidgetBase,
            renderTemplate,
            abbottMolecularApi,
            resourceRowTemplate
) {
    return provide(module.id, [_WidgetBase], {

        /**
         * The resource table
         */
        resourceTable: null,

        /**
         * The save button
         */
        saveButton: null,

        /**
         * Buttons and event handlers for all of the rows in the table
         */
        resourceButtons: {
            addOrEditNote: null,
            remove: null
        },
        resourceButtonHandles: [],

        /**
         * The ID of the Customer Portal user that we're editing resources for
         */
        userId: null,

        /**
         * The object we'll pass to the backend when saving changes
         */
        resources: {
            userId: null,
            deleted: [],
            added: []
        },

        /**
         * Properties and objects related to the 'Add/Edit Note' dialog
         */
        noteDialog: null,
        noteDialogElements: {
            title: null,
            textarea: null,
            charsRemaining: null
        },
        noteDialogButtons: {
            cancel: null,
            clear: null,
            save: null
        },
        noteDialogButtonHandles: [],

        showUnloadConfirmation: false,

        /**
         * -------------------------------------------------------------------------------------------------------------
         * Create our widget
         */
        postCreate: function() {
            this.inherited(arguments);

            this._addUnloadConfirmation();

            // Set the userId on our request object
            this.resources.userId = this.userId;

            // Find the actual table
            this.resourceTable = query('table tbody', this.domNode)[0];

            // Find the save button and listen for clicks
            this.saveButton = query('.save-changes', this.domNode)[0];
            this.own(on(this.saveButton, 'click', lang.hitch(this, '_saveChanges')));

            // Find the buttons associated with each resource
            this._attachResourceButtonEvents();

            // Subscribe to the event published when an asset(s) is chosen from the Library
            connect.subscribe('/customerPortal/admin/addResources', lang.hitch(this, function(selections) {
                // Loop through each of the user's selection, adding it to a temporary list of resources.
                var resources = [];
                _.forEach(selections, lang.hitch(this, function(selection) {
                    if (this._isAssetAValidResourceTemplate(selection) &&
                        !this._isAssetAlreadyPendingAddition(selection.id) &&
                        !this._doesAssetAlreadyExistAsResource(selection.id)) {
                        resources.push(this._createResourceFromSelection(selection));
                    }
                }));

                // Post an AJAX request to get the title of each of the assets.
                // (Workaround for a flaw in Pepper that does not return the title of a chosen asset.)
                abbottMolecularApi.post(abbottMolecularApi.ENDPOINTS.QUERY_CUSTOMER_PORTAL_ADMIN_GET_ASSET_TITLE, resources)
                    .done($.proxy(function(responseResources) {
                        _.forEach(responseResources, lang.hitch(this, function(resource) {
                            // Once the request is complete, add the resource to our list of 'added' resources and to the table
                            this._addResource(resource);
                        }));
                    }, this)
                );
            }));
        },

        /**
         * Add a browser confirmation message when user attempts to leave page
         *
         * @private
         */
        _addUnloadConfirmation: function() {
            window.addEventListener('beforeunload', lang.hitch(this, function (event) {
                if (this.showUnloadConfirmation) {
                    event.returnValue = 'You are about to leave the page. Any unsaved changes will be lost.';
                }
            }));
        },

        // =============================================================================================================
        // Resource Management
        // =============================================================================================================

        /**
         * -------------------------------------------------------------------------------------------------------------
         * Attach click event listeners to various buttons in each resource row
         *
         * @private
         */
        _attachResourceButtonEvents: function() {
            // Remove any handles to previous onclick events
            if (this.resourceButtonHandles) {
                _.forEach(this.resourceButtonHandles, lang.hitch(this, function(handle) {
                    handle.remove();
                }));
            }

            // Find all of the 'Add/Edit Note' and 'Remove Resource' buttons
            this.resourceButtons.addOrEditNote  = query('.add-or-edit-note', this.domNode);
            this.resourceButtons.removeResource = query('.remove-resource', this.domNode);

            // Respond to clicks
            this.resourceButtonHandles.push(on(this.resourceButtons.addOrEditNote, 'click', lang.hitch(this, '_addOrEditNote')));
            this.resourceButtonHandles.push(on(this.resourceButtons.removeResource, 'click', lang.hitch(this, '_removeResource')));
        },

        /**
         * -------------------------------------------------------------------------------------------------------------
         * Add a new resource given the user's selection from the Pepper Library
         *
         * @param resource
         * @private
         */
        _addResource: function(resource) {
            // First, add it to the list of our 'added' resources
            this.resources.added.push(resource);

            // Create the markup for the row and add it to the table
            var newRow = renderTemplate(resourceRowTemplate, resource);
            domConstruct.place(newRow, this.resourceTable);

            // Re-attach click events for the rows now that we have a new one
            this._attachResourceButtonEvents();

            // Update the unload confirmation boolean
            this.showUnloadConfirmation = true;
        },

        /**
         * -------------------------------------------------------------------------------------------------------------
         * Remove a resource given a click event from the 'Remove Resource' button on the resource's row
         *
         * @param event
         * @private
         */
        _removeResource: function(event) {
            var row = this._getRowForEvent(event);

            if (this._isRowForExistingResource(row)) {
                // If the resource is already assigned to the user, we need to add it to a list of 'deleted' resources
                var resourceId = this._getResourceIdForRow(row);
                this.resources.deleted.push({resourceId: resourceId});
            } else {
                // If it's a newly added resource, we just need to remove it from our list of 'added' resources
                var assetId = this._getAssetIdForRow(row);
                _.remove(this.resources.added, function (resource) {
                    return resource.assetId === assetId;
                });
            }

            // Physically remove the row from the dom
            domConstruct.destroy(row)

            // Update the unload confirmation boolean
            this.showUnloadConfirmation = true;
        },

        /**
         * -------------------------------------------------------------------------------------------------------------
         * Edit the note of a resources given a click event from the 'Add/Edit Note' button on the resource's row
         *
         * @param event
         * @private
         */
        _addOrEditNote: function(event) {
            // Remove any handles to previous onclick events
            if (this.noteDialogButtonHandles) {
                _.forEach(this.noteDialogButtonHandles, lang.hitch(this, function(handle) {
                    handle.remove();
                }));
            }

            var row     = this._getRowForEvent(event);
            var note    = this._getNoteCellForRow(row).innerHTML.trim();
            var title   = this._getTitleCellForRow(row).innerHTML.trim();

            // Find and show the dijit.Dialog we added to the JSP for adding/editing Notes on a resource
            this.noteDialog = dijit.byId('addOrEditNoteDialog');
            this.noteDialog.show();

            // Find all of the elements in the dialog we need and update some of their values/text
            this.noteDialogElements.title           = query('.title span', this.noteDialog.domNode)[0];
            this.noteDialogElements.textarea        = query('textarea', this.noteDialog.domNode)[0];
            this.noteDialogElements.charsRemaining  = query('.remaining span', this.noteDialog.domNode)[0];

            html.set(this.noteDialogElements.title, title);
            this.noteDialogElements.textarea.value = note;

            // Find all of the buttons in the dialog that we need and respond to click events
            this.noteDialogButtons.cancel   = query('.cancel', this.noteDialog.domNode);
            this.noteDialogButtons.clear    = query('.delete', this.noteDialog.domNode);
            this.noteDialogButtons.save     = query('.save', this.noteDialog.domNode);

            this.noteDialogButtonHandles.push(on(this.noteDialogButtons.cancel, 'click', lang.hitch(this, function() {
                this.noteDialog.hide(); // Just close the dialog if they hit Cancel
            })));
            this.noteDialogButtonHandles.push(on(this.noteDialogButtons.clear, 'click', lang.hitch(this, '_deleteNoteForRow', row)));
            this.noteDialogButtonHandles.push(on(this.noteDialogButtons.save, 'click', lang.hitch(this, '_updateNoteForRow', row)));

            // Update the unload confirmation boolean
            this.showUnloadConfirmation = true;
        },

        /**
         * -------------------------------------------------------------------------------------------------------------
         * Delete the note for a resource
         *
         * @param row
         * @param event
         * @private
         */
        _deleteNoteForRow: function(row, event) {
            // When they click 'Delete' from the Note dialog, all we need to do is clear the textarea value and call
            // the _updateNoteForRow function
            this.noteDialogElements.textarea.value = '';
            this._updateNoteForRow(row, event);

            // Update the unload confirmation boolean
            this.showUnloadConfirmation = true;
        },

        /**
         * -------------------------------------------------------------------------------------------------------------
         * Update the note for a resource
         *
         * @param row
         * @param event
         * @private
         */
        _updateNoteForRow: function(row, event) {
            // Find the value they entered for the note and the title of the document
            var note        = this.noteDialogElements.textarea.value;
            var title       = this._getTitleCellForRow(row).innerHTML.trim();
            var assetId     = this._getAssetIdForRow(row);
            var resourceId  = this._getResourceIdForRow(row);

            if (this._isRowForExistingResource(row)) {
                // If we're updating the note of a current row, we actually need to delete that resource and re-add
                //  as an entirely new resource. So, first add it to the list of 'deleted' resources...
                this.resources.deleted.push({resourceId: resourceId});

                // ... and then add a whole new object to our list of 'added' resources
                if (!this._isAssetAlreadyPendingAddition(assetId)) {
                    // (Don't use the same resourceId. It'll get a new one when we save to the database.)
                    this.resources.added.push(this._createResourceObject(null, assetId, title, note));
                }
            }

            // Find the object in our list of 'added' resources, and update its note property
            var addedResource = _.find(this.resources.added, {'assetId': assetId});
            addedResource.note = note;

            // Update the cell in the table with the new note value
            this._getNoteCellForRow(row).innerHTML = note;

            // Hide the dialog
            this.noteDialog.hide();

            // Update the unload confirmation boolean
            this.showUnloadConfirmation = true;
        },

        /**
         * -------------------------------------------------------------------------------------------------------------
         * Save changes by posting the resources object
         * Upon success, the page will be reloaded so that all cells of all rows are correctly populated
         *
         * @private
         */
        _saveChanges: function() {
            abbottMolecularApi.post(abbottMolecularApi.ENDPOINTS.QUERY_CUSTOMER_PORTAL_ADMIN_SAVE_RESOURCES, this.resources)
                .done($.proxy(function(response) {
                    if (response.success) {
                        this.showUnloadConfirmation = false;
                        alert('Your changes were successfully saved. Reloading the page now.');
                        location.reload(true);
                    } else {
                        alert('There was an error saving your changes. Please refresh the page and try again.');
                    }
                }, this)
            );
        },

        // =============================================================================================================
        // Helper Methods
        // =============================================================================================================

        _createResourceObject: function(resourceId, assetId, title, note) {
            return {
                resourceId: resourceId,
                assetId: assetId,
                title: title,
                note: note
            }
        },

        _createResourceFromSelection: function(selection) {
            return this._createResourceObject(null, selection.id, selection.title, null);
        },

        _isAssetAlreadyPendingAddition: function(assetId) {
            return _.some(this.resources.added, function(resource) {
                return resource.assetId == assetId;
            });
        },

        _doesAssetAlreadyExistAsResource: function(assetId) {
            return query('[data-existing-resource="true"][data-asset-id="' + assetId + '"]', this.resourceTable).length;
        },

        _isAssetAValidResourceTemplate: function(selection) {
            return selection.templateId === 'amCustomerPortalResourceImportTemplate';
        },

        _getRowForEvent: function(event) {
            return event.currentTarget.closest('tr');
        },

        _getAssetIdForRow: function(row) {
            return domAttr.get(row, 'data-asset-id');
        },

        _getResourceIdForRow: function(row) {
            return domAttr.get(row, 'data-resource-id');
        },

        _getTitleCellForRow: function(row) {
            return query('td.title', row)[0];
        },

        _getNoteCellForRow: function(row) {
            return query('td.note', row)[0];
        },

        _isRowForExistingResource: function(row) {
            return domAttr.get(row, 'data-existing-resource') != null;
        }
    });
});
},
'abbott/infoDialog/ByteConversion':function(){
define([
    'module', 'vodori/provide', 'dijit/_WidgetBase'
], function(module, provide, _WidgetBase
    ) {
    return provide(module.id, [_WidgetBase], {

        /**
         * Pass in the byte size
         */
        byteSize: null,

        /**
         * Simple widget for converting a number of bytes to human readable format.
         * Example usage:
         *  <div data-dojo-type="abbott/infoDialog/ByteConversion"
         *       data-dojo-props="byteSize:'${pageObject.fileSize}'"></div>
         */
        postCreate:function(){
            if(this.byteSize != null){
                this.domNode.innerHTML = this._humanizeBytes();
            }
        },

        _humanizeBytes: function() {
            var bytes = this.byteSize;
            var precision = 2;
            var kilobyte = 1024;
            var megabyte = kilobyte * 1024;
            var gigabyte = megabyte * 1024;
            var terabyte = gigabyte * 1024;

            if ((bytes >= 0) && (bytes < kilobyte)) {
                return bytes + ' B';
            } else if ((bytes >= kilobyte) && (bytes < megabyte)) {
                return (bytes / kilobyte).toFixed(precision) + ' KB';
            } else if ((bytes >= megabyte) && (bytes < gigabyte)) {
                return (bytes / megabyte).toFixed(precision) + ' MB';
            } else if ((bytes >= gigabyte) && (bytes < terabyte)) {
                return (bytes / gigabyte).toFixed(precision) + ' GB';
            } else if (bytes >= terabyte) {
                return (bytes / terabyte).toFixed(precision) + ' TB';
            } else {
                return bytes + ' B';
            }
        }
    })
});
},
'abbott/infoDialog/FilteringSelect':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'dojo/on',
    'dijit/_WidgetBase', 'dijit/form/FilteringSelect'
], function(module, provide,
            lang, on,
            _WidgetBase, FilteringSelect
    ) {
    return provide(module.id, [FilteringSelect], {

        // Default max height of the menu.
        maxHeight: 200,

        // Make the query 'contains' and not just 'begins with'
        queryExpr: "*${0}*",

        /**
         * Custom implementation to fix the issue where if you're scrolling through the select's options
         *  with your keyboard and hit Enter, you would expect it to just select that option and not submit the form
         */
        postCreate: function() {
            this.inherited(arguments);

            // vodori/ui/FromProxyPane is eating every widget's onInput function
            // Need to override that in this case so that hitting Enter doesn't submit the form
            on.once(this, 'input', lang.hitch(this, function() {
                this.onInput = this.__onInput;
            }));
        },

        __onInput:function() {
            // Don't need to do anything here
        }
    })
});
},
'abbott/infoDialog/GSSParentDocumentBrowserButton':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'dojo/on',
    'pepper/ui/LibraryBrowserButton'
], function(module, provide,
            lang, on,
            LibraryBrowserButton
    ) {
    return provide(module.id, [LibraryBrowserButton], {

        /**
         * Custom implementation of Pepper's LibraryBrowserButton,
         *  so that we can disable the button when Supporting Document Type is 'None'
         */
        postCreate: function() {
            this.inherited(arguments);

            on(select_supportingDocumentType, 'change', lang.hitch(this, function(value) {
                if (value && value == 'NONE') {
                    this.disableBrowser();
                } else {
                    this.enableBrowser();
                }
            }));

            // Need to check the value on initialization as well
            // For some reason though, if this isn't in a timeout it won't looked disabled until clicked
            setTimeout(lang.hitch(this, function() {
                if (select_supportingDocumentType.value == 'NONE') {
                    this.disableBrowser();
                }
            }, 500));
        },

        disableBrowser: function() {
            this.setDisabled(true);
        },

        enableBrowser: function() {
            this.setDisabled(false);
        }
    });
});

},
'abbott/infoDialog/ProductMultiSelect':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'dojo/on',
    'dijit/form/MultiSelect'
], function(module, provide,
            lang, on,
            MultiSelect
    ) {
    return provide(module.id, [MultiSelect], {

        /**
         * A custom MultiSelect for the Product field that publishes an event when the value is changed
         */
        postCreate: function() {
            this.inherited(arguments);
            on(this, 'change', lang.hitch(this, 'productChange'));
        },

        /**
         * Publish an event when Product value changes
         * @param value
         */
        productChange: function(value) {
            dojo.publish('amd/product/productChange', [value]);
        }
    });
});

},
'abbott/infoDialog/ProductSpecificationMultiSelect':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'dojo/_base/Deferred', 'dojo/on', 'dojo/dom-construct', 'dojo/_base/array',
    'abbott/ajax/abbottMolecularApi',
    'dijit/form/MultiSelect'
], function(
    module, provide,
    lang, Deferred, on, domConstruct, array,
    abbottMolecularApi,
    MultiSelect
) {
    return provide(module.id, [MultiSelect], {

        selectedProductSubTypes: null,
        selectedProducts: null,

        defaultOption: domConstruct.create('option', {label: '-- Select All That Apply --', value: ''}),

        /**
         * A custom MultiSelect for the Product Specification field that dynamically updates its values based on the value of the Product field
         */
        postCreate: function() {
            this.inherited(arguments);

            if (this.selectedProducts) {
                // Get the Product Specs for the initial selected products
                this.selectedProducts = this.selectedProducts.replace('[','').replace(']','').replace(/\s/g,'').split(',');
                this.getSpecificationsForProducts(this.selectedProducts);
            }

            if (this.selectedProductSubTypes) {
                // Set this select with the initial value
                this.selectedProductSubTypes = this.selectedProductSubTypes.replace('[','').replace(']','').replace(/\s/g,'').split(',');
                this.set('value', this.selectedProductSubTypes);
            } else {
                this.disableProductSpecifications(); // Disable the section if it has no initial value
            }

            // Subscribe to the Product select changing
            dojo.subscribe('amd/product/productChange', lang.hitch(this, 'getSpecificationsForProducts'));
        },

        /**
         * Perform AJAX request to get the Product Specs for the given Product value
         *
         * @param value - Array of Product values
         */
        getSpecificationsForProducts: function(value) {
            if (this.containerNode) {
                this.selectedProducts = value;

                if (value && value != '') {
                    var returnDeferred = new Deferred();
                    var params = { productNames: value };

                    var queryPromise = abbottMolecularApi.post(abbottMolecularApi.ENDPOINTS.QUERY_PRODUCT_SPECIFICATIONS, params);
                    queryPromise.done($.proxy(function(responseObject) {
                        var productSpecificationsMap = responseObject.productSpecificationsMap;
                        returnDeferred.resolve(productSpecificationsMap);

                        this.updateProductSpecifications(productSpecificationsMap);
                    }, this)).fail($.proxy(function() {
                        if (console) {
                            console.error('AJAX library query failed.');
                        }
                        this.disableProductSpecifications();
                    }, this));
                } else {
                    this.disableProductSpecifications(); // no Products selected
                }
            }
        },

        /**
         * Update the options in the Product Specification's select
         *
         * @param map Product Specification ID -> Name map
         */
        updateProductSpecifications: function(map) {
            // Empty the select and add the default
            this.containerNode.innerHTML = '';
            this.containerNode.appendChild(this.defaultOption);

            // Loop through the map, create an <option> for each, and append to this node, setting to 'selected' when applicable
            if (map && Object.keys(map).length != 0) {
                for (var property in map) {
                    if (map.hasOwnProperty(property)) {
                        var o = domConstruct.create('option', {
                            label: map[property],
                            value: property,
                            selected: this.isSubTypeSelected(property)
                        });
                        this.containerNode.appendChild(o);
                    }
                }
                this.enableProductSpecifications();
            } else {
                this.disableProductSpecifications(); // No Product Specifications for the Products selected
            }
        },

        /**
         * Is the property one of the current Product Specification values
         *
         * @param property
         * @returns {boolean}
         */
        isSubTypeSelected: function(property) {
            return array.indexOf(this.value, property) > -1;
        },

        /**
         * Enable the Product Specification section
         */
        enableProductSpecifications: function(){
            this.set('disabled', false);
            this.domNode.parentNode.setAttribute('style', 'opacity:1');
        },

        /**
         * Disable the Product Specification section and empty the value
         */
        disableProductSpecifications: function(){
            this.set('value', '');
            this.set('disabled', true);
            this.domNode.parentNode.setAttribute('style', 'opacity:.5');
        }
    });
});

},
'abbott/product/MolecularCatalogProductFilteringSelect':function(){
define([
    'module',
    'vodori/provide',
    'dijit/_WidgetBase', 'dojo/store/Memory',
    'dojo/_base/lang', 'dojo/request/xhr', 'dijit/registry', 'dojo/dom-class',
    'dojo/on', 'dojo/query'
], function(
    module,
    provide,
    _WidgetBase, Memory,
    lang, xhr, registry, domClass,
    on, query
) {

    var GET_PRODUCTS_FOR_PRODUCT_FAMILY_URL = "/ajax/product/getMolecularCatalogProductsForFamily";


    /**
     * This widget is used on the Molecular Catalog Product Template
     *
     * This widget updates the list of available products for a given product family id
     */
    return provide(module.id, [_WidgetBase], {

        // Id from the Product Family selector
        productFamilyId: null,

        // Id from the Product selector
        productCanonicalId: null,

        // List of products for the given productFamilyId, this is set by the resposne from the ajax call
        productsForProductFamily: null,

        /**
         * Product Widget - Contains full list of available products on initialization . List is filtered down upon selection of product family.
         * child of MolecularCatalogProductFilteringSelect
         * @type: abbott/infoDialog/FilteringSelect
         */
        productWidget: null,

        /**
         * Product Family Widget - Contains full list of available product families.
         * child of MolecularCatalogProductFilteringSelect
         * @type: abbott/infoDialog/FilteringSelect
         */
        productFamilyWidget: null,

        // The original list of products that is set on the product dropdown, used to reset the product dropdown if the user clears out the
        // productFamily selector
        originalListOfProducts: null,

        /**
         * dom element containing the '*' indicating the product field is required
         */
        productRequiredLabel: null,

        /**
         * The current marketId, determined by the current channel id from the CAP
         */
        marketId: null,


        /**
         * Dojo lifecycle function called after creation of the widget.
         */
        startup: function() {
            this.inherited(arguments);

            this._setChildWidgetReferences();
            this._initDomNodes();
            this._setOriginalProductDataStore();
            this._setInitalIdValues();
            this._addEventListeners();


            this._initializeWidgetValues();

        },
        
        _initDomNodes: function() {
            this.productRequiredLabel  = query('.field-required', this.domNode)[0]
        },

        /**
         * Set references to productWidget and ProductFamilyWidget
         * @private
         */
        _setChildWidgetReferences: function() {
            this.productWidget = registry.byNode(query('[widgetid^=productCanonicalId]', this.domNode)[0]);
            this.productFamilyWidget = registry.byNode(query('[widgetid^=productFamilyCanonicalId]', this.domNode)[0]);
        },

        /**
         * Creates a copy of the original values from the product dropdown so that we can reset the productWidget list when productis cleared
         * @private
         */
        _setOriginalProductDataStore: function() {
            this.originalListOfProducts = this.productWidget.get("store");
        },

        /**
         * Captures current value of product and productFamily widets
         * @private
         */
        _setInitalIdValues: function() {
            this._saveProductFamilyId();
            this._saveProductCanonicalId();
        },

        /**
         * Adds listeners to both the product and product Family Widgets
         * @private
         */
        _addEventListeners: function() {
            this.own(
                on(this.productFamilyWidget, 'change', lang.hitch(this, '_updateProductDropdown'))
            );
            this.own(
                on(this.productWidget, 'change', lang.hitch(this, '_saveProductCanonicalId'))
            );
        },

        /**
         * If  productCanonicalId has already been set and the Product family ID is not blank, update the product dropdown with the correct values for the current product family
         * @private
         */
        _initializeWidgetValues: function () {
            if (null !== this.productCanonicalId && this.productCanonicalId !== "") {
                this.productWidget.set('value', this.productCanonicalId);
            }

            if (this.productFamilyWidget.value !== "") {
                this._updateProductDropdown();
                this._updateProductRequirement();
            }
        },

        /**
         * Makes an Ajax request to the backend. Uses the Id from the Product Family Widget to query for
         * all products with that product family id.
         * @private
         */
        _updateProductDropdown: function() {

            this._productFamilyChanged();

            if(this.productFamilyId !=="") {

                xhr(GET_PRODUCTS_FOR_PRODUCT_FAMILY_URL, {
                    handleAs: "json",
                    query : {
                        productFamilyId: this.productFamilyId,
                        marketId: this.marketId
                    }
                }).then(lang.hitch(this, function(response) {
                    var productStore = new Memory({data: response});
                    this._updateProductWidgetDataSotre(productStore);
                }))
            } else {
                this._resetProductWidgetStore();
            }

            this._updateProductRequirement();
        },

        /**
         * Verifies that the product family id actually changed, and the user didn't just save the form or select the same product family.
         * If product family has changed:
         * 1. reset the product widget option list
         * 2. update the product family id and save it
         * 3. Based on the product family value, determine if the product is required
         * @private
         */
        _productFamilyChanged: function () {
            if(this.productFamilyId !== this.productFamilyWidget.value) {
                this._resetProductWidgetValue();
                this._saveProductFamilyId();
            }
        },

        /**
         * Captures the current value of the productFamilyWidget
         * @private
         */
        _saveProductFamilyId: function() {
            this.productFamilyId = this.productFamilyWidget.value;
            this._updateProductRequirement()
        },

        /**
         * Saves the Product Canonical Id. Used to persist the productCanonicalId after the data store has changed
         * @private
         */
        _saveProductCanonicalId: function() {
            this.productCanonicalId = this.productWidget.value;
        },

        /**
         * Updates the data store on the Product Widget with the given data store
         * @param productStore
         * @private
         */
        _updateProductWidgetDataSotre: function (productStore) {
            this.productWidget.set("store", productStore);
            if (this.productCanonicalId !== "") {
                this.productWidget.set('value', this.productCanonicalId);
            }
        },

        /**
         * Resets the productWidgets store to be the original entire list of products
         * @private
         */
        _resetProductWidgetStore: function() {
            this.productWidget.set("store", this.originalListOfProducts)
        },

        /**
         * Sets the value on the Product Family Widget to ''
         * @private
         */
        _resetProductFamilyWidget: function() {
            this.productFamilyWidget.set('value', '');
        },

        /**
         * Sets the value on the Product Widget to ''
         * @private
         */
        _resetProductWidgetValue: function() {
            this.productWidget.set('value', '');
        },

        _updateProductRequirement: function() {
            if(this.productFamilyId !== '') {
                this._productNotRequired();
            } else {
                this._productIsRequired();
            }
        },

        /**
         * Set the productWidget to required and show the required asterisk
         * @private
         */
        _productIsRequired: function() {
            this.productWidget.required = true;
            domClass.remove(this.productRequiredLabel, 'hidden');
        },

        /**
         * Set the productWidget to not required and hide the required asterisk
         * @private
         */
        _productNotRequired: function() {
            this.productWidget.required = false;
            domClass.add(this.productRequiredLabel, 'hidden');
        }

    });
});
},
'abbott/product/ProductFilteringSelect':function(){
define([
    'module',
    'vodori/provide',
    'dijit/_WidgetBase', 'dojo/store/Memory',
    'dojo/_base/lang', 'dojo/request/xhr', 'dijit/registry',
    'dojo/on', 'dojo/query', 'dojo/json'
], function(
    module,
    provide,
    _WidgetBase, Memory,
    lang, xhr, registry,
    on, query, json
) {

    var GET_PRODUCTS_FOR_PRODUCT_FAMILY_URL = "/ajax/product/getProductsForProductFamily";


    /**
     * This widget is used on the Probe Map template.
     *
     * It Takes a given product family Id from the product family select and updates the list of available products in the product select
     */
    return provide(module.id, [_WidgetBase], {

        // Id from the Product Family selector that is used to query for products within that family on the backend
        productFamilyId: null,

        // Node that contains the productFamily FilteringSelect Widget
        productFamilyNode: null,

        // Node that contains the product FilteringSelect widget
        productNode: null,

        // List of products for the given productFamilyId, this is set by the resposne from the ajax call
        productsForProductFamily: null,

        // The product widget
        productWidget: null,

        // The original list of products that is set on the product dropdown, used to reset the product dropdown if the user clears out the
        // productFamily selector
        originalListOfProducts: null,

        /**
         * Dojo lifecycle function called after creation of the widget.
         */
        startup: function() {
            this.inherited(arguments);

            this._initDomNodes();
            this._setOriginalProductDataStore();
            this._addEventListeners();

            this._updateProductFamilyId();

            this._initializeWidgetValues();

        },

        /**
         * Initializes product and product Family domNodes and widgets
         * @private
         */
        _initDomNodes: function () {
            this.productFamilyNode = query('.product-family-data-id-select', this.domNode)[0];
            this.productNode = query('.product-data-id-select', this.domNode)[0];
            this.productWidget = registry.byNode(query('[widgetid]', this.productNode)[0]);
            this.productFamilyWidget = registry.byNode(query('[widgetid]', this.productFamilyNode)[0]);
        },

        /**
         * Creates a copy of the original values from the product dropdown
         * @private
         */
        _setOriginalProductDataStore: function() {
            this.originalListOfProducts = this.productWidget.get("store");
        },

        /**
         * Adds listeners to both the product and product Family Widgets
         * @private
         */
        _addEventListeners: function() {
            on(this.productFamilyWidget, 'change', lang.hitch(this, '_updateProductDropdown'));
            on(this.productWidget, 'change', lang.hitch(this, '_saveProductId'));
        },

        /**
         * If the productId has already been set and the Product family ID is not '', update the product dropdown with the correct values.
         * @private
         */
        _initializeWidgetValues: function() {
            if(null != this.productId && this.productId != "") {
                this.productWidget.set('value', this.productId);
                if(this.productFamilyWidget.value != "") {
                    this._updateProductDropdown()
                }
            } else {
                // If productId has not been set, clear the productFamilyWidget
                this._resetProductFamilyWidget();
            }
        },

        /**
         * Makes an Ajax request to the backend. Uses the Id from the Product Family Widget to query for
         * all products with that product family id.
         * @private
         */
        _updateProductDropdown: function() {

            this._hasProductFamilyChanged();

            if(this.productFamilyId != "") {

                xhr(GET_PRODUCTS_FOR_PRODUCT_FAMILY_URL, {
                    handleAs: "json",
                    query : {
                        productFamilyId: this.productFamilyId
                    }
                }).then(lang.hitch(this, function(response) {
                    this._populateProductDropdown(response);
                }))
            } else {
                this._resetProductWidgetStore();
            }
        },

        /**
         * If the product family has changed, clear the productWidgetValue and update productFamilyId
         * @private
         */
        _hasProductFamilyChanged: function () {
            if(this.productFamilyId != this.productFamilyWidget.value) {
                this._resetProductWidgetValue();
                this._updateProductFamilyId();
            }
        },

        _updateProductFamilyId: function() {
            this.productFamilyId = this.productFamilyWidget.value;
        },

        /**
         * Uses the response from _updateProductDropdown to build a new data store object for the Product Dropdown.
         * If there was already a productId set (ex user is modifying an existing template) set that value on the Product Widget
         * @param response
         * @private
         */
        _populateProductDropdown: function (response) {
            this.productsForProductFamily = [];

            response.forEach(function (result) {
                // Check to see if result has vials. If so, it is a Probe Kit and we need to loop through
                // All vials and Probes
                if(null != result.vials) {
                    this._loopThroughVials(result.vials);
                } else {
                    // If the result does not have vials, it is a Single Probe. Add the probe to the list.
                    if(null != result.probe) {
                        this._addProbeToProductDataStore(probe);
                    }
                }

            }, this);

            var productStore = new Memory({data: this.productsForProductFamily});
            this._updateProductWidgetDataSotre(productStore);

        },

        /**
         * Loops through all vials in the result
         * @param vials
         * @private
         */
        _loopThroughVials: function(vials) {
            vials.forEach(function(vial) {
                this._loopThroughProbes(vial.probes);
            }, this)
        },

        /**
         * Loops through all probes in the vial
         * @param probes
         * @private
         */
        _loopThroughProbes: function(probes) {
            probes.forEach(function(probe) {
                this._addProbeToProductDataStore(probe);
            }, this)
        },

        /**
         * if the product list does not contain a probes id it will add the probe to the list
         * @param probe
         * @private
         */
        _addProbeToProductDataStore: function (probe) {
            if (!this._productListContainsProduct(probe.canonicalId)) {
                this.productsForProductFamily.push(
                    {
                        id: probe.canonicalId,
                        name: probe.name,
                        value: probe.canonicalId
                    });
            }
        },

        /**
         * Checks to see if the new product list already contains the given id
         * @param id
         * @returns {boolean}
         * @private
         */
        _productListContainsProduct: function (id) {
            var doesProductAlreadyExist = false;
            this.productsForProductFamily.forEach(function (product) {
                if (product.id == id) {
                    doesProductAlreadyExist = true;
                }
            });

            return doesProductAlreadyExist;
        },

        /**
         * Updates the data store on the Product Widget with the given data store
         * @param productStore
         * @private
         */
        _updateProductWidgetDataSotre: function (productStore) {
            this.productWidget.set("store", productStore);
            if (this.productId != "") {
                this.productWidget.set('value', this.productId);
            }
        },

        /**
         * Resets the productWidgets store to be the original entire list of products
         * @private
         */
        _resetProductWidgetStore: function() {
            this.productWidget.set("store", this.originalListOfProducts)
        },

        /**
         * Sets the value on the Product Family Widget to ''
         * @private
         */
        _resetProductFamilyWidget: function() {
            this.productFamilyWidget.set('value', '');
        },

        /**
         * Sets the value on the Product Widget to ''
         * @private
         */
        _resetProductWidgetValue: function() {
            this.productWidget.set('value', '');
        },

        /**
         * Saves the Product Id. Used to persist the productId after the data store has changed
         * @private
         */
        _saveProductId: function() {
            this.productId = this.productWidget.value;
        }
    });
});
},
'abbott/workflow/WorkflowWizardFormValidator':function(){
define([
    'vodori/provide', 'module',
    'pepper/form/workflowWizard/WorkflowWizardFormValidator'
], function(
    provide, module,
    WorkflowWizardFormValidator
    ) {

    /**
     * Generic validator for a workflow wizard field
     * Checks to make sure we're on the correct step for validation, since
     * the workflow wizard form is unique in having its fields on different steps.
     * @param {string} value The field value
     * @param {string} key The field name
     * @param {Object} formValues A map of all form inputs
     * @return {boolean} Whether the  input is valid or not at the given step
     */
    var basicIsSetValidator =  function(value, key, formValues) {
        var tryingToMoveForward = (formValues.nextStep > formValues.currentStep);
        var onCorrectPage       = (formValues.currentStep > 1);
        var isSet               = this.hasText(value);

        return !tryingToMoveForward || !onCorrectPage || isSet;
    };

    /**
     * Form validator for the Workflow Wizard. Contains validating and error functions for
     * fields that require validation in the wizard (see pepper.ui._FormValidator).
     */
    return provide(module.id, [ WorkflowWizardFormValidator ], {

        /**
         * Make sure the flowPurpose (which represents the Change value) is set
         */
        flowPurpose: basicIsSetValidator,

        flowPurposeError: function(value, key) {
            this.createErrorMessage(key, 'Please document the Change associated with this workflow.');
        },

        clientParameterValidators: {
            /**
             * Make sure clientParameters['flowReason'] is set
             */
            flowReason: basicIsSetValidator,

            flowReasonError: function(value, key) {
                this.createErrorMessage(key, 'Please provide the Reason for the change in this workflow.');
            },

            /**
             * Make sure clientParameters['flowJustification'] is set
             */
            flowJustification: basicIsSetValidator,

            flowJustificationError: function(value, key) {
                this.createErrorMessage(key, 'Please provide the Justification for the change in this workflow.');
            }

        }
    });
});


},
'abbott/workflow/TriageForm':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'dojo/_base/array', 'dojo/on', 'dojo/query', 'dojo/dom-class',
    'dijit/registry', 'dijit/_WidgetBase',
    'pepper/ui/Form'
], function(module, provide,
            lang, array, on, query, domClass,
            registry,
            _WidgetBase, Form
) {
    return provide(module.id, [Form], {

        isValidForm: null,

        startup: function(){
            this.inherited(arguments);

            var checks = query('.dijitCheckBoxInput', this.domNode);
            array.forEach(checks, function(item) {
                var parent = this._findParent(item);
                var check = registry.byNode(this._findCheckBox(parent));
                var select = registry.byNode(this._findSelect(parent));

                // Connect to CheckBoxes change, so that we can enable/disable its corresponding Select
                check.onChange = this._toggleSelect(select);

                // Some CheckBoxes might be checked from the start. If so, set the corresponding Select to be enabled
                if (item.checked){
                    select.setDisabled(false);
                }
            }, this);
        },

        /**
         * Create a function to toggle the specified Select to be enabled/disabled
         * @private
         */
        _toggleSelect: function(select) {

            return function() {
                var disabled = select.disabled;
                select.setDisabled(!disabled);
            }
        },

        /**
         * Find the parent with class name 'triage-assign'. It's what wraps the CheckBox and Select
         * @param item
         * @return {*}
         * @private
         */
        _findParent: function(item) {
            do {
                item = item.parentNode;
            } while (item && !domClass.contains(item, 'triage-assign'));
            return item;
        },

        /**
         *
         * @param parent - node to look for the CheckBox in
         * @return {*} the Select
         * @private
         */
        _findCheckBox: function(parent){
            return query('.dijitCheckBox', parent)[0];
        },

        /**
         *
         * @param parent - node to look for the Select in
         * @return {*} the Select
         * @private
         */
        _findSelect: function(parent){
            return query('.dijitSelect', parent)[0];
        }
    });
});
},
'abbott/workflow/ApproveReject':function(){
/*
 * Copyright (c) 2015. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'pepper/workflow/ApproveReject',
    'abbott/workflow/_ToggleReleaseTaskOptionMixin'
], function(module, provide,
            lang,
            ApproveReject,
            _ToggleReleaseTaskOptionMixin
    ) {
    return provide(module.id, [ApproveReject, _ToggleReleaseTaskOptionMixin], {

        _createResponseSubmitter: function (approved) {
            return lang.hitch(this, function () {
                this.hiddenCheckbox.checked = approved;
                this.value = this.hiddenCheckbox.checked;
                this.valid = true;
                this.hideReleaseTaskOption();

                if (this.autoSubmit && this.parentForm) {
                    this.parentForm.mimicFormSubmit();
                }
            });
        }
    });
});
},
'pepper/workflow/ApproveReject':function(){
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'dojo/on', 'dojo/topic',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'vodori/util/getDijitAncestorByClass',
    'pepper/ui/FormProxyPane',
    'pepper/events',
    'dojo/text!./templates/ApproveRejectButtons.html'
],
    function (
        module, provide,
        lang, on, topic,
        _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
        getDijitAncestorByClass,
        FormProxyPane,
        events,
        template) {
        /**
         * This widget is intended to be loaded from a checkbox input.
         * It will then clone the checkbox node, and then replace it with
         * two {vodori.ui.Button}s, Approve and Reject, and then append the
         * copy of the checkbox next to these buttons. This cloned checkbox
         * is intended to stay hidden, like a hidden boolean input. The
         * Approve and Reject buttons will flip the checkbox value accordingly
         * in order to approve or reject workflows.
         * @class
         */
        var ApproveReject = {
            /* attach points */
            approveButton: null,
            rejectButton: null,

            autoSubmit: false,

            /**
             * The HTML used inside the accept button.
             * @type {string}
             */
            approveButtonHtml: 'Approve',

            /**
             * The HTML used inside the reject button.
             *
             * @type {string}
             */
            rejectButtonHtml: 'Reject',

            templateString: template,

            widgetsInTemplate: true,
            checkboxNode: null,

            mustChoose: true,
            hiddenCheckbox: null,


            /**
             * Create a clone of the checkbox this is called on so that we
             * can destroy the original one by replacing it with this widget.
             * @param {Object} params Additional parameters to pass in
             * @param {DOMStringMap} checkboxNodeRef The checkbox this widget replaces
             */
            constructor: function (params, checkboxNodeRef) {
                this.value = checkboxNodeRef.value;
                this.name = checkboxNodeRef.name;
                this.valid = false;
            },

            /**
             * Place the cloned checkbox, and attach checking/unchecking
             * event handlers to the Accept and Reject buttons.
             */
            postCreate: function () {
                this.inherited(arguments);

                this.value = this.hiddenCheckbox.checked;

                this.parentForm = getDijitAncestorByClass(this.domNode, FormProxyPane);

                on(this.approveButton, 'click', this._createResponseSubmitter(true));
                on(this.rejectButton, 'click', this._createResponseSubmitter(false));
            },

            _createResponseSubmitter: function (approved) {
                return lang.hitch(this, function () {
                    this.hiddenCheckbox.checked = approved;
                    this.value = this.hiddenCheckbox.checked;
                    this.valid = true;
                    if (this.autoSubmit && this.parentForm) {
                        var promise = this.parentForm.mimicFormSubmit();

                        promise.then(function() {
                            topic.publish(events.workflow.task.statusChanged);
                        });
                    }
                });
            },

            /**
             * In order to prevent accidental submission of forms that contain these buttons by pressing ENTER,
             * this input is invalid until one of the buttons is pressed.
             *
             * @return {boolean} true, if a button has been pressed; otherwise false
             */
            validate: function () {
                return this.mustChoose ? this.valid : true;
            }
        };
        return provide(module.id, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], ApproveReject);
    }
);

},
'abbott/workflow/_ToggleReleaseTaskOptionMixin':function(){
/*
 * Copyright (c) 2015. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/query',
    'dojo/dom-style'
], function (
    module, provide,
    _,
    query,
    domStyle
    ) {

    /**
     * Temporary workaround to hide and show 'Release Task' during various task actions.
     * Pepper Bug logged: PSP-1148
     */
    return provide(module.id, [], {

        /**
         * Shows the elements associated with a workflow task's Release Task option
         */
        showReleaseTaskOption: function() {
            this._toggleReleaseTaskOption(true);
        },

        /**
         * Hides the elements associated with a workflow task's Release Task option
         */
        hideReleaseTaskOption: function() {
            this._toggleReleaseTaskOption(false);
        },

        /**
         * Toggles the display of elements for the Release Task option for a workflow task
         * @param {Boolean} shouldShow Whether to show or hide the elements related to the Release Task option
         * @private
         */
        _toggleReleaseTaskOption: function(shouldShow) {

            if (!_.isBoolean(shouldShow)) {
                throw new Error('Module with _ToggleReleaseTaskOptionMixin had _toggleReleaseTaskOption called ' +
                    'without a boolean argument!');
            }

            _([
                '.action-message-container',
                '.action-button-container',
                '.release-button-container'
            ]).forEach(function(selector) {

                domStyle.set(query(selector)[0], 'display', shouldShow ? '' : 'none');

            });

        }

    });
});
},
'abbott/workflow/MockFormSubmit':function(){
/*
 * Copyright (c) 2015. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'dojo/on',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'vodori/util/getDijitAncestorByClass',
    'pepper/ui/FormProxyPane',
    'abbott/workflow/_ToggleReleaseTaskOptionMixin',
    'dojo/text!./templates/MockFormSubmit.html'
], function(module, provide,
            lang, on,
            _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
            getDijitAncestorByClass,
            FormProxyPane,
            _ToggleReleaseTaskOptionMixin,
            template) {

    /**
     * This widget should only be used in workflows!
     */

    var MockForm = {
        templateString: template,
        parentForm: null,
        submitButton: null,

        postCreate: function() {
            this.inherited(arguments);

            this.parentForm = getDijitAncestorByClass(this.domNode, FormProxyPane);

            this.own(
                on(this.submitButton, 'click', lang.hitch(this, '_submit'))
            );
        },

        _submit: function() {
            // Hide Release Task and comments during submission
            this.hideReleaseTaskOption();

            this.parentForm.mimicFormSubmit();
        }
    };

    return provide(module.id,
        [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, _ToggleReleaseTaskOptionMixin],
        MockForm);
});
},
'abbott/workflow/CancelRejectionButton':function(){
/*
 * Copyright (c) 2015. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'module', 'vodori/provide',
    'dojo/_base/lang', 'dojo/_base/array',
    'dojo/on',
    'dojo/query', 'dojo/dom-style',
    'dijit/registry',
    'dijit/form/Form',
    'vodori/ui/Button',
    'vodori/util/getDijitAncestorByClass',
    'pepper/ui/FormProxyPane',
    'abbott/workflow/_ToggleReleaseTaskOptionMixin'
], function (
    module, provide,
    lang, array,
    on,
    query, domStyle,
    registry,
    Form,
    Button,
    getDijitAncestorByClass,
    FormProxyPane,
    _ToggleReleaseTaskOptionMixin
    ) {

    /**
     * Button widget that cancels a workflow rejection action.
     */

    return provide(module.id, [Button, _ToggleReleaseTaskOptionMixin], {

        postCreate: function() {
            this.inherited(arguments);

            this.own(on(this.domNode, 'click', lang.hitch(this, function() {

                var CANCEL_REJECT_NAME = 'cancelReject';
                var taskForm = getDijitAncestorByClass(this.domNode, Form);
                var form = getDijitAncestorByClass(this.domNode, FormProxyPane);

                // There will only be one cancelReject input.
                var cancelRejectInput = registry.byNode(
                    query('input[name="' + CANCEL_REJECT_NAME + '"]', taskForm.domNode)[0]);

                // Show release option
                this.showReleaseTaskOption();

                cancelRejectInput.set('value', true);
                form.mimicFormSubmit();

            })))
        }

    });
});
},
'abbott/workflow/IncludeRelatedDistributionsCheckbox':function(){
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/_base/lang', 'dojo/request/xhr',
    'dojo/json',
    'dojo/on', 'dojo/query', 'dojo/dom-style',
    'dijit/_WidgetBase',
    'vodori/util/csrf'
],
function (module, provide,
          _,
          lang, xhr,
          json,
          on, query, domStyle,
          _WidgetBase,
          csrf
) {

    /**
     * URI for sending front end errors to be displayed on the backend
     *
     * @type {string}
     * @private
     */
    var _logExpWorkflowURI = '/workflow/expiration-workflow/debug';

    /*
     * @class abbott/workflow/IncludeRelateDistributionsCheckbox
     *
     * Current duties of this class:
     *
     *    On change of the 'Include Related Distributions' checkbox, update the hidden includeRelatedDistributions
     *    field to 'true' or 'false' and set the flowedObjects property to be the flowed item IDs +
     *    related distribution IDs.
     *
     *    Also, hide the Previous and Next buttons (Next is disabled anyway), because navigating to previous screens
     *    will force update the flowed items of the workflow (if they had chosen to include related distributions),
     *    and things will get out of whack.
     *
     * @extends dijit/_WidgetBase
     */
    return provide(module.id, [_WidgetBase], {

        input_flowedObjects: null,
        input_includeRelatedDistributions: null,
        hiddenInput_includeRelatedDistributions: null,

        flowedItemIdsWithoutRelatedDistributions: null,
        flowedItemIdsWithRelatedDistributions: null,

        wizardDialogPreviousButton: null,
        wizardDialogNextButton: null,

        /**
         * Temporary object for debugging the expiration workflow
         * @type Object
         */
        _logExpWorkflowObject: null,

        constructor: function() {
            this._logExpWorkflowObject = {};
        },

        postCreate: function() {
            this.inherited(arguments);

            // Find the form property that holds the list of items to be included in the workflow
            this.input_flowedObjects = query('[name=flowedObjects]');

            // Find the 'Include Related Distributions' checkbox and listen for changes
            this.input_includeRelatedDistributions = query('#includeRelatedDistributions');
            this.hiddenInput_includeRelatedDistributions = query('#hiddenIncludeRelatedDistributions');

            // Set checkbox to be true by default (and set list of items to be included)
            this.updateFields(true);

            this.own(
                this.input_includeRelatedDistributions.on('change', lang.hitch(this, function() {
                    // If they chose to include related distributions, update the hidden form field and set
                    //  the flowedObjects property to be the list of flowed item IDs + related distribution IDs
                    this._logExpWorkflowObject.checkBoxElement = event.target.tagName;

                    this.updateFields(event.target.checked);
                }))
            );

            // Find and hide the 'Previous' and 'Next' buttons
            this.wizardDialogPreviousButton =
                query('.pepperWorkflowWizardDialog .vodoriWizardDialogActionBar .vodoriButton.previous');
            this.wizardDialogNextButton =
                query('.pepperWorkflowWizardDialog .vodoriWizardDialogActionBar .vodoriButton.next');

            domStyle.set(this.wizardDialogPreviousButton[0], 'display', 'none');
            domStyle.set(this.wizardDialogNextButton[0], 'display', 'none');
        },

        /**
         * Updateds the hidden input to include related distributions, and updates the flowedObjects
         * field to the correct set of items.
         *
         * @param value {@type boolean} Whether the related distributions should be included.
         */
        updateFields: function(value) {
            this._logExpWorkflowObject.initialSize = this.input_flowedObjects.length;
            this.hiddenInput_includeRelatedDistributions[0].value = (value ? 'true' : 'false');

            this.input_flowedObjects[0].value = (value ?
                this.flowedItemIdsWithRelatedDistributions :
                this.flowedItemIdsWithoutRelatedDistributions);
            this._logExpWorkflowObject.finalWorkspaceIds = this.input_flowedObjects[0].value;

            this.sendExpWorkflowToLog();
        },

        /**
         * Posts error method to the backend for logging for ADP-6095
         */
        sendExpWorkflowToLog: function() {
            var headers = {
                'Content-Type': 'application/json'
            };
            lang.mixin(headers, csrf.getHeaderKeyValuePair());

            xhr(_logExpWorkflowURI, {
                method: 'POST',
                data: json.stringify({
                    initialSize: this._logExpWorkflowObject.initialSize,
                    finalWorkspaceIds: this._logExpWorkflowObject.finalWorkspaceIds,
                    checkBoxElement: this._logExpWorkflowObject.checkBoxElement
                }),
                headers: headers,
                handleAs: 'text/plain'
            }).always(function() {
                // reset the _logExpWorkflowObject to prevent mixed data
                this._logExpWorkflowObject = {};
            });

        }
    });
});
},
'abbott/pepperConsole/Badge':function(){
/*
 * Copyright (c) 2014. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'vodori/provide', 'module',
    'dojo/_base/lang',
    'dojo/on',
    'dijit/_WidgetBase', 'dijit/_TemplatedMixin', 'dijit/_WidgetsInTemplateMixin',
    'pepper/commands/dialogs/showLibrary',
    'dojo/text!abbott/pepperConsole/templates/BadgeTemplate.html'
], function(provide, module,
            lang,
            on,
            _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin,
            showLibrary,
            template
) {

    /**
     * Pepper console page badge that opens up the Pepper library with a channel selected
     *
     * Usage:
     *   <div data-dojo-type=".../Badge"
     *     data-dojo-props="
     *        imageUrl: '${imageUrl}',
     *        label: '${label}',
     *        channelId: '${channelId}'"></div>
     */
    return provide(module.id, [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {

        templateString: template,

        /**
         * Url for badge image
         * @type {string}
         */
        imageUrl: null,

        /**
         * Label for image's alt and button
         * @type {string}
         */
        label: null,

        /**
         * Channel Id number to open the Pepper Library to
         * @type {number}
         */
        channelId: null,


        postCreate: function() {
            this.inherited(arguments);

            this.own( on(this, 'click', lang.hitch(this, '_showPepperLibrary')) );
        },

        /**
         * Show the Pepper library with this badge's channel id
         * @private
         */
        _showPepperLibrary: function() {
            showLibrary({
                channelId: this.channelId
            });
        }

    });
});
},
'simple-approval-workflow/authorMain':function(){
define([
    'simple-approval-workflow/workflow/ApproveReject',
    'simple-approval-workflow/workflow/SimpleWorkflowWizardFormValidator'
], function() {});
},
'simple-approval-workflow/workflow/ApproveReject':function(){
/*
 * Copyright (c) 2015. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'module', 'vodori/provide',
    'dojo/_base/lang',
    'pepper/workflow/ApproveReject',
    'simple-approval-workflow/workflow/_ToggleReleaseTaskOptionMixin'
], function(module, provide,
            lang,
            ApproveReject,
            _ToggleReleaseTaskOptionMixin
    ) {
    return provide(module.id, [ApproveReject, _ToggleReleaseTaskOptionMixin], {

        _createResponseSubmitter: function (approved) {
            this.hideReleaseTaskOption();

            return lang.hitch(this, function () {
                this.hiddenCheckbox.checked = approved;
                this.value = this.hiddenCheckbox.checked;
                this.valid = true;
                this.hideReleaseTaskOption();

                if (this.autoSubmit && this.parentForm) {
                    this.parentForm.mimicFormSubmit();
                }
            });
        }
    });
});
},
'simple-approval-workflow/workflow/_ToggleReleaseTaskOptionMixin':function(){
/*
 * Copyright (c) 2015. Vodori, Inc.  All rights reserved.
 *
 * This software is not open source and license for its use and
 * modification can only be granted through an agreement with
 * Vodori, Inc.
 *
 * http://www.vodori.com
 */
define([
    'module', 'vodori/provide',
    'lodash',
    'dojo/query',
    'dojo/dom-style'
], function (
    module, provide,
    _,
    query,
    domStyle
    ) {

    /**
     * Temporary workaround to hide and show 'Release Task' during various task actions.
     * Pepper Bug logged: PSP-1148
     */
    return provide(module.id, [], {

        /**
         * Shows the elements associated with a workflow task's Release Task option
         */
        showReleaseTaskOption: function() {
            this._toggleReleaseTaskOption(true);
        },

        /**
         * Hides the elements associated with a workflow task's Release Task option
         */
        hideReleaseTaskOption: function() {
            this._toggleReleaseTaskOption(false);
        },

        /**
         * Toggles the display of elements for the Release Task option for a workflow task
         * @param {Boolean} shouldShow Whether to show or hide the elements related to the Release Task option
         * @private
         */
        _toggleReleaseTaskOption: function(shouldShow) {

            if (!_.isBoolean(shouldShow)) {
                throw new Error('Module with _ToggleReleaseTaskOptionMixin had _toggleReleaseTaskOption called ' +
                    'without a boolean argument!');
            }

            _([
                '.action-message-container',
                '.action-button-container',
                '.release-button-container'
            ]).forEach(function(selector) {

                domStyle.set(query(selector)[0], 'display', shouldShow ? '' : 'none');

            });

        }

    });
});
},
'simple-approval-workflow/workflow/SimpleWorkflowWizardFormValidator':function(){
define([
    'vodori/provide', 'module',
    'lodash',
    'dijit/registry',
    'dojo/query',
    'pepper/ui/_FormValidator'
], function(
    provide, module,
    _,
    registry,
    query,
    WorkflowWizardFormValidator
) {

    /**
     * Generic validator for a workflow wizard field
     * Checks to make sure we're on the correct step for validation, since
     * the workflow wizard form is unique in having its fields on different steps.
     * @param {string} value The field value
     * @param {string} key The field name
     * @param {Object} formValues A map of all form inputs
     * @return {boolean} Whether the  input is valid or not at the given step
     */
    var basicIsSetValidator =  function(value, key, formValues) {
        var tryingToMoveForward = (formValues.nextStep > formValues.currentStep);
        var onCorrectPage       = (formValues.currentStep > 1);
        var isSet               = this.hasText(value);

        return !tryingToMoveForward || !onCorrectPage || isSet;
    };

    /**
     * Form validator for the Workflow Wizard. Contains validating and error functions for
     * fields that require validation in the wizard (see pepper.ui._FormValidator).
     */
    return provide(module.id, [ WorkflowWizardFormValidator ], {

        startup: function () {
            _.forEach(this.clientParameterValidators, function (fn, fnName) {
                var suffix = '';
                if (fnName.indexOf('Error') >= 0) {
                    fnName = fnName.substring(0, fnName.indexOf('Error'));
                    suffix = 'Error';
                }
                this['clientParameters[\'' + fnName + '\']' + suffix] = fn;
            }, this);

            this.inherited(arguments);
            this._selectFirstWorkflowOption()
        },

        /**
         * Select the first workflow option by default
         * @private
         */
        _selectFirstWorkflowOption: function() {
            var groupedSelectNode = query('.workflowDefinition-pepperInput', this.domNode.parentNode);
            if (!_.isEmpty(groupedSelectNode)) {
                groupedSelectNode = groupedSelectNode[0];
                var workflowOptions = registry.byNode(groupedSelectNode);
                workflowOptions.set('value', workflowOptions.options[0].value);
            }
        },

        /**
         * Make sure the flowPurpose (which represents the Change value) is set
         */
        flowPurpose: basicIsSetValidator,

        flowPurposeError: function(value, key) {
            this.createErrorMessage(key, 'Please document the Change associated with this workflow.');
        },

        clientParameterValidators: {
            /**
             * Make sure clientParameter['systemAssetreviewer'] is set
             */
            systemAssetReviewer: function (value, key, formValues) {
                var tryingToMoveForward = (formValues.nextStep > formValues.currentStep);
                var onCorrectPage = (formValues.currentStep > 1);
                var validPerformer = this.hasText(value);

                return !tryingToMoveForward || !onCorrectPage || validPerformer;
            },

            systemAssetReviewerError: function (value) {
                //Setting key to 'nextPerformer' due to system Asset Reviewer parameter using the pepper-workflow:NextPerformer input
                var key = "nextPerformer";
                // Doesn't pass in an HTML tag type, as the default of span is fine here
                this.createErrorMessage(key, 'Must select a performer from the list');
            }
        }
    });
});


},
'url:pepper/ui/templates/EditorToolbar.html':"<div data-dojo-attach-event=\"mousedown:_probablyAccidentalMouseDown\">\n    <div class=\"tabs\">\n        <div class=\"inner\" data-dojo-attach-point=\"tabContainer\"></div>\n    </div>\n    <div class=\"toolbars\">\n        <div class=\"inner\" data-dojo-attach-point=\"toolbarContainer\">\n            <div class=\"noEditorMessage\" data-dojo-attach-point=\"noEditorMessageNode\"></div>\n        </div>\n    </div>\n</div>\n",
'url:vodori/ui/templates/PieceOfToast.html':"<div>\n    <span data-dojo-attach-point=\"closeButtonNode\" data-dojo-attach-event=\"ondijitclick: hide\"\n          class=\"closeButton\">&times;</span>\n\n    <div data-dojo-attach-point=\"wrapperNode\" class=\"wrapper\">\n        <div data-dojo-attach-point=\"messageNode\" class=\"message\">\n            <div data-dojo-attach-point=\"titleNode\" class=\"title\">${title}</div>\n            <div data-dojo-attach-point=\"containerNode\" class=\"content\">${content}</div>\n        </div>\n\n        <div data-dojo-attach-point=\"actionsNode\" class=\"actions\"></div>\n    </div>\n</div>\n",
'url:vodori/input/templates/LogoutForm.html':"<form action=\"{{logoutUrl}}\" method=\"post\" style=\"display: none;\">\n    <input type=\"hidden\" name=\"{{csrfParam}}\" value=\"{{csrfToken}}\" />\n</form>",
'url:pepper/dialogs/distribute/templates/AssetsDisplay.html':"<div>\n    <h4>Assets (<span data-dojo-attach-point=\"assetsCount\" class=\"assets-count\"></span>)</h4>\n    {{#enableToggler}}\n    <div class=\"toggle-container\">\n        <div class=\"include-linked-assets\"\n             data-dojo-attach-point=\"togglerNode\"\n             data-dojo-type=\"vodori/input/CheckBox\"\n             data-dojo-props=\"checked: true, name: 'includeLinkedAssets'\"></div>\n        <label>Include linked assets</label>\n    </div>\n    {{/enableToggler}}\n    <fieldset>\n        <ul class=\"assets-list\" data-dojo-attach-point=\"assetsList\">\n        {{#objects}}\n        <li title=\"{{path}}\" class=\"top-level-asset {{#links.length}}has-linked-assets{{/links.length}}\">{{description}}\n            <ul class=\"assets-with-links linked-assets-list\">\n                {{#links}}\n                <li class=\"linked-asset\" title=\"{{path}}\">{{description}}</li>\n                {{/links}}\n            </ul>\n        </li>\n        {{/objects}}\n        </ul>\n    </fieldset>\n</div>",
'url:pepper/dialogs/distribute/templates/SelectChannelsPane.html':"<form data-dojo-type=\"dijit/form/Form\" class=\"pepper-form\">\n    <span class=\"errors\" style=\"display: none\"></span>\n\n    <div class=\"distribution-name-box\">\n        <label for=\"distributionName\">Distribution Name: <span class=\"field-required\">*</span></label>\n        <input data-dojo-type=\"dijit/form/TextBox\" type=\"text\" name=\"distributionName\"\n               class=\"pepper-input-field\" />\n    </div>\n\n    <!--<input type=\"checkbox\" name=\"includeLinkedAssets\" class=\"include-linked-assets\"-->\n           <!--checked=\"checked\" data-dojo-type=\"vodori/input/CheckBox\"/>-->\n    <!--<label class=\"include-linked-assets-label\" for=\"includeLinkedAssets\">Include Linked Assets</label>-->\n\n    <div class=\"assets-box\"\n         data-dojo-type=\"pepper/dialogs/distribute/AssetsDisplay\"\n         data-dojo-props=\"showLinkedAssets: {{showLinkedAssets}},\n                          assetsCountWithoutLinks: {{assetsCountWithoutLinks}},\n                          assetsCountWithLinks: {{assetsCountWithLinks}},\n                          serializedObjects: {{serializedObjects}},\n                          enableToggler: true\">\n    </div>\n\n    <div class=\"channels-box\">\n        <h4>Select channels to receive these assets:</h4>\n        <fieldset>\n            {{#networks}}\n            <h5>{{name}}</h5>\n            <select data-dojo-type=\"vodori/input/GroupedSelect\" name=\"selectedChannels\" multiple=\"true\"\n                    class=\"columns-2\" >\n                {{#channels}}\n                <option value=\"{{id}}\">{{name}}</option>\n                {{/channels}}\n            </select>\n            {{/networks}}\n        </fieldset>\n    </div>\n\n    <div style=\"clear: both\"/>\n\n</form>",
'url:pepper/dialogs/distribute/templates/ReviewPane.html':"<div class=\"pepper-form\">\n\n    <h2>Distribution Started.</h2>\n\n    <div class=\"distribution-name-box\">\n        <label>Distribution Name:</label>\n        <span>{{distributionName}}</span>\n    </div>\n\n    <div class=\"assets-box\"\n         data-dojo-type=\"pepper/dialogs/distribute/AssetsDisplay\"\n         data-dojo-props=\"showLinkedAssets: {{showLinkedAssets}},\n                          assetsCountWithoutLinks: {{assetsCountWithoutLinks}},\n                          assetsCountWithLinks: {{assetsCountWithLinks}},\n                          serializedObjects: {{serializedObjects}}\">\n    </div>\n\n    <div class=\"channels-box\">\n        <h4>Channels: ({{selectedChannels.length}})</h4>\n        <fieldset>\n            {{#networks}}\n            <h5>{{name}}</h5>\n            <ul>\n                {{#channels}}\n                <li>{{name}}</li>\n                {{/channels}}\n            </ul>\n            {{/networks}}\n        </fieldset>\n    </div>\n\n    <div style=\"clear: both\"/>\n\n</div>",
'url:pepper/dialogs/templates/Info-content.html':"<div>\n    <div data-dojo-type=\"dijit/layout/BorderContainer\"\n         data-dojo-attach-point=\"borderContainer\"\n         class=\"pepperInfoDialog\">\n\n        <div data-dojo-type=\"pepper/dialogs/info/TemplateSelector\"\n             data-dojo-props=\"region: 'leading', layoutPriority: 1\"\n             data-dojo-attach-point=\"templateSelector\"\n             class=\"templateSelector\">\n        </div>\n\n        <div data-dojo-type=\"pepper/dialogs/info/PropertyViewer\"\n             data-dojo-props=\"region: 'center'\"\n             data-dojo-attach-point=\"propertyViewer\"\n             class=\"standard tabs propertyViewer\">\n        </div>\n\n        <div data-dojo-type=\"dijit/layout/ContentPane\"\n             data-dojo-props=\"region: 'bottom', layoutPriority: 1\"\n             class=\"footer\">\n            <div data-dojo-type=\"pepper/dialogs/info/Footer\"\n                 data-dojo-attach-point=\"footer\"\n                 class=\"trailing\">\n            </div>\n        </div>\n    </div>\n</div>",
'url:dijit/templates/TitlePane.html':"<div>\n\t<div data-dojo-attach-event=\"ondijitclick:_onTitleClick, onkeydown:_onTitleKey\"\n\t\t\tclass=\"dijitTitlePaneTitle\" data-dojo-attach-point=\"titleBarNode\" id=\"${id}_titleBarNode\">\n\t\t<div class=\"dijitTitlePaneTitleFocus\" data-dojo-attach-point=\"focusNode\">\n\t\t\t<span data-dojo-attach-point=\"arrowNode\" class=\"dijitInline dijitArrowNode\" role=\"presentation\"></span\n\t\t\t><span data-dojo-attach-point=\"arrowNodeInner\" class=\"dijitArrowNodeInner\"></span\n\t\t\t><span data-dojo-attach-point=\"titleNode\" class=\"dijitTitlePaneTextNode\"></span>\n\t\t</div>\n\t</div>\n\t<div class=\"dijitTitlePaneContentOuter\" data-dojo-attach-point=\"hideNode\" role=\"presentation\">\n\t\t<div class=\"dijitReset\" data-dojo-attach-point=\"wipeNode\" role=\"presentation\">\n\t\t\t<div class=\"dijitTitlePaneContentInner\" data-dojo-attach-point=\"containerNode\" role=\"region\" id=\"${id}_pane\" aria-labelledby=\"${id}_titleBarNode\">\n\t\t\t\t<!-- nested divs because wipeIn()/wipeOut() doesn't work right on node w/padding etc.  Put padding on inner div. -->\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n",
'url:vodori/input/templates/DateAndTime.html':"<div class=\"date_and_time_inputs\">\n    <input data-dojo-type=\"vodori/input/DateTextBox\" data-dojo-attach-point=\"dateInput\" value=\"\" class=\"date_input\"/>\n    <input data-dojo-type=\"vodori/input/TimeTextBox\" data-dojo-attach-point=\"timeInput\" value=\"\" class=\"time_input\"/>\n    <button type=\"button\" data-dojo-attach-point=\"clearButton\" class=\"standard clearDateTime\"\n            data-dojo-type=\"vodori/ui/Button\">X\n    </button>\n</div>",
'url:dijit/templates/Calendar.html':"<table cellspacing=\"0\" cellpadding=\"0\" class=\"dijitCalendarContainer\" role=\"grid\" aria-labelledby=\"${id}_mddb ${id}_year\" data-dojo-attach-point=\"gridNode\">\n\t<thead>\n\t\t<tr class=\"dijitReset dijitCalendarMonthContainer\" valign=\"top\">\n\t\t\t<th class='dijitReset dijitCalendarArrow' data-dojo-attach-point=\"decrementMonth\" scope=\"col\">\n\t\t\t\t<span class=\"dijitInline dijitCalendarIncrementControl dijitCalendarDecrease\" role=\"presentation\"></span>\n\t\t\t\t<span data-dojo-attach-point=\"decreaseArrowNode\" class=\"dijitA11ySideArrow\">-</span>\n\t\t\t</th>\n\t\t\t<th class='dijitReset' colspan=\"5\" scope=\"col\">\n\t\t\t\t<div data-dojo-attach-point=\"monthNode\">\n\t\t\t\t</div>\n\t\t\t</th>\n\t\t\t<th class='dijitReset dijitCalendarArrow' scope=\"col\" data-dojo-attach-point=\"incrementMonth\">\n\t\t\t\t<span class=\"dijitInline dijitCalendarIncrementControl dijitCalendarIncrease\" role=\"presentation\"></span>\n\t\t\t\t<span data-dojo-attach-point=\"increaseArrowNode\" class=\"dijitA11ySideArrow\">+</span>\n\t\t\t</th>\n\t\t</tr>\n\t\t<tr role=\"row\">\n\t\t\t${!dayCellsHtml}\n\t\t</tr>\n\t</thead>\n\t<tbody data-dojo-attach-point=\"dateRowsNode\" data-dojo-attach-event=\"ondijitclick: _onDayClick\" class=\"dijitReset dijitCalendarBodyContainer\">\n\t\t\t${!dateRowsHtml}\n\t</tbody>\n\t<tfoot class=\"dijitReset dijitCalendarYearContainer\">\n\t\t<tr>\n\t\t\t<td class='dijitReset' valign=\"top\" colspan=\"7\" role=\"presentation\">\n\t\t\t\t<div class=\"dijitCalendarYearLabel\">\n\t\t\t\t\t<span data-dojo-attach-point=\"previousYearLabelNode\" class=\"dijitInline dijitCalendarPreviousYear\" role=\"button\"></span>\n\t\t\t\t\t<span data-dojo-attach-point=\"currentYearLabelNode\" class=\"dijitInline dijitCalendarSelectedYear\" role=\"button\" id=\"${id}_year\"></span>\n\t\t\t\t\t<span data-dojo-attach-point=\"nextYearLabelNode\" class=\"dijitInline dijitCalendarNextYear\" role=\"button\"></span>\n\t\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\t</tfoot>\n</table>\n",
'url:vodori/input/templates/WhatsThis.html':"<div class=\"whats-this\">\n    <span data-dojo-attach-point=\"whatsThisButton\" class=\"whats-this-button\">What's This?</span>\n\n    <div data-dojo-attach-point=\"whatsThisContent\" class=\"whats-this-content hidden\"></div>\n</div>",
'url:pepper/input/templates/FileInput.html':"<div class=\"fileInput\">\n    <input data-dojo-type=\"dijit/form/TextBox\" data-dojo-props='name:\"file\", type:\"file\"'\n           class=\"realFileInput\" data-dojo-attach-point=\"realFileInput\"/>\n\n    <div class=\"fakeInput\">\n        <span class=\"browse\">Browse</span>\n        <input data-dojo-attach-point=\"fakeFileInput\" type=\"text\"/>\n    </div>\n</div>",
'url:pepper/ui/templates/TableTreeSection.mustache':"<div class=\"tree-section\">\n    <h3 class=\"tree-header\">{{sectionHeader}}</h3>\n\n    <hr/>\n\n    {{^children.length}}\n        <div class=\"no-content-message\">\n            {{noContentMessage}}\n        </div>\n    {{/children.length}}\n\n    {{#children.length}}\n        <div class=\"tree-root\" data-dojo-attach-point=\"tree\">\n            <div class=\"tree-top-layer\">\n                {{>tableTree}}\n            </div>\n        </div>\n    {{/children.length}}\n\n</div>\n",
'url:pepper/ui/templates/TableTreePartial.mustache':"<table class=\"tree-layer\">\n\n    <thead>\n        <tr>\n            <th></th>\n            {{#headers}}\n                <th>\n                    {{#content}}{{{content}}}{{/content}}\n                    {{^content}}\n                        {{#icon}}<div class=\"{{icon}}\"></div>{{/icon}}\n                    {{/content}}\n                </th>\n            {{/headers}}\n        </tr>\n    </thead>\n\n    <tbody>\n\n        {{#children}}\n\n            <tr {{#current}}class=\"current-row\"{{/current}}>\n\n                <td>\n                    {{#children.length}}\n                        <div class=\"expando-icon expando-open\" data-expando-button-id=\"{{id}}\"></div>\n                    {{/children.length}}\n                </td>\n\n                {{#columns}}\n                    <td>\n                        {{#content}}{{{content}}}{{/content}}\n                        {{^content}}\n                            {{#icon}}\n                            <div class=\"{{icon}}\" {{#title}}title=\"{{title}}\"{{/title}}></div>\n                            {{/icon}}\n                        {{/content}}\n                    </td>\n                {{/columns}}\n\n            </tr>\n\n            {{#children.length}}\n                <tr data-expando-section-id=\"{{id}}\">\n                    <td></td>\n                    <td colspan=\"{{headers.length}}\">\n                        <div class=\"tree-sub-layer\">\n                            {{>tableTree}}\n                        </div>\n                    </td>\n                </tr>\n            {{/children.length}}\n\n        {{/children}}\n\n    </tbody>\n</table>",
'url:pepper/dialogs/info/tabs/templates/RelationshipsTab.html':"<div class=\"relationshipsTab\">\n\n    <div class=\"relationships-header\">\n        <h4>Current asset in <span data-dojo-attach-point=\"channelNameNode\" class=\"current-channel\"></span>\n        </h4>\n    </div>\n\n    <div class=\"relationships-container\">\n        <div data-dojo-attach-point=\"distributionNode\"></div>\n\n        <div data-dojo-attach-point=\"linkNode\"></div>\n\n        <div data-dojo-attach-point=\"copyNode\"></div>\n    </div>\n\n</div>",
'url:pepper/dialogs/info/tabs/templates/PermissionsTab.html':"<div>\n    <div data-dojo-type=\"dijit/layout/ContentPane\" data-dojo-attach-point=\"pane\"></div>\n</div>",
'url:vodori/ui/templates/LazyDialog.html':"<div class=\"dijitDialog vodoriLazyDialog\" role=\"dialog\" aria-labelledby=\"${id}_title\">\n    <div data-dojo-attach-point=\"titleBar\" class=\"dijitDialogTitleBar\">\n\t\t<span data-dojo-attach-point=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"\n              role=\"header\" level=\"1\"></span>\n\t\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\"\n              data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n\t\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t\t</span>\n    </div>\n    <div data-dojo-attach-point=\"lazyContainerNode\"\n         data-dojo-type=\"dijit/layout/ContentPane\"\n         data-dojo-props=\"href: '${contentHref}'\"\n         class=\"dijitDialogPaneContent vodoriLazyDialogPaneContent\"></div>\n</div>\n",
'url:pepper/dialogs/info/tabs/templates/RenditionsTab.html':"<div>\n    <div class=\"renditionsGrid\" data-dojo-attach-point=\"grid\" style=\"height: 85%\"></div>\n    <div data-dojo-attach-point=\"addSection\" class=\"add-section\">\n        <button class=\"standard\"\n                type=\"button\"\n                data-dojo-type=\"vodori/ui/Button\"\n                data-dojo-attach-point=\"uploadButton\">\n            Upload New Rendition\n        </button>\n    </div>\n</div>",
'url:pepper/dialogs/templates/Footer-content.html':"<div class=\"trailing\">\n    <button type=\"button\"\n            data-dojo-type=\"vodori/ui/Button\"\n            data-dojo-attach-point=\"cancel\"\n            class=\"cancel standard\">\n        Cancel\n    </button>\n    <button type=\"button\"\n            data-dojo-type=\"vodori/ui/Button\"\n            data-dojo-attach-point=\"previous\"\n            class=\"previous previousButton standard\">\n        Previous\n    </button>\n    <button type=\"button\"\n            data-dojo-type=\"vodori/ui/Button\"\n            data-dojo-attach-point=\"next\"\n            class=\"next nextButton standard\">\n        Next\n    </button>\n    <button type=\"button\"\n            data-dojo-type=\"vodori/ui/Button\"\n            data-dojo-attach-point=\"skip\"\n            class=\"skip skipButton standard\">\n        Skip\n    </button>\n    <button type=\"button\"\n            data-dojo-type=\"vodori/ui/Button\"\n            data-dojo-attach-point=\"save\"\n            class=\"apply standard action\">\n        Save\n    </button>\n    <button type=\"button\"\n            data-dojo-type=\"vodori/ui/Button\"\n            data-dojo-attach-point=\"done\"\n            class=\"doneButton standard default action\">\n        Done\n    </button>\n    <button type=\"button\"\n            data-dojo-type=\"vodori/ui/Button\"\n            data-dojo-attach-point=\"exit\"\n            class=\"exit standard\">\n        Cancel\n    </button>\n</div>",
'url:dijit/templates/ProgressBar.html':"<div class=\"dijitProgressBar dijitProgressBarEmpty\" role=\"progressbar\"\n\t><div  data-dojo-attach-point=\"internalProgress\" class=\"dijitProgressBarFull\"\n\t\t><div class=\"dijitProgressBarTile\" role=\"presentation\"></div\n\t\t><span style=\"visibility:hidden\">&#160;</span\n\t></div\n\t><div data-dojo-attach-point=\"labelNode\" class=\"dijitProgressBarLabel\" id=\"${id}_label\"></div\n\t><span data-dojo-attach-point=\"indeterminateHighContrastImage\"\n\t\t   class=\"dijitInline dijitProgressBarIndeterminateHighContrastImage\"></span\n></div>\n",
'url:pepper/import/templates/Review.html':"<div>\n    <div data-dojo-type=\"dijit/layout/BorderContainer\" style=\"height: 400px; width: 600px;\"\n         data-dojo-attach-point=\"container\">\n        <div data-dojo-type=\"vodori/ui/Grid\"\n             data-dojo-props=\"columns: pepper.dialogs.import.configs.review.columns,\n                            store: pepper.dialogs.import.configs.review.store,\n                            region: 'center',\n                            title: 'Review'\"\n             data-dojo-attach-point=\"grid\"\n             class=\"grid pepperGrid\">\n        </div>\n\n        <div data-dojo-type=\"dijit/layout/ContentPane\" data-dojo-props=\"region: 'bottom', layoutPriority: 2\" class=\"status\">\n        <span class=\"actions\">\n            <button type=\"button\" data-dojo-type=\"vodori/ui/Button\"\n                    data-dojo-attach-point=\"selectAllBtn\"\n                    class=\"selectAll\">select all\n            </button> |\n            <button type=\"button\" data-dojo-type=\"vodori/ui/Button\"\n                    data-dojo-attach-point=\"selectNoneBtn\"\n                    class=\"selectNone\">select none\n            </button>\n        </span>\n        <span class=\"selected\">\n            Selected <span class=\"selectedItems\"\n                           data-dojo-attach-point=\"selectedItemsText\"></span>.\n        </span>\n            <span class=\"progress\">0%</span>\n        </div>\n\n        <div data-dojo-type=\"dijit/layout/ContentPane\" data-dojo-props=\"region: 'bottom', layoutPriority: 1\" class=\"footer\">\n            <!--<div class=\"leading\">-->\n            <!--<button type=\"button\" data-dojo-type=\"vodori/ui/Button\" class=\"standard help\">?</button>-->\n            <!--</div>-->\n\n            <div class=\"trailing\">\n                <button type=\"button\" data-dojo-type=\"vodori/ui/Button\"\n                        data-dojo-attach-point=\"laterBtn\"\n                        class=\"standard cancel later\">Review later\n                </button>\n                <button type=\"button\" data-dojo-type=\"vodori/ui/Button\"\n                        data-dojo-attach-point=\"reviewBtn\"\n                        data-dojo-props=\"disabled: true\" class=\"standard default action review\">Review\n                </button>\n                <button type=\"button\" data-dojo-type=\"vodori/ui/Button\"\n                        data-dojo-attach-point=\"doneBtn\"\n                        class=\"standard default done action\">Done\n                </button>\n            </div>\n        </div>\n    </div>\n</div>",
'url:pepper/import/templates/ImportPepperDoc.html':"<div>\n    <div data-dojo-type=\"dijit/layout/BorderContainer\"\n         data-dojo-attach-point=\"importerPane\" style=\"height: 400px; width: 600px;\" class=\"importPepperDoc\">\n        <!--One thousand apologies for this simulated table-->\n\n        <div data-dojo-type=\"dijit/layout/ContentPane\" data-dojo-props=\"region: 'top', layoutPriority: 1\">\n            <div class=\"heading\">\n                <span class=\"name\">File Name</span>\n                <span class=\"size\">Size</span>\n                <span class=\"status\">Import Status</span>\n            </div>\n        </div>\n\n        <div data-dojo-type=\"dijit/layout/ContentPane\"\n             data-dojo-props=\"region: 'top', layoutPriority: 2\"\n             data-dojo-attach-point=\"failuresPane\" class=\"failures\">\n            <div class=\"heading\">\n                <span><span data-dojo-attach-point=\"failuresCount\" class=\"failed\"></span> could not be imported. </span>\n                <!--<button type=\"button\" data-dojo-attach-point=\"messageButton\"\n                                          data-dojo-type=\"vodori/ui/Button\" class=\"sendMessage\">Send me the list</button>-->\n            </div>\n        </div>\n\n        <div data-dojo-type=\"dijit/layout/ContentPane\"\n             data-dojo-props=\"region: 'center'\"\n             data-dojo-attach-point=\"filesPane\"\n             class=\"files\">\n            <!--<div class=\"file\">\n                <span class=\"name\">Name</span>\n                <span class=\"size\">Size</span>\n                <span class=\"status\">Status</span>\n            </div>-->\n        </div>\n\n        <div class=\"dragFilesHere\"\n             data-dojo-attach-point=\"dragFilesHere\">\n            Drag Files Here\n        </div>\n\n        <div data-dojo-type=\"dijit/layout/ContentPane\" data-dojo-props=\"region: 'bottom', layoutPriority: 2\"\n             class=\"progress\">\n        <span class=\"name\">\n            <span><span class=\"imported\" data-dojo-attach-point=\"progressImportedNode\">0</span> of\n                <span data-dojo-attach-point=\"progressTotalNode\" class=\"total\">0</span> files imported</span>\n            <span class=\"progressBar\"\n                  data-dojo-type=\"dijit/ProgressBar\"\n                  data-dojo-attach-point=\"progressBarNode\" value=\"0\"></span>\n        </span>\n            <span class=\"size\" data-dojo-attach-point=\"totalSizeNode\">0B</span>\n            <span class=\"status\" data-dojo-attach-point=\"progressStatusNode\">0%</span>\n        </div>\n\n        <div data-dojo-type=\"dijit/layout/ContentPane\" data-dojo-props=\"region: 'bottom', layoutPriority: 1\" class=\"footer\">\n            <div class=\"trailing\" data-dojo-attach-point=\"footerTrailNode\">\n                <button type=\"button\" data-dojo-type=\"vodori/ui/Button\"\n                        data-dojo-attach-point=\"cancelButton\" class=\"standard cancel cancelImport\">Cancel\n                </button>\n                <button type=\"button\" data-dojo-type=\"vodori/ui/Button\"\n                        data-dojo-attach-point=\"addButton\" class=\"standard action add\">Add Files\n                </button>\n                <button type=\"button\" data-dojo-type=\"vodori/ui/Button\"\n                        data-dojo-attach-point=\"startButton\"\n                        data-dojo-props=\"disabled: 'disabled'\" class=\"standard default action start\">Start Upload\n                </button>\n                <button type=\"button\" data-dojo-type=\"vodori/ui/Button\"\n                        data-dojo-attach-point=\"closeButton\" class=\"standard close\">Close\n                </button>\n                <button type=\"button\" data-dojo-type=\"vodori/ui/Button\"\n                        data-dojo-attach-point=\"reviewLaterButton\" class=\"standard cancel reviewLater\">Review later\n                </button>\n                <button type=\"button\" data-dojo-type=\"vodori/ui/Button\"\n                        data-dojo-attach-point=\"reviewNowButton\" class=\"standard default action reviewNow\">Start asset\n                    review\n                </button>\n            </div>\n        </div>\n    </div>\n</div>",
'url:pepper/dialogs/templates/FolderInfo.html':"<div class=\"folderInfoWidget\">\n    <div data-dojo-type=\"pepper/dialogs/info/FolderPropertiesPane\" data-dojo-attach-point=\"form\"\n         data-dojo-props=\"type: '${type}', folderId: '${folderId}', parentFolderId: '${parentFolderId}'\"\n         class=\"folderInfoForm\"></div>\n    <div class=\"trailing-container group\">\n        <div class=\"trailing\">\n            <button type=\"button\"\n                    data-dojo-type=\"vodori/ui/Button\"\n                    data-dojo-attach-point=\"cancelButton\"\n                    class=\"cancel standard\">\n                Cancel\n            </button>\n            <button type=\"button\"\n                    data-dojo-type=\"vodori/ui/Button\"\n                    data-dojo-attach-point=\"saveButton\"\n                    class=\"apply standard action\">\n                Save\n            </button>\n            <button type=\"button\"\n                    data-dojo-type=\"vodori/ui/Button\"\n                    data-dojo-attach-point=\"doneButton\"\n                    class=\"doneButton standard default action\">\n                Done\n            </button>\n        </div>\n    </div>\n</div>",
'url:pepper/dialogs/info/templates/PostTemplateViewer-content.html':"<div class=\"postTemplateViewer\">\n    <div data-dojo-attach-event=\"onClick:deselectTemplate\" data-dojo-type=\"vodori/ui/Button\"\n         class=\"pepper-ui channel-network-select-button standard action\">Browse\n    </div>\n    <div><img class=\"thumb\" data-dojo-attach-point=\"templateThumbnail\"></div>\n    <div class=\"label\" data-dojo-attach-point=\"templateLabel\"></div>\n</div>",
'url:pepper/import/templates/ImportRefDoc.html':"<div>\n    <div data-dojo-type=\"dijit/layout/BorderContainer\"\n         data-dojo-attach-point=\"importerPane\" style=\"height: 400px; width: 600px;\" class=\"importRefDoc\">\n        <!--One thousand apologies for this simulated table-->\n\n        <div data-dojo-type=\"dijit/layout/ContentPane\" data-dojo-props=\"region: 'top', layoutPriority: 1\">\n            <div class=\"heading\">\n                <span class=\"name\">File Name</span>\n                <span class=\"size\">Size</span>\n                <span class=\"status\">Import Status</span>\n            </div>\n        </div>\n\n        <div data-dojo-type=\"dijit/layout/ContentPane\"\n             data-dojo-props=\"region: 'top', layoutPriority: 2\"\n             data-dojo-attach-point=\"failuresPane\" class=\"failures\">\n            <div class=\"heading\">\n                <span><span data-dojo-attach-point=\"failuresCount\" class=\"failed\"></span> could not be imported. </span>\n                <!--<button type=\"button\" data-dojo-attach-point=\"messageButton\"\n                                          data-dojo-type=\"vodori/ui/Button\" class=\"sendMessage\">Send me the list</button>-->\n            </div>\n        </div>\n\n        <div data-dojo-type=\"dijit/layout/ContentPane\"\n             data-dojo-props=\"region: 'center'\"\n             data-dojo-attach-point=\"filesPane\"\n             class=\"files\">\n            <!--<div class=\"file\">\n                <span class=\"name\">Name</span>\n                <span class=\"size\">Size</span>\n                <span class=\"status\">Status</span>\n            </div>-->\n        </div>\n\n        <div class=\"dragFilesHere\"\n             data-dojo-attach-point=\"dragFilesHere\">\n            Drag Files Here\n        </div>\n\n        <div data-dojo-type=\"dijit/layout/ContentPane\" data-dojo-props=\"region: 'bottom', layoutPriority: 2\"\n             class=\"progress\">\n        <span class=\"name\">\n            <span><span class=\"imported\" data-dojo-attach-point=\"progressImportedNode\">0</span> of\n                <span data-dojo-attach-point=\"progressTotalNode\" class=\"total\">0</span> files imported</span>\n            <span class=\"progressBar\"\n                  data-dojo-type=\"dijit/ProgressBar\"\n                  data-dojo-attach-point=\"progressBarNode\" value=\"0\"></span>\n        </span>\n            <span class=\"size\" data-dojo-attach-point=\"totalSizeNode\">0B</span>\n            <span class=\"status\" data-dojo-attach-point=\"progressStatusNode\">0%</span>\n        </div>\n\n        <div data-dojo-type=\"dijit/layout/ContentPane\" data-dojo-props=\"region: 'bottom', layoutPriority: 1\" class=\"footer\">\n            <div class=\"trailing\" data-dojo-attach-point=\"footerTrailNode\">\n                <button type=\"button\" data-dojo-type=\"vodori/ui/Button\"\n                        data-dojo-attach-point=\"cancelButton\" class=\"standard cancel cancelImport\">Cancel\n                </button>\n                <button type=\"button\" data-dojo-type=\"vodori/ui/Button\"\n                        data-dojo-attach-point=\"addButton\" class=\"standard action add\">Add Files\n                </button>\n                <button type=\"button\" data-dojo-type=\"vodori/ui/Button\"\n                        data-dojo-attach-point=\"startButton\"\n                        data-dojo-props=\"disabled: 'disabled'\" class=\"standard default action start\">Start Upload\n                </button>\n                <button type=\"button\" data-dojo-type=\"vodori/ui/Button\"\n                        data-dojo-attach-point=\"closeButton\" class=\"standard close\">Close\n                </button>\n            </div>\n        </div>\n    </div>\n</div>",
'url:pepper/form/workflowWizard/templates/OptionsGrid-option.html':"<div class=\"workflow-definition\">\n    <div class=\"label\">${label}</div>\n    <img src=\"${thumbnail}\" class=\"thumb\"/>\n    <article class=\"description\">${description}</article>\n</div>\n",
'url:dijit/templates/InlineEditBox.html':"<span data-dojo-attach-point=\"editNode\" role=\"presentation\" class=\"dijitReset dijitInline dijitOffScreen\"\n\t><span data-dojo-attach-point=\"editorPlaceholder\"></span\n\t><span data-dojo-attach-point=\"buttonContainer\"\n\t\t><button data-dojo-type=\"./form/Button\" data-dojo-props=\"label: '${buttonSave}', 'class': 'saveButton'\"\n\t\t\tdata-dojo-attach-point=\"saveButton\" data-dojo-attach-event=\"onClick:save\"></button\n\t\t><button data-dojo-type=\"./form/Button\"  data-dojo-props=\"label: '${buttonCancel}', 'class': 'cancelButton'\"\n\t\t\tdata-dojo-attach-point=\"cancelButton\" data-dojo-attach-event=\"onClick:cancel\"></button\n\t></span\n></span>\n",
'url:pepper/form/workflowWizard/templates/ObjectListItem.html':"<li data-pepper-object-list-item-id=\"${listedItem.item.id}\">\n    <div class=\"listed-document\">\n        <!-- Note that you cannot comment things out. -->\n        <div class=\"thumbnail-wrapper\">\n            <img src=\"${listedItem.thumbnailUrl}\" alt=\"Thumbnail for ${listedItem.item.logicalName}\">\n        </div>\n        <div class=\"meta-data\">\n            <h3 class=\"item-title\">${listedItem.item.logicalName}</h3>\n            <span class=\"remove-btn ${mutability}\" data-pepper-object-list-item-remover=\"true\">\n                <button type=\"button\" data-dojo-type=\"vodori/ui/Button\" class=\"remove-button\">remove</button>\n            </span>\n            <hr/>\n            <span class=\"path\"><a href=\"${listedItem.item.url}\" target=\"pepper-review-window\">\n                ${listedItem.item.primaryUri}</a></span>\n            Attached:\n            <span data-dojo-type=\"pepper/utilities/DateFormatWrapper\">\n                ${listedItem.dateAdded.time}\n            </span>\n\n            <div class=\"comment-box\">\n                <h3 class=\"item-title\">Comments & Specific Reference Points</h3>\n\n                <div class=\"item-comment add-btn\">${listedItem.comment}</div>\n            </div>\n        </div>\n        <div class=\"group\"></div>\n    </div>\n</li>\n",
'url:pepper/workflow/templates/NextPerformerSelector.html':"<div class=\"pepper-workflow-next-performer-selector\">\n    <div class=\"group-selector next-performer-selector-option selected\" data-dojo-attach-point=\"groupContainer\">Any\n        member of group:\n        <div class=\"group-name\">${groupName}</div>\n    </div>\n    <div class=\"person-selector next-performer-selector-option nextPerformer-pepperInput\" data-dojo-attach-point=\"performerContainer\">\n        Select specific performer:\n        <div>\n            <input data-dojo-type=\"dijit/form/FilteringSelect\"\n                   data-dojo-props=\"searchAttr:'name',\n                                    placeHolder: 'Last name, First name',\n                                    required: false,\n                                    autoComplete: 'true',\n                                    invalidMessage:'Not a member of this review group'\"\n                   name=\"performer\"\n                   data-dojo-attach-point=\"performerSelector\">\n        </div>\n        <div>\n            <span class=\"selected-performer\"></span>\n        </div>\n    </div>\n    <div class=\"hidden-inputs\">\n        <input type=\"text\" data-dojo-type=\"vodori/input/TextBox\" name=\"performerType\"\n               data-dojo-attach-point=\"performerType\"/>\n        <input type=\"text\" data-dojo-type=\"vodori/input/TextBox\" name=\"${propertyName}\"\n               data-dojo-attach-point=\"nextPerformer\"/>\n    </div>\n</div>",
'url:pepper/dialogs/sync/templates/Sync.html':"<div>\n    <div class=\"main\">\n        <div class=\"top\" data-dojo-attach-point=\"messageNode\">\n            <strong>Author's Note:</strong> \"${syncMessage}\"\n        </div>\n        <div class=\"asset-headers\">\n            <div class=\"arrow\"></div>\n            <div class=\"column left\">\n                <div class=\"header-data\">\n                    <div class=\"sync-icon\"></div>\n                    <div class=\"name-and-channel\">\n                        <h1>${latestSyncInfo.logicalName}</h1>\n                        <h2>${latestSyncInfo.channelName}</h2>\n                    </div>\n                </div>\n                <div class=\"change-status\">\n                    Updates have been made to: <strong>${updateText}</strong>\n                </div>\n            </div>\n            <div class=\"column right\">\n                <div class=\"header-data\">\n                    <div class=\"name-and-channel\">\n                        <h1>${outOfDateInfo.logicalName}</h1>\n                        <h2>${outOfDateInfo.channelName}</h2>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <div class=\"asset-bodies\">\n            <div class=\"column left\">\n                <table class=\"asset-data\">\n                    <tr class=\"data-item\">\n                        <td class=\"label\">Version:</td>\n                        <td class=\"value\">${latestSyncInfo.version} (${latestSyncInfo.state})</td>\n                    </tr>\n                    <tr class=\"data-item\">\n                        <td class=\"label\">Date available:</td>\n                        <td class=\"value\">${latestSyncInfo.available.friendlyDate} (${latestSyncInfo.available.display})</td>\n                    </tr>\n                    <tr class=\"data-item\">\n                        <td class=\"label\">Language:</td>\n                        <td class=\"value\">${latestSyncInfo.locale.localeDisplay} (${latestSyncInfo.locale.localeCode})</td>\n                    </tr>\n                    <tr class=\"data-item\">\n                        <td class=\"label\">Size:</td>\n                        <td class=\"value\">${latestSyncInfo.size}</td>\n                    </tr>\n                    <tr class=\"data-item\">\n                        <td class=\"label\">Path:</td>\n                        <td class=\"value\">${latestSyncInfo.path}</td>\n                    </tr>\n                </table>\n            </div>\n            <div class=\"column right\">\n                <table class=\"asset-data\">\n                    <tr class=\"data-item\">\n                        <td class=\"label\">Last sync:</td>\n                        <td class=\"value\">${outOfDateInfo.lastSyncVersion} (${outOfDateInfo.lastSyncState})</td>\n                    </tr>\n                    <tr class=\"data-item\">\n                        <td class=\"label\">Last sync date:</td>\n                        <td class=\"value\">${outOfDateInfo.lastSyncDate.friendlyDate} (${outOfDateInfo.lastSyncDate.display})</td>\n                    </tr>\n                    <tr class=\"data-item\">\n                        <td class=\"label\">Language:</td>\n                        <td class=\"value\">${outOfDateInfo.locale.localeDisplay} (${outOfDateInfo.locale.localeCode})</td>\n                    </tr>\n                    <tr class=\"data-item\">\n                        <td class=\"label\">Size:</td>\n                        <td class=\"value\">${outOfDateInfo.size}</td>\n                    </tr>\n                    <tr class=\"data-item\">\n                        <td class=\"label\">Path:</td>\n                        <td class=\"value\">${outOfDateInfo.path}</td>\n                    </tr>\n                </table>\n            </div>\n        </div>\n        <div class=\"asset-footers\">\n            <div class=\"column left\">\n                <div class=\"asset-thumbnail\" data-dojo-type=\"pepper/ui/ThumbnailPreviewer\"\n                     data-dojo-props=\"\n                     thumbnailUri:'${latestSyncInfo.thumbnailUri}',\n                     targetUri:'${latestSyncInfo.primaryUri}',\n                     size:'small'\"></div>\n                <div class=\"view-properties-wrapper\">\n                    <button data-dojo-type=\"pepper/workflow/ViewInfoButton\"\n                            data-dojo-props=\"objectId: '${latestSyncInfo.objectId}'\"\n                            class=\"vodoriButton standard default\">View properties</button>\n                </div>\n            </div>\n            <div class=\"column right\">\n                <div class=\"asset-thumbnail\" data-dojo-type=\"pepper/ui/ThumbnailPreviewer\"\n                     data-dojo-props=\"\n                     thumbnailUri:'${outOfDateInfo.thumbnailUri}',\n                     targetUri:'${outOfDateInfo.primaryUri}',\n                     size:'small'\"></div>\n                <div class=\"view-properties-wrapper\">\n                    <button data-dojo-type=\"pepper/workflow/ViewInfoButton\"\n                            data-dojo-props=\"objectId: '${outOfDateInfo.objectId}'\"\n                            class=\"vodoriButton standard default\">View properties</button>\n                </div>\n            </div>\n        </div>\n    </div>\n    <div class=\"footer group\">\n        <div class=\"trailing\">\n            <button type=\"button\"\n                    data-dojo-type=\"vodori/ui/Button\"\n                    data-dojo-attach-point=\"cancelButton\"\n                    class=\"cancel standard\">\n                Cancel\n            </button>\n            <button type=\"button\"\n                    data-dojo-type=\"vodori/ui/Button\"\n                    data-dojo-attach-point=\"updateButton\"\n                    class=\"standard default action\">\n                Sync as latest\n            </button>\n        </div>\n    </div>\n</div>",
'url:pepper/ui/templates/ThumbnailPreviewer.html':"<div class=\"${size}\">\n    <a class=\"target-link\" href=\"${targetUri}\" target=\"_blank\">\n        <img class=\"link-icon\" src=\"/static/js/pepper/images/new-window.png\"/>\n    </a>\n    <!-- Do not put any white space around the image tag or you will run into the inline-block bug -->\n    <div class=\"thumbnail-wrapper\"><img class=\"thumbnail\" src=\"${thumbnailUri}\" /></div>\n    <div class=\"caption\"><em>${caption}</em></div>\n</div>",
'url:pepper/stripe/templates/Lifecycle/Lifecycle-state.html':"<section class=\"state {{id}}\"\n         data-lifecycle-version=\"{{version}}\"\n         data-lifecycle-id=\"{{id}}\"\n         data-lifecycle-url=\"{{url}}\">\n\n    <div class=\"version-group\">\n        <h1 class=\"label\">{{label}}</h1>\n\n        <div class=\"version\"><span class=\"number\">{{{getDisplayVersion}}}</span></div>\n    </div>\n\n    <div class=\"hor-rule\"></div>\n\n    <ul class=\"description\">\n        {{#dates}}\n        <li>{{dateDescription}}</li>\n        <li>{{getDate}}</li>\n        <li>{{userName}}</li>\n        {{/dates}}\n    </ul>\n</section>",
'url:pepper/stripe/templates/Lifecycle/Lifecycle-workflow.html':"<div class=\"workflow\">\n    <span class=\"workflowIcon\"></span>\n\n    <ul class=\"detail-list\">\n        <li><strong>In workflow: {{workflowName}}{{^workflowName}}Unnamed workflow{{/workflowName}}</strong></li>\n        <li><em>Current task:</em> <a href=\"{{#taskId}}/pepper/inbox#/tasks/{{taskId}}{{/taskId}}\"\n                                      target=\"pepperInboxWindow\">\n            {{taskName}}{{^taskName}}Unnamed Task{{/taskName}}</a>, assigned to:\n            {{assignee}}{{^assignee}}Unassigned{{/assignee}}\n        </li>\n        {{#createdDate}}\n        <li>Task created on: {{createdDate}}{{^createdDate}}Unknown date{{/createdDate}}</li>\n        {{/createdDate}}\n    </ul>\n</div>\n",
'url:pepper/stripe/templates/Lifecycle/Lifecycle-versions.html':"<div class=\"pepperLifecyclePopupPanel pepper quarantine\" data-lifecycle-panel=\"closed\">\n    <div class=\"container\">\n        <div class=\"handle\"><span>Past Versions</span></div>\n        <div class=\"content\"><p><a href=\"javascript:pepper.commands.dialogs.showInfo('Versions')\">View version history\n            list</a></p></div>\n    </div>\n</div>",
'url:pepper/stripe/templates/Lifecycle/Lifecycle-info.html':"<div class=\"pepperLifecyclePopupDetails\">\n    <div class=\"details\"></div>\n    <div class=\"separator\"></div>\n    <div class=\"history\"></div>\n</div>",
'url:pepper/stripe/templates/Lifecycle/Lifecycle-details.html':"<ul class=\"detail-list\">\n    <li>Version {{version}}:<span>Created: {{versionCreateDate}}</span></li>\n    <li>Last modified:<span>{{modified}} by {{modifiedBy}}</span></li>\n    <li>Original (1.0) created:<span>{{createDate}}</span></li>\n    <li>{{{lockStatus}}}</li>\n</ul>",
'url:pepper/stripe/templates/Lifecycle/Lifecycle-history.html':"<ul class=\"detail-list\">\n    <li>{{action}} on: <span>{{date}}</span></li>\n    <li>by: <span class=\"userName\">{{userName}}</span></li>\n    <li>from: <span>{{fileName}}, version {{version}}</span></li>\n</ul>",
'url:vodori/ui/templates/LazyPopup.html':"<div role=\"presentation\" tabIndex=\"-1\">\n    <div class=\"dijitTooltipContainer\" role=\"presentation\">\n        <div data-dojo-attach-point=\"lazyContainerNode\"\n             data-dojo-type=\"dijit/layout/ContentPane\"\n             data-dojo-props=\"href: '${contentHref}'\"\n             role=\"dialog\"\n             class=\"dijitTooltipContents dijitTooltipFocusNode vodoriLazyPopupContent\"></div>\n    </div>\n    <div class=\"dijitTooltipConnector\" role=\"presentation\" data-dojo-attach-point=\"connectorNode\"></div>\n</div>\n",
'url:pepper/stripe/templates/Messages.html':"<div class=\"messages\"\n     data-dojo-attach-point=\"messagesContainerNode\"></div>\n\n<div class=\"statusBar\">\n    <span class=\"unread\"><span class=\"count\" data-dojo-attach-point=\"messagesCountNode\">0</span> unread messages</span>\n    <button class=\"viewInbox\" data-dojo-attach-point=\"inboxButtonNode\">View inbox</button>\n</div>\n",
'url:pepper/stripe/templates/MessageItem.html':"<div class=\"message\">\n    <div class=\"messageTitle\">${title} <span class=\"messageSent\">${sent}</span></div>\n    <div class=\"messageSender\">${sender}</div>\n    <div class=\"messageBody\">${body}</div>\n\n    <div class=\"messageTools\">\n        <button class=\"open\">Open</button>\n        <button class=\"markRead\">Mark read</button>\n        <button class=\"delete\">Delete</button>\n    </div>\n</div>\n",
'url:pepper/stripe/templates/SearchBox.html':"<div>\n    <input data-dojo-attach-point=\"textbox\" data-dojo-type=\"vodori/input/TextBox\"\n           data-dojo-props=\"\n                placeHolder: 'Search the Library',\n                intermediateChanges: true\"/>\n    <div data-dojo-attach-point=\"popup\" data-dojo-type=\"pepper/stripe/SearchPopup\"></div>\n</div>\n",
'url:pepper/stripe/templates/SearchPopup.html':"<table class=\"results\" data-dojo-attach-point=\"resultsTable\"></table>\n<button type=\"button\" data-dojo-type=\"vodori/ui/Button\" class=\"viewAll\"\n        data-dojo-attach-point=\"viewAllButton\">View all results&rsaquo;</button>",
'url:vodori/tinymce/codemirror/templates/CodeEditorDialog.html':"<div class=\"tinymce-html-editor\">\n    <textarea data-dojo-type=\"vodori/input/CodeEditor\"\n              data-dojo-props=\"hasToolbars: false\"\n              value=\"${value}\"\n              class=\"codeEditor\"\n            data-dojo-attach-point=\"codeEditor\"></textarea>\n    <div class=\"mceActionPanel\">\n        <button type=\"button\"\n               data-dojo-type=\"vodori/ui/Button\"\n               data-dojo-attach-point=\"cancel\"\n               name=\"cancel\"\n               class=\"cancel standard\">\n            Cancel\n        </button>\n        <button type=\"button\"\n               data-dojo-type=\"vodori/ui/Button\"\n               data-dojo-attach-point=\"insert\"\n               name=\"insert\"\n               class=\"save action standard default insert\">\n            Update\n        </button>\n    </div>\n</div>",
'url:vodori/video/templates/LimelightVideoPlayer.html':"<div class=\"limelightVideoContainer\">\n    ${!videoHTML}\n</div>",
'url:vodori/ui/templates/Twitter.html':"<div id=\"twitterWidgetWrapper \">\n\n    <!-- MODE: SINGLE USER -->\n    <div class=\"twitterWidget\">\n        <div class=\"twitterHeader\">\n            <span class=\"userThumbnailImg\" dojoAttachPoint=\"userThumbnailNode\"></span>\n            <span class=\"userName\" dojoAttachPoint=\"usernameNode\"></span>\n        </div>\n        <div class=\"singleUserTweetList\" dojoAttachPoint=\"singleUserTweetList\"></div>\n    </div>\n\n\n    <!-- MODE: MULTI USER/HASHTAG -->\n    <div class=\"twitterWidget\">\n        <div class=\"multiUserTweetList\" dojoAttachPoint='multiUserTweetList'></div>\n    </div>\n\n\n    <!-- MODE: SINGLE TWEET FROM MULTIPLE USERS -->\n</div>",
'url:vodori/filter/templates/FilterUIBox.html':"<div class=\"filter-ui-box filter-group\">\n    <div data-dojo-type=\"dijit/TitlePane\" data-dojo-attach-point=\"titlePane\" class=\"filter-title\"\n         data-dojo-props=\"title: '${title}'\">\n\n        <div class=\"filter-body ${paddingOption}\">\n            <button type=\"button\"\n                    data-dojo-type=\"vodori/ui/Button\"\n                    data-dojo-attach-point=\"clearBtn\"\n                    style=\"display:none;\"\n                    class=\"clearAll\">Clear\n            </button>\n\n            <div data-dojo-attach-point='containerNode'></div>\n\n        </div>\n    </div>\n    <div class=\"summary\" data-dojo-attach-point=\"summaryPane\">\n        Summary\n    </div>\n</div>",
'url:vodori/filter/templates/summaryPane.html':"<div>\n    <div class=\"summary-title\">Currently selected {{title}}</div>\n    <ul class=\"summary-list\">\n        {{#summaries}}\n        <li>{{text}}<span class='summary-delete-handle' data-filter-deselect-target='{{label}}'>x</span></li>\n        {{/summaries}}\n    </ul>\n</div>",
'url:pepper/library/filter/ui/templates/ContentType.html':"<div>\n    <div data-dojo-type=\"vodori/filter/FilterUIBox\" data-dojo-props=\"title: '{{title}}'\">\n        <div data-dojo-type=\"vodori/filter/BasicFilterWidget\"\n             data-dojo-props=\"filter:'pepper/library/filter/model/OnlyMyStuff'\"></div>\n\n        <hr/>\n\n        <div data-dojo-type=\"vodori/filter/BasicFilterWidget\"\n             data-dojo-props='filter: \"pepper/library/filter/model/Type\"\n                         {{#filterData}},filterData: {{{filterData}}} {{/filterData}}'></div>\n    </div>\n</div>\n",
'url:pepper/library/filter/ui/templates/LockOwner.html':"<div>\n    <div data-dojo-type=\"vodori/filter/FilterUIBox\" data-dojo-props=\"title: '{{title}}'\">\n        <div data-dojo-type=\"vodori/filter/BasicFilterWidget\"\n             data-dojo-props='filter:\"pepper/library/filter/model/LockOwner\"\n                              {{#filterData}},filterData: {{{filterData}}} {{/filterData}}'></div>\n    </div>\n</div>\n",
'url:pepper/library/filter/ui/templates/StateVersion.html':"<div>\n    <div data-dojo-type=\"vodori/filter/FilterUIBox\" data-dojo-props=\"title: '{{title}}'\">\n        <div data-dojo-type=\"vodori/filter/BasicFilterWidget\"\n             data-dojo-props=\"filter:'pepper/library/filter/model/AllVersions'\"\n             data-dojo-attach-point=\"allVersionFilter\"></div>\n        <hr/>\n        <div class=\"filter-description\"><i>The current version...</i></div>\n        <div class=\"state-filter-target-type group\" data-dojo-type=\"vodori/filter/BasicFilterWidget\"\n             data-dojo-props=\"filter: 'pepper/library/filter/model/StateTargetType'\"\n             data-dojo-attach-point=\"stateFilterTargetType\"></div>\n        <div class=\"filter-description\"><i>state of</i></div>\n        <div data-dojo-type=\"vodori/filter/BasicFilterWidget\"\n             data-dojo-props='filter: \"pepper/library/filter/model/State\",\n                              separators: { before: [\"Reception\"], after: [\"Reception\"] }\n             {{#filterData}},filterData: {{{filterData}}} {{/filterData}}'\n             data-dojo-attach-point=\"stateFilter\"></div>\n    </div>\n</div>\n\n",
'url:pepper/library/filter/ui/templates/TimeEvent.html':"<div>\n    <div class=\"time-event-filter\"\n         data-dojo-type=\"vodori/filter/FilterUIBox\"\n         data-dojo-props=\"title: '{{title}}', asComposite: true\"\n         data-dojo-attach-point=\"filterBox\">\n\n        <div data-dojo-type=\"vodori/filter/DropdownFilterWidget\"\n             data-dojo-props='filter: \"pepper/library/filter/model/EventType\"'\n             data-dojo-attach-point=\"eventType\"></div>\n\n        <label>occurred...</label>\n\n        <div data-dojo-type=\"vodori/filter/BasicFilterWidget\"\n             data-dojo-props='filter: \"pepper/library/filter/model/EventOccurrence\"'\n             data-dojo-attach-point=\"eventOccurrence\"></div>\n\n        <div data-dojo-type=\"vodori/filter/DateFilterWidget\"\n             data-dojo-props='filter: \"pepper/library/filter/model/EventDate\"'\n             data-dojo-attach-point=\"eventDate\"></div>\n\n        <button data-dojo-type=\"vodori/ui/Button\" data-dojo-event=\"click\" class=\"standard action apply\"\n                data-dojo-attach-point=\"applyButton\">Apply\n        </button>\n\n    </div>\n</div>\n",
'url:pepper/library/filter/ui/templates/Directory.html':"<div>\n    <div data-dojo-type=\"vodori/filter/FilterUIBox\" data-dojo-props=\"title: '{{title}}', paddingOption: 'no-padding'\">\n        <div data-dojo-type=\"pepper/library/filter/ui/TreeFilterWidget\" data-dojo-attach-point='treeWidget'\n             data-dojo-props='\n                filter: \"pepper/library/filter/model/Directory\"\n                {{#filterData}},filterData: {{{filterData}}} {{/filterData}}\n             '></div>\n    </div>\n</div>\n\n",
'url:pepper/library/filter/ui/templates/Category.html':"<div>\n    <div data-dojo-type=\"vodori/filter/FilterUIBox\" data-dojo-props=\"title: '{{title}}', paddingOption: 'no-padding'\">\n        <div data-dojo-type=\"pepper/library/filter/ui/TreeFilterWidget\" data-dojo-attach-point='treeWidget'\n             data-dojo-props='\n                filter: \"pepper/library/filter/model/Category\",\n             '></div>\n    </div>\n</div>\n\n",
'url:pepper/library/filter/ui/templates/Tag.html':"<div>\n    <div data-dojo-type=\"vodori/filter/FilterUIBox\" data-dojo-props=\"title: '{{title}}', paddingOption: 'no-padding'\">\n        <div data-dojo-type=\"pepper/library/filter/ui/TreeFilterWidget\" data-dojo-attach-point='treeWidget'\n             data-dojo-props='\n                filter: \"pepper/library/filter/model/Tag\",\n             '></div>\n    </div>\n</div>\n\n",
'url:pepper/library/filter/ui/templates/Workflow.html':"<div>\n    <div data-dojo-type=\"vodori/filter/FilterUIBox\" data-dojo-props=\"title: 'Workflow'\">\n        <div data-dojo-type=\"vodori/filter/BasicFilterWidget\"\n             data-dojo-props=\"filter:'pepper/library/filter/model/AllWorkflowHistory'\"></div>\n        <hr/>\n        <div><i>Show only items in workflow type...</i></div>\n\n        <div data-dojo-type=\"vodori/filter/BasicFilterWidget\"\n             data-dojo-props='filter: \"pepper/library/filter/model/WorkflowType\",\n                                              filterData: {{filterData.workflowDefinitions}}'></div>\n\n        <div data-dojo-type=\"vodori/filter/BasicFilterWidget\"\n             data-dojo-props='filter: \"pepper/library/filter/model/WorkflowName\"'></div>\n\n    </div>\n</div>\n",
'url:vodori/input/templates/FilteringCheckedSelect.html':"<div name=\"${name}\">\n    <input data-dojo-attach-point=\"focusNode\"\n           placeholder=\"${placeholder}\"\n           name=\"_${name}_textBox\"/>\n\n    <div id=\"${id}_selectBox\"\n         name=\"_${name}_selectBox\"\n         data-dojo-attach-point=\"containerNode,_checkedSelectNode\">\n    </div>\n</div>\n",
'url:abbott/editing/ui/block/formBased/orderingInformation/sortable/MolecularCatalogOrderingInformationSingleRowTemplate.html':"{{#orderingInformation}}\n<td>{{#productDisplayName}}{{{productDisplayName}}}{{/productDisplayName}}{{^productDisplayName}}{{productName}}{{/productDisplayName}}{{#regulatoryStatus}}<span class=\"bold\"> ({{regulatoryStatus}})</span>{{/regulatoryStatus}}</td>\n<td>{{quantity}}</td>\n<td>{{orderNumber}}</td>\n<td>{{gtin}}</td>\n{{/orderingInformation}}",
'url:abbott/editing/ui/block/formBased/instructionsForUse/InstructionsForUseBlockLanguageDropdownOptions.html':"{{#options}}\n<option value=\"{{value}}\" {{#selected}}selected=\"true\"{{/selected}}>{{displayValue}}</option>\n{{/options}}",
'url:abbott/editing/ui/block/formBased/instructionsForUse/InstructionsForUseBlockSearchOptionsDropdownOptions.html':"{{#options}}\n<option value=\"{{searchValue}}\" {{#selected}}selected=\"true\"{{/selected}}>{{displayValue}}</option>\n{{/options}}",
'url:abbott/editing/ui/block/formBased/instructionsForUse/InstructionsForUseBlockProductGroupDropdownOptions.html':"{{#options}}\n<option value=\"{{value}}\">{{displayValue}}</option>\n{{/options}}",
'url:abbott/editing/ui/block/formBased/MolecularCatalogOrderingInformationTemplate.html':"<div class=\"row add-block-margin\">\n    <div class=\"column-12\">\n        <h5>{{orderingInformationHeader}}</h5>\n        <div class=\"table-wrapper\">\n            <table>\n                <tbody>\n                <tr>\n                    <td>Product Name</td>\n                    <td>Unit Size</td>\n                    <td>Order Number</td>\n                    <td>GTIN</td>\n                </tr>\n                {{#orderingInformation}}\n                <tr>\n                    <td>{{#productDisplayName}}{{{productDisplayName}}}{{/productDisplayName}}{{^productDisplayName}}{{productName}}{{/productDisplayName}}{{#regulatoryStatus}}<span class=\"bold\"> ({{regulatoryStatus}})</span>{{/regulatoryStatus}}</td>\n                    <td>{{quantity}}</td>\n                    <td>{{orderNumber}}</td>\n                    <td>{{gtin}}</td>\n                </tr>\n                {{/orderingInformation}}\n                </tbody>\n            </table>\n        </div>\n    </div>\n</div>",
'url:pepper/library/templates/IconViewCell.html':"<div>\n    <div data-dojo-attach-point=\"iconContainer\" class=\"icon\">\n        <img src=\"${data.thumbnailUrl}\"/>\n    </div>\n    <div data-dojo-attach-point=\"name\" class=\"name\">${data.name}</div>\n</div>",
'url:pepper/library/filter/ui/templates/ChannelSelector.html':"<div>\n    Channel:\n    <div data-dojo-type=\"pepper/ui/DropDownButton\" data-dojo-attach-point=\"_dropdownButton\">\n        <span><i>Loading...</i></span>\n        <div data-dojo-type=\"dijit/TooltipDialog\" data-dojo-attach-point=\"_dropdownDialog\"\n             class=\"channelSelectorDialog\"></div>\n    </div>\n</div>",
'url:pepper/library/filter/ui/templates/NetworksAndChannels.html':"<div>\n    {{# networks }}\n    <div class=\"network\">\n        <strong>{{ name }}</strong><br />\n        {{# channels }}\n        <button data-dojo-type=\"vodori/ui/Button\"\n                data-dojo-props=\"objectId: '{{ id }}'\"\n                class=\"{{ current }}\">{{ name }}</button><br />\n        {{/ channels }}\n    </div>\n    {{/ networks }}\n</div>",
'url:pepper/library/filter/ui/templates/CustomFilter.html':"<div>\n    <div data-dojo-type=\"vodori/filter/FilterUIBox\" data-dojo-props=\"title: '{{title}}'\">\n        <div data-dojo-type=\"vodori/filter/BasicFilterWidget\"\n             data-dojo-props='filter:\"pepper/library/filter/model/CustomFilter\"\n                              {{#filterData}},filterData: {{{filterData}}} {{/filterData}}'></div>\n    </div>\n</div>\n",
'url:pepper/library/templates/Library.html':"<div class=\"library-container pepperLibrary\">\n    <div data-dojo-type=\"dijit/layout/BorderContainer\"\n         data-dojo-attach-point=\"_container\"\n         class=\"border-container\">\n\n        <!-- This becomes the title if we're in a dialog. -->\n        <div data-dojo-type=\"dijit/layout/ContentPane\"\n             data-dojo-attach-point=\"_title\"\n             data-dojo-props=\"region: 'top'\"\n             data-vodori-dialog-title=\"true\"\n             class=\"title-container titleBar\">\n            <span class=\"title\">Pepper Library</span>\n\n            <div class=\"leading\">\n                <div data-dojo-attach-point=\"_channelSelectorNode\"></div>\n            </div>\n\n            <div class=\"trailing\">\n                <input type=\"text\" data-dojo-type=\"vodori/input/TextBox\"\n                       data-dojo-props=\"placeHolder: 'Search', intermediateChanges: true\"\n                       data-dojo-attach-point=\"_searchBox\"\n                       class=\"search\"/>\n                <div data-dojo-attach-point=\"facetedSearch\"\n                     data-dojo-type=\"pepper/library/filter/ui/FacetedSearch\"\n                     class=\"facetedSearch\"></div>\n            </div>\n        </div>\n\n        <div data-dojo-type=\"dijit/layout/ContentPane\"\n             data-dojo-attach-point=\"_viewSelectorContainer\"\n             data-dojo-props=\"region: 'top'\">\n            <div data-dojo-attach-point=\"_viewSelectorButtons\" class=\"view-selector\">\n            </div>\n        </div>\n\n        <div data-dojo-type=\"dijit/layout/ContentPane\"\n             data-dojo-attach-point=\"_summarizer\"\n             data-dojo-props=\"region: 'top'\"\n             class=\"summarizer\">\n            <h3>Summarizer</h3>\n        </div>\n\n        <div data-dojo-type=\"dijit/layout/BorderContainer\"\n             data-dojo-props=\"region: 'center', liveSplitters: false\"\n             data-dojo-attach-point=\"_centerBorderContainer\"\n             class=\"center-border-container\">\n\n            <div data-dojo-type=\"vodori/filter/FilterContainer\"\n                 data-dojo-attach-point=\"_primaryFilterContainer\"\n                 data-dojo-props=\"splitter: true, region: 'leading'\"\n                 class=\"primary-filter-container filters\">\n            </div>\n\n            <div data-dojo-type=\"dijit/layout/BorderContainer\"\n                 data-dojo-attach-point=\"_primaryViewer\"\n                 data-dojo-props=\"region: 'center'\"\n                 class=\"nested-view-filter\">\n                <div data-dojo-type=\"dijit/layout/ContentPane\"\n                     data-dojo-attach-point=\"_channelsGrid\"\n                     data-dojo-props=\"region: 'center'\"\n                     class=\"channels-grid\">\n                    <h4>Channel grid</h4>\n                </div>\n\n                <div data-dojo-type=\"dijit/layout/ContentPane\"\n                     data-dojo-attach-point=\"_subscriptionsGrid\"\n                     data-dojo-props=\"region: 'center'\"\n                     class=\"subscriptions-grid\">\n                    <h4>Subs grid</h4>\n                </div>\n\n                <div data-dojo-type=\"dijit/layout/ContentPane\"\n                     data-dojo-attach-point=\"_categoriesGrid\"\n                     data-dojo-props=\"region: 'center'\"\n                     class=\"categories-grid\">\n                    <h4>Cat grid</h4>\n                </div>\n\n                <div data-dojo-type=\"dijit/layout/ContentPane\"\n                     data-dojo-attach-point=\"_tagsGrid\"\n                     data-dojo-props=\"region: 'center'\"\n                     class=\"tags-grid\">\n                    <h4>Tag grid</h4>\n                </div>\n\n                <div data-dojo-type=\"pepper/library/ResultsHeader\"\n                     data-dojo-attach-point=\"_resultsHeader\"\n                     data-dojo-props=\"region: 'top'\"\n                     class=\"header\"></div>\n\n                <div data-dojo-attach-point=\"_resultsGridNode\"\n                     class=\"results-grid resultsGrid pepperGrid\">\n                </div>\n            </div>\n            <div data-dojo-type=\"pepper/library/DetailsPane\"\n                 data-dojo-attach-point=\"_details\"\n                 data-dojo-props=\"region: 'bottom', layoutPriority: 1\"\n                 class=\"details\">\n            </div>\n        </div>\n        <div data-dojo-type=\"dijit/layout/ContentPane\"\n             data-dojo-attach-point=\"_footer\"\n             data-dojo-props=\"region: 'bottom', layoutPriority: 0\"\n             class=\"footer\">\n            <div class=\"leading\"></div>\n            <div class=\"total\"></div>\n            <div class=\"trailing\">\n                <div data-dojo-type=\"vodori/ui/Button\" data-dojo-attach-event=\"onClick: cancel\" class=\"standard cancel\">Cancel</div>\n                <div data-dojo-type=\"vodori/ui/Button\" data-dojo-attach-event=\"onClick: _confirmHandler\" class=\"apply insert standard default action\">OK</div>\n            </div>\n        </div>\n    </div>\n</div>\n\n",
'url:vodori/filter/templates/FilterContainer.html':"<div class=\"vodori-filter-container\">\n    <div data-dojo-attach-point=\"headerNode\" class=\"filter-container-head\">\n        <strong>Narrow Results By</strong>\n        <button type=\"button\"\n                data-dojo-type=\"vodori/ui/Button\"\n                data-dojo-attach-point=\"clearAllButton\"\n                data-dojo-props=\"disabled: true\"\n                class=\"clearAll\">Clear all</button>\n    </div>\n    <div data-dojo-attach-point=\"containerNode\" class=\"filterbox-container\"></div>\n</div>",
'url:pepper/library/filter/ui/templates/TreeFilterWidget.html':"<div>\n    <div data-dojo-attach-point=\"tree\" class=\"filter-tree pepperGrid noLayout\"></div>\n</div>\n",
'url:pepper/library/templates/DetailsPane.html':"<div data-dojo-attach-point=\"containerNode\">\n    <div data-dojo-type=\"dijit/layout/ContentPane\"\n         data-dojo-attach-point=\"_fileDisplay\"\n         class=\"details-container\">\n        <!-- Rendered via Mustache. See ./detailsPane/(bulk|single).html -->\n    </div>\n    <div data-dojo-type=\"dijit/layout/ContentPane\"\n         data-dojo-attach-point=\"_categorizationDisplay\"\n         class=\"categorization\">\n\n        <div class=\"tags-and-categories\">\n            <table>\n                <tbody>\n                <tr>\n                    <td class=\"label-col\">${tagsName}</td>\n                    <td class=\"tags\" data-dojo-attach-point=\"tagsNode\">(Tags)</td>\n                </tr>\n                <tr>\n                    <td class=\"label-col\">${categoriesName}</td>\n                    <td class=\"categories\" data-dojo-attach-point=\"categoriesNode\">(Categories)</td>\n                </tr>\n                </tbody>\n            </table>\n        </div>\n    </div>\n</div>\n",
'url:pepper/library/templates/detailsPane/single.html':"<div class=\"file-display single\">\n    <div class=\"thumbnail-container\">\n        {{#thumbnailUrl}}\n        <img class=\"thumbnail\"\n             data-dojo-type=\"vodori/ui/LoadingAwareImage\"\n             data-dojo-props=\"src: '{{thumbnailUrl}}'\"\n             data-dojo-attach-point=\"_thumbnail\"/>\n        {{/thumbnailUrl}}\n    </div>\n    <div class=\"file-details\">\n        <p class=\"description\">{{description}}</p>\n        <p class=\"size\">({{contentStreamLength}})</p>\n        {{#lifecycle}}\n            {{#details}}\n                <p>{{createMessage}} by {{createdBy}} {{#originalChannel}} from Channel {{originalChannel}} {{/originalChannel}}on {{createDateLocal}}</p>\n            {{/details}}\n        {{/lifecycle}}\n        {{#lastModifier}}\n            <p>Last Modified by {{lastModifier}}</p>\n        {{/lastModifier}}\n        {{#lifecycle}}\n            {{#lockOwner}}\n                <div class=\"locked-asset\"></div><p>Locked by {{lockOwner}}</p>\n            {{/lockOwner}}\n        {{/lifecycle}}\n        {{#pathLabels}}\n            <div class=\"path-details\">\n                <div>Paths: {{pathLabels}}</div>\n            </div>\n        {{/pathLabels}}\n    </div>\n</div>\n",
'url:pepper/library/templates/detailsPane/bulk.html':"<div class=\"file-display bulk\">\n    <div class=\"thumbnail-container\">\n        <img class=\"thumbnail\"\n             data-dojo-type=\"vodori/ui/LoadingAwareImage\"\n             data-dojo-props=\"src: '/static/js/pepper/images/MultiAsset.png'\"\n             data-dojo-attach-point=\"_thumbnail\"/>\n    </div>\n    <div class=\"file-details\">\n        <p class=\"description\">Selected {{count}} objects.</p>\n        <p class=\"size\">({{contentStreamLength}})</p>\n        {{#lastModifier}}\n        <p>Last Modified by {{lastModifier}}</p>\n        {{/lastModifier}}\n    </div>\n</div>\n",
'url:pepper/library/templates/ResultsHeader-content.html':"<form> <!-- This form is needed to contain the List/Grid GroupedSelect -->\n    <div class=\"leading buttonSet\">\n        <button data-dojo-type=\"vodori/ui/Button\" class=\"createBtn\">Create</button>\n        <button data-dojo-type=\"vodori/ui/Button\" class=\"importBtn\">Import</button>\n    </div>\n\n    <div class=\"leading action buttonSet\">\n        <button data-dojo-type=\"pepper/ui/DropDownButton\" disabled=\"disabled\" class=\"actionMenuBtn\">\n            <span>&#9784;</span>\n            <div data-dojo-type=\"pepper/library/LibraryContextMenu\" data-dojo-props=\"inline: true\" class=\"actionMenu\"></div>\n        </button>\n    </div>\n\n    <div class=\"leading action buttonSet\">\n        <button data-dojo-type=\"vodori/ui/Button\" class=\"downloadBtn\">Download CSV</button>\n    </div>\n\n    <div class=\"leading action buttonSet\">\n        <button data-dojo-type=\"vodori/ui/Button\" class=\"refreshBtn\">Refresh</button>\n    </div>\n\n    <div class=\"leading shortcut buttonSet\">\n        <button data-dojo-type=\"vodori/ui/Button\" class=\"removeFolderButton\">Remove from Folder</button>\n        <button data-dojo-type=\"vodori/ui/Button\" class=\"removeTagButton\">Remove Tag</button>\n        <button data-dojo-type=\"vodori/ui/Button\" class=\"removeCategoryButton\">Remove Category</button>\n    </div>\n\n    <div class=\"trailing view buttonSet\">\n        <div data-dojo-type=\"vodori/input/GroupedSelect\" data-dojo-props=\"options: [{ label : 'List', value : 'list' }, { label : 'Grid', value : 'grid' }]\" class=\"viewSelect\">\n        </div>\n    </div>\n\n    <div class=\"trailing totalResults buttonSet\">\n        <span class=\"totalResultsCount\">---</span>\n    </div>\n</form>",
'url:pepper/library/filter/ui/templates/FacetedSearch.html':"<div>\n    <div data-dojo-type=\"pepper/ui/DropDownButton\" data-dojo-attach-point=\"_dropDownButton\">\n        <span class=\"activeFacetCount\"></span>\n        <div data-dojo-type=\"dijit/ConfirmTooltipDialog\" class=\"facetedSearchDialog\"\n             data-dojo-props=\"buttonCancel: 'Clear All', buttonOk: 'Apply'\"\n             data-dojo-attach-point=\"_facetsDialog\">\n            <div data-dojo-attach-point=\"_facetsContainer\" class=\"facets\"></div>\n        </div>\n    </div>\n</div>",
'url:pepper/library/filter/ui/templates/SearchFacet.html':"<input type=\"text\" class=\"searchFacet\" name=\"{{property}}\"\n       data-dojo-type=\"vodori/input/TextBox\"\n       data-dojo-props=\"placeHolder: '{{placeHolder}}', clearable: true\"/>",
'url:dijit/templates/actionBar.html':"<div class='dijitDialogPaneActionBar' data-dojo-attach-point=\"actionBarNode\">\n\t<button data-dojo-type='dijit/form/Button' type='submit' data-dojo-attach-point=\"okButton\"></button>\n\t<button data-dojo-type='dijit/form/Button' type='button'\n\t\t\tdata-dojo-attach-point=\"cancelButton\" data-dojo-attach-event='click:onCancel'></button>\n</div>\n",
'url:pepper/dialogs/templates/BookmarkBrowser.html':"<div data-dojo-type=\"dijit/layout/BorderContainer\"\n     class=\"borderContainer pepperBookmarkBrowser\"\n     style=\"height: 300px; width: 300px;\">\n\n    <div data-dojo-type=\"dijit/layout/ContentPane\"\n         data-dojo-props=\"region: 'center'\"\n         class=\"bookmarks\">\n        <div class=\"bookmarkChoices\"\n             data-dojo-attach-point=\"bookmarkChoices\">\n        </div>\n    </div>\n\n    <div data-dojo-type=\"dijit/layout/ContentPane\"\n         data-dojo-props=\"region: 'bottom'\"\n         class=\"footer\">\n        <div class=\"trailing\">\n            <button type=\"button\"\n                    data-dojo-type=\"vodori/ui/Button\"\n                    data-dojo-attach-point=\"cancelButton\"\n                    class=\"cancel standard\">\n                Cancel\n            </button>\n            <button type=\"button\"\n                    data-dojo-type=\"vodori/ui/Button\"\n                    data-dojo-attach-point=\"insertButton\"\n                    class=\"save action standard default insert\">\n                Insert\n            </button>\n        </div>\n    </div>\n</div>\n",
'url:pepper/dialogs/templates/CustomEvents.html':"<div data-dojo-type=\"dijit/layout/BorderContainer\"\n     data-dojo-attach-point=\"pepperEventsManager\"\n     class=\"borderContainer pepperEventsManager\">\n\n    <div data-dojo-type=\"dijit/layout/ContentPane\"\n         data-dojo-props=\"region: 'center'\"\n         class=\"eventsManagerContainer\">\n\n        <div class=\"event-editor-wrapper\">\n            <div class=\"event-editor\">\n                <p class=\"event-label\">\n                    <label>On Click</label>\n                </p>\n                 <textarea data-dojo-attach-point=\"onclickTextArea\"\n                           data-dojo-type=\"dijit/form/SimpleTextarea\"\n                           class=\"eventsManagerText\"\n                           data-dojo-props=\"disabled: false, rows: 5\"></textarea>\n            </div>\n\n\n            <div class=\"event-editor\">\n                <p class=\"event-label\">\n                    <label>On Mouseover</label>\n                </p>\n                 <textarea data-dojo-attach-point=\"onmouseoverTextArea\"\n                           data-dojo-type=\"dijit/form/SimpleTextarea\"\n                           class=\"eventsManagerText\"\n                           data-dojo-props=\"disabled: false, rows: 5\"></textarea>\n            </div>\n\n        </div>\n\n    </div>\n\n    <div data-dojo-type=\"dijit/layout/ContentPane\"\n         data-dojo-props=\"region: 'bottom'\"\n         class=\"footer\">\n        <div class=\"trailing\">\n            <button type=\"button\"\n                    data-dojo-type=\"vodori/ui/Button\"\n                    data-dojo-attach-point=\"cancelButton\"\n                    class=\"cancel standard\">\n                Cancel\n            </button>\n            <button type=\"button\"\n                    data-dojo-type=\"vodori/ui/Button\"\n                    data-dojo-attach-point=\"insertButton\"\n                    class=\"save action standard default insert\">\n                Insert\n            </button>\n        </div>\n    </div>\n</div>\n",
'url:pepper/dialogs/templates/LinkManager-pepper-link-actions.html':"<a href=\"#\" title=\"{{title}}\" data-pepper-target=\"_library\">Open in library</a>\n<a href=\"{{path}}\" title=\"{{title}}\" target=\"_blank\">Open link target</a>",
'url:pepper/dialogs/templates/Stamper-details.html':"<div data-template-id=\"{{id}}\" class=\"templateStampDetails\">\n    {{#thumbnail}}\n    <div>\n        <h4>Preview</h4>\n        <img src=\"{{thumbnail}}\" alt=\"A rendered stamp.\"/>\n    </div>\n    {{/thumbnail}}\n    {{#label}}\n    <div>\n        <h4>Name</h4>\n        <span>{{label}}</span>\n    </div>\n    {{/label}}\n    {{#description}}\n    <div>\n        <h4>Description</h4>\n        <span>{{description}}</span>\n    </div>\n    {{/description}}\n</div>",
'url:pepper/dialogs/templates/Stamper-default-state.html':"<div class=\"waiting\">\n    <p>Please select a stamp from the left column.</p>\n</div>\n",
'url:dijit/templates/TreeNode.html':"<div class=\"dijitTreeNode\" role=\"presentation\"\n\t><div data-dojo-attach-point=\"rowNode\" class=\"dijitTreeRow\" role=\"presentation\"\n\t\t><span data-dojo-attach-point=\"expandoNode\" class=\"dijitInline dijitTreeExpando\" role=\"presentation\"></span\n\t\t><span data-dojo-attach-point=\"expandoNodeText\" class=\"dijitExpandoText\" role=\"presentation\"></span\n\t\t><span data-dojo-attach-point=\"contentNode\"\n\t\t\tclass=\"dijitTreeContent\" role=\"presentation\">\n\t\t\t<span role=\"presentation\" class=\"dijitInline dijitIcon dijitTreeIcon\" data-dojo-attach-point=\"iconNode\"></span\n\t\t\t><span data-dojo-attach-point=\"labelNode,focusNode\" class=\"dijitTreeLabel\" role=\"treeitem\"\n\t\t\t\t   tabindex=\"-1\" aria-selected=\"false\" id=\"${id}_label\"></span>\n\t\t</span\n\t></div>\n\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitTreeNodeContainer\" role=\"presentation\"\n\t\t style=\"display: none;\" aria-labelledby=\"${id}_label\"></div>\n</div>\n",
'url:dijit/templates/Tree.html':"<div role=\"tree\">\n\t<div class=\"dijitInline dijitTreeIndent\" style=\"position: absolute; top: -9999px\" data-dojo-attach-point=\"indentDetector\"></div>\n\t<div class=\"dijitTreeExpando dijitTreeExpandoLoading\" data-dojo-attach-point=\"rootLoadingIndicator\"></div>\n\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitTreeContainer\" role=\"presentation\">\n\t</div>\n</div>\n",
'url:pepper/dialogs/templates/ThemeChanger-details.html':"<div data-template-id=\"{{id}}\" class=\"templateStampDetails\">\n    {{#thumbnail}}\n    <div>\n        <h4>Preview</h4>\n        <img src=\"{{thumbnail}}\" alt=\"Theme Preview\"/>\n    </div>\n    {{/thumbnail}}\n    {{#label}}\n    <div>\n        <h4>Name</h4>\n        <span>{{label}}</span>\n    </div>\n    {{/label}}\n    {{#description}}\n    <div>\n        <h4>Description</h4>\n        <span>{{description}}</span>\n    </div>\n    {{/description}}\n</div>",
'url:pepper/dialogs/templates/ThemeChanger-default-state.html':"<div class=\"waiting\">\n    <p>Please select a theme from the left column.</p>\n</div>\n",
'url:pepper/dialogs/templates/ThemeChanger-content.html':"<div data-dojo-type=\"dijit/layout/BorderContainer\"\n     class=\"borderContainer\">\n\n    <div data-dojo-type=\"vodori/ui/Tree\"\n         data-dojo-props=\"region: 'leading', layoutPriority: 0\"\n         data-dojo-attach-point=\"categoriesTree\"\n         class=\"categories\"></div>\n\n    <div data-dojo-type=\"vodori/input/GroupedSelect\"\n         data-dojo-props=\"region: 'leading', layoutPriority: 1, options:[{ 'value':0, 'label':'0' }]\"\n         data-dojo-attach-point=\"themeSelect\"\n         class=\"themeSelect\">\n        <!-- These options depend on the selected category -->\n    </div>\n\n    <div data-dojo-type=\"dijit/layout/ContentPane\"\n         data-dojo-props=\"region: 'center'\"\n         data-dojo-attach-point=\"themeProperties\"\n         class=\"properties\">\n        <!-- The contents of this pane depend on the selected theme -->\n    </div>\n\n    <div data-dojo-type=\"dijit/layout/ContentPane\"\n         data-dojo-props=\"region: 'bottom'\"\n         class=\"footer\">\n        <div class=\"trailing\">\n            <button type=\"button\"\n                    data-dojo-type=\"vodori/ui/Button\"\n                    data-dojo-attach-point=\"cancelButton\"\n                    class=\"standard cancel\">\n                Cancel\n            </button>\n\n            <button type=\"button\"\n                    data-dojo-attach-point=\"insertButton\"\n                    data-dojo-type=\"vodori/ui/Button\"\n                    class=\"standard default action insert\">\n                Insert\n            </button>\n        </div>\n    </div>\n</div>\n",
'url:abbott/input/video/templates/VideoFlyoutList.html':"<div class=\"abbott-input-video-videoflyoutlist\">\n    <h3>Videos</h3>\n\n    <div>\n        <input type=\"checkbox\" data-dojo-type=\"dijit/form/CheckBox\" data-dojo-attach-point=\"displayCheckbox\"/>\n        Display Video Widget\n    </div>\n\n    <div data-dojo-type=\"vodori/input/FormBasedEditor\" data-dojo-attach-point=\"form\" class=\"videoflyoutlist-form\">\n        <script type=\"text/template\" data-dojo-attach-point=\"formTemplate\" >\n            <div class=\"flyout-list-title\">\n                <label>List Title</label>\n                <input type=\"text\"\n                       data-parse=\"listTitle\"\n                       value=\"{{ listTitle }}\"\n                       placeholder=\"e.g. Videos\">\n            </div>\n            <div data-dojo-type=\"abbott/ui/NodeRepeater\" >\n                <button type=\"button\" data-dojo-type=\"dijit/form/Button\" class=\"node-repeater-add\">ADD VIDEO</button>\n                <div class=\"node-repeater-template\">\n                    ${!formItemTemplate}\n                </div>\n\n                {{#mediaLinks}}\n                <div class=\"node-repeater-node\">\n                    ${!formItemTemplate}\n                </div>\n                {{/mediaLinks}}\n            </div>\n        </script>\n        <script type=\"text/template\" data-dojo-attach-point=\"valueTemplate\">\n            <div data-dojo-type=\"abbott/ui/video/VideoFlyoutList\">\n                <span data-parse=\"listTitle\">{{listTitle}}</span>\n                <ol>\n                    {{#mediaLinks}}\n                    <li data-parse=\"mediaLinks:[]\">\n                        <img src=\"{{placeholderPath}}\" data-parse=\"mediaLinks.placeholderPath\"/>\n                        <a href=\"{{videoPath}}\" data-parse=\"mediaLinks.videoPath, mediaLinks.name:textContent\">{{name}}</a>\n                    </li>\n                    {{/mediaLinks}}\n                </ol>\n            </div>\n        </script>\n    </div>\n</div>",
'url:abbott/input/video/templates/VideoFlyoutListFormItem.html':"<form data-parse=\"mediaLinks:[]\" class=\"flyout-link\">\n        <label>Name</label>\n        <input type=\"text\"\n               name=\"flyout-link-name\"\n               data-parse=\"mediaLinks.name\"\n               placeholder=\"Video title, one or two words\"\n               value=\"{{ name }}\">\n\n        <label>Video</label>\n        <input type=\"text\"\n               data-dojo-type=\"abbott/input/LibraryInput\"\n               data-dojo-props=\"queryFor: 'mp4'\"\n               name=\"videoPath\"\n               data-parse=\"mediaLinks.videoPath\"\n               placeholder=\"Video\"\n               value=\"{{ videoPath }}\">\n\n        <label>Placeholder Image</label>\n        <input type=\"text\"\n               data-dojo-type=\"abbott/input/LibraryInput\"\n               data-dojo-props=\"queryFor: 'image'\"\n               name=\"placeholderPath\"\n               data-parse=\"mediaLinks.placeholderPath\"\n               placeholder=\"Placeholder image\"\n               value=\"{{ placeholderPath }}\">\n\n    <div class=\"node-repeater-controls\"><!--\n        --><div class=\"node-repeater-move up\"></div><!--\n        --><div class=\"node-repeater-move down\"></div><!--\n        --><div class=\"node-repeater-remove\"></div><!--\n    --></div>\n</form>",
'url:abbott/ui/am/customerPortal/admin/templates/ResourceRow.mustache':"<tr data-asset-id=\"{{assetId}}\">\n    <td class=\"title\">{{title}}</td>\n    <td class=\"note\"></td>\n    <td>\n        <a href=\"javascript:void(0);\" class=\"add-or-edit-note\">Add/Edit Note</a>\n    </td>\n    <td>\n        <a href=\"javascript:void(0);\" class=\"remove-resource\">Remove Document</a>\n    </td>\n    <td><em>Pending Save</em></td>\n    <td><em>Pending Save</em></td>\n</tr>",
'url:pepper/workflow/templates/ApproveRejectButtons.html':"<div class=\"approveRejectButtons\">\n    <button data-dojo-type=\"vodori/ui/Button\" data-dojo-attach-point=\"approveButton\" class=\"accept\">${approveButtonHtml}\n    </button>\n    <button data-dojo-type=\"vodori/ui/Button\" data-dojo-attach-point=\"rejectButton\" class=\"reject\">${rejectButtonHtml}\n    </button>\n    <div class=\"approveRejectCheckbox\" data-dojo-attach-point=\"hiddenCheckboxContainer\">\n        <input type=\"checkbox\" name=\"${name}\" value=\"${value}\" data-dojo-attach-point=\"hiddenCheckbox\"/>\n    </div>\n</div>\n",
'url:abbott/workflow/templates/MockFormSubmit.html':"<div style=\"display: inline-block\">\n    <button data-dojo-type=\"vodori/ui/Button\" data-dojo-attach-point=\"submitButton\" class=\"accept\">Submit</button>\n</div>",
'url:abbott/pepperConsole/templates/BadgeTemplate.html':"<div class=\"content-link\">\n    <div class=\"image-container\">\n        <img src=\"${imageUrl}\" alt=\"${label}\"/>\n    </div>\n    <div class=\"button-container button-single\">\n        <div class=\"button\">\n            ${label}\n        </div>\n    </div>\n</div>"}});
define("pepper/main", [
    'dijit/ToolbarSeparator',

    'vodori/ui/Toolbar',

    'pepper/ui/EditorToolbar', 'pepper/ui/Popup',
    'pepper/stripe/Toolbar', 'pepper/stripe/PepperPopup', 'pepper/stripe/StripeActionMenu',
    'pepper/stripe/LifecycleButton', 'pepper/stripe/LifecyclePopup', 'pepper/stripe/MessagesButton',
    'pepper/stripe/MessagesPopup', 'pepper/stripe/SearchBox', 'pepper/stripe/SearchPopup',
    'pepper/stripe/ToolbarPin'

], function() {
    console.info('Pepper Dependencies loaded');
    return {};
});
